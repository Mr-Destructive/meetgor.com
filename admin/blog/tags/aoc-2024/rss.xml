<rss version="2.0">
  <channel>
    <title>Meet Gor - Tag: aoc-2024</title>
    <link>meetgor.com</link>
    <description>Posts tagged with aoc-2024</description>
    <language>en-us</language>
    <pubDate>Fri, 17 Oct 2025 16:57:38 UTC</pubDate>
    <item>
      <title>Advent of Code Day 5 in Golang: Ordering Pages</title>
      <link>meetgor.com/aoc-2024-day-5</link>
      <description>Solving day 5 of Advent of Code 2024 in Golang. Diving into one of the possible approaches to the puzzle.</description>
      <pubDate>Wed, 11 Dec 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;It is day 5 of the advent of code, and today we have an interesting problem of ordering pages. Let’s dive into the problem and how I approached it. It was a pretty simple problem if thought it peacefully, otherwise, it would get into a map, list, and indices mess.&#xA;&#xA;## Input&#xA;&#xA;In the input for day 5, we have two sections, The first defines the rules for ordering the pages, specifically which page should come before which and the second contains the actual order of pages.&#xA;&#xA;```plaintext&#xA;47|53&#xA;97|13&#xA;97|61&#xA;97|47&#xA;75|29&#xA;61|13&#xA;75|53&#xA;29|13&#xA;97|29&#xA;53|29&#xA;61|53&#xA;97|53&#xA;61|29&#xA;47|13&#xA;75|47&#xA;97|75&#xA;47|61&#xA;75|61&#xA;47|29&#xA;75|13&#xA;53|13&#xA;&#xA;75,47,61,53,29&#xA;97,61,53,29,13&#xA;75,29,13&#xA;75,97,47,61,53&#xA;61,13,29&#xA;97,13,75,29,47&#xA;```&#xA;&#xA;So, the first section has the rules mapped out, the other has the ordering of pages, and each line is a query or a list of pages as our actual data to process. We need to use it in the processing of parts 1 and 2.&#xA;&#xA;### Reading Sections&#xA;&#xA;So, we need to parse these sections and read them in a data structure that could be easier to access.&#xA;&#xA;One way to do that would be&#xA;&#xA;* A list with two sections&#xA;    &#xA;* The first section will be a list&#xA;    &#xA;    * The list will be a list of integers to hold the two integers i.e. for rules&#xA;        &#xA;* The second section will be a list&#xA;    &#xA;    * The list will be a list of integers to hold the page list&#xA;        &#xA;&#xA;So, the data structure would look like a list of list of list of integers.&#xA;&#xA;```go&#xA;&#xA;func ReadFileSections(path string) [][][]int {&#xA;&#xA;&#x9;fileBytes := ReadFileBytes(path)&#xA;&#x9;lines := []string{}&#xA;&#x9;separator := []byte(&#34;&#xA;&#xA;&#34;)&#xA;&#x9;for _, line := range bytes.Split(fileBytes, separator) {&#xA;&#x9;&#x9;if string(line) != &#34;&#34; {&#xA;&#x9;&#x9;&#x9;lines = append(lines, string(line))&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;sections := [][][]int{}&#xA;&#x9;for i, section := range lines {&#xA;&#x9;&#x9;nums := [][]int{}&#xA;&#x9;&#x9;lineStrs := strings.Split(section, &#34;&#xA;&#34;)&#xA;&#x9;&#x9;separator := &#34;,&#34;&#xA;&#x9;&#x9;if i == 0 {&#xA;&#x9;&#x9;&#x9;separator = &#34;|&#34;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;for _, lineStr := range lineStrs {&#xA;&#x9;&#x9;&#x9;if lineStr == &#34;&#34; {&#xA;&#x9;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;numL := []int{}&#xA;&#x9;&#x9;&#x9;for _, numStr := range strings.Split(lineStr, separator) {&#xA;&#x9;&#x9;&#x9;&#x9;num, _ := strconv.Atoi(numStr)&#xA;&#x9;&#x9;&#x9;&#x9;numL = append(numL, num)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;nums = append(nums, numL)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;sections = append(sections, nums)&#xA;&#x9;}&#xA;&#x9;return sections&#xA;}&#xA;```&#xA;&#xA;The above function called `ReadFileSections` takes in a path to the input file and returns a slice/array) of the list of list of integers as discussed. We first read the file and split the bytes into two newline characters that will be the separator for the sections, we will store the lines as a list of strings, the first will contain the rule lines and the second will contain the page list lines.&#xA;&#xA;Then we iterate over the section and split the individual lines for sections separately with the respective separator i.e. `|` for the first section and (whitespace) for the second section. We are parsing each line to get a list of integers and append them to the respective sections.&#xA;&#xA;So, we now have data that we can use to construct the rules and pages to help process the problem.&#xA;&#xA;### Constructing Rules&#xA;&#xA;Now, we need to process the rules list for convenient access, we need to get the page number that should appear after a given page, so we will use a map of integer with a list of integers, where the key will be the first number and the one of the value will be the second number ( the number that should appear after in order of the pages).&#xA;&#xA;```go&#xA;func ConstructRules(rulesList [][]int) map[int][]int {&#xA;&#x9;rules := make(map[int][]int)&#xA;&#x9;for _, rule := range rulesList {&#xA;&#x9;&#x9;rules[rule[0]] = append(rules[rule[0]], rule[1])&#xA;&#x9;}&#xA;&#x9;return rules&#xA;}&#xA;```&#xA;&#xA;We simply iterate over the list of integers and map the first element as the key and the value as the second element in the list, so to visualize:&#xA;&#xA;```go&#xA;FROM&#xA;&#xA;[][]int&#xA;&#xA;[&#xA;    [47,53]&#xA;    [97,13]&#xA;    [97,61]&#xA;]&#xA;&#xA;TO&#xA;&#xA;map[int][]int&#xA;{&#xA;    47: [53]&#xA;    97: [13,61]&#xA;}&#xA;```&#xA;&#xA;So, now have the rules as a map of integers with integers.&#xA;&#xA;### Constructing indices&#xA;&#xA;Now, to make the first and second parts easier, we need to make a map for each number in the rules section with the indices that appear in the pages list.&#xA;&#xA;So, we will iterate over the rules, which is a map of integers and integers, we will create a map of integers that will help us create a unique list of integers from the rules.&#xA;&#xA;Now, once we have the list of integers from the rules, we will iterate over all the numbers and on each page line, check on which index it appears, for creating a list of integers(indices).&#xA;&#xA;So, we iterate over all the numbers in the line of pages, if we find that number in the list of pages, we append the index, however, if we don’t we append -1, so for each line we need to have an index appended for that number like so:&#xA;&#xA;```plaintext&#xA;# 75&#xA;&#xA;75,47,61,53,29  -&gt;  0&#xA;97,61,53,29,13  -&gt; -1&#xA;75,29,13        -&gt;  0&#xA;75,97,47,61,53  -&gt;  0&#xA;61,13,29        -&gt; -1&#xA;97,13,75,29,47  -&gt;  2&#xA;&#xA;75[0,-1,0,0,-1,2]&#xA;&#xA;# map[int][]int&#xA;# 75 -&gt; int&#xA;# [0,-1,0,0,-1,2] -&gt; []int&#xA;```&#xA;&#xA;So, in the above example, we have taken 75 for reference, we will get the index for each list of page numbers, and we get the list of indexes where 75 appears.&#xA;&#xA;Now, this can be done with the following function:&#xA;&#xA;```go&#xA;&#xA;func GetPageIndices(rules map[int][]int, pages [][]int) map[int][]int {&#xA;&#x9;nums := make(map[int]bool)&#xA;&#x9;for num, list := range rules {&#xA;&#x9;&#x9;nums[num] = true&#xA;&#x9;&#x9;for _, elem := range list {&#xA;&#x9;&#x9;&#x9;if !nums[elem] {&#xA;&#x9;&#x9;&#x9;&#x9;nums[elem] = true&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;numIndices := make(map[int][]int)&#xA;&#x9;for num, _ := range nums {&#xA;&#x9;&#x9;for _, numLine := range pages {&#xA;&#x9;&#x9;&#x9;index := -1&#xA;&#x9;&#x9;&#x9;for i, n := range numLine {&#xA;&#x9;&#x9;&#x9;&#x9;if n == num {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;index = i&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;numIndices[num] = append(numIndices[num], index)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return numIndices&#xA;}&#xA;```&#xA;&#xA;So, we now have the index mapped at each page numbers list from the rules.&#xA;&#xA;## Part 1&#xA;&#xA;Now, for part one we need to iterate over each page update (line), then we need to check if the page numbers are following the rules, each number should follow the rules. This means that if a number is after a certain number but the rule says it should be before, then it has violated the page numbering rule in that update, so we cannot consider it as the correct ordered page, we need to add the middle page number of each update which is correctly ordered as the answer for the part one.&#xA;&#xA;To do that, we iterate over each page update, then we need to iterate over each of the numbers in that page update, we obtain all the rules associated with that number (let’s call it the current number) since we have a map of integers with a list of integers. Now, we have to check if the number that we currently are in is before the numbers in its rules. So, we check with the index of the current number using the number indices that we created which is a map of the number with a list of integers as indices. So, we obtain the list of indices of the map with the current number as the key for the map and the index in the list as the number of line/page updates we are currently in.&#xA;&#xA;Then once we have got the index for the current number, we obtain the same for the second number which is all the numbers in its rule, and if that number in its rule is present in that page line/update i.e. it is not -1 and if that is the case, we get the index of it similarly and check if it appears after the current number following the rule, And so if any number violates the rule, we need to mark the page update as not in correct order.&#xA;&#xA;As we see that the index rule for that page update is violated, we mark the order as false. If we see the ordered flag is still true, we update the score with the middle element of that page update.&#xA;&#xA;```go&#xA;&#xA;func GetOrderedPages(rules, numIndices map[int][]int, pages [][]int) int {&#xA;&#x9;score := 0&#xA;&#xA;&#x9;for index, pageLine := range pages {&#xA;&#x9;&#x9;ordered := true&#xA;&#x9;&#x9;for _, num1 := range pageLine {&#xA;&#x9;&#x9;&#x9;rule := rules[num1]&#xA;&#x9;&#x9;&#x9;index1 := numIndices[num1][index]&#xA;&#x9;&#x9;&#x9;for _, num2 := range rule {&#xA;&#x9;&#x9;&#x9;&#x9;index2 := numIndices[num2][index]&#xA;&#x9;&#x9;&#x9;&#x9;if index1 == -1 || index2 == -1 {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if index1 &gt; index2 {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ordered = false&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if ordered {&#xA;&#x9;&#x9;&#x9;score += pageLine[int(len(pageLine)/2)]&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return score&#xA;}&#xA;```&#xA;&#xA;So, to reiterate, we create a function called `GetOrderedPage` with rule and number indices as a map of integers with a list of integers and the pages which is a list of integers as the page update. We return the score as the output of this function.&#xA;&#xA;We iterate through each of the page updates, then through each page number in the update, we check for the rule of that number and if the index of that is lower than the current number we mark it as not ordered, and hence at the end of each page update we update the score with the middle element of the page update, if the order is correct.&#xA;&#xA;So, that will be part one summed up, we just have to get the score of the correct ordered page updates.&#xA;&#xA;## Part 2&#xA;&#xA;In part 2 however, we need to check if the page update is in order, if it is not then we need to make it in order.&#xA;&#xA;We do a similar thing for part 2, we need to iterate over each of the page updates, and for each number in that page update, we need to check if the rule is violated or not, if we encounter any case where the rule is violated for any number, we mark the flag ordered as false, this we will use to correct the order of the page updates. After updating the pages in that page line/update, we need to add the score with middle element of the corrected order of page update.&#xA;&#xA;```go&#xA;&#xA;&#xA;func GetCorrectOrderedPages(rules, numIndices map[int][]int, pages [][]int) int {&#xA;&#xA;&#x9;score := 0&#xA;&#x9;for index, pageLine := range pages {&#xA;&#x9;&#x9;ordered := true&#xA;&#x9;&#x9;for _, num1 := range pageLine {&#xA;&#x9;&#x9;&#x9;rule := rules[num1]&#xA;&#x9;&#x9;&#x9;index1 := numIndices[num1][index]&#xA;&#x9;&#x9;&#x9;for _, num2 := range rule {&#xA;&#x9;&#x9;&#x9;&#x9;index2 := numIndices[num2][index]&#xA;&#x9;&#x9;&#x9;&#x9;if index1 == -1 || index2 == -1 {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if index1 &gt; index2 {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ordered = false&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if !ordered {&#xA;&#x9;&#x9;&#x9;newLine := CorrectPageOrder(pageLine, rules)&#xA;&#x9;&#x9;&#x9;score += newLine[len(newLine)/2]&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return score&#xA;}&#xA;```&#xA;&#xA;We need to implement the CorrectPageOrder function that takes in the page line or page update and the rules, we need to create a new page update, that will populate the page that follows all the rules.&#xA;&#xA;So, we first keep track of the initialized elements index and update the index if we need to move the element before it.&#xA;&#xA;So, we iterate over all the numbers in the page update and set the index before any number in the rule, if we encounter any such number in the rule map, we need to update the index with the index of that number.&#xA;&#xA;And once we have got the index where we want to swap the element to, we create a slice before that index and append that number into it, and append everything after that index.&#xA;&#xA;```go&#xA;func CorrectPageOrder(line []int, rules map[int][]int) []int {&#xA;&#x9;newLine := []int{}&#xA;&#x9;for _, num := range line {&#xA;&#x9;&#x9;index := make(map[int]int)&#xA;&#x9;&#x9;for i, n := range newLine {&#xA;&#x9;&#x9;&#x9;index[n] = i&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;newInsertIndex := len(newLine)&#xA;&#x9;&#x9;for _, rule := range rules[num] {&#xA;&#x9;&#x9;&#x9;if idx, ok := index[rule]; ok {&#xA;&#x9;&#x9;&#x9;&#x9;if newInsertIndex &gt; idx {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;newInsertIndex = idx&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;afterNum := slices.Clone(newLine[newInsertIndex:])&#xA;&#x9;&#x9;newLine = append(newLine[:newInsertIndex], num)&#xA;&#x9;&#x9;newLine = append(newLine, afterNum...)&#xA;&#x9;}&#xA;&#x9;return newLine&#xA;}&#xA;```&#xA;&#xA;So, this function will find the index of a number to place it at the most extreme left (beginning of the list) so that we are not violating any rules for that number, then we create a slice to append that number before that index and append everything after that index.&#xA;&#xA;That’s it from part two, we have updated the page order if there were any discrepancies in the page order.&#xA;&#xA;## Conclusion&#xA;&#xA;So, that is it from day 5 of Advent of Code in Golang, let me know if you have any suggestions, and how you approached it. any better solutions?&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Advent of Code Day 4 in Golang: Finding XMAS and X-MAS</title>
      <link>meetgor.com/aoc-2024-day-4</link>
      <description>Solving day 4 of Advent of Code 2024 in Golang. Diving into one of the possible approaches to the puzzle.</description>
      <pubDate>Mon, 09 Dec 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Moving on to day 4, we have a grid problem in front of us, we are given some numbers in the form of a grid, i.e. some rows and columns with some upper case letters. What we need to do is to find is the word `XMAS` in any direction (up, left, down, right, diagonals), and in the second part we need to find the word `MAS` forming an X.&#xA;&#xA;So, let’s see how we can approach this and solve it in golang.&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day04/main.go)[.](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day04/main.go)&#xA;&#xA;### [Constructin](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day02/main.go)g the grid&#xA;&#xA;The most fundamental part of the problem lies in actually converting the text into a grid or a matrix form. We can split the lines, into individual lines and append each character as an element in a list, and that way we can have a list of list of strings which is a matrix or grid-like (2-dimensional) structure.&#xA;&#xA;So, below is the input for the puzzle.&#xA;&#xA;```plaintext&#xA;MMMSXXMASM&#xA;MSAMXMSMSA&#xA;AMXSXMAAMM&#xA;MSAMASMSMX&#xA;XMASAMXAMM&#xA;XXAMMXXAMA&#xA;SMSMSASXSS&#xA;SAXAMASAAA&#xA;MAMMMXMMMM&#xA;MXMXAXMASX&#xA;```&#xA;&#xA;We need to convert it into something like this&#xA;&#xA;```plaintext&#xA;[&#xA;    [M M M S X X M A S M]&#xA;    [M S A M X M S M S A]&#xA;    [A M X S X M A A M M]&#xA;    [M S A M A S M S M X]&#xA;    [X M A S A M X A M M]&#xA;    [X X A M M X X A M A]&#xA;    [S M S M S A S X S S]&#xA;    [S A X A M A S A A A]&#xA;    [M A M M M X M M M M]&#xA;    [M X M X A X M A S X]&#xA;]&#xA;```&#xA;&#xA;So, this is a list of strings, we can say in golang it is a `[][]string` . We can do that by creating a function like this:&#xA;&#xA;```go&#xA;func ConstructGrid(lines []string) [][]string {&#xA;&#x9;grid := [][]string{}&#xA;&#x9;for _, line := range lines {&#xA;&#x9;&#x9;row := []string{}&#xA;&#x9;&#x9;for _, char := range strings.Split(line, &#34;&#34;) {&#xA;&#x9;&#x9;&#x9;row = append(row, char)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;grid = append(grid, row)&#xA;&#x9;}&#xA;&#x9;return grid&#xA;}&#xA;```&#xA;&#xA;The above function takes in a list of strings and returns a list of list of strings that are individual letters in the grid.  &#xA;We can read the file bytes and split the bytes on newline characters and then this will be used as the input for this function.&#xA;&#xA;So, once the input is parsed into a grid, we can start thinking about the actual logic of finding the word `XMAS` in it.&#xA;&#xA;## Part 1&#xA;&#xA;So, in the first part, we need to find the word `XMAS` in the matrix which could be appearing:&#xA;&#xA;* forwards (as `XMAS`)&#xA;    &#xA;* backward (as `SAMX`)&#xA;    &#xA;* upwards&#xA;    &#xA;     ```plaintext&#xA;            S&#xA;            A&#xA;            M&#xA;            X&#xA;        ```&#xA;        &#xA;* downwards&#xA;    &#xA;     ```plaintext&#xA;            X&#xA;            M&#xA;            A&#xA;            S&#xA;        ```&#xA;        &#xA;* Diagonal upwards (right or up left)&#xA;    &#xA;     ```plaintext&#xA;            S&#xA;              A&#xA;                M&#xA;                  X&#xA;            &#xA;            OR&#xA;                  S&#xA;                A&#xA;              M &#xA;            X&#xA;        ```&#xA;        &#xA;* Diagonals downwards (right or left)&#xA;    &#xA;     ```plaintext&#xA;                     X&#xA;                   M&#xA;                 A&#xA;               S&#xA;            &#xA;            OR&#xA;            X&#xA;              M&#xA;                A&#xA;                  S&#xA;        ```&#xA;        &#xA;&#xA;So, there are 8 directions where `XMAS` could appear in the grid, there could n number of these `XMAS` . We need to find the count of these in the grid.&#xA;&#xA;![](https://cdn.hashnode.com/res/hashnode/image/upload/v1733761379973/8a0a0263-b286-47f1-a338-410dec2c6b7b.png)&#xA;&#xA;To approach this, we can either find the first character in the word `XMAS` and then search in all directions one by one and check if we find `M` and if we have found `M` in any of the direction, we keep moving ahead in that direction and check if there is `A` and `S` in that direction.&#xA;&#xA;The approach looks like this:&#xA;&#xA;* Initialize the counter to 0&#xA;    &#xA;* Iterate over each line&#xA;    &#xA;    * Iterate over each character in the line&#xA;        &#xA;        * Check if the character is equal to `X`&#xA;            &#xA;        * If the character is `X`→&#xA;            &#xA;            * Iterate over all the directions (up, down, right, left, up-left, up-right, down-left, down-right)&#xA;                &#xA;                * For that direction if we find the character to be `M`&#xA;                    &#xA;                * Keep moving ahead in the same direction to find `A` and `S` similarly, if we found all the characters `XMAS` then, increment the counter&#xA;                    &#xA;                * Else choose another direction in the loop&#xA;                    &#xA;&#xA;This looks complex and large but is simple, focus one thing at a time and you can solve this easily.&#xA;&#xA;So, for the implementation of this, we need to define a few things first:&#xA;&#xA;```go&#xA; var directions [][]int = [][]int{&#xA;&#x9;[]int{0, -1},   // up&#xA;&#x9;[]int{0, 1},  // down&#xA;&#x9;[]int{1, 0},   // right&#xA;&#x9;[]int{-1, 0},  // left&#xA;&#x9;[]int{1, -1},   // up right&#xA;&#x9;[]int{-1, -1},  // up left&#xA;&#x9;[]int{1, 1},  // down right&#xA;&#x9;[]int{-1, 1}, // down left&#xA;}&#xA;&#xA;var wordList []string = []string{&#34;X&#34;, &#34;M&#34;, &#34;A&#34;, &#34;S&#34;}&#xA;```&#xA;&#xA;So, we have defined the list of integers in the directions which are the x and y coordinates that we need to add or subtract to get to the desired location. It is basically like a unit vector, it has a distance of 1 and a direction indicated by `+` or `-` indicating to move the left or right for x coordinates and up and down for y c-ordinates.&#xA;&#xA;So, let me explain that more clearly, let’s say I am at `(1,2)` in the grid which is of 4x4 dimension.&#xA;&#xA;```plaintext&#xA;A B C D&#xA;E F G H&#xA;I J K L&#xA;M N O P&#xA;```&#xA;&#xA;So, at 2,1 we have `G` , so we check some directions for this&#xA;&#xA;up → `0,-1` → 2+0, 1-1 → 2,0, we have moved to `C`&#xA;&#xA;right → `1,0` → 2+1, 1+0 → 3,1 , we have moved to `H`&#xA;&#xA;down, left → `-1,1` → 2-1, 1+1 → 1, 2, we have moved to `J`&#xA;&#xA;So, you get the idea, that we are moving in some directions using these coordinates.&#xA;&#xA;We can use these to get the next direction jump we want to make to find if that element has the next character in the word that we are searching.&#xA;&#xA;We will write a function that does this first and abstract the function that checks if we have found the word in the grid.&#xA;&#xA;```go&#xA;func TraverseGrid(grid [][]string) int {&#xA;&#x9;score := 0&#xA;&#x9;for x, row := range grid {&#xA;&#x9;&#x9;for y, char := range row {&#xA;&#x9;&#x9;&#x9;if char == wordList[0] {&#xA;&#x9;&#x9;&#x9;&#x9;for _, direction := range directions {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if FindXMAS(x, y, 1, direction, grid) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;score += 1&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return score&#xA;}&#xA;```&#xA;&#xA;The above function takes in a grid and returns an integer which will be the score i.e. the count of words `XMAS` found in the grid/matrix.&#xA;&#xA;First, we need to iterate through each of the rows in the grid, for each row, we iterate over the character, so we will have x and y coordinates as the index of the grid. We need to then check if the current character is `X` or `wordList[0]` , if that is the case, we iterate over all the directions and check if we can find `XMAS` i.e. `MAS` in that direction, if so we increment the counter. What is the `FindXMAS` function, let’s abstract that away, and pass in the `x`, `y`, which are the coordinates of the current word, `1` which will be the word position of the `XMAS` and in this case, we already have found `X` we need to find `MAS` in that direction. We pass the grid and the direction, so this function will return true or false if that direction has `MAS` in it.&#xA;&#xA;So to iterate:&#xA;&#xA;* We iterate over the grid and get `row` and `x` as the list of strings and index of the current row.&#xA;    &#xA;* For each row i.e. list of strings, we iterate over the list of strings to get `char` and `y` as the character (string) and the index of that character in the list of the string.&#xA;    &#xA;* If we find the current character to be equal to `X` which is the 0th index of the `wordList` then&#xA;    &#xA;    * We iterate over all the directions and call the function `FindXMAS` to check if the remaining word `MAS` in that direction&#xA;        &#xA;    * If we find all the words, we increment the counter.&#xA;        &#xA;* So, we return the counter as we count the number of words `XMAS` in the grid/matrix.&#xA;    &#xA;&#xA;Now, we can implement the `FindXMAS` function, that takes in a `x`, `y` coordinates, the `wordPosition`, the direction and the grid, and return if the word is found.&#xA;&#xA;* First, we take the current x coordinates and add the direction’s x component (0th index or first element)&#xA;    &#xA;* add current y coordinates to the direction’s y component (1st index or second element)&#xA;    &#xA;* if the word position i.e.. the word index or the word itself in the current function is equal to the wordList, it means that it has found the required word completely&#xA;    &#xA;* We need to check by adding the direction to the x and y coordinates, we are not overshooting the width and height of the grid, so if we do, we return a false&#xA;    &#xA;* The final if is for checking if the current character is equal to the word that we are looking for, it could be `M`, `A` , or `S` . If so, we return the recursively call the `FindXMAS` function by passing the updated x and y coordinates and the next word in the wordList, we keep the direction the same and pass the entire grid.&#xA;    &#xA;&#xA;```go&#xA;func FindXMAS(x, y, wordPosition int, direction []int, grid [][]string) bool {&#xA;&#x9;xNext := x + direction[0]&#xA;&#x9;yNext := y + direction[1]&#xA;&#x9;if wordPosition &gt; len(wordList)-1 {&#xA;&#x9;&#x9;return true&#xA;&#x9;}&#xA;&#xA;&#x9;if xNext &lt; 0 || xNext &gt;= len(grid) || yNext &lt; 0 || yNext &gt;= len(grid[x]) {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;if grid[xNext][yNext] == wordList[wordPosition] {&#xA;&#x9;&#x9;return FindXMAS(xNext, yNext, wordPosition+1, direction, grid)&#xA;&#x9;}&#xA;&#x9;return false&#xA;&#xA;}&#xA;```&#xA;&#xA;So, we have implemented the `FindXMAS` function, this will just return if we have found the `MAS` word by going in a particular direction by updating the coordinates and checking if the word at that position in the gird is the next word in `MAS` list.&#xA;&#xA;So, this is what the entire first part looks like:&#xA;&#xA;```go&#xA;func main() {&#xA;&#x9;lines := ReadFileLines(&#34;sample.txt&#34;)&#xA;&#x9;grid := ConstructGrid(lines)&#xA;&#x9;score := TraverseGrid(grid)&#xA;&#x9;fmt.Println(score)&#xA;}&#xA;```&#xA;&#xA;We take in the lines as a list of strings and pass that to `ConstructGrid` and get the grid, finally, we call `TraverseGrid` , by passing the grid and getting the score as the count of the words `XMAS` in the grid.&#xA;&#xA;That’s it from the part 1.&#xA;&#xA;## Part 2&#xA;&#xA;For part two, we need to find `MAS` in the cross shape, like below:&#xA;&#xA;```plaintext&#xA;M.S&#xA;.A.&#xA;M.S&#xA;```&#xA;&#xA;So, to solve this, we can do a similar approach but much simpler, we just need to find `A` as there will always be the word `MAS` in the center, so we just check if we have `A` and the top-left, top-right, or bottom-right, bottom-left has `M` or `S` .&#xA;&#xA;We get the coordinates of the top-right, top-left positions, down-right, and down-left positions by adding and subtracting 1 from it. We make a basic check if we are not overshooting the boundary of the grid. If we overshoot the boundaries, we won’t find the `MAS`&#xA;&#xA;But if we are within the grid, we now get the character at those 4 positions, we check if the top-left and bottom-right have `M` and `S` or `S` or `M`, similarly for top-right and bottom-left has `M` and `S` or `S` or `M` respectively. This is the diagonal search for `M` and `S` above and below the character `A`.&#xA;&#xA;So, if we have both the diagonal matched we return true.&#xA;&#xA;```go&#xA;&#xA;&#xA;func FindMAS(x, y int, grid [][]string, wordList []string) bool {&#xA;&#x9;xL, yT := x-1, y+1 // Top-left neighbor&#xA;&#x9;xR, yD := x+1, y-1 // Bottom-right neighbor&#xA;&#xA;&#x9;// Check if the indices are within bounds&#xA;&#x9;if xL &lt; 0 || xR &gt;= len(grid) || yT &lt; 0 || yD &lt; 0 ||&#xA;&#x9;&#x9;yT &gt;= len(grid[xL]) || yD &gt;= len(grid[xR]) {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;topLeft := grid[xL][yT]&#xA;&#x9;bottomRight := grid[xR][yD]&#xA;&#x9;topRight := grid[xR][yT]&#xA;&#x9;bottomLeft := grid[xL][yD]&#xA;&#xA;&#x9;word1, word3 := wordList[1], wordList[3]&#xA;&#xA;&#x9;isDiagonalMatch := (topLeft == word1 &amp;&amp; bottomRight == word3) || (topLeft == word3 &amp;&amp; bottomRight == word1)&#xA;&#x9;isAntiDiagonalMatch := (topRight == word1 &amp;&amp; bottomLeft == word3) || (topRight == word3 &amp;&amp; bottomLeft == word1)&#xA;&#xA;&#x9;return isDiagonalMatch &amp;&amp; isAntiDiagonalMatch&#xA;}&#xA;```&#xA;&#xA;So, that is the simple implementation for finding the `MAS` the diagonal.&#xA;&#xA;Now, we need to change the `TraverseGrid` a bit, as we just iterate over the grid, and check if we have `A` in the character in the row, i.e. `wordList[2]`. Now, if we have `A`, we need to call the `FindMAS` function with the current coordinates and the grid, if that function returns true, we increment the counter,.&#xA;&#xA;```go&#xA;&#xA;func TraverseGrid2(grid [][]string) int {&#xA;&#x9;score := 0&#xA;&#x9;for x, row := range grid {&#xA;&#x9;&#x9;for y, char := range row {&#xA;&#x9;&#x9;&#x9;if char == wordList[2] {&#xA;&#x9;&#x9;&#x9;&#x9;if FindMAS(x, y, grid) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;score += 1&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return score&#xA;}&#xA;```&#xA;&#xA;So, that is the final implementation of part 2, we get the count of `MAS` in the cross direction.&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day04/main.go)[.](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day04/main.go)&#xA;&#xA;## Conclusion&#xA;&#xA;So, that is it from day 4 of Advent of Code in Golang, let me know if you have any suggestions, and how you approached it. any better solutions?&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Advent of Code Day 3 in Golang: Do Or Don’t Regex</title>
      <link>meetgor.com/aoc-2024-day-3</link>
      <description>Solving day 3 of Advent of Code 2024 in Golang. Diving into one of the possible approaches to the puzzle.</description>
      <pubDate>Sat, 07 Dec 2024 00:00:00 UTC</pubDate>
      <content>&#xA;&#xA;## Introduction&#xA;&#xA;Well, it is day 3 of the advent of code 2024, and I have been doing it on live streams. I am behind two days but working through them one by one. So far, I have learned a lot of things in Go. Let’s dive in for the day 3.&#xA;&#xA;## Part 1&#xA;&#xA;Part one to any AOC problem seems straightforward, but as soon as part two is revealed, the real implementation starts to break the sweat (if you weren’t optimistic or thoughtful)&#xA;&#xA;For part 1 for this day, was to parse a string that contained `mul(X,Y`) an expression, where X could be any 3-digit number. So, there could be multiple such expressions within the string and the purpose was to multiply the X and Y in the individual expression and add them up.&#xA;&#xA;![AOC Day 3 Part 1](https://meetgor-cdn.pages.dev/aoc-2024-d3-solution-part1.jpg)&#xA;&#xA;```plaintext&#xA;&#xA;xmul(2,4)&amp;mul[3,7]!^don&#39;t()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))&#xA;```&#xA;&#xA;In this example above there are 4 such expressions, and if we add the multiplications of those, we get the answer as 161.&#xA;&#xA;### Approach&#xA;&#xA;It looks like a Regex pattern, finding an expression-like pattern in a string. So, the approach would be to find such expressions with a regex pattern and parse the numbers to integers, and multiply them, simply.&#xA;&#xA;You could go ahead and write the parser for iterating over each character in the string and parsing the tokens, then evaluating the expression. That is a valid approach, but I choose to do this because I don’t know how to write a parser honestly, I want to try that solution at the end as well.&#xA;&#xA;But for the first part, a quick regular expression seems a good idea.&#xA;&#xA;### Constructing the Regular Expression&#xA;&#xA;The first thing is to write the regular expression for the `mul(X,Y)` part which is the only challenging section in part one. The rest is just simple math.&#xA;&#xA;So, we need to find `mul`, then a `(` then any number which is 1 to 3 digits long, then `,` and again a number that is 1 to 3 digits long, and finally ends with a `)`&#xA;&#xA;That translates to:&#xA;&#xA;```plaintext&#xA;mul\((\d{1,3}),(\d{1,3})\) &#xA;```&#xA;&#xA;Let’s breakdown:&#xA;&#xA;* `mul` for capturing the literal word `mul`&#xA;    &#xA;* `\(` this is for the first parenthesis in the expression `mul()` , we need to escape the bracket in a regular expression if we want to match it, so we use `\` before it.&#xA;    &#xA;* Then we have a match group `(\d{1,3})` , this will be the `X` in `mul(X,Y)`:&#xA;    &#xA;    * A match group is like a group of a match in a regex, basically, if you want to capture specific parts in the entire match, then we use `()` to group them individually, this is not necessary but helps in getting the right things without overhead&#xA;        &#xA;    * In this case, we are using a match group for capturing a number which can have 1 to 3 digits.&#xA;        &#xA;    * The other way to write this is `([0-9]{1,3})` , which also would do the same thing, (NOTE: there are some differences in `[0-9]` and `\d`, but that is very subtle and won’t affect this puzzle, if you are still curious, I prefer reading this [StackOverflow question](https://unix.stackexchange.com/questions/414226/difference-between-0-9-digit-and-d))&#xA;        &#xA;* We then use `,` for the separator of `X` and `Y` operands in the `mul(X,Y)` expression&#xA;    &#xA;* We then similarly do the match for `Y` in `mul(X,Y)` with the `(\d{1,3})` match group&#xA;    &#xA;* Finally, we end the regular expression with the `)` to end the expression&#xA;    &#xA;&#xA;### Code it&#xA;&#xA;This is quite straightforward, we grab the line as a string and use [regexp.MustCompile](https://pkg.go.dev/regexp#MustCompile) function which gives us a [Regexp](https://pkg.go.dev/regexp#Regexp) object, that in turn has a few methods associated with it to find, match, replace, and other things that can be done with a regular expression on a string.&#xA;&#xA;Once we have the `mulRegex` , we can use the [FindAllStringSubmatch](https://pkg.go.dev/regexp#Regexp.FindAllStringSubmatch) method associated with the `Regexp` struct in the `regexp` package. The function takes in a string to perform the regex on, and the maximum number of matches to return. We want all the results, so we pass them in `-1` to get all the matches.&#xA;&#xA;Now, this method returns a slice of a slice of strings, each slice is a match, and within each slice, there is a slice of string, with the matched string and the subsequent match groups in the string if any.&#xA;&#xA;```go&#xA;func FindMulExpression(line string) [][]string {&#xA;  mulRegex := regexp.MustCompile(`mul\((\d{1,3}),(\d{1,3})\)`)&#xA;  return mulRegex.FindAllStringSubmatch(line, len(line))&#xA;}&#xA;```&#xA;&#xA;So, the above function will return something like this&#xA;&#xA;```go&#xA;[&#xA;    [mul(2,4) 2 4]&#xA;    [mul(5,5) 5 5]&#xA;    [mul(11,8) 11 8]&#xA;    [mul(8,5) 8 5]&#xA;]&#xA;```&#xA;&#xA;This is a list of list of strings, these look like numbers but those are string types in Golang.&#xA;&#xA;Now we have this, we can create the actual logic part of obtaining the result, which is to parse these expressions, multiply `X` and `Y` and add the results for each of the expressions.&#xA;&#xA;```go&#xA;func Multiply(matches [][]string) int {&#xA;&#x9;score := 0&#xA;&#x9;for _, match := range matches {&#xA;&#x9;&#x9;x, err := strconv.Atoi(string(match[1]))&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;panic(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;y, err := strconv.Atoi(string(match[2]))&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;panic(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;score += x * y&#xA;&#x9;}&#xA;&#x9;return score&#xA;}&#xA;```&#xA;&#xA;This is pretty straightforward, we iterate over each of the matches, that is one `mul(X,Y)` expression and parse the `X` and `Y` each into integers and multiply them, the result obtained is then added to the score. We do this for each `mul(X,Y)` expression that is found in the string(line) and return the final score.&#xA;&#xA;### Input&#xA;&#xA;Now, the example gave us a single string, but I realized there were six lines in the input (individual input), so we needed to parse each line and add up the score.&#xA;&#xA;Remember this as it will be critical in part 2, it took me some time and questioning my existence to realize we need to combine all the lines to get the result (not necessary in part 1 but for sure in part 2).&#xA;&#xA;## Part 2&#xA;&#xA;This is where things go wrong usually. At least for me, it did.&#xA;&#xA;I started with a very naive approach, with a forever loop and finding the index of do or don’t and stripping off those sections, and then looping until we have no do and don’ts left. That was working for the test case but failed on the actual input.&#xA;&#xA;The approach I finally came up and was working by tweaking the same approach slightly.&#xA;&#xA;### Approach&#xA;&#xA;What I came up with is to find the first match location of `don’()` and `do()` strings in the entire string, we take that and remove the parts after `don’t()` or before `do()` . That way we can trim down the string to only valid/enabled `mul()`expressions.&#xA;&#xA;![AOC Day 3 Part 2](https://meetgor-cdn.pages.dev/aoc-2024-d3-solution-part2.jpg)&#xA;&#xA;So, the approach more clearly defined will be:&#xA;&#xA;* Find the location (index) of the `don’t()` and `do()` expressions&#xA;    &#xA;* We need to keep track of whether the previous string was enabled or disabled so will keep a flag to append the enabled expressions (part of the string) to the final result&#xA;    &#xA;* If none of them are found, return the string(line) as it is&#xA;    &#xA;* If we found either of them then:&#xA;    &#xA;    * If we find don’t first (`don’t()` appears before `do()`)&#xA;        &#xA;        * If the enabled flag is true → append the string before the `don’t()` expression&#xA;            &#xA;        * Then toggle the enabled as false and trim off the `don’t()` part  &#xA;            (This way we have completed checking everything before the don’t expression, so we remove that part from the line string)&#xA;            &#xA;    * If we find do first (`do()` appears before `don’t()`)&#xA;        &#xA;        * If the enabled flag is true → append the string before the `do()` expression&#xA;            &#xA;        * Then toggle the enabled as true and trim off the `do()` part  &#xA;            (This way we have completed checking everything before the do expression, so we remove the part from the line string)&#xA;            &#xA;* We do this until there is no line string left to be checked&#xA;    &#xA;&#xA;### Code&#xA;&#xA;I used simple Strings.Index to get the first match index for the substring, In this case, I want the first matching index for `don’t()` and `do()` . Once we have the indices of both the matches, we can iterate over till we are not left with any do or don’ts in the string.&#xA;&#xA;If we have either do or don’t we append to the string the part before don’t if enabled or part before do if enabled and toggle on and off the enabled flag accordingly. By the end of the loop, the result string will have only the enabled parts of the line/string.&#xA;&#xA;```go&#xA;func StripDoDont(line string) string {&#xA;    result := &#34;&#34;&#xA;    enabled := true&#xA;    dontOffset := len(&#34;don&#39;t()&#34;)&#xA;    doOffset := len(&#34;do()&#34;)&#xA;&#xA;    for len(line) &gt; 0 {&#xA;        dontIndex := strings.Index(line, &#34;don&#39;t()&#34;)&#xA;        doIndex := strings.Index(line, &#34;do()&#34;)&#xA;&#xA;        if dontIndex == -1 &amp;&amp; doIndex == -1 {&#xA;            if enabled {&#xA;                result += line&#xA;            }&#xA;            break&#xA;        }&#xA;        &#xA;        if dontIndex != -1 &amp;&amp; (doIndex == -1 || dontIndex &lt; doIndex) {&#xA;            if enabled {&#xA;                result += line[:dontIndex]&#xA;            }&#xA;            enabled = false&#xA;            line = line[dontIndex+dontOffset:]&#xA;        } else {&#xA;            if enabled {&#xA;                result += line[:doIndex]&#xA;            }&#xA;            enabled = true&#xA;            line = line[doIndex+doOffset:]&#xA;        }&#xA;    }&#xA;&#xA;    return result&#xA;}&#xA;```&#xA;&#xA;I take this function and pass it to the multiply function where I get the matching patterns for the `mul` expression and do the math.&#xA;&#xA;The [strings.Index](https://pkg.go.dev/strings#Index) method takes in a string and a substring to find within that string and returns the index of the first occurring instance of that substring. With that we can identify if the line string contains the `do()` or `don’t()` expressions, if they don’t we simply return the line and if there are instances of them, we loop and trim the string before and after the expressions depending on whether the flag is enabled or disabled.&#xA;&#xA;Let’s take an example and walk through the logic:&#xA;&#xA;```plaintext&#xA;abcxmul(1,3)don&#39;t()mul(9, 7)do()mul(1,2)don&#39;t()mul(8,7)&#xA;&#xA;enabled = True&#xA;result = &#34;&#34;&#xA;line = &#34;abcxmul(1,3)don&#39;t()mul(9, 7)do()mul(1,2)don&#39;t()mul(8,7)&#34;&#xA;---&#xA;After Iteration 1:&#xA;    result -&gt; abcxmul(1,3)&#xA;    line -&gt; mul(9, 7)do()mul(1,2)don&#39;t()mul(8,7)&#xA;    enabled = False&#xA;---&#xA;After Iteration 2:&#xA;    result -&gt; abcxmul(1,3)&#xA;    line -&gt; mul(1,2)don&#39;t()mul(8,7)&#xA;    enabled = True&#xA;---&#xA;After Iteration 3:&#xA;    result -&gt; abcxmul(1,3)mul(1,2)&#xA;    line -&gt; mul(8,7)&#xA;    enabled -&gt; False&#xA;---&#xA;After Iteration 4:&#xA;    No do and don&#39;t found&#xA;    result -&gt; abcxmul(1,3)mul(1,2)&#xA;    break out of loop&#xA;---&#xA;&#xA;Result -&gt; abcxmul(1,3)mul(1,2)&#xA;```&#xA;&#xA;We process the result with the same `Multiply` function that we used in the first part after passing it through the `FindMulExpression` function that will return all the mul expressions in the result line string.&#xA;&#xA;### Heads up with the input&#xA;&#xA;The actual input of the puzzle is I think multiple lines, so we need to preserve this state of the line in all the remaining lines. OR, we could be smarter and create a single large string and process that. Both are valid and would give the same results. I just didn’t like to add an overhead of keeping track of all the states and line, so I just concatenated all the lines and processed that single string.&#xA;&#xA;## Conclusion&#xA;&#xA;This was a simple problem in essence but if you are not aware of regex you could go down a rabbit hole of writing your own parser or wired string manipulation (just like I did).&#xA;&#xA;That’s it form day 3, I will be doing more live stream solving over the weekend and may be the next week as well. Find the code for my AoC solutions here on GitHub.&#xA;&#xA;Till then,&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Advent of Code Day 2 in Golang: Slicing and Dicing Reports</title>
      <link>meetgor.com/aoc-2024-day-2</link>
      <description>Solving day 2 of Advent of Code 2024 in Golang. Diving into one of the possible approaches to the puzzle.</description>
      <pubDate>Mon, 02 Dec 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;So, this is day 2 of the Advent of Code 2024 in Golang, and we will be exploring my approach and solution for the same. The problem was not as easy but was pretty simple after implemented and found correct.&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day02/main.go).&#xA;&#xA;## Part 1&#xA;&#xA;We have been given some lines called reports, and each report has a bunch of levels. and the requirement of the report is that it needs to be either strictly increasing or decreasing by a factor of at least 1 or at most 3.&#xA;&#xA;This means if the first two elements are increasing even by one, the other subsequent elements in that report should be increasing (by 1, 2, or 3) levels, and there cannot be any change (i.e. 0 change in two adjacent numbers, or two adjacent numbers cannot be same)&#xA;&#xA;```plaintext&#xA;7 6 4 2 1&#xA;1 2 7 8 9&#xA;9 7 6 2 1&#xA;1 3 2 4 5&#xA;8 6 4 4 1&#xA;1 3 6 7 9&#xA;```&#xA;&#xA;* We first do the input parsing, it is pretty straightforward, we need to split it by `&#xA;` to get individual reports, this will be a string so `”7 6 4 2 1&#34;` , we want to get a slice of integers.&#xA;    &#xA;* So we go ahead and split by spaces/whitespace `” “` to get the individual levels (numbers) and we need to convert them into integers.&#xA;    &#xA;* Once we have individual strings of the report i.e. levels as `[“7”, “6”, “4”, “2”, “1”]` , we need to cast them to integers.&#xA;    &#xA;* We iterate over each of them and cast them to integers and append to the list.&#xA;    &#xA;* Once we have constructed the list, we append to the reports list which will be the array of arrays, i.e. each line is a report, and each report has many levels so slice of slice of integers.&#xA;    &#xA;&#xA;```go&#xA;func SplitLevels(lines []string) [][]int {&#xA;&#x9;reportLevels := [][]int{}&#xA;&#x9;for i, reportLine := range lines {&#xA;&#x9;&#x9;reportLevels = append(reportLevels, []int{})&#xA;&#x9;&#x9;for _, levelStr := range strings.Split(reportLine, &#34; &#34;) {&#xA;&#x9;&#x9;&#x9;level, err := strconv.Atoi(levelStr)&#xA;&#x9;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;reportLevels[i] = append(reportLevels[i], level)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return reportLevels&#xA;}&#xA;```&#xA;&#xA;Once we have constructed the reports and levels, we move ahead in actually analyzing the patterns within the levels in the individual reports.&#xA;&#xA;For that:&#xA;&#xA;* We first take individual reports, calculate the difference between the first two elements, and remember to use absolute difference carefully here.&#xA;    &#xA;* We need to maintain a flag which indicates whether the levels in the report are increasing or decreasing, which can be determined with the first two elements.&#xA;    &#xA;    That is if the first two elements are increasing, the subsequent levels should also be increasing and if they are decreasing then all the levels should be decreasing as well&#xA;    &#xA;* We first have a guard check, if the difference between them is 0 or greater than 3 or less than -3 which is the condition of the levels to be safe. If that is the case then we return false that is the report is not safe.&#xA;    &#xA;* We now iterate on the report after the first two elements, we then compute the difference between the next two levels, if the flag is increasing is true and the current difference is less than or equal to 0 or it exceeding 3 we also mark it as false&#xA;    &#xA;* The other condition is that if the flag is is decreasing, which means the first two elements were having a negative difference, so we check if the current difference is greater than or equal to 0 or it is less than -3, if that is the case we mark that as false&#xA;    &#xA;* After computing the difference for all the levels, if we come out of the loop, we return true as we didn’t see any discrepancy in the levels.&#xA;    &#xA;&#xA;```go&#xA;&#xA;&#xA;func IsSafe(report []int) (bool) {&#xA;&#x9;prevDiff := report[1] - report[0]&#xA;&#x9;isIcreasing := prevDiff &gt; 0&#xA;&#x9;if prevDiff == 0 || prevDiff &gt; 3 || prevDiff &lt; -3 {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;for i := 2; i &lt; len(report); i++ {&#xA;&#x9;&#x9;currDiff := report[i] - report[i-1]&#xA;&#x9;&#x9;if isIcreasing {&#xA;&#x9;&#x9;&#x9;if currDiff &lt;= 0 || currDiff &gt; 3 {&#xA;&#x9;&#x9;&#x9;&#x9;return false&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if currDiff &gt;= 0 || currDiff &lt; -3 {&#xA;&#x9;&#x9;&#x9;&#x9;return false&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return true&#xA;}&#xA;```&#xA;&#xA;## Part 2&#xA;&#xA;For part two, we need to do a few things, we need to compute if the report is safe or not, and if that is unsafe, we can almost remove one element from the report to make it safe.&#xA;&#xA;For that the approach is:&#xA;&#xA;* Get the index where we first saw the discrepancy in the levels&#xA;    &#xA;* Check by removing that element from the report, if that makes the report safe, then return true i.e. we found the safe report&#xA;    &#xA;* If we still find the report unsafe, remove the element before the index where the discrepancy was found, if now we find it safe after removing that element, then mark it safe&#xA;    &#xA;* If still we find the report unsafe, then remove the element after the index where we originally found the discrepancy, if the report becomes safe, we mark that report safe&#xA;    &#xA;* Else we mark the report unsafe, as we cannot find only the element removable that makes the report safe.&#xA;    &#xA;&#xA;```go&#xA;func RemoveAndCheck(report []int, index int) bool {&#xA;&#x9;if index &gt; len(report)-1 || index &lt; 0 {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#x9;reportNew := append([]int{}, report[:index]...)&#xA;&#x9;reportNew = append(reportNew, report[index+1:]...)&#xA;&#x9;safe, _ := IsSafe(reportNew)&#xA;&#x9;fmt.Println(safe, report)&#xA;&#x9;return safe&#xA;}&#xA;&#xA;func RemoveLevels(report []int) bool {&#xA;&#x9;safe, unsafeIndex := IsSafe(report)&#xA;&#x9;if safe {&#xA;&#x9;&#x9;return true&#xA;&#x9;} else {&#xA;&#x9;&#x9;if RemoveAndCheck(report, unsafeIndex) {&#xA;&#x9;&#x9;&#x9;return true&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if RemoveAndCheck(report, unsafeIndex-1) {&#xA;&#x9;&#x9;&#x9;return true&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if RemoveAndCheck(report, unsafeIndex+1) {&#xA;&#x9;&#x9;&#x9;return true&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day02/main.go).&#xA;&#xA;## Conclusion&#xA;&#xA;So that was it, a pretty simple problem for day 2 of the advent of code 2024 in Golang. Hope you enjoyed this walkthrough of the day one puzzle in the Advent of Code 2024 in Golang.&#xA;&#xA;Let me know if you have any other interesting solutions, or if you have anything to share about this, any feedback, questions, or suggestions are welcome.&#xA;&#xA;Thank you for reading, and I will see you tomorrow for day 3&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Advent of Code, 2024, Day 1 in Golang: Historian Hysteria</title>
      <link>meetgor.com/aoc-2024-day-1</link>
      <description>Solving day 1 of Advent of Code 2024 in Golang. Diving into one of the possible approaches to the puzzle.</description>
      <pubDate>Sun, 01 Dec 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Hello everyone, it’s that time of the year, Advent of Code, I will be solving this year as well with Golang. In previous years I have been doing Advent of Code but was not able to keep up with the pace and left it midway (not even halfway). This year however I am determined and want to solve all the problems as much as I can.&#xA;&#xA;Let’s dive into the first day which should be and is pretty simple and straightforward. A simple list and map creation and traversal and basic math operations.&#xA;&#xA;I also live-streamed the solution, you can check it out the [stream on YouTube](https://www.youtube.com/live/3K02tEEBgto?si=ojS5rsh5nGpk3U-B)&#xA;&#xA;And also a [shorter video](https://youtu.be/4U97gLyz0Ss?si=SvINHaGz-mow_q3O) on the approach and solution in Golang.&#xA;&#xA;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/4U97gLyz0Ss&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&#xA;Or you stick here and continue reading. Thank you&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day01/main.go).&#xA;&#xA;## Part 1&#xA;&#xA;[Advent of code, 2024, day 1](https://adventofcode.com/2024/day/1)&#xA;&#xA;We are given two lists here, the first part aims to find the absolute difference (distance) between each element sorted from smallest to largest.&#xA;&#xA;So, in essence, we take the two lists, sort them and one by one, for each corresponding element paired up, we take the absolute difference and sum that difference up for all the numbers in the list.&#xA;&#xA;```plaintext&#xA;3   4&#xA;4   3&#xA;2   5&#xA;1   3&#xA;3   9&#xA;3   3&#xA;```&#xA;&#xA;So, first, we need to split the input into different lists:&#xA;&#xA;1. We first range over all the lines, initialize two empty lists of integers&#xA;    &#xA;2. Then we split the line with the space as the separator, so this gives us the slice of strings as `[“3”, “4”]`&#xA;    &#xA;3. But we need to elements as integers, so take the first number and convert it to integer, similarly we do it for the second number.&#xA;    &#xA;4. Then once we have both numbers, we append them to the corresponding lists, the first number goes to the first list, and the second is appended to the second list.&#xA;    &#xA;5. Then we return the two lists&#xA;    &#xA;&#xA;NOTE: You cannot take the difference of those two numbers here itself, since we need to find the smallest number and sort the numbers in each list, so we need to get the lists populated first.&#xA;&#xA;```go&#xA;func SplitLists(lines []string) ([]int, []int) {&#xA;&#x9;listOne := []int{}&#xA;&#x9;listTwo := []int{}&#xA;&#xA;&#x9;for _, line := range lines {&#xA;&#x9;&#x9;// |3   4&#xA;&#x9;&#x9;// [&#34;3&#34;,&#34;4&#34;] slice of string ([]string)&#xA;&#x9;&#x9;// 3 &#xA;        // 4&#xA;        // [3,4] slice of int ([]int)&#xA;&#x9;&#x9;numbers := strings.Split(line, &#34;   &#34;)&#xA;&#x9;&#x9;numOne, err := strconv.Atoi(numbers[0])&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;numTwo, err := strconv.Atoi(numbers[1])&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;listOne = append(listOne, numOne)&#xA;&#x9;&#x9;listTwo = append(listTwo, numTwo)&#xA;&#x9;}&#xA;&#x9;return listOne, listTwo&#xA;}&#xA;```&#xA;&#xA;In the above code, we have initialized two empty slices of strings, we take the parameter lines which is a slice of string, indicating a line-by-line string representation of the input. I have parsed the input with these helper functions.&#xA;&#xA;The ReadFileBytes and ReadFileLines, one the bytes, the other gives the line-by-line string which gives a slice of strings.&#xA;&#xA;So once we have the lines, we iterate over each line and split the lines on space to get the two numbers. So, the line “`3 4`“ will be split into `[“3”, “4”]` . Now we get the first element and convert it into an integer as we need to sort and take the difference later.&#xA;&#xA;So, by accessing the first and second elements in the split line as `numbers[0]` and `numbers[1]` and converting the type to integer, [strconv.Atoi](https://pkg.go.dev/strconv#Atoi) function, which takes in a string and gives back an integer or an error.&#xA;&#xA;Now, we have two numbers as integers, we append the first element to the first element as `listOne = append(listOne, numOne)` and `listTwo = append(listTwo, numTwo)`&#xA;&#xA;So, we append one by one as we iterate over the input through all the lines, so at the end of this function, we will have two lists of integers.&#xA;&#xA;```&#xA;[3 4 2 1 3 3]&#xA;[4 3 5 3 9 3]&#xA;```&#xA;&#xA;Then, once we have the slices of integers, we sort those lists. Then we range over the lists one by one element, since both the lists are of the same size, we can reference one by the index of the other.&#xA;&#xA;Then for each difference of the two integers (one from the first list and the other from the second list), we cast it to a `float64` and pass it to the [math.Abs](https://pkg.go.dev/math#Abs) function, which is annoying as Golang doesn’t have an absolute function for intgers. We cast the integer to float for parsing it to the Abs method and cast the returned float64 value back to int. Kind of wired but fine.&#xA;&#xA;We keep adding the absolute differences for each paired difference of the elements in the two lists. At the end, we will have a final score which is the score for part one.&#xA;&#xA;```go&#xA;func PartOne(lines []string) int {&#xA;&#x9;listOne, listTwo := SplitLists(lines)&#xA;&#x9;sort.Ints(listOne)&#xA;&#x9;sort.Ints(listTwo)&#xA;&#x9;totalScore := 0&#xA;&#x9;for i := range listOne {&#xA;&#x9;&#x9;totalScore += int(math.Abs(float64(listOne[i] - listTwo[i]))&#xA;&#x9;}&#xA;&#x9;return totalScore&#xA;}&#xA;```&#xA;&#xA;## Part 2&#xA;&#xA;For part two, we need to take all the numbers in the first list count the number of times that number has occurred in the second list, and take a product of them and add it up for all the numbers.&#xA;&#xA;So in the example:&#xA;&#xA;```plaintext&#xA;3   4&#xA;4   3&#xA;2   5&#xA;1   3&#xA;3   9&#xA;3   3&#xA;```&#xA;&#xA;The numbers in the first list are \[3,4,2,1,3,3\]&#xA;&#xA;We have to count the occurrences of each of them in the second list&#xA;&#xA;So, in the second list \[4,3,5,3,9,3\], the number `3` occurs `3` times, so we do `3×3` which is `9` and then, do the same for `4` which occurs only once in the second list so, we get `4`, then `2` occurs `0` times, so we get `0`&#xA;&#xA;We get → `(3×3) + (4×1) + (2×0) + (1×0) + (3×3) + (3×3)`&#xA;&#xA;The first number is the element in the first list and the second number is the occurrence of that number in the second list.&#xA;&#xA;which comes out to be `9+4+0+0+9+9` , so the answer is `31` for the example.&#xA;&#xA;Once it is clear, what we have to do, we simply have to iterate over the second list and create a map of the frequency/occurances/number of times it appears in that list.&#xA;&#xA;### Solution&#xA;&#xA;So, we will have to modify the `SplitLists` functions a bit, we need to split and also map the second list with the key as the number itself and the value as its count in the second list.&#xA;&#xA;Just that change, we create an additional return value with an empty map of integers with integers. The mapTwo variable will be a map that will have a key as the number in the second list and its value as the number of times it is present in that list.&#xA;&#xA;```go&#xA;func SplitListsAndMap(lines []string) ([]int, map[int]int) {&#xA;&#x9;listOne := []int{}&#xA;&#x9;listTwoCounts := make(map[int]int)&#xA;&#xA;&#x9;for _, line := range lines {&#xA;&#x9;&#x9;numbers := strings.Split(line, &#34;   &#34;)&#xA;&#x9;&#x9;numOne, err := strconv.Atoi(numbers[0])&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;numTwo, err := strconv.Atoi(numbers[1])&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;listOne = append(listOne, numOne)&#xA;        listTwoCounts[numTwo] += 1&#xA;&#x9;}&#xA;&#x9;return listOne, listTwoCounts&#xA;}&#xA;```&#xA;&#xA;So, as we iterate over each line, we parse the string number into an integer and increment its count in the map.&#xA;&#xA;```&#xA;[3 4 2 1 3 3]&#xA;map[3:3 4:1 5:1 9:1]&#xA;```&#xA;&#xA;In the actual calculation of the score, we need to iterate over the elements of the first list and multiply the number with its count in the second list as we now have the map of it. We multiply those and add them up for each line, which becomes the final score.&#xA;&#xA;```go&#xA;func PartTwo(lines []string) int {&#xA;    similarityScore := 0&#xA;&#xA;&#x9;listOne, mapTwo := SplitListsAndMap(lines)&#xA;&#xA;&#x9;for _, numOne := range listOne {&#xA;&#x9;&#x9;score := numOne * mapTwo[numOne]&#xA;&#x9;&#x9;similarityScore += score&#xA;&#x9;}&#xA;&#xA;&#x9;return similarityScore&#xA;}&#xA;```&#xA;&#xA;So, that is how we got the final score for part two.&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day01/main.go).&#xA;&#xA;## Conclusion&#xA;&#xA;So that was it, a pretty simple problem for day 1 of the advent of code 2024 in Golang. Hope you enjoyed this walkthrough of the day one puzzle in the Advent of Code 2024 in Golang.&#xA;&#xA;Thank you for reading, and I will see you tomorrow for day 2&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
  </channel>
</rss>