<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <title>Read a Rss Feed with a URL in Golang | Meet Gor</title>
    <meta name="title" content="Read a Rss Feed with a URL in Golang | Meet Gor">
    <meta name="description" content="Reading Rss Feed with a Rss XML Link/URL in golang using encoding package">
    <meta name="author" content="Meet Gor">
    <meta name="keywords" content="go">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="meetgor.com/til/golang-read-rss-feed">
    
    
    <meta property="og:type" content="article">
    <meta property="og:url" content="meetgor.com/til/golang-read-rss-feed">
    <meta property="og:title" content="Read a Rss Feed with a URL in Golang | Meet Gor">
    <meta property="og:description" content="Reading Rss Feed with a Rss XML Link/URL in golang using encoding package">
    <meta property="og:image" content="meetgor.com/tbicon.png">
    <meta property="og:site_name" content="Meet Gor">
    <meta property="article:published_time" content="2022-11-11">
    <meta property="article:modified_time" content="2022-11-11">
    <meta property="article:author" content="Meet Gor">
    
    <meta property="article:tag" content="go">
    
    
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@meetgor711">
    <meta name="twitter:creator" content="@meetgor711">
    <meta name="twitter:url" content="meetgor.com/til/golang-read-rss-feed">
    <meta name="twitter:title" content="Read a Rss Feed with a URL in Golang | Meet Gor">
    <meta name="twitter:description" content="Reading Rss Feed with a Rss XML Link/URL in golang using encoding package">
    <meta name="twitter:image" content="meetgor.com/tbicon.png">
    
    
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "meetgor.com/til\/golang-read-rss-feed"
        },
        "headline": "Read a Rss Feed with a URL in Golang",
        "description": "Reading Rss Feed with a Rss XML Link\/URL in golang using encoding package",
        "datePublished": "2022-11-11",
        "dateModified": "2022-11-11",
        "author": {
            "@type": "Person",
            "name": "Meet Gor"
        },
        "publisher": {
            "@type": "Organization",
            "name": "Meet Gor",
            "logo": {
                "@type": "ImageObject",
                "url": "meetgor.com/tbicon.png"
            }
        },
        
        "keywords": "go",
        "articleBody": "\u0026lt;h2 id=\u0026#34;reding-rss-feed\u0026#34;\u0026gt;Reding Rss Feed\u0026lt;\/h2\u0026gt;\n\u0026lt;p\u0026gt;We can use golang\u0026#39;s \u0026lt;a href=\u0026#34;https:\/\/pkg.go.dev\/encoding\/xml\u0026#34;\u0026gt;encoding\/xml\u0026lt;\/a\u0026gt; package to read a Rss feed. Though we have to be speicific of what type of structure the Rss feed has, so it is not dynamic but it works really well with structs. I have covered a few nuances of reading XML file in the \u0026lt;a href=\u0026#34;https:\/\/www.meetgor.com\/golang-config-file-read\/#reading-xml-file\u0026#34;\u0026gt;config file reading\u0026lt;\/a\u0026gt; post of the 100 days of golang series.\u0026lt;\/p\u0026gt;\n\u0026lt;h3 id=\u0026#34;get-request-to-rss-feed\u0026#34;\u0026gt;Get request to Rss feed\u0026lt;\/h3\u0026gt;\n\u0026lt;p\u0026gt;We first need to send a \u0026lt;code\u0026gt;GET\u0026lt;\/code\u0026gt; request to the Rss feed, we can use the \u0026lt;a href=\u0026#34;https:\/\/pkg.go.dev\/net\/http\u0026#34;\u0026gt;http\u0026lt;\/a\u0026gt; package to grab the response.\u0026lt;\/p\u0026gt;\n\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;go\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;language-go\u0026#34;\u0026gt;package main\n\nimport (\n\t\u0026#34;log\u0026#34;\n\t\u0026#34;net\/http\u0026#34;\n)\n\nfunc main() {\n\n\turl := \u0026#34;https:\/\/meetgor.com\/rss.xml\u0026#34;\n\tresponse, err := http.Get(url)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n    log.Println(response.Body)\n\tdefer response.Body.Close()\n\n}\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;p\u0026gt;So, in the above example, we have used the \u0026lt;code\u0026gt;net\/http\u0026lt;\/code\u0026gt; package to send a \u0026lt;code\u0026gt;GET\u0026lt;\/code\u0026gt; request with the \u0026lt;a href=\u0026#34;https:\/\/pkg.go.dev\/net\/http#Get\u0026#34;\u0026gt;Get\u0026lt;\/a\u0026gt; funciton. The function takes in a string as a \u0026lt;code\u0026gt;URL\u0026lt;\/code\u0026gt; and returns either the object as response or an error. If there arose any error, we simply exit out of the program and log the error. If the error is \u0026lt;code\u0026gt;nil\u0026lt;\/code\u0026gt;, we return the response in the \u0026lt;code\u0026gt;response\u0026lt;\/code\u0026gt; variable. This builds up a good foundation for the next step to read the response body and fetching the actual bytes from the response.\u0026lt;\/p\u0026gt;\n\u0026lt;h3 id=\u0026#34;fetch-the-content-from-the-link\u0026#34;\u0026gt;Fetch the content from the Link\u0026lt;\/h3\u0026gt;\n\u0026lt;p\u0026gt;Since we have the \u0026lt;code\u0026gt;response\u0026lt;\/code\u0026gt; object, we can use the \u0026lt;a href=\u0026#34;https:\/\/pkg.go.dev\/io#ReadAll\u0026#34;\u0026gt;io.ReadAll\u0026lt;\/a\u0026gt; function to read the bytes in the response body. The function takes in the \u0026lt;a href=\u0026#34;https:\/\/pkg.go.dev\/io#Reader\u0026#34;\u0026gt;Reader\u0026lt;\/a\u0026gt; object in this case it is \u0026lt;a href=\u0026#34;https:\/\/pkg.go.dev\/io#ReadCloser\u0026#34;\u0026gt;ReadCloser\u0026lt;\/a\u0026gt; object as a http object. The function then returns the slice of bytes\/int8. The slice then can be interpreted as string or other form data that can be used for parsing the xml from the response.\u0026lt;\/p\u0026gt;\n\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;go\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;language-go\u0026#34;\u0026gt;package main\n\nimport (\n\t\u0026#34;log\u0026#34;\n\t\u0026#34;net\/http\u0026#34;\n    \u0026#34;io\u0026#34;\n)\n\nfunc main() {\n\n\turl := \u0026#34;https:\/\/meetgor.com\/rss.xml\u0026#34;\n\tresponse, err := http.Get(url)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdata, err := io.ReadAll(response.Body)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n    log.Println(string(data))\n    log.Printf(\u0026#34;Type -\u0026gt; %T\u0026#34;, data)\n}\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;\u0026lt;rss\u0026gt;\n    \u0026lt;channel\u0026gt;\n        \u0026lt;item\u0026gt;\n        ...\n        ...\n        ...\n        \u0026lt;\/item\u0026gt;\n    \u0026lt;\/channel\u0026gt;\n\u0026lt;\/rss\u0026gt;\n\n\nType -\u0026gt; []uint8 \n\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;p\u0026gt;So, we can see that the parsed content is indeed xml, it is type casted to string from the slice of bytes. This can be further used for the parsing the text as Rss structure and fetch the required details.\u0026lt;\/p\u0026gt;\n\u0026lt;h2 id=\u0026#34;parsing-rss-with-a-struct\u0026#34;\u0026gt;Parsing Rss with a struct\u0026lt;\/h2\u0026gt;\n\u0026lt;p\u0026gt;We can now move into creating a struct for individual tags required in the parsing.\u0026lt;\/p\u0026gt;\n\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;go\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;language-go\u0026#34;\u0026gt;package main\n\nimport (\n    \u0026#34;encoding\/xml\u0026#34;\n\t\u0026#34;io\u0026#34;\n\t\u0026#34;log\u0026#34;\n\t\u0026#34;net\/http\u0026#34;\n)\n\ntype Rss struct {\n\tXMLName xml.Name \u0060xml:\u0026#34;rss\u0026#34;\u0060\n\tChannel Channel  \u0060xml:\u0026#34;channel\u0026#34;\u0060\n}\n\ntype Channel struct {\n\tXMLName     xml.Name \u0060xml:\u0026#34;channel\u0026#34;\u0060\n\tTitle       string   \u0060xml:\u0026#34;title\u0026#34;\u0060\n\tDescription string   \u0060xml:\u0026#34;description\u0026#34;\u0060\n\tItem        []Item   \u0060xml:\u0026#34;item\u0026#34;\u0060\n}\n\ntype Item struct {\n\tXMLName xml.Name \u0060xml:\u0026#34;item\u0026#34;\u0060\n\tTitle   string   \u0060xml:\u0026#34;title\u0026#34;\u0060\n\tLink    string   \u0060xml:\u0026#34;link\u0026#34;\u0060\n}\n\nfunc main() {\n\n\turl := \u0026#34;https:\/\/meetgor.com\/rss.xml\u0026#34;\n\tresponse, err := http.Get(url)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdata, err := io.ReadAll(response.Body)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n    log.Println(string(data))\n}\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;p\u0026gt;If you would look at the \u0026lt;a href=\u0026#34;https:\/\/meetgor.com\/rss.xml\u0026#34;\u0026gt;rss feed\u0026lt;\/a\u0026gt;, you can see it has a structure of tags and elements. The \u0026lt;code\u0026gt;rss\u0026lt;\/code\u0026gt; tag is the root tag, followed by \u0026lt;code\u0026gt;channel\u0026lt;\/code\u0026gt; and other types of nested tags speicific for the type of information to be stored like \u0026lt;code\u0026gt;title\u0026lt;\/code\u0026gt; for the title in the feed, \u0026lt;code\u0026gt;link\u0026lt;\/code\u0026gt; for the link to the feed, etc.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;So, we create those as structure, the root structure is the \u0026lt;code\u0026gt;Rss\u0026lt;\/code\u0026gt; which we will create with a few attributes like \u0026lt;code\u0026gt;Channel\u0026lt;\/code\u0026gt; and the name of the current tag. In the \u0026lt;code\u0026gt;Rss\u0026lt;\/code\u0026gt; case the name of the tag\/element is \u0026lt;code\u0026gt;rss\u0026lt;\/code\u0026gt;, so it is given the \u0026lt;code\u0026gt;xml.Name\u0026lt;\/code\u0026gt; as \u0026lt;code\u0026gt;xml:\u0026#39;rss\u0026#39;\u0026lt;\/code\u0026gt; in backticks indicating the type hint for the field. The next field is the \u0026lt;code\u0026gt;Channel\u0026lt;\/code\u0026gt; which is another type(custom type struct). We have defined \u0026lt;code\u0026gt;Channel\u0026lt;\/code\u0026gt; as a struct just after it that will hold information like the \u0026lt;code\u0026gt;title\u0026lt;\/code\u0026gt;, \u0026lt;code\u0026gt;description\u0026lt;\/code\u0026gt; of the website. We also have the \u0026lt;code\u0026gt;xml.Name\u0026lt;\/code\u0026gt; as \u0026lt;code\u0026gt;xml:\u0026amp;quot;channel\u0026amp;quot;\u0026lt;\/code\u0026gt; which indicates the current struct is representation of \u0026lt;code\u0026gt;channel\u0026lt;\/code\u0026gt; tag in the rss feed. Finally, we also have a custom type struct as \u0026lt;code\u0026gt;Item\u0026lt;\/code\u0026gt;. The \u0026lt;code\u0026gt;Item\u0026lt;\/code\u0026gt; struct has a few attributes like \u0026lt;code\u0026gt;Title\u0026lt;\/code\u0026gt;, \u0026lt;code\u0026gt;Link\u0026lt;\/code\u0026gt; and you can now start to see the pattern, you can customize it as per your requirements and speicifications.\u0026lt;\/p\u0026gt;\n\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;go\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;language-go\u0026#34;\u0026gt;package main\n\nimport (\n    \u0026#34;encoding\/xml\u0026#34;\n\t\u0026#34;io\u0026#34;\n\t\u0026#34;log\u0026#34;\n\t\u0026#34;net\/http\u0026#34;\n)\n\ntype Rss struct {\n\tXMLName xml.Name \u0060xml:\u0026#34;rss\u0026#34;\u0060\n\tChannel Channel  \u0060xml:\u0026#34;channel\u0026#34;\u0060\n}\n\ntype Channel struct {\n\tXMLName     xml.Name \u0060xml:\u0026#34;channel\u0026#34;\u0060\n\tTitle       string   \u0060xml:\u0026#34;title\u0026#34;\u0060\n\tDescription string   \u0060xml:\u0026#34;description\u0026#34;\u0060\n\tItem        []Item   \u0060xml:\u0026#34;item\u0026#34;\u0060\n}\n\ntype Item struct {\n\tXMLName xml.Name \u0060xml:\u0026#34;item\u0026#34;\u0060\n\tTitle   string   \u0060xml:\u0026#34;title\u0026#34;\u0060\n\tLink    string   \u0060xml:\u0026#34;link\u0026#34;\u0060\n}\n\nfunc main() {\n\n\turl := \u0026#34;https:\/\/meetgor.com\/rss.xml\u0026#34;\n\tresponse, err := http.Get(url)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdata, err := io.ReadAll(response.Body)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n    \/\/ New Code\n\n\td := Rss{}\n\terr = xml.Unmarshal(data, \u0026amp;d)\n\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfor _, item := range d.Channel.Item {\n\t\tlog.Println(item.Title)\n\t}\n}\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;$ go run main.go\n\nWhy and How to make and use Vim as a text editor and customizable IDE\nSetting up Vim for Python\nSetting up Vim for BASH Scripting\nVim: Keymapping Guide\n...\n...\n...\nDjango \u002b HTMX CRUD application\nPGCLI: Postgres from the terminal\nGolang: Closures\nGolang: Interfaces\nGolang: Error Handling\nGolang: Paths\nGolang: File Reading\nGolang: JSON YAML TOML (config) File Reading.\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;p\u0026gt;So, here we have initialized the \u0026lt;code\u0026gt;Rss\u0026lt;\/code\u0026gt; struct as empty and then used the \u0026lt;a href=\u0026#34;https:\/\/pkg.go.dev\/encoding\/xml#Unmarshal\u0026#34;\u0026gt;Unmarshal\u0026lt;\/a\u0026gt; method in the \u0026lt;code\u0026gt;xml\u0026lt;\/code\u0026gt; package. The Unmarshal method will parse the data as per the type of either int, float, bool or string, any other type of data will be discarded as interface or struct. We can usually parse any valid type of data into \u0026lt;code\u0026gt;Unmarshal\u0026lt;\/code\u0026gt; method and it generally gives a proper expected outcome.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;The Unmarshal method takes in the slice of byte and the second paramter as pointer to a struct or any variable that will store the parsed xml content from the slice of byte. The function just returns the error type, either \u0026lt;code\u0026gt;nil\u0026lt;\/code\u0026gt; in case of no errors, and returns the actual error obejct if there arise any type of error.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;So we parse the \u0026lt;code\u0026gt;data\u0026lt;\/code\u0026gt; which is a slice of byte to the funciton and the reference to the \u0026lt;code\u0026gt;d\u0026lt;\/code\u0026gt; object which is a empty \u0026lt;code\u0026gt;Rss\u0026lt;\/code\u0026gt; object. This will get us the data in the \u0026lt;code\u0026gt;d\u0026lt;\/code\u0026gt; object. We can then iterate over the object as per the struct and use the perform operations like type casting or converting types, etc to get your required data back.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;In the above example, we simply iterate over the \u0026lt;code\u0026gt;d.Channel.Item\u0026lt;\/code\u0026gt; which is a list of elements of tag \u0026lt;code\u0026gt;item\u0026lt;\/code\u0026gt; in the rss feed. Inside the for loop, we can access the object and simply print or perform any sort of operations. I have simply printed the list of articles with titles.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;Links for the code available on the \u0026lt;a href=\u0026#34;https:\/\/github.com\/Mr-Destructive\/100-days-of-golang\/blob\/main\/scripts\/files\/read\/config_files\/xml\/rss.go\u0026#34;\u0026gt;100 days of golang\u0026lt;\/a\u0026gt; GitHub repository.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;So, that\u0026#39;s how we parse an XML feed in golang. Just plug and play if you have a similar type of structure of the Rss XML feed. Happy Coding :)\u0026lt;\/p\u0026gt;\n"
    }
    </script>
    
    
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="/code-block.css">
    
    <link rel="icon" href="/tbicon.png" type="image/png">
    <link rel="apple-touch-icon" href="/tbicon.png">
    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <link id="syntax-theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/sql-wasm.js"></script>
    <link rel="stylesheet" href="/sql-playground.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/monokai.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/sql/sql.min.js"></script>
    <script src="/sql-playground.js"></script>
    
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script>
    document.addEventListener("DOMContentLoaded", () => {
        const body = document.body;
        const stylesheet = document.getElementById("syntax-theme");
        const themeToggle = document.getElementById('theme-toggle');

        function setSyntaxTheme(theme) {
            if (theme === "secondary") {
                stylesheet.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css";
            } else {
                stylesheet.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css";
            }
        }

        
        document.querySelectorAll("pre code").forEach((block) => {
            hljs.highlightElement(block);
        });

        
        const currentTheme = localStorage.getItem("theme") || "default";
        if (currentTheme === "secondary") {
            body.classList.add("secondary-theme");
            if (themeToggle) themeToggle.checked = true;
        }
        setSyntaxTheme(currentTheme);

        
        if (themeToggle) {
            themeToggle.addEventListener('change', () => {
                const newTheme = themeToggle.checked ? 'secondary' : 'default';
                if (themeToggle.checked) {
                    body.classList.add('secondary-theme');
                } else {
                    body.classList.remove('secondary-theme');
                }
                localStorage.setItem('theme', newTheme);
                setSyntaxTheme(newTheme);
            });
        }
        
        
        const editBtn = document.getElementById('editor-edit');
        if (editBtn) {
            editBtn.addEventListener('click', async function () {
                const slug = "til\/golang-read-rss-feed";
                const type = "til";
                console.log("Editing post:", slug, type);
                const url = "https:\/\/devmeetgor.netlify.app/.netlify/functions/api?slug=" + slug + "&method=edit&type=" + type;
                
                try {
                    const res = await fetch(url);
                    if (!res.ok) throw new Error("Failed to fetch edit content");
                    const html = await res.text();
                    document.querySelector('.post-content').innerHTML = html;
                } catch (err) {
                    console.error(err);
                    alert("Error loading editor content");
                }
            });
        }
    });
    </script>
    
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-EET2ZX4QY1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-EET2ZX4QY1');
    </script>
</head>
<body>
    <header class="header">
  <a class="site-title" href="/" aria-label="Meet Gor - Home">Meet Gor</a>
  <nav>
    <ul>
      <li><a href="/" aria-label="Home">Home</a></li>
      <li><a href="/posts" aria-label="Posts">Posts</a></li>
      <li><a href="/about" aria-label="About">About</a></li>
      <li><a href="/contact" aria-label="Contact">Contact</a></li>
    </ul>
  </nav>
  <div class="theme-switch">
    <input type="checkbox" id="theme-toggle" aria-label="Toggle Theme">
    <label for="theme-toggle"></label>
  </div>
  
    <button id="editor" onclick="location.href='/editor'" aria-label="Editor">
      Editor
    </button>
  
</header>
    
    <main class="container">
        <article class="blog-post">
            <h1>Read a Rss Feed with a URL in Golang</h1>
            
            <div class="post-meta">
                Published on 📅 <time datetime="2022-11-11">2022-11-11</time>
            </div>
            
            <div class="post-meta">
                Type: <a href="/til">til</a>
            </div>
            
            <div class="post-meta tags">
                <span class="post-series-label">🏷️ Tags:</span>
                
                <a href="/tags/go">#go</a>
                
            </div>
            
            
            
            
            <div class="post-meta admin-controls">
                <button id="editor-edit">Edit</button>
                <button id="editor-delete" 
                        onclick="location.href='/editor/?slug=til\/golang-read-rss-feed&method=delete'">
                    Delete
                </button>
            </div>
            
            
            <hr>
            
            <div class="post-content">
                <h2 id="reding-rss-feed">Reding Rss Feed</h2>
<p>We can use golang's <a href="https://pkg.go.dev/encoding/xml">encoding/xml</a> package to read a Rss feed. Though we have to be speicific of what type of structure the Rss feed has, so it is not dynamic but it works really well with structs. I have covered a few nuances of reading XML file in the <a href="https://www.meetgor.com/golang-config-file-read/#reading-xml-file">config file reading</a> post of the 100 days of golang series.</p>
<h3 id="get-request-to-rss-feed">Get request to Rss feed</h3>
<p>We first need to send a <code>GET</code> request to the Rss feed, we can use the <a href="https://pkg.go.dev/net/http">http</a> package to grab the response.</p>
<div class="code-block"><div class="code-header"><span class="language-name">go</span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code class="language-go">package main

import (
	"log"
	"net/http"
)

func main() {

	url := "https://meetgor.com/rss.xml"
	response, err := http.Get(url)

	if err != nil {
		log.Fatal(err)
	}

    log.Println(response.Body)
	defer response.Body.Close()

}
</code></pre></div><p>So, in the above example, we have used the <code>net/http</code> package to send a <code>GET</code> request with the <a href="https://pkg.go.dev/net/http#Get">Get</a> funciton. The function takes in a string as a <code>URL</code> and returns either the object as response or an error. If there arose any error, we simply exit out of the program and log the error. If the error is <code>nil</code>, we return the response in the <code>response</code> variable. This builds up a good foundation for the next step to read the response body and fetching the actual bytes from the response.</p>
<h3 id="fetch-the-content-from-the-link">Fetch the content from the Link</h3>
<p>Since we have the <code>response</code> object, we can use the <a href="https://pkg.go.dev/io#ReadAll">io.ReadAll</a> function to read the bytes in the response body. The function takes in the <a href="https://pkg.go.dev/io#Reader">Reader</a> object in this case it is <a href="https://pkg.go.dev/io#ReadCloser">ReadCloser</a> object as a http object. The function then returns the slice of bytes/int8. The slice then can be interpreted as string or other form data that can be used for parsing the xml from the response.</p>
<div class="code-block"><div class="code-header"><span class="language-name">go</span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code class="language-go">package main

import (
	"log"
	"net/http"
    "io"
)

func main() {

	url := "https://meetgor.com/rss.xml"
	response, err := http.Get(url)

	if err != nil {
		log.Fatal(err)
	}

	data, err := io.ReadAll(response.Body)

	if err != nil {
		log.Fatal(err)
	}

    log.Println(string(data))
    log.Printf("Type -> %T", data)
}
</code></pre></div><div class="code-block"><div class="code-header"><span class="language-name"></span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code><rss>
    <channel>
        <item>
        ...
        ...
        ...
        </item>
    </channel>
</rss>


Type -> []uint8 

</code></pre></div><p>So, we can see that the parsed content is indeed xml, it is type casted to string from the slice of bytes. This can be further used for the parsing the text as Rss structure and fetch the required details.</p>
<h2 id="parsing-rss-with-a-struct">Parsing Rss with a struct</h2>
<p>We can now move into creating a struct for individual tags required in the parsing.</p>
<div class="code-block"><div class="code-header"><span class="language-name">go</span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code class="language-go">package main

import (
    "encoding/xml"
	"io"
	"log"
	"net/http"
)

type Rss struct {
	XMLName xml.Name `xml:"rss"`
	Channel Channel  `xml:"channel"`
}

type Channel struct {
	XMLName     xml.Name `xml:"channel"`
	Title       string   `xml:"title"`
	Description string   `xml:"description"`
	Item        []Item   `xml:"item"`
}

type Item struct {
	XMLName xml.Name `xml:"item"`
	Title   string   `xml:"title"`
	Link    string   `xml:"link"`
}

func main() {

	url := "https://meetgor.com/rss.xml"
	response, err := http.Get(url)

	if err != nil {
		log.Fatal(err)
	}

	data, err := io.ReadAll(response.Body)

	if err != nil {
		log.Fatal(err)
	}

    log.Println(string(data))
}
</code></pre></div><p>If you would look at the <a href="https://meetgor.com/rss.xml">rss feed</a>, you can see it has a structure of tags and elements. The <code>rss</code> tag is the root tag, followed by <code>channel</code> and other types of nested tags speicific for the type of information to be stored like <code>title</code> for the title in the feed, <code>link</code> for the link to the feed, etc.</p>
<p>So, we create those as structure, the root structure is the <code>Rss</code> which we will create with a few attributes like <code>Channel</code> and the name of the current tag. In the <code>Rss</code> case the name of the tag/element is <code>rss</code>, so it is given the <code>xml.Name</code> as <code>xml:'rss'</code> in backticks indicating the type hint for the field. The next field is the <code>Channel</code> which is another type(custom type struct). We have defined <code>Channel</code> as a struct just after it that will hold information like the <code>title</code>, <code>description</code> of the website. We also have the <code>xml.Name</code> as <code>xml:&quot;channel&quot;</code> which indicates the current struct is representation of <code>channel</code> tag in the rss feed. Finally, we also have a custom type struct as <code>Item</code>. The <code>Item</code> struct has a few attributes like <code>Title</code>, <code>Link</code> and you can now start to see the pattern, you can customize it as per your requirements and speicifications.</p>
<div class="code-block"><div class="code-header"><span class="language-name">go</span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code class="language-go">package main

import (
    "encoding/xml"
	"io"
	"log"
	"net/http"
)

type Rss struct {
	XMLName xml.Name `xml:"rss"`
	Channel Channel  `xml:"channel"`
}

type Channel struct {
	XMLName     xml.Name `xml:"channel"`
	Title       string   `xml:"title"`
	Description string   `xml:"description"`
	Item        []Item   `xml:"item"`
}

type Item struct {
	XMLName xml.Name `xml:"item"`
	Title   string   `xml:"title"`
	Link    string   `xml:"link"`
}

func main() {

	url := "https://meetgor.com/rss.xml"
	response, err := http.Get(url)

	if err != nil {
		log.Fatal(err)
	}

	data, err := io.ReadAll(response.Body)

	if err != nil {
		log.Fatal(err)
	}

    // New Code

	d := Rss{}
	err = xml.Unmarshal(data, &d)

	if err != nil {
		log.Fatal(err)
	}

	for _, item := range d.Channel.Item {
		log.Println(item.Title)
	}
}
</code></pre></div><div class="code-block"><div class="code-header"><span class="language-name"></span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code>$ go run main.go

Why and How to make and use Vim as a text editor and customizable IDE
Setting up Vim for Python
Setting up Vim for BASH Scripting
Vim: Keymapping Guide
...
...
...
Django + HTMX CRUD application
PGCLI: Postgres from the terminal
Golang: Closures
Golang: Interfaces
Golang: Error Handling
Golang: Paths
Golang: File Reading
Golang: JSON YAML TOML (config) File Reading.
</code></pre></div><p>So, here we have initialized the <code>Rss</code> struct as empty and then used the <a href="https://pkg.go.dev/encoding/xml#Unmarshal">Unmarshal</a> method in the <code>xml</code> package. The Unmarshal method will parse the data as per the type of either int, float, bool or string, any other type of data will be discarded as interface or struct. We can usually parse any valid type of data into <code>Unmarshal</code> method and it generally gives a proper expected outcome.</p>
<p>The Unmarshal method takes in the slice of byte and the second paramter as pointer to a struct or any variable that will store the parsed xml content from the slice of byte. The function just returns the error type, either <code>nil</code> in case of no errors, and returns the actual error obejct if there arise any type of error.</p>
<p>So we parse the <code>data</code> which is a slice of byte to the funciton and the reference to the <code>d</code> object which is a empty <code>Rss</code> object. This will get us the data in the <code>d</code> object. We can then iterate over the object as per the struct and use the perform operations like type casting or converting types, etc to get your required data back.</p>
<p>In the above example, we simply iterate over the <code>d.Channel.Item</code> which is a list of elements of tag <code>item</code> in the rss feed. Inside the for loop, we can access the object and simply print or perform any sort of operations. I have simply printed the list of articles with titles.</p>
<p>Links for the code available on the <a href="https://github.com/Mr-Destructive/100-days-of-golang/blob/main/scripts/files/read/config_files/xml/rss.go">100 days of golang</a> GitHub repository.</p>
<p>So, that's how we parse an XML feed in golang. Just plug and play if you have a similar type of structure of the Rss XML feed. Happy Coding :)</p>

            </div>
        </article>
    </main>
    
    <div id="comments">
        <script src="https://giscus.app/client.js"
            data-repo="Mr-Destructive/meetgor.com"
            data-repo-id="R_kgDOHZ6V_g"
            data-category="Q&A"
            data-category-id="DIC_kwDOHZ6V_s4CRfn4"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-theme="dark_high_contrast"
            data-lang="en"
            crossorigin="anonymous"
            async>
        </script>
    </div>
    
    <footer class="site-footer" role="contentinfo">
  <div class="footer-content">
    <p>&copy; Meet Gor. All rights reserved.</p>
    <div class="social-links">
      <a href="/contact" aria-label="Connect with me">Connect with me</a>
    </div>
  </div>
</footer>
    
</body>
</html>
