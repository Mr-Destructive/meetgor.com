<rss version="2.0">
  <channel>
    <title>Meet Gor - Tag: docker</title>
    <link>meetgor.com</link>
    <description>Posts tagged with docker</description>
    <language>en-us</language>
    <pubDate>Fri, 17 Oct 2025 16:57:38 UTC</pubDate>
    <item>
      <title>Django App from Scratch Using Docker with Debian Base Image</title>
      <link>meetgor.com/django-app-from-scratch</link>
      <description>Creating a django basic application with configuration for static files, templates and user authentication using docker and debian base image.</description>
      <pubDate>Tue, 24 May 2022 00:00:00 UTC</pubDate>
      <content>## Pull a Fresh Debian Image&#xA;&#xA;Create a docker container from a Debian image, the following command can be used to pull a debain 11-slim image and create a container of it, also enter into the container in a interactive environment `-it` mode. &#xA;&#xA;```&#xA;docker run -v $(pwd):/var/www --rm -it -p 8001:80 debian:11-slim&#xA;```&#xA;&#xA;## Create a Django App from Shell script&#xA;&#xA;Now, since we are inside a Debian container, we can enter a few commands, you can refer to the Mark Gibney&#39;s [GitHub repository](https://github.com/no-gravity/web_app_from_scratch) for the script.&#xA;&#xA;```&#xA;apt update&#xA;&#xA;apt install wget&#xA;&#xA;wget https://raw.githubusercontent.com/no-gravity/web_app_from_scratch/main/django.sh&#xA;```&#xA;&#xA;Also, if you want to do a few adjustments, you can install an editor, get used to vim or use nano.&#xA;&#xA;```&#xA;apt install vim &#xA;&#xA;OR&#xA;&#xA;apt install nano&#xA;```&#xA;&#xA;```&#xA;chmod +x django.sh&#xA;bash django.sh&#xA;```&#xA;&#xA;I also have a few adjustment of the original script, that accepts a project name and creates a django project based on the positional parameter given to it. You can get it from the [quick-setup-script repository](https://github.com/Mr-Destructive/quick-setup-scripts/blob/main/django_docker.sh) or directly the [script](https://raw.githubusercontent.com/Mr-Destructive/quick-setup-scripts/main/django_docker.sh).&#xA;&#xA;To use the above file, you need to execute the command as :&#xA;&#xA;```&#xA;chmod +x django_docker.sh&#xA;bash django_docker.sh &lt;project_name&gt;&#xA;```&#xA;&#xA;This will generate the project in the `/var/www/` folder with the name of the project. The script will prompt you with a few things for setting up at some iterations like basic application setup , `static file` configuration, `basic tempalte` setup and the `user authentication` setup.&#xA;&#xA;## Copy the contents from the docker container&#xA;&#xA;You can copy the contents of the folder into your local machine by entering the [cp](https://docs.docker.com/engine/reference/commandline/cp/) command in docker. &#xA;&#xA;```&#xA;docker cp &lt;container_id&gt;:/var/www/&lt;project_name&gt; /path/in_local_machine/&#xA;```&#xA;&#xA;This will copy the project in the docker container into the local machine for you to extend and tweak it as per your needs.&#xA;&#xA;That&#39;s a basic Django Project Setup by using Docker with a Debian Image.&#xA;</content>
      <type>til</type>
    </item>
    <item>
      <title>Dockerize a Django project</title>
      <link>meetgor.com/dockerize-django-prj</link>
      <description></description>
      <pubDate>Wed, 02 Mar 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Dockerize a Django project&#xA;&#xA;We can run our Django projects in a Docker Container by creating a Docker image for our project. It is really easy and intuitive to create a Dockerfile for any given application as it really is a matter of writing commands in a file and basically running it is a isolated environment. To create a Docker image, we first need a Dockerfile. A Dockerfile is simply a Blueprint to create a image in Docker. In this file we specify the instructions/commands/environment variables to create a image for our app to run. &#xA;&#xA;### Create a Docker File&#xA;&#xA;To create a dockerfile, simply create a file named as `Dockerfile` without any extension(not a .txt file). We need to then add the following code into the file. &#xA;&#xA;```dockerfile&#xA;FROM python:3.9-buster&#xA;&#xA;ENV PYTHONUNBUFFERED=1&#xA;&#xA;WORKDIR /code&#xA;&#xA;COPY requirements.txt .&#xA;&#xA;RUN pip install -r requirements.txt&#xA;&#xA;COPY . .&#xA;&#xA;EXPOSE 8000&#xA;&#xA;CMD [&#34;python&#34;,&#34;manage.py&#34;,&#34;runserver&#34;,&#34;0.0.0.0:8000&#34;]&#xA;```&#xA;&#xA;- Let&#39;s see what are we doing here, first we are pulling a base image of Python in this case it is [3.9-buster](https://github.com/docker-library/python/blob/a4b368154b7e3c33c76385f1be7a998fcf3123eb/3.9/buster/Dockerfile), but it can be any of the [Official Python images](https://hub.docker.com/_/python) from [dockerhub](https://hub.docker.com). It is simply a environment for our Django project to run. You can even use linux environments like ubuntu, debian or alpine. &#xA;&#xA;- Next we add a `PYTHONUNBUFFERED` as a environment variable and initialize it to `1`, which basically allows to parse python output straight into the terminal without actually buffering first. &#xA;&#xA;- We set the `WORKDIR` as the `code` directory, this sets the provided directory as the base to run any command or instructions in the Dockerfile. &#xA;&#xA;- We then `COPY` the `requirements.txt` file in the current(`.`) directory which is `code` as mentioned earlier. We simply want the `requirements.txt` file in the current directory so we can proceed with the next step which is to install the dependencies for the Django project&#xA;&#xA;- After copying the `requirements.txt` file, we simply install the packages mentioned int the file with `pip` we use the `RUN` command to execute any shell commands in the environment. &#xA;&#xA;- Next step is to `COPY` all the files from the current folder(local machine) into the docker environment image. So, we have the source code files in the Container. &#xA;&#xA;- Expose the port `8000`(default) or any other port you would want to run Django in the image. We use the expose command in complement to the `-p` argument when we want to create the container. I have explained the [port-forwarding](https://mr-destructive.github.io/techstructive-blog/docker-port-forward) concept in the previous TIL. &#xA;&#xA;- Finally we can run the server. We need to parse every command as a comma separated string in the list to the `CMD` which the container actually executes the command when the image is build. So, all the commands previously were to build an image for the django project, the `CMD` will actually run the server in a container after building the image of the django project.  &#xA;&#xA;### Build the image&#xA;&#xA;Using the Dockerfile, we can create the image for the Django project by a simple command.&#xA;&#xA;```&#xA;docker build . -t django-app&#xA;```&#xA;&#xA;Assuming the Dockerfile is in the same folder from which you are running this command.&#xA;&#xA;![Build the django-app image](https://res.cloudinary.com/techstructive-blog/image/upload/v1646230907/blog-media/jj04subyvkuvfb5obytu.png)&#xA;&#xA;![Build Complete Success](https://res.cloudinary.com/techstructive-blog/image/upload/v1646230988/blog-media/ugjoakqgyhiwelqkyaat.png)&#xA;&#xA;### Run the Image and Create a Container&#xA;&#xA;```&#xA;docker run -p 8000:8000 django-app&#xA;```&#xA;&#xA;![Create Container](https://res.cloudinary.com/techstructive-blog/image/upload/v1646231023/blog-media/yneuz46burorz4b5vzp4.png)&#xA;&#xA;You can use any port like `3000` or `4000` on your local system by changing the first port number as `3000:8000` and so on. So, the first port number is the local system&#39;s port number and the port number followed by a `:` is the port number for the environment inside the container of the django project. The container port is the same which we have `exposed` while creating the image. You can now go to [127.0.0.1:8000](127.0.0.1:8000) or your chosen port in your local environment and see the django app running. &#xA;&#xA;If you are using a Docker as a Virtual Machine, you need to find the IP-address of that Virtual-Machine(`docker-machine ip`) and use that instead of `localhost` or `127.0.0.1`. &#xA;&#xA;&#xA;### Cleaning the Container for iterations&#xA;&#xA;We need to stop the container to run it again after making a few changes in the app if any. Simply pressing the `CTRL + D` option wont stop the container here. We need to stop the container by executing: &#xA;&#xA;```&#xA;docker ps&#xA;&#xA;docker stop &lt;container-id&gt;&#xA;```&#xA;&#xA;This will stop the container. Also if you want to remove the images you built, you can run the command:&#xA;&#xA;```&#xA;docker image ls&#xA;&#xA;docker rmi -f &lt;image-id&gt;&#xA;```&#xA;&#xA;  So, we now have a image of our Django project, this image can be used by anyone inside a docker environment and thus creating much more easier to test/work on a given project irrespective of the system is being used.&#xA;&#xA;</content>
      <type>til</type>
    </item>
    <item>
      <title>Docker Port Forwarding</title>
      <link>meetgor.com/docker-port-forward</link>
      <description></description>
      <pubDate>Tue, 01 Mar 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Docker Port Forwarding&#xA;&#xA;Port forwarding is a process to redirect the communication of one address to other. &#xA;It is also known as Port Binding. &#xA;We can use `-p` command to use port forwarding in our local Docker environment.&#xA;&#xA;```&#xA;docker run -p 8000:8000 django-app&#xA;```&#xA;&#xA;The first port number is the local machine port and followed by a `:` is the container port number.&#xA;SO, the request from the container port are forwarded to the local/outside world in the docker environment.&#xA;&#xA;Additionally, we need to expose the container port first. We can do that in the Dockerfile or by adding a `-e` argument followed by the port to expose. This will open the port on container to forward the requests to the specified port in the `-p` option.&#xA;&#xA;In the Dockerfile, we can expose the port by adding the command `EXPOSE 8000`, or any other port number. &#xA;&#xA;</content>
      <type>til</type>
    </item>
  </channel>
</rss>