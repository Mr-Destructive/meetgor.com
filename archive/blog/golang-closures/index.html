<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <title>Golang: Closures | Meet Gor</title>
    <meta name="title" content="Golang: Closures | Meet Gor">
    <meta name="description" content="Understanding the baiscs of closures in Golang. Creating some simple examples for exploring the concept of closures with Golang.">
    <meta name="author" content="Meet Gor">
    <meta name="keywords" content="go">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="meetgor.com/golang-closures">
    
    
    <meta property="og:type" content="article">
    <meta property="og:url" content="meetgor.com/golang-closures">
    <meta property="og:title" content="Golang: Closures | Meet Gor">
    <meta property="og:description" content="Understanding the baiscs of closures in Golang. Creating some simple examples for exploring the concept of closures with Golang.">
    <meta property="og:image" content="https://meetgor-cdn.pages.dev/golang-018-closures.png">
    <meta property="og:site_name" content="Meet Gor">
    <meta property="article:published_time" content="2022-08-11">
    <meta property="article:modified_time" content="2022-08-11">
    <meta property="article:author" content="Meet Gor">
    
    <meta property="article:tag" content="go">
    
    
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@meetgor711">
    <meta name="twitter:creator" content="@meetgor711">
    <meta name="twitter:url" content="meetgor.com/golang-closures">
    <meta name="twitter:title" content="Golang: Closures | Meet Gor">
    <meta name="twitter:description" content="Understanding the baiscs of closures in Golang. Creating some simple examples for exploring the concept of closures with Golang.">
    <meta name="twitter:image" content="https://meetgor-cdn.pages.dev/golang-018-closures.png">
    
    
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "meetgor.com/golang-closures"
        },
        "headline": "Golang: Closures",
        "description": "Understanding the baiscs of closures in Golang. Creating some simple examples for exploring the concept of closures with Golang.",
        "datePublished": "2022-08-11",
        "dateModified": "2022-08-11",
        "author": {
            "@type": "Person",
            "name": "Meet Gor"
        },
        "publisher": {
            "@type": "Organization",
            "name": "Meet Gor",
            "logo": {
                "@type": "ImageObject",
                "url": "meetgor.com/tbicon.png"
            }
        },
        "image": "https:\/\/meetgor-cdn.pages.dev\/golang-018-closures.png",
        "keywords": "go",
        "articleBody": "\u0026lt;h2 id=\u0026#34;introduction\u0026#34;\u0026gt;Introduction\u0026lt;\/h2\u0026gt;\n\u0026lt;p\u0026gt;In the previous part of the series, we covered \u0026lt;a href=\u0026#34;https:\/\/meetgor.com\/golang-anonymous-functions\/\u0026#34;\u0026gt;anonymous functions\u0026lt;\/a\u0026gt; and in this section, we will look into \u0026lt;code\u0026gt;closures\u0026lt;\/code\u0026gt; which are quite a cool concept for various things. Closures are basically a function that returns a function instead of a value, so basically we will leverage anonymous functions for creating closures.\u0026lt;\/p\u0026gt;\n\u0026lt;h2 id=\u0026#34;simple-closures\u0026#34;\u0026gt;Simple Closures\u0026lt;\/h2\u0026gt;\n\u0026lt;p\u0026gt;A simple closure can be constructed for understanding how we can use closures in golang. We will return a function from a function, that is a simple closure. So, in the below code example, we have created a function \u0026lt;code\u0026gt;gophy()\u0026lt;\/code\u0026gt; which takes no parameters but returns a function that returns a \u0026lt;code\u0026gt;string\u0026lt;\/code\u0026gt;.  The function simply returns an anonymous function that returns a string.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;We will initialize the variable \u0026lt;code\u0026gt;g\u0026lt;\/code\u0026gt; that is assigned to the function \u0026lt;code\u0026gt;gophy\u0026lt;\/code\u0026gt; which will simply return a function call. We are not calling the function simply returning the call to the function \u0026lt;code\u0026gt;gophy\u0026lt;\/code\u0026gt; that has the return value as the anonymous function. We will simply have the function in the variable \u0026lt;code\u0026gt;g\u0026lt;\/code\u0026gt; rather than the simple value string. So we will have to call the \u0026lt;code\u0026gt;g\u0026lt;\/code\u0026gt; variable for actually returning the string.\u0026lt;\/p\u0026gt;\n\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;go\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;language-go\u0026#34;\u0026gt;package main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc gophy() func() string{\n  return func() string{\n    return \u0026#34;Hello, Gophers!\u0026#34;\n  }\n}\n\nfunc main() {\n\n\t\/\/ using clousure\/anonymous function to return a value\n\t\/\/ that value can be assigned to the variable\n\tg := gophy()\n\tfmt.Println(g())\n}\n\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;$ go run simple.go\nHello, Gophers!\n\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;p\u0026gt;So, that is how we can call the function \u0026lt;code\u0026gt;g\u0026lt;\/code\u0026gt; that will return a string, so we have the function body stored in the variable \u0026lt;code\u0026gt;g\u0026lt;\/code\u0026gt;. We can call it as many times as we want.\u0026lt;\/p\u0026gt;\n\u0026lt;h2 id=\u0026#34;variable-scope-in-closures\u0026#34;\u0026gt;Variable Scope in Closures\u0026lt;\/h2\u0026gt;\n\u0026lt;p\u0026gt;We can even use variables that will remain in the function scope once it is initialized. So, let’s say we have a function that will increment the counter, but if we want to keep the counter the same throughout the program, we might have to use a global variable so as to maintain the context, but with closures, we will retain the value once we have initialized the function call.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;In the below example, we are creating the function \u0026lt;code\u0026gt;incrementer\u0026lt;\/code\u0026gt; that is a closure with int as the return type. We are initializing the variable \u0026lt;code\u0026gt;counter\u0026lt;\/code\u0026gt; that will be acting as the counter in the program, the function returns an anonymous function that will increment the counter and return it.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;Here, when we create an instance of the \u0026lt;code\u0026gt;increment\u0026lt;\/code\u0026gt; function it basically initializes the \u0026lt;code\u0026gt;counter\u0026lt;\/code\u0026gt; to \u0026lt;code\u0026gt;0\u0026lt;\/code\u0026gt; and returns the anonymous function as a call. Now, \u0026lt;code\u0026gt;c\u0026lt;\/code\u0026gt; will act as a function that has the counter variable bound to it and we can call \u0026lt;code\u0026gt;c\u0026lt;\/code\u0026gt; that will, in turn, call the anonymous function keeping the scope of the \u0026lt;code\u0026gt;counter\u0026lt;\/code\u0026gt; variable.  So, each time we call the function \u0026lt;code\u0026gt;c\u0026lt;\/code\u0026gt; it will increment the counter and thus we keep the counter inside the scope of the function \u0026lt;code\u0026gt;incrementer\u0026lt;\/code\u0026gt; in the \u0026lt;code\u0026gt;c\u0026lt;\/code\u0026gt; variable.\u0026lt;\/p\u0026gt;\n\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;go\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;language-go\u0026#34;\u0026gt;package main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc inrementer() func() int{\n  counter := 0\n  return func() int{\n    counter \u002b= 1\n    return counter\n  }\n}\n\nfunc main() {\n\n  c := inrementer()\n\n  fmt.Println(c())\n  fmt.Println(c())\n  fmt.Println(c())\n  fmt.Println(c())\n  fmt.Println(c())\n\n}\n\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;$go run simple.go\n1\n2\n3\n4\n5\n\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;p\u0026gt;If we want to extend the functionality,  we can even assign the function call \u0026lt;code\u0026gt;c()\u0026lt;\/code\u0026gt; to a variable and access the returned value which will be the current state of the counter.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;We can even use different scope or closures tied to a particular function, that is we can bind data to a different instances of a closure.\u0026lt;\/p\u0026gt;\n\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;go\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;language-go\u0026#34;\u0026gt;package main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc inrementer() func() int{\n  counter := 0\n  return func() int{\n    counter \u002b= 1\n    return counter\n  }\n}\n\nfunc main() {\n\n  c1 := inrementer()\n\n  fmt.Println(c1())\n  fmt.Println(c1())\n  fmt.Println(c1())\n\n  c2 := inrementer()\n\n  fmt.Println(c2())\n  fmt.Println(c2())\n  fmt.Println(c2())\n  fmt.Println(c2())\n\n}\n\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;$go run simple.go\n1\n2\n3\n1\n2\n3\n4\n\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;p\u0026gt;Here we have \u0026lt;code\u0026gt;c1\u0026lt;\/code\u0026gt; and \u0026lt;code\u0026gt;c2\u0026lt;\/code\u0026gt; forming different closures and thereby we can have different scopes of the variables associated with it. The variable is bound to the instance it which was initialized, so we can see the different closure instances having different values.\u0026lt;\/p\u0026gt;\n\u0026lt;h2 id=\u0026#34;factorial-of-a-function-with-closures\u0026#34;\u0026gt;Factorial of a function with Closures\u0026lt;\/h2\u0026gt;\n\u0026lt;p\u0026gt;We can create some interesting programs with closures, we will implement the calculation of factorial with closures in golang.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;This will be a \u0026lt;code\u0026gt;factorial\u0026lt;\/code\u0026gt; function that returns an anonymous function with the return type as \u0026lt;code\u0026gt;int\u0026lt;\/code\u0026gt;. The function will initialize the variable \u0026lt;code\u0026gt;fact\u0026lt;\/code\u0026gt; which will store the actual factorial value and \u0026lt;code\u0026gt;n\u0026lt;\/code\u0026gt; as the initial number for calculating the factorial of it.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;Inside the anonymous function, we will calculate the factorial and increment the number and simply return the factorial value from the function. The \u0026lt;code\u0026gt;fact\u0026lt;\/code\u0026gt; variable will contain the factorial of the number n, so here we can leverage the use of closures as we will maintain the state of the variable \u0026lt;code\u0026gt;fact\u0026lt;\/code\u0026gt; and \u0026lt;code\u0026gt;n\u0026lt;\/code\u0026gt; from the previous calls or the initialization of the function.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;Inside the \u0026lt;code\u0026gt;main\u0026lt;\/code\u0026gt; function, we have created the \u0026lt;code\u0026gt;f\u0026lt;\/code\u0026gt; variable and called the \u0026lt;code\u0026gt;factorial\u0026lt;\/code\u0026gt; function, so that will initialize the \u0026lt;code\u0026gt;fact\u0026lt;\/code\u0026gt; and \u0026lt;code\u0026gt;n\u0026lt;\/code\u0026gt; of the variable and thereby returning the anonymous function call. Now we can call the variable \u0026lt;code\u0026gt;f\u0026lt;\/code\u0026gt; as many times as we want that will simply return the factorial of the number incremented each time we call the function.\u0026lt;\/p\u0026gt;\n\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;go\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code class=\u0026#34;language-go\u0026#34;\u0026gt;package main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc factorial() func() int{\n\tfact, n := 1, 1\n\treturn func() int{\n    fact = fact * n\n    n \u002b= 1\n\t\treturn fact\n\t}\n}\n\nfunc main() {\n\n  f := factorial()\n  fmt.Println(f())\n  fmt.Println(f())\n  fmt.Println(f())\n  fmt.Println(f())\n  fmt.Println(f())\n\n}\n\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;div class=\u0026#34;code-block\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;code-header\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;language-name\u0026#34;\u0026gt;\u0026lt;\/span\u0026gt;\u0026lt;button class=\u0026#34;copy-button\u0026#34;\u0026gt;\u0026lt;svg xmlns=\u0026#34;http:\/\/www.w3.org\/2000\/svg\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 24 24\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34; stroke-linecap=\u0026#34;round\u0026#34; stroke-linejoin=\u0026#34;round\u0026#34; class=\u0026#34;feather feather-copy\u0026#34;\u0026gt;\u0026lt;rect x=\u0026#34;9\u0026#34; y=\u0026#34;9\u0026#34; width=\u0026#34;13\u0026#34; height=\u0026#34;13\u0026#34; rx=\u0026#34;2\u0026#34; ry=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;\/rect\u0026gt;\u0026lt;path d=\u0026#34;M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\u0026#34;\u0026gt;\u0026lt;\/path\u0026gt;\u0026lt;\/svg\u0026gt;\u0026lt;\/button\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;pre\u0026gt;\u0026lt;code\u0026gt;$ go run simple.go\n1\n2\n6\n24\n120\n\n\u0026lt;\/code\u0026gt;\u0026lt;\/pre\u0026gt;\u0026lt;\/div\u0026gt;\u0026lt;p\u0026gt;So, we can see that the factorial is getting printed for each call and the number is being incremented at each call.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;So that\u0026#39;s the basics of closures in golang, we can use closures to keep the content secured and encapsulated from different function calls. We can bind data with closures, with the help of anonymous functions a closure can be constructed and data can be bound to a particular function called scope.\u0026lt;\/p\u0026gt;\n\u0026lt;p\u0026gt;That\u0026#39;s it from this part. Reference for all the code examples and commands can be found in the \u0026lt;a href=\u0026#34;https:\/\/github.com\/mr-destructive\/100-days-of-golang\/tree\/main\/scripts\/closures\/main.go\u0026#34;\u0026gt;100 days of Golang\u0026lt;\/a\u0026gt; GitHub repository.\u0026lt;\/p\u0026gt;\n\u0026lt;h2 id=\u0026#34;conclusion\u0026#34;\u0026gt;Conclusion\u0026lt;\/h2\u0026gt;\n\u0026lt;p\u0026gt;From this post, we could understand the fundamentals of closures in golang. The basic concept of closures in golang was understood with a few examples. Thank you for reading, if you have any queries or feedback please leave them in the comments or on my social handles. Happy Coding :)\u0026lt;\/p\u0026gt;\n"
    }
    </script>
    
    
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="/code-block.css">
    
    <link rel="icon" href="/tbicon.png" type="image/png">
    <link rel="apple-touch-icon" href="/tbicon.png">
    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <link id="syntax-theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/sql-wasm.js"></script>
    <link rel="stylesheet" href="/sql-playground.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/monokai.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/sql/sql.min.js"></script>
    <script src="/sql-playground.js"></script>
    
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script>
    document.addEventListener("DOMContentLoaded", () => {
        const body = document.body;
        const stylesheet = document.getElementById("syntax-theme");
        const themeToggle = document.getElementById('theme-toggle');

        function setSyntaxTheme(theme) {
            if (theme === "secondary") {
                stylesheet.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css";
            } else {
                stylesheet.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css";
            }
        }

        
        document.querySelectorAll("pre code").forEach((block) => {
            hljs.highlightElement(block);
        });

        
        const currentTheme = localStorage.getItem("theme") || "default";
        if (currentTheme === "secondary") {
            body.classList.add("secondary-theme");
            if (themeToggle) themeToggle.checked = true;
        }
        setSyntaxTheme(currentTheme);

        
        if (themeToggle) {
            themeToggle.addEventListener('change', () => {
                const newTheme = themeToggle.checked ? 'secondary' : 'default';
                if (themeToggle.checked) {
                    body.classList.add('secondary-theme');
                } else {
                    body.classList.remove('secondary-theme');
                }
                localStorage.setItem('theme', newTheme);
                setSyntaxTheme(newTheme);
            });
        }
        
        
        const editBtn = document.getElementById('editor-edit');
        if (editBtn) {
            editBtn.addEventListener('click', async function () {
                const slug = "golang-closures";
                const type = "posts";
                console.log("Editing post:", slug, type);
                const url = "https:\/\/devmeetgor.netlify.app/.netlify/functions/api?slug=" + slug + "&method=edit&type=" + type;
                
                try {
                    const res = await fetch(url);
                    if (!res.ok) throw new Error("Failed to fetch edit content");
                    const html = await res.text();
                    document.querySelector('.post-content').innerHTML = html;
                } catch (err) {
                    console.error(err);
                    alert("Error loading editor content");
                }
            });
        }
    });
    </script>
    
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-EET2ZX4QY1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-EET2ZX4QY1');
    </script>
</head>
<body>
    <header class="header">
  <a class="site-title" href="/" aria-label="Meet Gor - Home">Meet Gor</a>
  <nav>
    <ul>
      <li><a href="/" aria-label="Home">Home</a></li>
      <li><a href="/posts" aria-label="Posts">Posts</a></li>
      <li><a href="/about" aria-label="About">About</a></li>
      <li><a href="/contact" aria-label="Contact">Contact</a></li>
    </ul>
  </nav>
  <div class="theme-switch">
    <input type="checkbox" id="theme-toggle" aria-label="Toggle Theme">
    <label for="theme-toggle"></label>
  </div>
  
</header>
    
    <main class="container">
        <article class="blog-post">
            <h1>Golang: Closures</h1>
            
            <div class="post-meta">
                Published on 📅 <time datetime="2022-08-11">2022-08-11</time>
            </div>
            
            <div class="post-meta">
                Type: <a href="/posts">posts</a>
            </div>
            
            <div class="post-meta tags">
                <span class="post-series-label">🏷️ Tags:</span>
                
                <a href="/tags/go">#go</a>
                
            </div>
            
            
            <div class="post-series">
                <span class="series-label">Part of the
                <span class="series-list">
                    
                    <a href="/series/100-days-of-golang" class="series-link">📖 100-days-of-golang</a>
                    
                </span></span>
                <span class="series-label">series</span>
            </div>
            
            
            
            
            <hr>
            
            <div class="post-content">
                <h2 id="introduction">Introduction</h2>
<p>In the previous part of the series, we covered <a href="https://meetgor.com/golang-anonymous-functions/">anonymous functions</a> and in this section, we will look into <code>closures</code> which are quite a cool concept for various things. Closures are basically a function that returns a function instead of a value, so basically we will leverage anonymous functions for creating closures.</p>
<h2 id="simple-closures">Simple Closures</h2>
<p>A simple closure can be constructed for understanding how we can use closures in golang. We will return a function from a function, that is a simple closure. So, in the below code example, we have created a function <code>gophy()</code> which takes no parameters but returns a function that returns a <code>string</code>.  The function simply returns an anonymous function that returns a string.</p>
<p>We will initialize the variable <code>g</code> that is assigned to the function <code>gophy</code> which will simply return a function call. We are not calling the function simply returning the call to the function <code>gophy</code> that has the return value as the anonymous function. We will simply have the function in the variable <code>g</code> rather than the simple value string. So we will have to call the <code>g</code> variable for actually returning the string.</p>
<div class="code-block"><div class="code-header"><span class="language-name">go</span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code class="language-go">package main

import "fmt"

func gophy() func() string{
  return func() string{
    return "Hello, Gophers!"
  }
}

func main() {

	// using clousure/anonymous function to return a value
	// that value can be assigned to the variable
	g := gophy()
	fmt.Println(g())
}

</code></pre></div><div class="code-block"><div class="code-header"><span class="language-name"></span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code>$ go run simple.go
Hello, Gophers!

</code></pre></div><p>So, that is how we can call the function <code>g</code> that will return a string, so we have the function body stored in the variable <code>g</code>. We can call it as many times as we want.</p>
<h2 id="variable-scope-in-closures">Variable Scope in Closures</h2>
<p>We can even use variables that will remain in the function scope once it is initialized. So, let’s say we have a function that will increment the counter, but if we want to keep the counter the same throughout the program, we might have to use a global variable so as to maintain the context, but with closures, we will retain the value once we have initialized the function call.</p>
<p>In the below example, we are creating the function <code>incrementer</code> that is a closure with int as the return type. We are initializing the variable <code>counter</code> that will be acting as the counter in the program, the function returns an anonymous function that will increment the counter and return it.</p>
<p>Here, when we create an instance of the <code>increment</code> function it basically initializes the <code>counter</code> to <code>0</code> and returns the anonymous function as a call. Now, <code>c</code> will act as a function that has the counter variable bound to it and we can call <code>c</code> that will, in turn, call the anonymous function keeping the scope of the <code>counter</code> variable.  So, each time we call the function <code>c</code> it will increment the counter and thus we keep the counter inside the scope of the function <code>incrementer</code> in the <code>c</code> variable.</p>
<div class="code-block"><div class="code-header"><span class="language-name">go</span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code class="language-go">package main

import "fmt"

func inrementer() func() int{
  counter := 0
  return func() int{
    counter += 1
    return counter
  }
}

func main() {

  c := inrementer()

  fmt.Println(c())
  fmt.Println(c())
  fmt.Println(c())
  fmt.Println(c())
  fmt.Println(c())

}

</code></pre></div><div class="code-block"><div class="code-header"><span class="language-name"></span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code>$go run simple.go
1
2
3
4
5

</code></pre></div><p>If we want to extend the functionality,  we can even assign the function call <code>c()</code> to a variable and access the returned value which will be the current state of the counter.</p>
<p>We can even use different scope or closures tied to a particular function, that is we can bind data to a different instances of a closure.</p>
<div class="code-block"><div class="code-header"><span class="language-name">go</span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code class="language-go">package main

import "fmt"

func inrementer() func() int{
  counter := 0
  return func() int{
    counter += 1
    return counter
  }
}

func main() {

  c1 := inrementer()

  fmt.Println(c1())
  fmt.Println(c1())
  fmt.Println(c1())

  c2 := inrementer()

  fmt.Println(c2())
  fmt.Println(c2())
  fmt.Println(c2())
  fmt.Println(c2())

}

</code></pre></div><div class="code-block"><div class="code-header"><span class="language-name"></span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code>$go run simple.go
1
2
3
1
2
3
4

</code></pre></div><p>Here we have <code>c1</code> and <code>c2</code> forming different closures and thereby we can have different scopes of the variables associated with it. The variable is bound to the instance it which was initialized, so we can see the different closure instances having different values.</p>
<h2 id="factorial-of-a-function-with-closures">Factorial of a function with Closures</h2>
<p>We can create some interesting programs with closures, we will implement the calculation of factorial with closures in golang.</p>
<p>This will be a <code>factorial</code> function that returns an anonymous function with the return type as <code>int</code>. The function will initialize the variable <code>fact</code> which will store the actual factorial value and <code>n</code> as the initial number for calculating the factorial of it.</p>
<p>Inside the anonymous function, we will calculate the factorial and increment the number and simply return the factorial value from the function. The <code>fact</code> variable will contain the factorial of the number n, so here we can leverage the use of closures as we will maintain the state of the variable <code>fact</code> and <code>n</code> from the previous calls or the initialization of the function.</p>
<p>Inside the <code>main</code> function, we have created the <code>f</code> variable and called the <code>factorial</code> function, so that will initialize the <code>fact</code> and <code>n</code> of the variable and thereby returning the anonymous function call. Now we can call the variable <code>f</code> as many times as we want that will simply return the factorial of the number incremented each time we call the function.</p>
<div class="code-block"><div class="code-header"><span class="language-name">go</span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code class="language-go">package main

import "fmt"

func factorial() func() int{
	fact, n := 1, 1
	return func() int{
    fact = fact * n
    n += 1
		return fact
	}
}

func main() {

  f := factorial()
  fmt.Println(f())
  fmt.Println(f())
  fmt.Println(f())
  fmt.Println(f())
  fmt.Println(f())

}

</code></pre></div><div class="code-block"><div class="code-header"><span class="language-name"></span><button class="copy-button"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-copy"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button></div><pre><code>$ go run simple.go
1
2
6
24
120

</code></pre></div><p>So, we can see that the factorial is getting printed for each call and the number is being incremented at each call.</p>
<p>So that's the basics of closures in golang, we can use closures to keep the content secured and encapsulated from different function calls. We can bind data with closures, with the help of anonymous functions a closure can be constructed and data can be bound to a particular function called scope.</p>
<p>That's it from this part. Reference for all the code examples and commands can be found in the <a href="https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/closures/main.go">100 days of Golang</a> GitHub repository.</p>
<h2 id="conclusion">Conclusion</h2>
<p>From this post, we could understand the fundamentals of closures in golang. The basic concept of closures in golang was understood with a few examples. Thank you for reading, if you have any queries or feedback please leave them in the comments or on my social handles. Happy Coding :)</p>

            </div>
        </article>
    </main>
    
    <div id="comments">
        <script src="https://giscus.app/client.js"
            data-repo="Mr-Destructive/meetgor.com"
            data-repo-id="R_kgDOHZ6V_g"
            data-category="Q&A"
            data-category-id="DIC_kwDOHZ6V_s4CRfn4"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-theme="dark_high_contrast"
            data-lang="en"
            crossorigin="anonymous"
            async>
        </script>
    </div>
    
    <footer class="site-footer" role="contentinfo">
  <div class="footer-content">
    <p>&copy; Meet Gor. All rights reserved.</p>
    <div class="social-links">
      <a href="/contact" aria-label="Connect with me">Connect with me</a>
    </div>
  </div>
</footer>
    
</body>
</html>
