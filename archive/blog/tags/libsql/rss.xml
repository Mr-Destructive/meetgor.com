<rss version="2.0">
  <channel>
    <title>Meet Gor - Tag: libsql</title>
    <link>meetgor.com</link>
    <description>Posts tagged with libsql</description>
    <language>en-us</language>
    <pubDate>Fri, 17 Oct 2025 16:57:38 UTC</pubDate>
    <item>
      <title>Use Embedded Replicas of LibSQL Database hosted on Turso with a Golang Application</title>
      <link>meetgor.com/turso-libsql-embedded-replicas-golang</link>
      <description>Understanding and exploring how to create, connect, and query local embedded replicas of LibSQL database hosted on Turso with a Golang application.</description>
      <pubDate>Thu, 31 Oct 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Welcome to the Let&#39;s Go with Turso series. In this series, we will learn how to interact with LibSQL databases with Golang. In the past article of the series, we explored how to connect remote/local LibSQL database in golang.&#xA;&#xA;With this section, we will specifally dive into understanding how to create, connect, and query local embedded replicas of LibSQL database hosted on Turso with a Golang application.&#xA;&#xA;If you want to check out the YouTube video, check this out:&#xA;&#xA;[LibSQL Embedded Replicas on Turso in Golang](https://www.youtube.com/watch?v=BitxB40rdVw)&#xA;&#xA;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/vBrvX0X0phw&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&#xA;## LibSQL Embedded Replicas on Turso in Golang&#xA;&#xA;### Embedded Replicas&#xA;The embedded replica is a native feature of the libSQL database. With embedded replicas, we can have faster writes as with the local database and global read access from the remote database.&#xA;&#xA;Embedded replica is like creating a copy of a primary remote database and using it for performing any operations from the applications as a local database and then it has a mechanism or standard to sync up with the primary remote database. The primary remote database serves as a single source of truth, however we can use the database locally as well. This however should be done carefully to avoid data corruption or stale data. To cope up with this stale or corruption of data, the periodic syncing can be used.&#xA;&#xA;Embedded replicas have a 3 fold process&#xA;- Create a copy of the primary remote database&#xA;- Perform any operations on the local database&#xA;- Sync up with the primary remote database&#xA;&#xA;![Embedded Replicas for LibSQL](https://meetgor-cdn.pages.dev/embedded-replicas-flow.png)&#xA;&#xA;There are a few things to remember here:&#xA;- The local database can read it&#39;s newly written data, however other local replica databases can only view those changes once the sync has happened and the primary database has been updated from the local copy.&#xA;- These would require to sync the local with the primary database first and then the other local database also needs to sync with the primary database.&#xA;&#xA;You can read more about it [here](https://docs.turso.tech/features/embedded-replicas/introduction) on the Turso documentation.&#xA;&#xA;Let&#39;s get started,&#xA;&#xA;What we are going to do is create a step by step procedure to understand how to work with embedded replicas of LibSQL database.&#xA;&#xA;1. Perform the operations on the local LibSQL database&#xA;2. Create a Embedded Replica and sync up with the primary remote database&#xA;3. Fetch data from the primary remote database&#xA;&#xA;![Embedded Replicas of LibSQL with Golang](https://meetgor-cdn.pages.dev/LibSQL_Embedded_Replicas_on_Turso_in_Golang.gif)&#xA;&#xA;In this way, we can understand how to operate the Embedded Replicas as a whole from locally as well as remotely&#xA;&#xA;## Initializing a Golang project&#xA;&#xA;Let&#39;s start with initializing a Golang project.&#xA;&#xA;```bash&#xA;# go mod init &lt;git-provider-domain&gt;/&lt;username&gt;/&lt;project-name&gt;&#xA;# Example&#xA;&#xA;go mod init github.com/mr-destructive/lets-go-with-turso&#xA;&#xA;```&#xA;&#xA;This will initialize the project in the current directory, creating a `go.mod` file with the specification of the Golang version and the packages that we will install and use in this module.&#xA;&#xA;## Installing go-libsql package&#xA;&#xA;We will need to install the [go-libsql](https://github.com/tursodatabase/go-libsql) package, this is the driver for LibSQL for Golang. To install simply use the `go get` command to be installed as the dependency for the project&#xA;&#xA;```bash&#xA;go get github.com/tursodatabase/go-libsql&#xA;```&#xA;&#xA;Once this is done, we can create a local LibSQL database.&#xA;&#xA;## Creating a local LibSQL database&#xA;&#xA;Let&#39;s create a local LibSQL database. With the `go-libsql` package, we can connect to the local database. This will be done using the `libsql` driver. There is really no much difference than the normal SQLite database driver, this works just like SQLite, the only difference being the ability to connect to the remote database.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;database/sql&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#xA;&#x9;_ &#34;github.com/tursodatabase/go-libsql&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;dbName := &#34;file:./local.db&#34;&#xA;&#xA;&#x9;db, err := sql.Open(&#34;libsql&#34;, dbName)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer db.Close()&#xA;}&#xA;```&#xA;&#xA;The above code will simply connect to the local LibSQL database which resides as the `local.db` file. Now, to demonstrate that it is an actual sqlite-like database, we can execute queries on the connected database.&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;database/sql&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#xA;&#x9;_ &#34;github.com/tursodatabase/go-libsql&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;dbName := &#34;file:./local.db&#34;&#xA;&#xA;&#x9;db, err := sql.Open(&#34;libsql&#34;, dbName)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer db.Close()&#xA;&#x9;rows, err := db.Query(&#34;SELECT ABS(RANDOM()%5) FROM generate_series(1,10)&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to query %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer rows.Close()&#xA;&#x9;for rows.Next() {&#xA;&#x9;&#x9;var i int&#xA;&#x9;&#x9;if err := rows.Scan(&amp;i); err != nil {&#xA;&#x9;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to scan %s&#34;, err)&#xA;&#x9;&#x9;&#x9;os.Exit(1)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Println(i)&#xA;&#x9;}&#xA;&#xA;}&#xA;```&#xA;Output:&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;3&#xA;0&#xA;4&#xA;4&#xA;2&#xA;1&#xA;2&#xA;3&#xA;4&#xA;1&#xA;&#xA;$ go run main.go&#xA;&#xA;0&#xA;2&#xA;1&#xA;2&#xA;3&#xA;2&#xA;2&#xA;1&#xA;0&#xA;2&#xA;```&#xA;&#xA;Just a simple `SELECT ABS(RANDOM()%5) FROM generate_series(1,10)` query will be executed on the connected database. This query will basically genrate a random number between `-4` and `4` and take the absolute value i.e. now between 0 and 4, this will genrate 10 such numbers.&#xA;&#xA;Now, we can move into the actual embedded replica creation of the primary remote database and use it as a local database to perform operations.&#xA;&#xA;## Creating an Embedded Replica of Turso&#39;s LibSQL database&#xA;&#xA;We need a few things to specify before we create the embedded replica, first being the primary remote database, that typically is a libsql database hosted on turso or self hosted. We also need to provide the local database path, where the local-replica will be stored or we can say the copy of the primary libsql database will be created.&#xA;&#xA;We will be using the [LibSQL.NewEmbeddedReplicaConnector](https://pkg.go.dev/github.com/levydsa/libsql-go#NewEmbeddedReplicaConnector) to create a local replica of a libsql database. The function takes in two paramters, the first paramter being the local database filename path to create the copy into, and the second paramter being the primary database URL. The function returns a connector object or an error if any. The connector object is then further used with [OpenDB](https://pkg.go.dev/database/sql#OpenDB) function to create a database connection. The `OpenDB` function returns a reference of database connections which we&#39;ll use to connect and perform operations on the database.&#xA;The same `connector` object could be used to sync with the primary database after performing operations on the local database with the [Sync](https://pkg.go.dev/github.com/levydsa/libsql-go#Connector.Sync) method. This will pull or push the changes from the local database to the primary database.&#xA;&#xA;We can configure the syncing mechanism while creating the embedded replica with the additional parameters to the `NewEmbeddedReplicaConnector` function. There are [Options](https://pkg.go.dev/github.com/levydsa/libsql-go#Option) to include for the paramters that could be passed like:&#xA;&#xA;- `WithAuthToken(string)`: This will be used to authenticate with the primary database.&#xA;- `WithSyncInterval(time.Duration)`: This will be used to specify the interval of syncing between the local and primary database.&#xA;- `WithEncrytion(string)`: This will be used to encrypt the local database.&#xA;- `WithReadYourWrites(bool)`: This will be used to specify if the local database can read the newly written changes or not.&#xA;&#xA;So, let&#39;s create a exmaple to create a embedded replica, make some changes by creating tables and then syncing the local with primary, finally appending some data to the local and reading those.&#xA;&#xA;#### Create the Embedded Replica&#xA;&#xA;We first need to create a copy of the primary database, as said, we will configure the 2 paramters that we need to create the embedded replica with `NewEmbeddedReplicaConnector`. Then once we have the connector object, we open up a database connection, at that point we can further run queries on the local replica that was just created from the primary remote LibSQL database.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;database/sql&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#x9;&#34;path/filepath&#34;&#xA;&#xA;&#x9;&#34;github.com/tursodatabase/go-libsql&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;dbName := &#34;local.db&#34;&#xA;    // this is not required, but can be used to create a temporary directory and then delete it later&#xA;&#x9;dir, err := os.MkdirTemp(&#34;&#34;, &#34;libsql-*&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&#34;Error creating temporary directory:&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer os.RemoveAll(dir)&#xA;&#xA;    // first paramter required for creating NewEmbeddedReplicaConnector&#xA;&#x9;dbPath := filepath.Join(dir, dbName)&#xA;&#x9;fmt.Println(dbPath)&#xA;&#xA;    // second paramter required for creating NewEmbeddedReplicaConnector&#xA;&#x9;dbURL := os.Getenv(&#34;TURSO_DATABASE_URL&#34;)&#xA;&#x9;dbAuthToken := os.Getenv(&#34;TURSO_AUTH_TOKEN&#34;)&#xA;&#xA;&#x9;connector, err := libsql.NewEmbeddedReplicaConnector(dbPath, dbURL, libsql.WithAuthToken(dbAuthToken))&#xA;&#x9;fmt.Println(connector)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer connector.Close()&#xA;&#xA;    // open a database connection from the connector object&#xA;&#x9;db := sql.OpenDB(connector)&#xA;&#x9;fmt.Println(&#34;Connected to database&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer db.Close()&#xA;}&#xA;```&#xA;&#xA;In the above code, we first create a temporary directory with the help of [MkdirTemp](https://pkg.go.dev/os#MkdirTemp), this is not required, but would be easier for cleanup later. We then the path for the local database to be created. The combined path string `dbPath` will serve as the first paramter to the `NewEmbeddedReplicaConnector`. Then we have taken the `dbURL` and the `dbAuthToken` from the environment variables `TURSO_DATABASE_URL` and `TURSO_AUTH_TOKEN` respectively. The `dbURL` will serve as the second paramter for the `NewEmbeddedReplicaConnector` that is the URL of the primary remote LibSQL database. The function `NewEmbeddedReplicaConnector` will return the `Connector` object if successfull in creation of the replica, else return `err` if it fails. The connector object needs to be closed at the end of the program, so we use the `defer connector.Close()` that will close the connection to the primary database at the end of the program. The `sql.OpenDB` is used to create the connection with the local database that will be created from the `connector` object. Finally we also need to close the local database connection at the end of the program.&#xA;&#xA;Further, we will try to query the local replica and create tables and append data to it.&#xA;&#xA;### Adding data to teh local replica&#xA;&#xA;Once we have the `db` connection to the local database, we can noramlly query the database as we did in the previous example, of querying the local LibSQL database. Let&#39;s start by creating a table `posts` to the local replica, this will basically create the schema in the local database.&#xA;&#xA;```go&#xA;    ....&#xA;&#xA;&#x9;createPostTableQuery := `CREATE TABLE IF NOT EXISTS posts(&#xA;        id INTEGER PRIMARY KEY,&#xA;        title VARCHAR(100),&#xA;        description VARCHAR(255),&#xA;        content TEXT&#xA;    );`&#xA;&#xA;&#x9;_, err = db.Exec(createPostTableQuery)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to create table %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;```&#xA;&#xA;The `createPostTableQuery` will be the `SQL` to create the table `posts` if it doesn&#39;t already exist in the database (local replica). Then with the help of [db.Exec](https://pkg.go.dev/database/sql#DB.Exec) function, we can execute the query and return back the rows if it had created any. In this case it won&#39;t as we have just added a table.&#xA;&#xA;Then, we can either sync the database to the primary, but let&#39;s populate the table `posts` with some data before syncing with the primary db.&#xA;&#xA;```go&#xA;&#xA;&#x9;createPostQuery := `INSERT INTO posts(title, description, content) &#xA;        VALUES(?, ?, ?)`&#xA;&#xA;&#x9;_, err = db.Exec(createPostQuery, &#34;test title&#34;, &#34;test description&#34;, &#34;test content&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to insert %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#xA;```&#xA;&#xA;We have created the `createPostQuery` similarly to insert into the `posts` table in the local replica. The values are added with the placeholders in the `Exec` function as positional parameters. Once we have executed the query, this will populate the `posts` table in the lcoal replica.&#xA;&#xA;We can now finally sync with the primary remote LibSQL database to make sure that the primary database also has these migrations applied.&#xA;&#xA;### Syncing the local replica&#xA;&#xA;Remember, `connector` is for primary database and `db` is for the local replica. So, we will sync the remote database from the replica that was created with the `connector.Sync`&#xA;&#xA;```go&#xA;&#xA;&#x9;_, err = connector.Sync()&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to sync %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#xA;&#x9;fmt.Printf(&#34;Successfully synced %s db&#xA;&#34;, dbPath)&#xA;&#x9;rows, err := db.Query(&#34;SELECT * FROM posts&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to query %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer rows.Close()&#xA;&#x9;for rows.Next() {&#xA;&#x9;&#x9;var id int&#xA;&#x9;&#x9;var title string&#xA;&#x9;&#x9;var description string&#xA;&#x9;&#x9;var content string&#xA;&#x9;&#x9;if err := rows.Scan(&amp;id, &amp;title, &amp;description, &amp;content); err != nil {&#xA;&#x9;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to scan %s&#34;, err)&#xA;&#x9;&#x9;&#x9;os.Exit(1)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Println(id, title, description, content)&#xA;&#x9;}&#xA;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```bash&#xA;&#xA;$ go run main.go                                                            &#xA;&#xA;/tmp/libsql-349052144/local.db&#xA;&amp;{0x2eec9d0 &lt;nil&gt; &lt;nil&gt;}&#xA;Connected to database&#xA;Successfully synced /tmp/libsql-349052144/local.db db&#xA;1 test title test description test content&#xA;```&#xA;&#xA;Once we have synced the local replica, we can now query the database i.e. the local replica, with the changes, also note that this could also be done without syncing the database, but the primary database won&#39;t have the applied changes.&#xA;&#xA;We finally Query the local replica with the query `SELECT * FROM posts` and print out the results. This has the 1 record in the `posts` table that we inserted.&#xA;&#xA;So, that&#39;s how we basically create a local replica from a remote LibSQL database hosted on Turso. We first create the path for the local database to be copied, then provide the primary database URL and credentials, then request a copy of the primary database, then we perform any mutation or operations on the local copy and finally sync up with the remote primary database to persist the data from that replica (acting like a session of database operation).&#xA;&#xA;That wraps the article for now.&#xA;&#xA;For all the code related to this article, you can check out the [Let&#39;s Go with Turso](https://github.com/mr-destructive/lets-go-with-turso) GitHub repo for all the examples and additional examples for using LibSQL with Golang.&#xA;&#xA;&#xA;## Conclusion&#xA;&#xA;So, that is a wrap for this part of the series, we have explored how to create a local embedded replica from a remote LibSQL database hosted on Turso with Golang. In the next part of the series, we will explore how to setup a local LibSQL database server and then connect it with Golang.&#xA;&#xA;Thank you for reading this post, If you have any questions, feedback, and suggestions, feel free to drop them in the comments.&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Connect LibSQL Database hosted on Turso in a Golang Application</title>
      <link>meetgor.com/turso-libsql-db-golang</link>
      <description>Exploring how to connect and query a LibSQL database hosted on Turso/Cloud in a Golang Application using libsql-client.</description>
      <pubDate>Mon, 30 Sep 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Welcome to the new series in Golang, Let&#39;s Go with Turso. In this series, we will learn how to interact with LibSQL databases with Golang. We will connect with a remote/local LibSQL database, create Embedded replicas, set up a local LibSQL database, and so much more as we explore and find out more features of LibSQL.&#xA;&#xA;## Connect a LibSQL database in a Golang application&#xA;&#xA;In this post, we will learn how to connect and query a LibSQL database hosted on Turso/Cloud in a Golang Application using libsql-client package. We will go from setting up golang project, installing turso-cli, creating a database on turso with the cli, connecting to the database with shell, and golang and finally, we can query the database using Golang.&#xA;&#xA;If you want to check out the YouTube video, check this out:&#xA;&#xA;[Conenct LibSQL Database hosted on Turso with Golang](https://www.youtube.com/watch?v=vBrvX0X0phw)&#xA;&#xA;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/vBrvX0X0phw&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&#xA;### Initializing a Golang project&#xA;&#xA;Let&#39;s start with initializing a Golang project.&#xA;&#xA;```bash&#xA;# go mod init &lt;git-provider-domain&gt;/&lt;username&gt;/&lt;project-name&gt;&#xA;# Example&#xA;&#xA;go mod init github.com/mr-destructive/lets-go-with-turso&#xA;&#xA;```&#xA;&#xA;This will initialize the project in the current directory, creating a `go.mod` file with the specification of the Golang version and the packages that we will install and use in this module.&#xA;&#xA;### Installing Turso CLI&#xA;&#xA;```bash&#xA;# Linux/Windows&#xA;curl -sSfL https://get.tur.so/install.sh | bash&#xA;curl -sSfL https://get.tur.so/install.sh | bash&#xA;&#xA;# macOS&#xA;brew install tursodatabase/tap/turso&#xA;&#xA;```&#xA;&#xA;This will install the Turso CLI. To verify that Turso CLI is installed properly, you can run the version command to check the setup.&#xA;&#xA;```&#xA;turso --version&#xA;```&#xA;&#xA;Once it is installed, we can now log in into Turso platform, simply by running the `auth signup` or `auth login` to Register or Log-in.&#xA;&#xA;```&#xA;turso auth signup&#xA;&#xA;# OR&#xA;&#xA;turso auth login&#xA;```&#xA;&#xA;This will redirect to the browser for the OAuth flow, once signed up and logged in, this will allow to interact with the Turso platform with the CLI that we downloaded.&#xA;&#xA;To make sure we are logged in as the correct user, we can run the `auth whoami` command to get the currently logged-in user.&#xA;&#xA;```&#xA;turso auth whoami&#xA;```&#xA;&#xA;This will print the username if you are logged-in. If everything seems correct, we can move ahead with the database creation step.&#xA;&#xA;### Creating a Remote LibSQL Database on Turso&#xA;&#xA;To create a LibSQL database hosted on Turso, we will use the `turso db create` command.&#xA;&#xA;```&#xA;turso db create&#xA;&#xA;# OR&#xA;&#xA;turso db create &lt;name&gt;&#xA;```&#xA;&#xA;This will create a database with the specified name, even if you don&#39;t provide the name, it will give out a random friendly two-word name to your database. It will create a database on the nearest location available from your location.&#xA;&#xA;This command will output the following:&#xA;&#xA;```&#xA;Created database &lt;db-name&gt; at group default in 1.99s.&#xA;&#xA;Start an interactive SQL shell with the following:&#xA;    turso db shell &lt;db-name&gt;&#xA;&#xA;To see information about the database, including a connection URL, run:&#xA;    turso db show &lt;db-name&gt;&#xA;&#xA;To get an authentication token for the database, run:&#xA;    turso db tokens create &lt;db-name&gt;&#xA;```&#xA;&#xA;The next step, it shows to start an interactive shell, to see information about the database, and to generate an authentication token for the database.&#xA;&#xA;We will move to the next part, which would be to create an authentication token for accessing the database from an external application.&#xA;&#xA;### Generating and Storing Authentication Token for LibSQL Database&#xA;&#xA;After we executed the `db create` command, and it created the database on the Turso cloud, there was a command hint for creating a `token` with the command `db tokens create`&#xA;&#xA;So, this command will create a JWT authentication token, that will be used to connect and read/write to the database.&#xA;&#xA;```bash&#xA;turso db tokens create &lt;db-name&gt;&#xA;&#xA;# OR&#xA;&#xA;turso db tokens create &lt;db-name&gt; --read-only&#xA;&#xA;# OR&#xA;&#xA;turso db tokens create &lt;db-name&gt; --expiration 30d&#xA;```&#xA;&#xA;We can use the simple `db tokens create &lt;db-name&gt;` to create an authentication token for the database with (read + write access). You can copy that returned token into a environment variable, or wherever your application can read that token.&#xA;&#xA;This could be stored in the environment variable as follows:&#xA;&#xA;```bash&#xA;export TURSO_AUTH_TOKEN=&#34;&lt;token&gt;&#34;&#xA;```&#xA;&#xA;To make a `read-only` token, we can use the flag `--read-only`. This will be handy, if you only have a database as a local replica, and the only purpose of the database is for querying data.&#xA;This will prevent any write operation on the database.&#xA;&#xA;We can also use the `--expiration` flag that will be used to set the duration of the token. By default the value for expiry is `never`, but that could be a little too risky if you are making a serious application. You can either set it to `7d` which will make the token expire after seven days.&#xA;&#xA;&#xA;Now, we can get the remote database URL and connect to the database. The URL could be obtained by running the command `db show &lt;db-name&gt;`&#xA;&#xA;```&#xA;turso db show &lt;db-name&gt;&#xA;```&#xA;&#xA;This will output the following:&#xA;&#xA;```bash&#xA;Name:           &lt;db-name&gt;&#xA;URL:            libsql://&lt;db-name&gt;-&lt;username&gt;.turso.io&#xA;ID:             &lt;db-id&gt;   &#xA;Group:          default&#xA;Version:        0.24.22&#xA;Locations:      bom&#xA;Size:           4.1 kB&#xA;Archived:       No&#xA;Bytes Synced:   0 B&#xA;Is Schema:      No&#xA;&#xA;Database Instances:&#xA;NAME        TYPE        LOCATION&#xA;bom         primary     bom&#xA;```&#xA;&#xA;The above output shows the meta-information of the database. This also has the URL hosted on Turso. We can construct the URL using the name of the database and your username as `libsql://&lt;db-name&gt;-&lt;username&gt;.turso.io`, you can set this in an environment variable or in the configuration wherever you can access it from the application.&#xA;&#xA;To set the URL of the database in your application, you can use the `TURSO_DB_URL` environment variable.&#xA;&#xA;```bash&#xA;export TURSO_DATABASE_URL=&#34;libsql://&lt;db-name&gt;-&lt;username&gt;.turso.io&#34;&#xA;```&#xA;&#xA;So, we have a remote database URL, and the access token configured, these are the two pieces that we will need to connect, read and write to the libsql database.&#xA;&#xA;&#xA;### Installing LibSQL Client for Golang&#xA;&#xA;So, we can install the [libsql-client-go](https://pkg.go.dev/github.com/tursodatabase/libsql-client-go/libsql) package for Golang which will be used as an SDK in Golang to interact with a remote LibSQL database.&#xA;&#xA;```bash&#xA;go get github.com/tursodatabase/libsql-client-go/libsql&#xA;```&#xA;&#xA;This will install the package `libsql` into the golang module. Now, we can use this in our golang application.&#xA;&#xA;### Populating the LibSQL Database&#xA;&#xA;Moving ahead, we have a database, but it doesn&#39;t have data! So let&#39;s create some tables and insert some rows. We can use the `db shell` command to open an interactive SQL shell on a remote LibSQL database.&#xA;&#xA;```bash&#xA;turso db shell libsql://&lt;db-name&gt;-&lt;username&gt;.turso.io&#xA;```&#xA;&#xA;This will be a default `sqlite3` like a shell, where we can execute SQL commands, like `.schema`, `.mode`, `.tables`, etc.&#xA;&#xA;```bash&#xA;  .dump       Render database content as SQL&#xA;  .help       List of all available commands.&#xA;  .indexes    List indexes in a table or database&#xA;  .mode       Set output mode&#xA;  .quit       Exit this program&#xA;  .read       Execute commands from a file&#xA;  .schema     Show table schemas.&#xA;  .tables     List all existing tables in the database.&#xA;```&#xA;&#xA;And definitely, we can use the normal SQL queries, to read, write and delete data from the database.&#xA;&#xA;#### Creating a Table&#xA;&#xA;First, let&#39;s create a simple table, called `posts` with columns like `id`, `title` as a `VARCHAR(100)`, `description` as a `VARCHAR(255)`, and `content` as `TEXT` which won&#39;t be `NULL`.&#xA;&#xA;```sql&#xA;CREATE TABLE posts&#xA;  (&#xA;     id          INTEGER PRIMARY KEY,&#xA;     title       VARCHAR(100),&#xA;     description VARCHAR(255),&#xA;     content     TEXT NOT NULL&#xA;  ); &#xA;```&#xA;&#xA;This will create a table `posts` on the LibSQL database, yes this will mutate the primary LibSQL database which is hosted on Turso.&#xA;&#xA;#### Inserting Rows&#xA;&#xA;Now, since we have the `posts` table, we will insert some rows into the table.&#xA;&#xA;```bash&#xA;INSERT INTO posts (title, description, content)&#xA;VALUES &#xA;    (&#39;test title&#39;, &#39;test description&#39;, &#39;test content&#39;);&#xA;```&#xA;&#xA;Now, we have some rows populated in the `posts` table. We can add more tables, and rows into the database, as usual, but this is just an example, so I&#39;ll keep it short.&#xA;&#xA;### Connecting to the LibSQL Database&#xA;&#xA;Now, we have something to query from a database, after we connect to the database via the Golang application program.&#xA;&#xA;First, we will grab two pieces to connect to the database.&#xA;&#xA;```bash&#xA;export TURSO_DATABASE_URL=&#34;libsql://&lt;db-name&gt;-&lt;username&gt;.turso.io&#34;&#xA;export TURSO_AUTH_TOKEN=&#34;&lt;token&gt;&#34;&#xA;```&#xA;&#xA;Now, let&#39;s start with the Golang program code.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    dbURL := os.Getenv(&#34;TURSO_DATABASE_URL&#34;)&#xA;    dbToken := os.Getenv(&#34;TURSO_AUTH_TOKEN&#34;)&#xA;    dbUrl := fmt.Sprintf(&#34;%s?authToken=%s&#34;, dbURL, dbToken)&#xA;}&#xA;```&#xA;&#xA;This will be the basic config to grab the database URL and the authentication token, then we can construct the `dbURL` along with `dbToken` to construct the complete dbURL which will allow to access the database.&#xA;&#xA;Moving ahead, we will import `database/sql` package that will be used to open the database connection and `github.com/tursodatabase/libsql-client-go/libsql` to connect to the remote LibSQL database.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;database/sql&#34;&#xA;    &#34;fmt&#34;&#xA;    &#34;os&#34;&#xA;&#xA;&#x9;_ &#34;github.com/tursodatabase/libsql-client-go/libsql&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;dbURL := os.Getenv(&#34;TURSO_DATABASE_URL&#34;)&#xA;&#x9;dbToken := os.Getenv(&#34;TURSO_AUTH_TOKEN&#34;)&#xA;&#x9;dbUrl := fmt.Sprintf(&#34;%s?authToken=%s&#34;, dbURL, dbToken)&#xA;&#xA;&#x9;db, err := sql.Open(&#34;libsql&#34;, dbUrl)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s: %s&#34;, dbUrl, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer db.Close()&#xA;&#xA;}&#xA;```&#xA;&#xA;The `sql.Open` function will open the connection to the database, this will return a `sql.DB` object. The driver selected is `libsql` and the `dbURL` is the entire URL along with the authentication token.&#xA;&#xA;&#xA;```go&#xA;type Post struct {&#xA;&#x9;Id          int&#xA;&#x9;Title       string&#xA;&#x9;Description string&#xA;&#x9;Content     string&#xA;}&#xA;&#xA;rows, err := db.Query(&#34;SELECT * FROM posts&#34;)&#xA;if err != nil {&#xA;    fmt.Fprintf(os.Stderr, &#34;failed to query: %s&#34;, err)&#xA;    os.Exit(1)&#xA;}&#xA;&#xA;for rows.Next() {&#xA;    var post Post&#xA;    if err := rows.Scan(&amp;post.Id, &amp;post.Title, &amp;post.Description, &amp;post.Content); err != nil {&#xA;        fmt.Fprintf(os.Stderr, &#34;failed to scan: %s&#34;, err)&#xA;        os.Exit(1)&#xA;    }&#xA;    fmt.Println(post)&#xA;}&#xA;defer rows.Close()&#xA;```&#xA;&#xA;Now, let&#39;s query some data from the database. We can construct the `Post` struct that will be used to grab the required fields like `Id`, `Title`, `Description`, and `Content` from the `posts` table in the database.&#xA;&#xA;Then, we will use the `db.Query` function to query the database. This function takes in a query and returns a `sql.Rows` object. We will iterate over all the `rows` returned from the database, with the `rows.Next()` that will fetch each row. Then we can `row.Scan` the row object with the appropriate and respective fields returned in the row. In this case, the `Id`, `Title`, `Description`, and the `Content` is fetched and stored into the `post` fields.&#xA;&#xA;We have fetched the rows and we can do operations on them as required, this was just a basic example. So the entire code can be found below.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;database/sql&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#xA;&#x9;_ &#34;github.com/tursodatabase/libsql-client-go/libsql&#34;&#xA;)&#xA;&#xA;type Post struct {&#xA;&#x9;Id          int&#xA;&#x9;Title       string&#xA;&#x9;Description string&#xA;&#x9;Content     string&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;dbURL := os.Getenv(&#34;TURSO_DATABASE_URL&#34;)&#xA;&#x9;dbToken := os.Getenv(&#34;TURSO_AUTH_TOKEN&#34;)&#xA;&#x9;dbUrl := fmt.Sprintf(&#34;%s?authToken=%s&#34;, dbURL, dbToken)&#xA;&#xA;&#x9;db, err := sql.Open(&#34;libsql&#34;, dbUrl)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s: %s&#34;, dbUrl, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer db.Close()&#xA;&#xA;&#x9;rows, err := db.Query(&#34;SELECT * FROM posts&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to query: %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#xA;&#x9;for rows.Next() {&#xA;&#x9;&#x9;var post Post&#xA;&#x9;&#x9;if err := rows.Scan(&amp;post.Id, &amp;post.Title, &amp;post.Description, &amp;post.Content); err != nil {&#xA;&#x9;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to scan: %s&#34;, err)&#xA;&#x9;&#x9;&#x9;os.Exit(1)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Println(post)&#xA;&#x9;}&#xA;&#x9;defer rows.Close()&#xA;&#xA;}&#xA;```&#xA;The output of the above code will result in all the rows present in the post table of the LibSQL database.&#xA;&#xA;```bash&#xA;$ go run remote.go&#xA;&#xA;{1 test title test description test content}&#xA;{2 test title test description test content}&#xA;{3 sample post libsql tutorial create db, connect, create tables, insert rows, sync}&#xA;{4 test title test description test content}&#xA;```&#xA;&#xA;I have added a few more rows to the post table, as you can see we have successfully connected, inserted, and read from the post table in the LibSQL database hosted on Turso.&#xA;&#xA;For all the code related to this article, you can check out the [Let&#39;s Go with Turso](https://github.com/mr-destructive/lets-go-with-turso) GitHub repo for all the examples and additional examples for using LibSQL with Golang.&#xA;&#xA;## Conclusion&#xA;&#xA;So, that is a wrap for this part of the series, we have explored how to connect a remote LibSQL database hosted on Turso with Golang. In the next part of the series, we will explore how to create embedded replicas on Turso&#39;s LibSQL database in Golang.&#xA;&#xA;Thank you for reading this post, If you have any questions, feedback, and suggestions, feel free to drop them in the comments.&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>LibSQL: Query a remote Turso database with cURL</title>
      <link>meetgor.com/libsql-query-remote-db</link>
      <description>Querying a libsql database hosted on turso with cURL. Using a remote sqlite-like db with turso api to query data.</description>
      <pubDate>Wed, 15 Nov 2023 00:00:00 UTC</pubDate>
      <content>If you are using a local [libsql](https://turso.tech/libsql) database, it is quite easy to query the database, but for a remote or a database on a hosted cloud platform like [turso](https://turso.tech/), we can use other clients or the api itself to query the data.&#xA;&#xA;We can use the turso cli to get the authentication token for the database and then query the database.&#xA;&#xA;## Turso CLI&#xA;&#xA;Using the [turso-cli](https://docs.turso.tech/reference/turso-cli) to access the turso platform. We will use turso cli to create a libsql database, create authentication tokens, and query the db.&#xA;&#xA;### Create a database (it&#39;s optional, you might already have a database)&#xA;&#xA;```bash&#xA;turso db create&#xA;```&#xA;&#xA;You will get a database on the turso cloud platform with some random interesting name like a passphrase.&#xA;&#xA;Use the command `turso db list` and copy the URL&#xA;&#xA;```graphql&#xA;DB_URL=dbname-orgname.turso.io&#xA;```&#xA;&#xA;### Create an authentication token for a particular database&#xA;&#xA;```bash&#xA;turso db tokens create db_name&#xA;```&#xA;&#xA;Copy the JWT token and this will be used as a authentication token when accessing the remote database in the turso cloud.&#xA;&#xA;```bash&#xA;TOKEN=abcdef.12345.wxyz&#xA;DB_URL=dbname-orgname.turso.io&#xA;```&#xA;&#xA;* Querying the database using curl or other [api clients](https://docs.turso.tech/libsql/client-access)&#xA;    &#xA;&#xA;```bash&#xA;curl -s -H &#34;Authorization: bearer $TOKEN&#34; \&#xA;     -d &#39;{&#34;statements&#34;: [&#34;SELECT name FROM sqlite_master WHERE type=\&#34;table\&#34;;&#34;]}&#39; \&#xA;     $DB_URL&#xA;```&#xA;&#xA;We can use `curl` or any api client tools to send queries to the database hosted on the turso platform. We need to provide the JWT token in the `Authorization` header to connect to that particular database. The request&#39;s body is a JSON string with a list of statements to query the database.&#xA;&#xA;```graphql&#xA;[&#xA;    {&#xA;        &#34;results&#34;:&#xA;            {&#xA;                &#34;columns&#34;: [&#34;name&#34;],&#xA;                &#34;rows&#34;:[&#xA;                    [&#34;libsql_wasm_func_table&#34;], [&#34;_litestream_seq&#34;], [&#34;_litestream_lock&#34;], [&#34;sqlite_sequence&#34;], [&#34;user&#34;]&#xA;                ]&#xA;            }&#xA;     }&#xA;]&#xA;```&#xA;&#xA;The result is a list of key-value pairs as `columns` and `rows` for each of the statements in the body. The columns are a list of column names requested in the query, and the rows are a list of rows where each row is a list of field values from the query.&#xA;</content>
      <type>til</type>
    </item>
  </channel>
</rss>