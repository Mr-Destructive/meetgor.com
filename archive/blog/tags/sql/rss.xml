<rss version="2.0">
  <channel>
    <title>Meet Gor - Tag: sql</title>
    <link>https://meetgor.com</link>
    <description>Posts tagged with sql</description>
    <language>en-us</language>
    <pubDate>Wed, 31 Dec 2025 16:49:07 UTC</pubDate>
    <item>
      <title>SQLITE SQL: Create Table with STRICT Option</title>
      <link>https://meetgor.com/sqlite-create-strict-table</link>
      <description></description>
      <pubDate>Fri, 12 Dec 2025 00:00:00 UTC</pubDate>
      <content>We have seen how to create `TABLE` loosely Not adhering to the types. Because if we create a table with column name of type text, and insert a integer, it will happily store it as text. It is very flexible as we saw. So, in such `CREATE TABLE` statement in SQLite, without the `STRICT` constraint, the types don&#39;t matter.&#xA;&#xA;&#xA;If you created a table with column type as XYZ it will accept it, because it really doesn&#39;t see that. It will see the data coming in from the insert statement and store it whatever it thinks is the best one for that piece of data. Look at the below example:&#xA;&#xA;```sql&#xA;CREATE TABLE t1 (n xyz);&#xA;INSERT INTO t1 values(4);&#xA;INSERT INTO t1 values(&#34;gg&#34;);&#xA;SELECT rowid, n, typeof(n) FROM t1;&#xA;```&#xA;&#xA;&#xA;```&#xA;rowid    n    typeof(n)&#xA;1        4    integer&#xA;2       gg    text&#xA;```&#xA;&#xA;&#xA;See? The column type, it doesn&#39;t matter.&#xA;&#xA;Unless it&#39;s strict or any constraints, or generated conditions have been added.&#xA;&#xA;The STRICT table option&#xA;&#xA;Let&#39;s quote from the documentation what it means&#xA;&#xA;&#xA;&gt; *   Every column definition must specify a datatype for that column.&#xA;&gt;&#xA;&gt; *   The freedom to specify a column without a datatype is removed.&#xA;&gt;&#xA;&gt; *   The datatype must be one of the following:&#xA;&gt;&#xA;&gt;     *   INT&#xA;&gt;&#xA;&gt;     *   INTEGER&#xA;&gt;&#xA;&gt;     *   REAL&#xA;&gt;&#xA;&gt;     *   TEXT&#xA;&gt;&#xA;&gt;     *   BLOB&#xA;&gt;&#xA;&gt;     *   ANY&#xA;&gt;&#xA;&gt; *   The [PRAGMA integrity\_check](https://sqlite.org/pragma.html#pragma_integrity_check) and [PRAGMA quick\_check](https://sqlite.org/pragma.html#pragma_quick_check) commands check the type of the content of all columns in STRICT tables and show errors if anything is amiss.&#xA;&gt;&#xA;&#xA;There are other nuances of the STRICT table options and the kind of constraint that you put on the columns, but that requires studying very specific examples. We&#39;ll check those nuances later.&#xA;&#xA;For now though, we need to understand how to create a strictly typed table, and what the strict option adds to the table.&#xA;&#xA;```sql&#xA;CREATE TABLE users(&#xA;    name TEXT,&#xA;    age  INT,&#xA;    credits REAL,&#xA;    profile_pic BLOB&#xA;) STRICT;&#xA;```&#xA;&#xA;So, we have all the actual possible types we can use in a table column when defining a table. If you don&#39;t provide an column type, or provide any other type than `TEXT`, `INT` or `INTEGER`, `REAL`, `BLOB`, or `ANY` (don&#39;t put any, you lose the purpose of strict) it won&#39;t compile and execute the table creation. You need to provide a valid type among the 5 types.&#xA;&#xA;However if you try to create a strict table with wrong column type or no column type.&#xA;&#xA;```sql&#xA;CREATE TABLE t1 (t) STRICT;&#xA;-- Error: missing datatype for t1.t&#xA;&#xA;CREATE TABLE t1 (t something) STRICT;&#xA;-- Error: unknown datatype for t1.t: &#34;something&#34;&#xA;```&#xA;&#xA;&#xA;&#xA;Without STRICT it works as usual:&#xA;&#xA;```sql&#xA;CREATE TABLE t1 (t  something);&#xA;INSERT INTO t1 values(123), (&#39;abc&#39;), (X&#39;&#39;), (123.45);&#xA;SELECT t, typeof(t) FROM t1;&#xA;```&#xA;&#xA;&#xA;```&#xA;t    typeof(t)&#xA;123    integer&#xA;abc    text&#xA;    blob&#xA;123.45    real&#xA;```&#xA;&#xA;&#xA;Now back to the original example:&#xA;&#xA;Insert a couple of rows:&#xA;&#xA;```sql&#xA;-- All are NULL Values&#xA;INSERT INTO users DEFAULT VALUES;&#xA;&#xA;INSERT INTO users (name, age, credits, profile_pic)&#xA;VALUES (&#xA;    &#39;Alice&#39;,&#xA;    30,&#xA;    100.0,&#xA;    X&#39;89504E470D0A1A0A&#39;&#xA;);&#xA;```&#xA;&#xA;&#xA;This will insert two rows, the first one, all the columns will be `NULL`. If you look at the type of these statement. Those will be as per the table schema, consistent for all rows.&#xA;&#xA;```&#xA;name    typeof(name)    age    typeof(age)    credits    typeof(credits)    profile_pic    typeof(profile_pic)&#xA;null        null        null        null&#xA;Alice    text    30    integer    100    real    137,80,78,71,13,10,26,10    blob&#xA;```&#xA;&#xA;This has rightly added NULL type for the null values but when the data is in the row, it forces that type stated in the schema of the table.&#xA;&#xA;&#xA;Now, if we try to mess up the column data, it won&#39;t work&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age, credits, profile_pic)&#xA;VALUES (34, &#39;4&#39;, 8, 123);&#xA;-- Error: cannot store INT value in BLOB column users.profile_pic&#xA;&#xA;INSERT INTO users (name, age, credits, profile_pic)&#xA;VALUES (34, &#39;4&#39;, 8, &#39;&#39;);&#xA;-- Error: cannot store TEXT value in BLOB column users.profile_pic&#xA;&#xA;INSERT INTO users (name, age, credits, profile_pic)&#xA;VALUES (34, &#39;abc&#39;, 8, X&#39;&#39;);&#xA;-- Error: cannot store TEXT value in INT column users.age&#xA;```&#xA;&#xA;This will work, as type affinity and the conversion is possible within the column types here.&#xA;&#xA;```&#xA;INSERT INTO users (name, age, credits, profile_pic)&#xA;VALUES (CAST(34 AS INT), &#39;3&#39;, 8, X&#39;&#39;);&#xA;```&#xA;&#xA;But if some data is not able to convert into that strict type, it will fail the constraint of strict column type.&#xA;&#xA;For instance&#xA;- `123` or `&#34;&#34;` is not force convertible to BLOB which is binary large object. We need to parse it with X&#39;&#39; strings for some raw data to make it a BLOB like object in SQLite.&#xA;- `abc`  is not convertible/casteble to INTEGER or REAL Value.&#xA;&#xA;So, the strict type is actually strict as we see the pattern repeating in SQLite.&#xA;&#xA;&gt; It is flexible till you allow it to be, you can at anytime change the lever and make it strict&#xA;&#xA;This is true for column-row level type checking with the STRICT table option while creating table.</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Create Table with Select</title>
      <link>https://meetgor.com/sqlite-create-table-from-select</link>
      <description></description>
      <pubDate>Sun, 28 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Creating table with Select Query&#xA;&#xA;Sometimes you want to create a new table based on data that already exists,maybe you’re archiving old rows, generating a summary, cloning a table, or transforming data into a new structure. Doing this might require you to write a `CREATE TABLE` statement with all column definitions, then running one or more `INSERT INTO` statements to populate it. That’s a lot of work.&#xA;&#xA;Well, SQL is more flexible then you might think, Instead of manually defining columns and inserting data, you write one statement that both builds the table and fills it with the rows returned by your `SELECT` query. This makes it incredibly useful for backups, and whatever you are doing (hopefully not taking down the prod db).&#xA;&#xA;We have CTAS, `CREATE TABLE AS SELECT` statements.&#xA;This basically means to take whatever the SELECT gives, and turn it into a table.&#xA;&#xA;## Creating CTAS&#xA;&#xA;Lets&#39;s start with a simple example, we will use our goodol users table first and populate it with some data.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL,&#xA;    age INTEGER NOT NULL&#xA;);&#xA;```&#xA;&#xA;This would create a table called `users` with the columns `id`, `name`, and `age`. The `id` column is the primary key, and the `name` and `age` columns are not null.&#xA;&#xA;Let&#39;s insert some data into the table.&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age)&#xA;VALUES (&#39;abc&#39;, 20), (&#39;def&#39;, 30), (&#39;ghi&#39;, 40);&#xA;```&#xA;&#xA;This would insert three rows into the `users` table, with the names `abc`, `def`, and `ghi`, and the ages 20, 30, and 40.&#xA;&#xA;Now, let&#39;s use the `CREATE TABLE AS SELECT` statement to create a new table called `users_copy` that is a copy of the `users` table.&#xA;&#xA;```sql&#xA;CREATE TABLE users_copy AS SELECT * FROM users;&#xA;```&#xA;This would create a new table called `users_copy` that is a copy of the `users` table, with the same columns and data.&#xA;&#xA;It will copy the same column structure and data from the `users` table to the `users_copy` table.&#xA;&#xA;```sql&#xA;SELECT * FROM users_copy;&#xA;```&#xA;&#xA;Let&#39;s check the schema of the new table `users_copy`&#xA;&#xA;```sql&#xA;PRAGMA table_info(users_copy);&#xA;PRAGMA table_info(users);&#xA;```&#xA;&#xA;This would print the schema of the `users_copy` table.&#xA;&#xA;```&#xA;PRAGMA table_info(users_copy);&#xA;+-----+------+------+---------+------------+----+&#xA;| cid | name | type | notnull | dflt_value | pk |&#xA;+-----+------+------+---------+------------+----+&#xA;| 0   | id   | INT  | 0       |            | 0  |&#xA;| 1   | name | TEXT | 0       |            | 0  |&#xA;| 2   | age  | INT  | 0       |            | 0  |&#xA;+-----+------+------+---------+------------+----+&#xA;&#xA;&#xA;PRAGMA table_info(users);&#xA;+-----+------+---------+---------+------------+----+&#xA;| cid | name |  type   | notnull | dflt_value | pk |&#xA;+-----+------+---------+---------+------------+----+&#xA;| 0   | id   | INTEGER | 0       |            | 1  |&#xA;| 1   | name | TEXT    | 1       |            | 0  |&#xA;| 2   | age  | INTEGER | 1       |            | 0  |&#xA;+-----+------+---------+---------+------------+----+&#xA;```&#xA;&#xA;You can see the difference here, the `users.id` column is a primary key in the `users` table, however in the `users_copy` table it isn&#39;t. Also the constraints like `notnull` are not reciprocated in the `users_copy` table.&#xA;&#xA;So, is this a good way to create a copy of a table?&#xA;&#xA;Maybe, its just copying the data and the bare-bone structure of the table and not the schema.&#xA;&#xA;```sqlite&#xA;&#xA;sqlite&gt; CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL,&#xA;    age INTEGER NOT NULL&#xA;);&#xA;sqlite&gt; INSERT INTO users (name, age)&#xA;VALUES (&#39;abc&#39;, 20), (&#39;def&#39;, 30), (&#39;ghi&#39;, 40);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+------+-----+&#xA;| id | name | age |&#xA;+----+------+-----+&#xA;| 1  | abc  | 20  |&#xA;| 2  | def  | 30  |&#xA;| 3  | ghi  | 40  |&#xA;+----+------+-----+&#xA;sqlite&gt; CREATE TABLE users_copy AS SELECT * FROM users;&#xA;sqlite&gt; SELECT * FROM users_copy;&#xA;+----+------+-----+&#xA;| id | name | age |&#xA;+----+------+-----+&#xA;| 1  | abc  | 20  |&#xA;| 2  | def  | 30  |&#xA;| 3  | ghi  | 40  |&#xA;+----+------+-----+&#xA;sqlite&gt; PRAGMA table_info(users_copy);&#xA;+-----+------+------+---------+------------+----+&#xA;| cid | name | type | notnull | dflt_value | pk |&#xA;+-----+------+------+---------+------------+----+&#xA;| 0   | id   | INT  | 0       |            | 0  |&#xA;| 1   | name | TEXT | 0       |            | 0  |&#xA;| 2   | age  | INT  | 0       |            | 0  |&#xA;+-----+------+------+---------+------------+----+&#xA;sqlite&gt; PRAGMA table_info(users);&#xA;+-----+------+---------+---------+------------+----+&#xA;| cid | name |  type   | notnull | dflt_value | pk |&#xA;+-----+------+---------+---------+------------+----+&#xA;| 0   | id   | INTEGER | 0       |            | 1  |&#xA;| 1   | name | TEXT    | 1       |            | 0  |&#xA;| 2   | age  | INTEGER | 1       |            | 0  |&#xA;+-----+------+---------+---------+------------+----+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;&#xA;&#xA;## What CTAS do?&#xA;&#xA;It will create a new table called `users_copy` that is a copy of the `users` table, with the same columns and data.&#xA;&#xA;However, it just copies the data and structure but not the entire schema.&#xA;&#xA;What I means is that if you have constraints and indexes, the select statement won&#39;t copy it over to the new table.&#xA;&#xA;So, it will not copy the following;&#xA;- Constraints&#xA;- indexes&#xA;- Triggers&#xA;&#xA;However, it will copy everything in the select statement&#39;s output.&#xA;&#xA;So, you can add custom columns, computed columns, etc.&#xA;&#xA;You can also filter the select statement with `WHERE` and `ORDER BY` statements in order to store the limited set of data that you wished to store.&#xA;&#xA;## Copying only the structure&#xA;&#xA;If you only wanted to only copy the structure and not the entire data, you can invalidate any rows from the select statement with the `WHERE` clause. This will just create columns in the new table. Giving you a fresh copy of the new table, without any data.&#xA;&#xA;```sql&#xA;CREATE TABLE users_copy AS SELECT * FROM users WHERE 0;&#xA;```&#xA;&#xA;This will create a new table called `users_copy` that is a copy of the `users` table, but without any data.&#xA; &#xA; ```sqlite&#xA;&#xA;sqlite&gt; CREATE TABLE users_copy AS SELECT * FROM users WHERE 0;&#xA;Parse error: table users_copy already exists&#xA;  CREATE TABLE users_copy AS SELECT * FROM users WHERE 0;&#xA;               ^--- error here&#xA;sqlite&gt; CREATE TABLE IF NOT EXISTS users_copy AS SELECT * FROM users WHERE 0;&#xA;sqlite&gt; SELECT * FROM users_copy;&#xA;+----+------+-----+&#xA;| id | name | age |&#xA;+----+------+-----+&#xA;| 1  | abc  | 20  |&#xA;| 2  | def  | 30  |&#xA;| 3  | ghi  | 40  |&#xA;+----+------+-----+&#xA;sqlite&gt; DROP TABLE users_copy;&#xA;sqlite&gt; CREATE TABLE IF NOT EXISTS users_copy AS SELECT * FROM users WHERE 0;&#xA;sqlite&gt; SELECT * FROM users_copy;&#xA;sqlite&gt; PRAGMA table_info(users_copy);&#xA;+-----+------+------+---------+------------+----+&#xA;| cid | name | type | notnull | dflt_value | pk |&#xA;+-----+------+------+---------+------------+----+&#xA;| 0   | id   | INT  | 0       |            | 0  |&#xA;| 1   | name | TEXT | 0       |            | 0  |&#xA;| 2   | age  | INT  | 0       |            | 0  |&#xA;+-----+------+------+---------+------------+----+&#xA;sqlite&gt;&#xA; ```&#xA; As you can see, we need to actually drop the table in order to create a new table form scratch just like any normal table in sqlite.&#xA;&#xA; So, there are a few more gotchas and details of this, than I thought to be, will be taking a closer look at each one by one in the next few posts.&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Create Table If Not Exists</title>
      <link>https://meetgor.com/sqlite-create-table-if-not-exists</link>
      <description></description>
      <pubDate>Fri, 26 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Creating table if not already exists&#xA;&#xA;The `CREATE TABLE` has one clause that we can add to create table if it doesn&#39;t exist already. So this comes handy if you already have created a table and instead of throwing an error it simply gracefully handles the query and doesn&#39;t re-create the table. &#xA;&#xA;Let&#39;s first creat a table, as usual, we&#39;ll use the goodol `users` table.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;```&#xA;Let&#39;s insert some data into the table.&#xA;&#xA;```sql&#xA;INSERT INTO users (name) VALUES (&#39;abc&#39;), (&#39;def&#39;);&#xA;```&#xA;&#xA;Ok, the table `users` exist and also has some data in it.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;Now, if we try to create the same table again, it will throw an error.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL,&#xA;    email TEXT NOT NULL,&#xA;    password TEXT NOT NULL&#xA;);&#xA;```&#xA;&#xA;It will result in `users` table already exists error.&#xA;&#xA;You cannot re-create a table that already exist, you need to drop the table and create again, or alter any columns you wanted to if that is possible.&#xA;&#xA;Or, if you just want to create a table only if it doesn&#39;t already exists, then you can add the `IF NOT EXISTS` clause:&#xA;&#xA;```sql&#xA;CREATE TABLE IF NOT EXISTS users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL,&#xA;    email TEXT NOT NULL,&#xA;    password TEXT NOT NULL&#xA;);&#xA;```&#xA;&#xA;Now, if we try to create the table again, it will not throw any error.&#xA;&#xA;However, it won&#39;t re-create the `users` table, it will just skip the creation.&#xA;&#xA;The table would be as is.&#xA;&#xA;```sqlite&#xA;&#xA;sqlite&gt; CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;sqlite&gt; INSERT INTO users (name) VALUES (&#39;abc&#39;), (&#39;def&#39;);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+------+&#xA;| id | name |&#xA;+----+------+&#xA;| 1  | abc  |&#xA;| 2  | def  |&#xA;+----+------+&#xA;sqlite&gt; CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL,&#xA;    email TEXT NOT NULL,&#xA;    password TEXT NOT NULL&#xA;);&#xA;Parse error: table users already exists&#xA;  CREATE TABLE users (     id INTEGER PRIMARY KEY,     name TEXT NOT NULL,     e&#xA;               ^--- error here&#xA;sqlite&gt; CREATE TABLE IF NOT EXISTS users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL,&#xA;    email TEXT NOT NULL,&#xA;    password TEXT NOT NULL&#xA;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+------+&#xA;| id | name |&#xA;+----+------+&#xA;| 1  | abc  |&#xA;| 2  | def  |&#xA;+----+------+&#xA;sqlite&gt; .schema users&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;sqlite&gt;&#xA;```&#xA;&#xA;## Where can we use this?&#xA;&#xA;- Accidental cases: Avoiding creating a table that already exists.&#xA;- Code Generation tools: If you are using schema-based code generation tools like [sqlc](https://github.com/sqlc-dev/sqlc), you might keep on re-running the generation code again and again, to avoid the error statements, you can use this to stop table from re-creating or erroing queries.&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Create Temporary Table</title>
      <link>https://meetgor.com/sqlite-create-temp-table</link>
      <description></description>
      <pubDate>Wed, 24 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Temporary Table in SQLite&#xA;&#xA;A Temporary table as the name suggests, is a temporary table. It only resisdes on the database until the current session of the database.&#xA;&#xA;In case of sqlite, the temporary table is available in the session until the file reader or session driver closes the connection.&#xA;&#xA;The table is created in a separate database file called `temp` that is stored in your temporary path.&#xA;&#xA;## Create a temporary table&#xA;&#xA;To create the temporary table, simply use the `TEMP` or `TEMPORARY` keyword before the `TABLE` in `CREATE TABLE` expression. So, `CREATE TEMP TABLE` or `CREATE TEMPORARY TABLE` will be the notation to create a temporary table in sqlite.&#xA;&#xA;```sql&#xA;CREATE TEMP TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT&#xA;);&#xA;```&#xA;This will create a temporary table called `users` in the `temp` database.&#xA;&#xA;You can insert, update, delete, query and relate to other tables just like a normal table.&#xA;&#xA;```sql&#xA;INSERT INTO users (name) VALUES (&#39;abc&#39;), (&#39;def&#39;), (&#39;ghi&#39;);&#xA;```&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;```sql&#xA;UPDATE users SET name = &#39;xyz&#39; WHERE name = &#39;abc&#39;;&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;```sql&#xA;DELETE FROM users WHERE name = &#39;def&#39;;&#xA;```&#xA;&#xA;```sql&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    title TEXT,&#xA;    content TEXT,&#xA;    user_id INTEGER,&#xA;    FOREIGN KEY (user_id) REFERENCES users (id)&#xA;);&#xA;```&#xA;&#xA;```sqlite&#xA;$ sqlite3 myusers.db&#xA;&#xA;sqlite&gt; CREATE TEMP TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT&#xA;);&#xA;&#xA;sqlite&gt; .tables&#xA;temp.users&#xA;&#xA;sqlite&gt; INSERT INTO users (name) VALUES (&#39;abc&#39;), (&#39;def&#39;), (&#39;ghi&#39;);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+------+&#xA;| id | name |&#xA;+----+------+&#xA;| 1  | abc  |&#xA;| 2  | def  |&#xA;| 3  | ghi  |&#xA;+----+------+&#xA;sqlite&gt; UPDATE users SET name = &#39;xyz&#39; WHERE name = &#39;abc&#39;;&#xA;SELECT * FROM users;&#xA;+----+------+&#xA;| id | name |&#xA;+----+------+&#xA;| 1  | xyz  |&#xA;| 2  | def  |&#xA;| 3  | ghi  |&#xA;+----+------+&#xA;sqlite&gt; DELETE FROM users WHERE name = &#39;def&#39;;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+------+&#xA;| id | name |&#xA;+----+------+&#xA;| 1  | xyz  |&#xA;| 3  | ghi  |&#xA;+----+------+&#xA;sqlite&gt; CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    title TEXT,&#xA;    content TEXT,&#xA;    user_id INTEGER,&#xA;    FOREIGN KEY (user_id) REFERENCES users (id)&#xA;);&#xA;&#xA;sqlite&gt; .tables&#xA;posts temp.users&#xA;&#xA;sqlite&gt; INSERT INTO posts(title, content, user_id) VALUES(&#39;banger post&#39;, &#39;ai slop&#39;, 1);&#xA;sqlite&gt; INSERT INTO posts(title, content, user_id) VALUES(&#39;ai slop&#39;, &#39;banger content&#39;, 3);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+-------------+----------------+---------+&#xA;| id |    title    |    content     | user_id |&#xA;+----+-------------+----------------+---------+&#xA;| 1  | banger post | ai slop        | 1       |&#xA;| 2  | ai slop     | banger content | 3       |&#xA;+----+-------------+----------------+---------+&#xA;sqlite&gt;&#xA;&#xA;```&#xA;&#xA;So, this creates a temporary table, but what if we already have a `users` table in the database?&#xA;&#xA;&gt; You can notice, when I query all the tables with the dot-command `.tables`, it adds a prefix of `temp.` to the temporary table. That is an indication of the table being stored in a temporary database file. Hence if there were two `users` table created, we would be able to identify it with the `temp` and the `main` as the database name.&#xA;&#xA;The `main` is optional, but if you want to refer to the `temporary` table then explicitly mention it as `temp.users` or `temp.&lt;table_name&gt;`&#xA;&#xA;However, if you try to perform anything on the actual table, you will have to explicitly mention the `main` keyword, as the temp table will take precedence over the table in the main database.&#xA;&#xA;I reponed the database as `myusers.db` , now the `users` table which was the temporary table, is gone.&#xA;&#xA;```sql&#xA;.tables&#xA;```&#xA;&#xA;This only shows, `posts` table, but the temporary table was destroyed.&#xA;&#xA;Let&#39;s create back the `users` table as a temporary table in the database.&#xA;&#xA;```sql&#xA;CREATE TEMP TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT&#xA;);&#xA;```&#xA;&#xA;This will create the table in the `temp` database.&#xA;&#xA;Now, if we check the tables, we will see the `temp.users` table.&#xA;&#xA;```sql&#xA;.tables&#xA;```&#xA;Let&#39;s create a new table `users` in the main database.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT&#xA;);&#xA;```&#xA;This would create a `users` table that will be stored permanently in the main database i.e. the `myusers.db` in my case to the file.&#xA;&#xA;Let&#39;s view what the `.tables` output, it shows 3 tables now&#xA;&#xA;- `posts`&#xA;- `temp.users`&#xA;- `users`&#xA;&#xA;Now, here, if you insert bunch of different values into the `users` table.&#xA;&#xA;```sql&#xA;INSERT INTO users (name) VALUES (&#39;abc&#39;), (&#39;def&#39;), (&#39;ghi&#39;);&#xA;```&#xA;&#xA;And query the `users` table&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;Which table is that inserted and queried?&#xA;&#xA;The `temp.users` table, because the precedence of temporary table is higher than the main table.&#xA;&#xA;So, let&#39;s try to query the `temp.users` table.&#xA;&#xA;```sql&#xA;SELECT * FROM temp.users;&#xA;```&#xA;&#xA;As you can see the table has the records. &#xA;&#xA;But if we try to query the `main.users` table, it will have no records.&#xA;&#xA;```sql&#xA;SELECT * FROM main.users;&#xA;```&#xA;This is empty.&#xA;As, expected, just the `users` table will refer to th temporary table and not the main table.&#xA;&#xA;So, let&#39;s insert different values in the `main.users` table.&#xA;&#xA;```sql&#xA;INSERT INTO main.users (name) VALUES (&#39;pqr&#39;), (&#39;stu&#39;);&#xA;```&#xA;&#xA;And query the `main.users` table.&#xA;&#xA;```sql&#xA;SELECT * FROM main.users;&#xA;```&#xA;This will show the inserted records in the `main.users` table.&#xA;&#xA;Here&#39;s the SQLog :)&#xA;&#xA;```sqlite&#xA;$ sqlite3 myusers.db&#xA;sqlite&gt; .tables&#xA;posts&#xA;&#xA;sqlite&gt; CREATE TEMP TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT&#xA;);&#xA;&#xA;sqlite&gt; .tables&#xA;posts       temp.users&#xA;&#xA;sqlite&gt; CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT&#xA;);&#xA;&#xA;sqlite&gt; .tables&#xA;posts       temp.users  users&#xA;&#xA;sqlite&gt; .schema temp.users&#xA;&#xA;CREATE TABLE temp.users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT&#xA;);&#xA;&#xA;sqlite&gt; .schema main.users&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT&#xA;);&#xA;&#xA;sqlite&gt; SELECT * FROM users;&#xA;sqlite&gt; SELECT * FROM temp.users;&#xA;sqlite&gt; INSERT INTO users (name) VALUES (&#39;abc&#39;), (&#39;def&#39;), (&#39;ghi&#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+------+&#xA;| id | name |&#xA;+----+------+&#xA;| 1  | abc  |&#xA;| 2  | def  |&#xA;| 3  | ghi  |&#xA;+----+------+&#xA;sqlite&gt; SELECT * FROM temp.users;&#xA;+----+------+&#xA;| id | name |&#xA;+----+------+&#xA;| 1  | abc  |&#xA;| 2  | def  |&#xA;| 3  | ghi  |&#xA;+----+------+&#xA;sqlite&gt; SELECT * FROM main.users;&#xA;sqlite&gt; INSERT INTO main.users (name) VALUES (&#39;pqr&#39;), (&#39;stu&#39;);&#xA;sqlite&gt; SELECT * FROM main.users;&#xA;+----+------+&#xA;| id | name |&#xA;+----+------+&#xA;| 1  | pqr  |&#xA;| 2  | stu  |&#xA;+----+------+&#xA;sqlite&gt; SELECT * FROM temp.users;&#xA;+----+------+&#xA;| id | name |&#xA;+----+------+&#xA;| 1  | abc  |&#xA;| 2  | def  |&#xA;| 3  | ghi  |&#xA;+----+------+&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+------+&#xA;| id | name |&#xA;+----+------+&#xA;| 1  | abc  |&#xA;| 2  | def  |&#xA;| 3  | ghi  |&#xA;+----+------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;So, to sum up:&#xA;- `CREATE TEMP TABLE` or `CREATE TEMPORARY TABLE` will create a temporary table in sqlite.&#xA;- The temporary table is available in the session until the file reader or session driver closes the connection.&#xA;- The temporary table is stored on the separate temporary file&#xA;- The temporary table is prefixed with the `temp` table.&#xA;- If there are two tables, one temporary and one permanent, with the same name, then the temporary table will be prefered unless `main` is prefixed to the table name.&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Collate Column Modifier</title>
      <link>https://meetgor.com/sqlite-collate-column-modifier</link>
      <description></description>
      <pubDate>Mon, 22 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Collate Column Modifier&#xA;&#xA;Collate is a modifier in SQL that specifies the column how to arrange and compare the values that would be populated in the rows.&#xA;&#xA;So, for a given table, we can specify a few modifiers that would let SQL decide how to handle the values.&#xA;&#xA;## Adding Collate Modifier&#xA;&#xA;To add a collate modifier, we can use the `COLLATE` keyword, followed by the collation name.&#xA;&#xA;There are 3 collations available in SQLite:&#xA;&#xA;- BINARY&#xA;- NOCASE&#xA;- RTRIM&#xA;&#xA;These basically define how the column value might be treated in later comparisons or populating in querying.&#xA;&#xA;Let&#39;s quickly understand each with the basic example&#xA;&#xA;## BINARY&#xA;&#xA;The `BINARY` modifier is the **default collation** in SQLite.  &#xA;It compares values **byte by byte**, meaning it is case-sensitive and space-sensitive.&#xA;&#xA;Let&#39;s create a demo table:&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    name TEXT COLLATE BINARY&#xA;);&#xA;```&#xA;Now, let&#39;s insert some values&#xA;&#xA;```sql&#xA;INSERT INTO users (name) VALUES (&#39;jane&#39;), (&#39;John&#39;), (&#39;JANE&#39;), (&#39;Jane   &#39;);&#xA;```&#xA;&#xA;Here, I have inserted 4 names in the `users` table. I have deliberately inserted a mix of cases. Let&#39;s now see how the values are populated in the table.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;We see that there are `4` rows rightly being populated.&#xA;&#xA;```sql&#xA;SELECT * FROM users WHERE name = &#39;jane&#39;;&#xA;```&#xA;Now, we see that only the `jane` name is being populated. This is because the `BINARY` modifier is not case sensitive and space sensitive.&#xA;&#xA;```sqlite&#xA;&#xA;sqlite&gt; CREATE TABLE users (&#xA;    name TEXT COLLATE BINARY&#xA;);&#xA;sqlite&gt; INSERT INTO users (name) VALUES (&#39;jane&#39;), (&#39;John&#39;), (&#39;JANE&#39;), (&#39;Jane   &#39;);&#xA;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+---------+&#xA;|  name   |&#xA;+---------+&#xA;| jane    |&#xA;| John    |&#xA;| JANE    |&#xA;| Jane    |&#xA;+---------+&#xA;sqlite&gt; SELECT * FROM users WHERE name = &#39;jane&#39;;&#xA;+------+&#xA;| name |&#xA;+------+&#xA;| jane |&#xA;+------+&#xA;```&#xA;&#xA;This is the modifier added by default to the columns that have `TEXT` affinity (not necessarily the `TEXT` type).&#xA;&#xA;## NOCASE&#xA;&#xA;The `NOCASE` modifier is used to ignore the case of the values in the column. When comparing the two values of the same column, if that values are comparable as strings, then the case is not considered.&#xA;&#xA;Let&#39;s create a typical `users` table with a `name` column&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    name TEXT COLLATE NOCASE &#xA;);&#xA;```&#xA;&#xA;Here, we have added a `COLLATE NOCASE` modifier to the `name` column.&#xA;&#xA;Let&#39;s insert some values:&#xA;&#xA;```sql&#xA;INSERT INTO users (name) VALUES (&#39;John&#39;), (&#39;jane&#39;), (&#39;JANE&#39;);&#xA;```&#xA;&#xA;Here, I have inserted 3 names in the `users` table. I have deliberately inserted a mix of cases. Let&#39;s now see how the values are populated in the table. The `Jane` name is in lowercase as well as uppercase.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;We see that there are `3` rows rightly being populated.&#xA;&#xA;Now, what would happen if the user queries for `jane`?&#xA;&#xA;```sql&#xA;SELECT * FROM users WHERE name = &#39;jane&#39;;&#xA;```&#xA;This comes with both the `jane`s the `jane` with lowercase as well `JANE` with uppercase. This is because the `NOCASE` modifier is not case sensitive.&#xA;&#xA;```sqlite&#xA;sqlite&gt; CREATE TABLE users (&#xA;    name TEXT COLLATE NOCASE&#xA;);&#xA;&#xA;sqlite&gt; INSERT INTO users (name) VALUES (&#39;John&#39;), (&#39;jane&#39;), (&#39;JANE&#39;);&#xA;&#xA;sqlite&gt; .mode table&#xA;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+------+&#xA;| name |&#xA;+------+&#xA;| John |&#xA;| jane |&#xA;| JANE |&#xA;+------+&#xA;&#xA;sqlite&gt; SELECT * FROM users WHERE name = &#39;jane&#39;;&#xA;+------+&#xA;| name |&#xA;+------+&#xA;| jane |&#xA;| JANE |&#xA;+------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;That is the basic idea of how the `NOCASE` collation works.&#xA;&#xA;&#xA;## RTRIM&#xA;&#xA;The `RTRIM` modifier is used to remove the trailing spaces from the values in the column.&#xA;&#xA;Let&#39;s create a typical `users` table with a `name` column&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    name TEXT COLLATE RTRIM &#xA;);&#xA;```&#xA;&#xA;Here, we have added a `COLLATE RTRIM` modifier to the `name` column.&#xA;&#xA;Let&#39;s insert some values:&#xA;&#xA;```sql&#xA;INSERT INTO users (name) VALUES (&#39;John&#39;), (&#39;jane&#39;), (&#39;JANE&#39;), (&#39;Jane   &#39;), (&#39;jane   &#39;);&#xA;```&#xA;Here, I have inserted 5 names in the `users` table. I have deliberately inserted a mix of cases. Let&#39;s now see how the values are populated in the table.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;We see that there are `5` rows rightly being populated.&#xA;&#xA;```sql&#xA;SELECT * FROM users WHERE name = &#39;jane&#39;;&#xA;```&#xA;&#xA;We see 2 rows being populated. This is because the `RTRIM` modifier is removing the trailing spaces.&#xA;&#xA;The first row is the `jane` name without any spaces, the 2nd row that we added. The second row is the `jane` name with the trailing space, the last one that was added.&#xA;&#xA;&#xA;```sql&#xA;sqlite&gt; CREATE TABLE users (&#xA;    name TEXT COLLATE RTRIM&#xA;);&#xA;sqlite&gt; INSERT INTO users (name) VALUES (&#39;John&#39;), (&#39;jane&#39;), (&#39;JANE&#39;), (&#39;Jane   &#39;), (&#39;jane   &#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+---------+&#xA;|  name   |&#xA;+---------+&#xA;| John    |&#xA;| jane    |&#xA;| JANE    |&#xA;| Jane    |&#xA;| jane    |&#xA;+---------+&#xA;sqlite&gt; SELECT * FROM users WHERE name = &#39;jane&#39;;&#xA;+---------+&#xA;|  name   |&#xA;+---------+&#xA;| jane    |&#xA;| jane    |&#xA;+---------+&#xA;sqlite&gt; SELECT rowid, * FROM users WHERE name = &#39;jane&#39;;&#xA;+-------+---------+&#xA;| rowid |  name   |&#xA;+-------+---------+&#xA;| 2     | jane    |&#xA;| 5     | jane    |&#xA;+-------+---------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;That is the basic idea of how the `RTRIM` collation works.&#xA;&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Many to Many Table without RowID</title>
      <link>https://meetgor.com/sqlite-many-to-many-table-without-rowid</link>
      <description></description>
      <pubDate>Sat, 20 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Many to Many Relation&#xA;&#xA;We saw the basic example of [Many-To-Many](https://www.meetgor.com/sqlog/sqlite-many-to-many-relations/) Relation in the second last post from this, there we just focused on the concept of the relation and not so much on the structure of the junction table.&#xA;&#xA;Let&#39;s take a look at the schema again:&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    title TEXT NOT NULL,&#xA;    content TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE author_post (&#xA;    user_id INTEGER NOT NULL,&#xA;    post_id INTEGER NOT NULL,&#xA;    PRIMARY KEY (user_id, post_id),&#xA;    FOREIGN KEY (user_id) REFERENCES users (id),&#xA;    FOREIGN KEY (post_id) REFERENCES posts (id)&#xA;);&#xA;```&#xA;&#xA;Let&#39;s now populate the tables.&#xA;&#xA;```sql&#xA;-- adding authors/users&#xA;INSERT INTO users(name) VALUES (&#39;Glauber&#39;), (&#39;Jamie&#39;), (&#39;Pekka&#39;);&#xA;&#xA;-- adding posts written by pekka&#xA;INSERT INTO posts(title, content) VALUES (&#39;Switching to Zig from Rust&#39;, &#39;I love C&#39;);&#xA;INSERT INTO posts(title, content) VALUES (&#39;RAG in SQLite&#39;, &#39;AI first database&#39;);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (3, 1), (3, 2);&#xA;&#xA;-- adding posts written by glauber&#xA;INSERT INTO posts(title, content) VALUES (&#39;Rewriting SQLite&#39;, &#39;We are no more a sqlite-fork&#39;);&#xA;INSERT INTO posts(title, content) VALUES (&#39;Offline Writes in SQLite&#39;, &#39;Lets sync&#39;);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (1, 3), (1, 4);&#xA;&#xA;-- adding a post co-authored by pekka and glauber&#xA;INSERT INTO posts(title, content) VALUES(&#39;Limbo&#39;, &#39;SQLite in Rust&#39;);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (3, 5);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (1, 5);&#xA;```&#xA;&#xA;This has now populated the following tables:&#xA;&#xA;```sql&#xA;SELECT&#xA;    p.id,&#xA;    p.content AS post,&#xA;    GROUP_CONCAT(u.name, &#39;, &#39;) AS authors&#xA;FROM posts p&#xA;JOIN author_post up ON p.id = up.post_id&#xA;JOIN users u ON u.id = up.user_id&#xA;GROUP BY p.id;&#xA;```&#xA;&#xA;This has 5 posts, two written by `Pekka`, two written by `Glauber`, and one co-authored by both `Pekka` and `Glauber`.&#xA;&#xA;Here&#39;s the SQLog:&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    title TEXT NOT NULL,&#xA;    content TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE author_post (&#xA;    user_id INTEGER NOT NULL,&#xA;    post_id INTEGER NOT NULL,&#xA;    PRIMARY KEY (user_id, post_id),&#xA;    FOREIGN KEY (user_id) REFERENCES users (id),&#xA;    FOREIGN KEY (post_id) REFERENCES posts (id)&#xA;);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; INSERT INTO users(name) VALUES (&#39;Glauber&#39;), (&#39;Jamie&#39;), (&#39;Pekka&#39;);&#xA;sqlite&gt; INSERT INTO posts(title, content) VALUES (&#39;Switching to Zig from Rust&#39;, &#39;I love C&#39;);&#xA;INSERT INTO posts(title, content) VALUES (&#39;RAG in SQLite&#39;, &#39;AI first database&#39;);&#xA;SELECT * FROM posts;&#xA;+----+----------------------------+-------------------+&#xA;| id |           title            |      content      |&#xA;+----+----------------------------+-------------------+&#xA;| 1  | Switching to Zig from Rust | I love C          |&#xA;| 2  | RAG in SQLite              | AI first database |&#xA;+----+----------------------------+-------------------+&#xA;sqlite&gt; INSERT INTO posts(title, content) VALUES (&#39;Rewriting SQLite&#39;, &#39;We are no more a sqlite-fork&#39;);&#xA;INSERT INTO posts(title, content) VALUES (&#39;Offline Writes in SQLite&#39;, &#39;Lets sync&#39;);&#xA;SELECT * FROM posts;&#xA;+----+----------------------------+------------------------------+&#xA;| id |           title            |           content            |&#xA;+----+----------------------------+------------------------------+&#xA;| 1  | Switching to Zig from Rust | I love C                     |&#xA;| 2  | RAG in SQLite              | AI first database            |&#xA;| 3  | Rewriting SQLite           | We are no more a sqlite-fork |&#xA;| 4  | Offline Writes in SQLite   | Lets sync                    |&#xA;+----+----------------------------+------------------------------+&#xA;sqlite&gt; INSERT INTO author_post(user_id, post_id) VALUES (1, 3), (1, 4);&#xA;sqlite&gt; INSERT INTO author_post(user_id, post_id) VALUES (3, 1), (3, 2);&#xA;sqlite&gt; INSERT INTO posts(title, content) VALUES(&#39;Limbo&#39;, &#39;SQLite in Rust&#39;);&#xA;sqlite&gt; INSERT INTO author_post(user_id, post_id) VALUES (3, 5);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (1, 5);&#xA;sqlite&gt; SELECT&#xA;    p.id,&#xA;    p.content AS post,&#xA;    GROUP_CONCAT(u.name, &#39;, &#39;) AS authors&#xA;FROM posts p&#xA;JOIN author_post up ON p.id = up.post_id&#xA;JOIN users u ON u.id = up.user_id&#xA;GROUP BY p.id;&#xA;+----+------------------------------+----------------+&#xA;| id |             post             |    authors     |&#xA;+----+------------------------------+----------------+&#xA;| 1  | I love C                     | Pekka          |&#xA;| 2  | AI first database            | Pekka          |&#xA;| 3  | We are no more a sqlite-fork | Glauber        |&#xA;| 4  | Lets sync                    | Glauber        |&#xA;| 5  | SQLite in Rust               | Pekka, Glauber |&#xA;+----+------------------------------+----------------+&#xA;sqlite&gt; SELECT * FROM author_post;&#xA;+---------+---------+&#xA;| user_id | post_id |&#xA;+---------+---------+&#xA;| 1       | 3       |&#xA;| 1       | 4       |&#xA;| 3       | 1       |&#xA;| 3       | 2       |&#xA;| 3       | 5       |&#xA;| 1       | 5       |&#xA;+---------+---------+&#xA;&#xA;sqlite&gt; SELECT rowid, * FROM author_post;&#xA;+-------+---------+---------+&#xA;| rowid | user_id | post_id |&#xA;+-------+---------+---------+&#xA;| 1     | 1       | 3       |&#xA;| 2     | 1       | 4       |&#xA;| 3     | 3       | 1       |&#xA;| 4     | 3       | 2       |&#xA;| 5     | 3       | 5       |&#xA;| 6     | 1       | 5       |&#xA;+-------+---------+---------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;The interesting part here is this `rowid`&#xA;&#xA;```sql&#xA;SELECT rowid, * FROM author_post;&#xA;```&#xA;&#xA;This table `author_post` has primary key identified from the combination of the `user_id` and `post_id` column. However, storing `rowid` makes no sense, as it is just redundant, right?&#xA;&#xA;Why would you not want to have the `rowid`?&#xA;&#xA;The answer is very naive and subtle, but might impact the database querying if the `author_post` has millions and billions of rows. The rowid space will be wasted for no reason.&#xA;&#xA;Hence, we can avoid creating the rowid using the `WITHOUT ROWID` parameter or option while creating the table.&#xA;&#xA;```sql&#xA;DROP TABLE author_post;&#xA;&#xA;CREATE TABLE author_post (&#xA;    user_id INTEGER NOT NULL,&#xA;    post_id INTEGER NOT NULL,&#xA;    PRIMARY KEY (user_id, post_id),&#xA;    FOREIGN KEY (user_id) REFERENCES users (id),&#xA;    FOREIGN KEY (post_id) REFERENCES posts (id)&#xA;) WITHOUT ROWID;&#xA;```&#xA;&#xA;The rest of the commands from inserts to selection and all of the things we saw above will remain the same.&#xA;&#xA;```sql&#xA;-- adding authors/users&#xA;INSERT INTO users(name) VALUES (&#39;Glauber&#39;), (&#39;Jamie&#39;), (&#39;Pekka&#39;);&#xA;&#xA;-- adding posts written by pekka&#xA;INSERT INTO posts(title, content) VALUES (&#39;Switching to Zig from Rust&#39;, &#39;I love C&#39;);&#xA;INSERT INTO posts(title, content) VALUES (&#39;RAG in SQLite&#39;, &#39;AI first database&#39;);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (3, 1), (3, 2);&#xA;&#xA;-- adding posts written by glauber&#xA;INSERT INTO posts(title, content) VALUES (&#39;Rewriting SQLite&#39;, &#39;We are no more a sqlite-fork&#39;);&#xA;INSERT INTO posts(title, content) VALUES (&#39;Offline Writes in SQLite&#39;, &#39;Lets sync&#39;);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (1, 3), (1, 4);&#xA;&#xA;-- adding a post co-authored by pekka and glauber&#xA;INSERT INTO posts(title, content) VALUES(&#39;Limbo&#39;, &#39;SQLite in Rust&#39;);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (3, 5);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (1, 5);&#xA;```&#xA;&#xA;However, when you query the `author_post` table, the `rowid` will not be returned as it doesn&#39;t exists.&#xA;&#xA;```sql&#xA;SELECT * FROM author_post;&#xA;```&#xA;&#xA;```sql&#xA;SELECT rowid, * FROM author_post;&#xA;```&#xA;This would return error as the `rowid` doesn&#39;t exists.&#xA;&#xA;We will still need the `rowid` in `posts` and `users` table as those are the `PRIMARY KEY` columns.&#xA;&#xA;Both the tables `users` and `posts` will have `rowid` referenced or aliased as id of their respective columns as we know because of the special case of `INTEGER PRIMARY KEY`&#xA;&#xA;```sql&#xA;SELECT rowid, _rowid_, * FROM users;&#xA;```&#xA;&#xA;```sql&#xA;SELECT rowid, _rowid_, * FROM posts;&#xA;```&#xA;&#xA;Only in the case of `author_post` or any junction table, where the primary key is referenced as a combination of other two foreign keys, we don&#39;t need the `rowid` as the junction table doesn&#39;t have any unique data in it, it is just the mapping of two existing data points/records in the other two tables in the database.&#xA;&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: One to One Relations</title>
      <link>https://meetgor.com/sqlite-one-to-one-relations</link>
      <description></description>
      <pubDate>Fri, 19 Sep 2025 00:00:00 UTC</pubDate>
      <content>## One to One Relations&#xA;&#xA;I might missed this basic relationship model as I haven&#39;t really found it quite commonly used, but its still used in very specific examples.&#xA;&#xA;That one relationship is `one-to-one`. As the name suggests, it maps one row to exactly one row.&#xA;&#xA;Unlike the `one-to-many` relation which had one of the records/rows from the tables or entities connected by multiple ropes, both the records/rows from the tables or entities are connected by only one rope in `one-to-one` relation.&#xA;&#xA;Where do you think this could be used?&#xA;&#xA;Since it can&#39;t be applied to a user and a posts relation model, as that will be a too rigid constrained relationship. One user can only author one post, and one post can only be authored by one user.&#xA;&#xA;So, can you think of a relation where one record or row is tied to exactly one other record or row in the other table?&#xA;&#xA;Well, it could be user and his unique card, passport or even his subscriptions.&#xA;&#xA;1. One user can only have one passport (or any other identity document).&#xA;2. One user can only have one credit card (for a specific bank)&#xA;3. One user can only have one subscription (to a specific service)&#xA;&#xA;In those cases, I think the `one-to-one` relation serves well and is maybe the only way to get over the constraint.&#xA;&#xA;You can definitely restrict the `one-to-many` relation to get this done, but might be a little wired. Will check that in other post.&#xA;&#xA;## Creating a One to One Relation&#xA;&#xA;How do we define a one to one relation, if we add a foreign key to the table that can refer multiple entities, so maybe if that foreign key is the primary key?&#xA;&#xA;Ok, let me explain more clearly.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    email TEXT NOT NULL,&#xA;    password TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE news_subscriptions (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL,&#xA;    price INTEGER NOT NULL,&#xA;    status TEXT NOT NULL,&#xA;    expiry_date TEXT NOT NULL,&#xA;    user_id INTEGER NOT NULL,&#xA;    FOREIGN KEY (user_id) REFERENCES users(id)&#xA;);&#xA;```&#xA;&#xA;In the above example, we have a `users` table and `news_subscriptions` table, where `news_subscriptions` table is a one to one relation to `users` table.&#xA;&#xA;Here, the `user_id` is a foreign key in `news_subscriptions` table that can refer to the `id` of the `users` table.&#xA;&#xA;This as you know is a `one-to-many` relation, as one user can have multiple news subscriptions.&#xA;&#xA;Becuase here, one user can create multiple subscriptions, we don&#39;t want that right?&#xA;&#xA;How can we restrict the many subscriptions to one user?&#xA;&#xA;What if the `PRIMARY KEY` of the `subscriptions` table was the same as the `users` table?&#xA;&#xA;That will restrict it to add any duplicate subscription for the same user.&#xA;&#xA;Solved!&#xA;&#xA;```sql&#xA;DROP TABLE IF EXISTS users;&#xA;DROP TABLE IF EXISTS news_subscriptions;&#xA;&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    email TEXT NOT NULL,&#xA;    password TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE news_subscriptions (&#xA;    user_id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL,&#xA;    price INTEGER NOT NULL,&#xA;    status TEXT NOT NULL,&#xA;    expiry_date TEXT NOT NULL,&#xA;    FOREIGN KEY (user_id) REFERENCES users(id)&#xA;);&#xA;```&#xA;&#xA;Here, instead of a separate `user_id` column, we have made the `user_id` the `PRIMARY KEY` of the `news_subscriptions` table.&#xA;&#xA;NOTE: OOPs! don&#39;t forget to turn on the `PRAGMA foreign_keys` option.&#xA;&#xA;&gt; PRAGMA foreign_keys = ON;&#xA;&#xA;This will tie the `news_subscriptions` table directly to an record/row that would require only one record/row in the `users` table.&#xA;&#xA;Let&#39;s try inserting a few users:&#xA;&#xA;```sql&#xA;INSERT INTO users(email, password) VALUES(&#39;harry&#39;, &#39;harry123&#39;),&#xA;(&#39;ron&#39;, &#39;ron123&#39;),&#xA;(&#39;malfoy&#39;, &#39;malfoy123&#39;);&#xA;```&#xA;&#xA;This will insert 3 records/rows in the `users` table.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;Now, let&#39;s try inserting a subscription:&#xA;&#xA;```sql&#xA;INSERT INTO news_subscriptions(user_id, name, price, status, expiry_date)&#xA;VALUES(1, &#39;Wizardry Weekly&#39;, 500, &#39;active&#39;, &#39;2025-12-31&#39;);&#xA;```&#xA;&#xA;This will insert 1 record/row in the `news_subscriptions` table. This is a subscription for the user with `id` as `1`.&#xA;&#xA;```sql&#xA;SELECT * FROM news_subscriptions;&#xA;```&#xA;&#xA;Let&#39;s get the user info too:&#xA;&#xA;```sql&#xA;SELECT &#xA;    u.id, u.email,&#xA;    n.*&#xA;FROM users u&#xA;JOIN news_subscriptions n&#xA;ON u.id = n.user_id;&#xA;```&#xA;&#xA;Now, if we try to insert another subscription for the same user:&#xA;&#xA;```sql&#xA;INSERT INTO news_subscriptions(user_id, name, price, status, expiry_date)&#xA;VALUES(1, &#39;Muggle Cup&#39;, 250, &#39;active&#39;, &#39;2025-12-31&#39;);&#xA;```&#xA;&#xA;This will throw an error, as we have already inserted a subscription for the user with `id` as `1`.&#xA;&#xA;Hence we successfully created a one to one relation between the `users` and `news_subscriptions` tables.&#xA;&#xA;&#xA;```&#xA;sqlite&gt;&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    email TEXT NOT NULL,&#xA;    password TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE news_subscriptions (&#xA;    user_id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL,&#xA;    price INTEGER NOT NULL,&#xA;    status TEXT NOT NULL,&#xA;    expiry_date TEXT NOT NULL,&#xA;    FOREIGN KEY (user_id) REFERENCES users(id)&#xA;);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; INSERT INTO users(email, password) VALUES(&#39;harry&#39;, &#39;harry123&#39;), (&#39;ron&#39;, &#39;ron123&#39;), (&#39;malfoy&#39;, &#39;malfoy123&#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+--------+-----------+&#xA;| id | email  | password  |&#xA;+----+--------+-----------+&#xA;| 1  | harry  | harry123  |&#xA;| 2  | ron    | ron123    |&#xA;| 3  | malfoy | malfoy123 |&#xA;+----+--------+-----------+&#xA;&#xA;sqlite&gt; INSERT INTO news_subscriptions(user_id, name, price, status, expiry_date) VALUES(1, &#39;Wizardry Weekly&#39;, 500, &#39;active&#39;, &#39;2025-12-31&#39;);&#xA;sqlite&gt; SELECT * FROM news_subscriptions;&#xA;+---------+-----------------+-------+--------+-------------+&#xA;| user_id |      name       | price | status | expiry_date |&#xA;+---------+-----------------+-------+--------+-------------+&#xA;| 1       | Wizardry Weekly | 500   | active | 2025-12-31  |&#xA;+---------+-----------------+-------+--------+-------------+&#xA;&#xA;sqlite&gt; INSERT INTO news_subscriptions(user_id, name, price, status, expiry_date) VALUES(1, &#39;Muggle Cup&#39;, 250, &#39;active&#39;, &#39;2025-12-31&#39;);&#xA;Runtime error: UNIQUE constraint failed: news_subscriptions.user_id (19)&#xA;sqlite&gt;&#xA;&#xA;sqlite&gt; SELECT&#xA;    u.id, u.email,&#xA;    n.*&#xA;FROM users u&#xA;JOIN news_subscriptions n&#xA;ON u.id = n.user_id;&#xA;+----+-------+---------+-----------------+-------+--------+-------------+&#xA;| id | email | user_id |      name       | price | status | expiry_date |&#xA;+----+-------+---------+-----------------+-------+--------+-------------+&#xA;| 1  | harry | 1       | Wizardry Weekly | 500   | active | 2025-12-31  |&#xA;+----+-------+---------+-----------------+-------+--------+-------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Dead simple, this is how we create `one-to-one` relation.&#xA;&#xA;We define the `primary key` of the child table as the `foreign key` of the parent table.&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Many to Many Relations</title>
      <link>https://meetgor.com/sqlite-many-to-many-relations</link>
      <description></description>
      <pubDate>Thu, 18 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Many to Many Relations&#xA;&#xA;We have seen [one-to-many](https://www.meetgor.com/sqlog/sqlite-one-to-many-foreign-key/) relationship and also the [self-join](https://www.meetgor.com/sqlog/sqlite-self-join-relations) relationship.&#xA;&#xA;Let&#39;s extend it with `many-to-many` relationship. Here one row can refer to many other rows, but that other row can also be referred by multiple rows.&#xA;&#xA;That was confusing, let&#39;s take the simple example of `users` and `posts` as usual.&#xA;&#xA;- In `One-To-Many` relation, one post can only be written by one user. However, one user can author multiple posts.&#xA;- In `Many-To-Many` relation, one user can author multiple posts and one post can be written by multiple users.&#xA;&#xA;That is the distinction, it is not about the relation, it is more about the design that your system needs.&#xA;&#xA;Let&#39;s start creating one simple example:&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    title TEXT NOT NULL,&#xA;    content TEXT NOT NULL&#xA;);&#xA;```&#xA;&#xA;We have created two tables, `users` and `posts` each representing their own data. However, we haven&#39;t referenced the users from the posts table, because that might not work out well.&#xA;&#xA;Why?&#xA;Well, there are few considerations in a `many-to-many` relationship.&#xA;&#xA;- In a `one-to-many` relation, we could simply add a `user_id` column in posts. That works because each post has exactly one author.&#xA;- But in a `many-to-many` relation, a single post can have multiple authors. If we put a `user_id` inside posts, we’d be forced to choose only one user, right?&#xA;&#xA;What if we tried multiple columns like `user_id_1`, `user_id_2` and so on?&#xA;You can see that won&#39;t work or rather create a lot of confusion and redundancy. What if a post has 4 authors? Or 6? Not practical but could be an exception.&#xA;&#xA;When we say, `many-to-many` we truly have to mean  `MANY` posts can be written by `ONE` author and `MANY` authors can write one `post`.&#xA;&#xA;This is where we need to create a separate table usually called as the junction or an association table. There are [other](https://en.wikipedia.org/wiki/Associative_entity) names too.&#xA;&#xA;For this we can create a table `author_post` (not the best of names but it&#39;s usually the table and it&#39;s relation as the name). This table will refer the `PRIMARY KEY`s of both the `users` and the `posts` table to map it to a single `post`, and the `PRIMARY KEY` of this table becomes the combinational pair of those two primary keys.&#xA;&#xA;```sql&#xA;CREATE TABLE author_post (&#xA;    user_id INTEGER NOT NULL,&#xA;    post_id INTEGER NOT NULL,&#xA;    PRIMARY KEY (user_id, post_id),&#xA;    FOREIGN KEY (user_id) REFERENCES users(id),&#xA;    FOREIGN KEY (post_id) REFERENCES posts(id)&#xA;);&#xA;```&#xA;&#xA;Here, the `user_id` and `post_id` are the `PRIMARY KEY`s of the `users` and the `posts` table respectively, however those are the `FOREIGN KEY`s for this `author_post` table. The `PRIMARY KEY` of the `author_post` table becomes, the combination of both `user_id` and `post_id` as `PRIMARY KEY(user_id, post_id)`.&#xA;&#xA;Let&#39;s take a example to make it clear as usual:&#xA;&#xA;Let&#39;s say `Pekka`(sir) is writing very technical details in a post and `Glauber` (sir) is writing the practical details in a post, both are important.They write individual posts, both of them have their audiences on the same blog. But, there is a topic they want to write together, how can they co-author a `posts` with the previous design of `one-to-many` relation?&#xA;&#xA;In the case of `one-to-many` relation, the `users` let&#39;s say `Pekka` with `id` as `3` and `Glauber` as `id` with `1`.  They wrote their own posts with id `98` and `99` respectively. Now, for the `100` th `post` they want to write it together. If we create a `posts` record with the `author_id` as `3`, then it will just refer the user with the id `3` which is `Pekka`, then the user with `id` as `1` can&#39;t be referred to the `posts` record.&#xA;&#xA;If we tried to create 2 posts with different `user_id` it might be redundant to create 2 posts, and those might lead to inconsistent number of post counts, since each post will have unique identifier.&#xA;&#xA;So, essentially, co-authoring in this `one-to-many` relationship, is not possible, we need to do something to make them write together.&#xA;&#xA;The `many-to-many` relation will help them write a `post` together.&#xA;&#xA;They both can write the `posts` record with just the `title` and `content`. Let&#39;s say the `post` was created with `id` as `100`&#xA;&#xA;Them, while publishing the `post`, they can provide the `user_id`s, so here, two records of `author_post` will be created, one with `user_id` as `3`and `post_id` as `100`, similarly another record will be created with `user_id` as `1` and `post_id` as `100`. Notice how we are duplicating the `post_id` (it is same, as `100`), but the `user_id` is different in each case. Hence the constraint is satisfied, the `user_id` and `post_id` the combination of those two is unique. Hence those two can write a `post` together now, the `100` th post is co-authored by `Pekka` and `Glauber`.&#xA;&#xA;And finally `Pekka` and `Glauber` decided to write a [post](https://turso.tech/blog/introducing-limbo-a-complete-rewrite-of-sqlite-in-rust)&#xA;&#xA;NOTE: This is just a made up example, I found it easier to relate and come up with a example of the similar blog post kind of table, so took that and wrote this, sorry if anyone got hurt.&#xA;&#xA;Let&#39;s look at actual queries:&#xA;&#xA;Create three users `Glauber`, `Jamie` and `Pekka`.&#xA;&#xA;```sql&#xA;INSERT INTO users(name) VALUES (&#39;Glauber&#39;), (&#39;Jamie&#39;), (&#39;Pekka&#39;);&#xA;```&#xA;These users are the authors with the ids `1`, `2` and `3` respectively.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;As we can see in this users table.&#xA;&#xA;Then, let&#39;s Pekka write the posts. He wrote 2 posts, one with the title `Switching to Zig from Rust` and the other with the title `RAG in SQLite`.&#xA;This is just for fun.&#xA;&#xA;```sql&#xA;INSERT INTO posts(title, content) VALUES (&#39;Switching to Zig from Rust&#39;, &#39;I love C&#39;);&#xA;INSERT INTO posts(title, content) VALUES (&#39;RAG in SQLite&#39;, &#39;AI first database&#39;);&#xA;SELECT * FROM posts;&#xA;```&#xA;Here, the `id` of the first post is `1` and the `id` of the second post is `2`. So, `Pekka` has authored posts with id `1` and `2` but that is not mapped yet.&#xA;&#xA;Let&#39;s map it in the `author_post` table, we know that the `PRIMARY KEY` for the `author_post` is a combination of `user_id` or `author_id` and the `post_id`, we know that `Pekka` has a `user_id` of `3` and he has written the `post` with `id`s `1` and `2`, so we&#39;ll simply insert those in to the `author_post` table as individual records.&#xA;&#xA;```sql&#xA;INSERT INTO author_post(user_id, post_id) VALUES (3, 1), (3, 2);&#xA;```&#xA;This will create two distinct records rightly so, for each posts.&#xA;&#xA;Then, Glauber decided to write a couple of posts. Let&#39;s say he wrote 2 posts, one with the title `Rewriting SQLite` and the other with the title `Offline Writes in SQLite`.&#xA;&#xA;```sql&#xA;INSERT INTO posts(title, content) VALUES (&#39;Rewriting SQLite&#39;, &#39;We are no more a sqlite-fork&#39;);&#xA;INSERT INTO posts(title, content) VALUES (&#39;Offline Writes in SQLite&#39;, &#39;Lets sync&#39;);&#xA;SELECT * FROM posts;&#xA;```&#xA;Here, the posts created by `Glauber` have ids `3` and `4`. Now, we need to map them in the `author_post` table.&#xA;&#xA;We know that `Glauber` has a `user_id` of `1` and he has written the `post` with `id`s `3` and `4`, so we&#39;ll simply insert those in to the `author_post` table as individual records.&#xA;&#xA;```sql&#xA;INSERT INTO author_post(user_id, post_id) VALUES (1, 3), (1, 4);&#xA;```&#xA;&#xA;So, this will create two distinct entries in the `author_post` table for the two posts created by `users` with `id` as `1`.&#xA;&#xA;Now, the question of how they co-author a post? That is a piece of cake.&#xA;&#xA;Let&#39;s say they wrote a post with the title `Limbo`.&#xA;&#xA;```sql&#xA;INSERT INTO posts(title, content) VALUES(&#39;Limbo&#39;, &#39;SQLite in Rust&#39;);&#xA;```&#xA;&#xA;Now, this will create a new post with `id` as `5`, let&#39;s map it in the `author_post` table&#xA;&#xA;```sql&#xA;INSERT INTO author_post(user_id, post_id) VALUES (3, 5);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (1, 5);&#xA;```&#xA;&#xA;Here, we create two records but the `post_id` value is the same, the `user_id` value changes for both the posts, one for `Glauber` and one for `Pekka` with ids 1 and 3 respectively.&#xA;&#xA;SQueaLicios!&#xA;&#xA;Now, you will say, isn&#39;t it still doing redundant insertions of two `author_post` records?&#xA;&#xA;Well ... yes ... but. &#xA;&#xA;Yes, that is true, it looks like we are doing redundant as we will create records in the `author_post` table (let&#39;s call it the junction table or the middle or connector table). But there is no redundant data, every row gives us unique insight into what it is actually storing. We aren&#39;t storing the original `posts` record twice or multiple twice, we are just `referencing` it with the `user_id` and the `post_id`&#xA;&#xA;Another question would be, how the heck do we query this `post` which is co-authored? Or that has multiple authors in it, easy peasy, sqly.&#xA;&#xA;Bear with some SQL shenanigans, some joins and wizardry.&#xA;&#xA;```sql&#xA;SELECT &#xA;    p.id,&#xA;    p.content AS post,&#xA;    GROUP_CONCAT(u.name, &#39;, &#39;) AS authors&#xA;FROM posts p&#xA;JOIN author_post up ON p.id = up.post_id&#xA;JOIN users u ON u.id = up.user_id&#xA;GROUP BY p.id&#xA;HAVING COUNT(u.id) &gt; 1;&#xA;```&#xA;Don&#39;t worry if you don&#39;t get this query as a whole, just understand three things.&#xA;- What are we querying? The post id, the post content, and the author names concatenated with `,`&#xA;- From where? The `posts`, `users` and the `author_post` table.&#xA;- How? Querying all the posts, joining the `posts` with the id in the `author_post` table, then also fetching the `name` of the `author` from the `users` name. We are grouping by post id in order to keep it per post, and not duplicate the posts in case of multiple authors, the last filtering is the `HAVING` that is done as a aggregate of the count of users in the `author_post` table having more than one author in the mapping.&#xA;&#xA;What about all the posts?&#xA;&#xA;We just remove the filter of `HAVING` clause to include all the posts, rather than only posts having more than 1 author.&#xA;&#xA;```sql&#xA;SELECT&#xA;    p.id,&#xA;    p.content AS post,&#xA;    GROUP_CONCAT(u.name, &#39;, &#39;) AS authors&#xA;FROM posts p&#xA;JOIN author_post up ON p.id = up.post_id&#xA;JOIN users u ON u.id = up.user_id&#xA;GROUP BY p.id;&#xA;```&#xA;&#xA;&#xA;The heavy SQLog:&#xA;&#xA;```sql&#xA;sqlite&gt; CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    title TEXT NOT NULL,&#xA;    content TEXT NOT NULL&#xA;);&#xA;sqlite&gt; CREATE TABLE author_post (&#xA;    user_id INTEGER NOT NULL,&#xA;    post_id INTEGER NOT NULL,&#xA;    PRIMARY KEY (user_id, post_id),&#xA;    FOREIGN KEY (user_id) REFERENCES users(id),&#xA;    FOREIGN KEY (post_id) REFERENCES posts(id)&#xA;);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; INSERT INTO users(name) VALUES (&#39;Glauber&#39;), (&#39;Jamie&#39;), (&#39;Pekka&#39;);&#xA;sqlite&gt; INSERT INTO posts(title, content) VALUES (&#39;Switching to Zig from Rust&#39;, &#39;I love C&#39;);&#xA;INSERT INTO posts(title, content) VALUES (&#39;RAG in SQLite&#39;, &#39;AI first database&#39;);&#xA;SELECT * FROM posts;&#xA;+----+----------------------------+-------------------+&#xA;| id |           title            |      content      |&#xA;+----+----------------------------+-------------------+&#xA;| 1  | Switching to Zig from Rust | I love C          |&#xA;| 2  | RAG in SQLite              | AI first database |&#xA;+----+----------------------------+-------------------+&#xA;sqlite&gt; INSERT INTO author_post(user_id, post_id) VALUES (3, 1), (3, 2);&#xA;sqlite&gt; INSERT INTO posts(title, content) VALUES (&#39;Rewriting SQLite&#39;, &#39;We are no more a sqlite-fork&#39;);&#xA;INSERT INTO posts(title, content) VALUES (&#39;Offline Writes in SQLite&#39;, &#39;Lets sync&#39;);&#xA;SELECT * FROM posts;&#xA;+----+----------------------------+------------------------------+&#xA;| id |           title            |           content            |&#xA;+----+----------------------------+------------------------------+&#xA;| 1  | Switching to Zig from Rust | I love C                     |&#xA;| 2  | RAG in SQLite              | AI first database            |&#xA;| 3  | Rewriting SQLite           | We are no more a sqlite-fork |&#xA;| 4  | Offline Writes in SQLite   | Lets sync                    |&#xA;+----+----------------------------+------------------------------+&#xA;sqlite&gt; INSERT INTO author_post(user_id, post_id) VALUES (1, 3), (1, 4);&#xA;sqlite&gt; INSERT INTO posts(title, content) VALUES(&#39;Limbo&#39;, &#39;SQLite in Rust&#39;);&#xA;sqlite&gt; INSERT INTO author_post(user_id, post_id) VALUES (3, 5);&#xA;INSERT INTO author_post(user_id, post_id) VALUES (1, 5);&#xA;sqlite&gt; SELECT&#xA;    p.id,&#xA;    p.content AS post,&#xA;    GROUP_CONCAT(u.name, &#39;, &#39;) AS authors&#xA;FROM posts p&#xA;JOIN author_post up ON p.id = up.post_id&#xA;JOIN users u ON u.id = up.user_id&#xA;GROUP BY p.id&#xA;HAVING COUNT(u.id) &gt; 1;&#xA;+----+----------------+----------------+&#xA;| id |      post      |    authors     |&#xA;+----+----------------+----------------+&#xA;| 5  | SQLite in Rust | Pekka, Glauber |&#xA;+----+----------------+----------------+&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+----------------------------+------------------------------+&#xA;| id |           title            |           content            |&#xA;+----+----------------------------+------------------------------+&#xA;| 1  | Switching to Zig from Rust | I love C                     |&#xA;| 2  | RAG in SQLite              | AI first database            |&#xA;| 3  | Rewriting SQLite           | We are no more a sqlite-fork |&#xA;| 4  | Offline Writes in SQLite   | Lets sync                    |&#xA;| 5  | Limbo                      | SQLite in Rust               |&#xA;+----+----------------------------+------------------------------+&#xA;sqlite&gt; SELECT&#xA;    p.id,&#xA;    p.content AS post,&#xA;    GROUP_CONCAT(u.name, &#39;, &#39;) AS authors&#xA;FROM posts p&#xA;JOIN author_post up ON p.id = up.post_id&#xA;JOIN users u ON u.id = up.user_id&#xA;GROUP BY p.id;&#xA;+----+------------------------------+----------------+&#xA;| id |             post             |    authors     |&#xA;+----+------------------------------+----------------+&#xA;| 1  | I love C                     | Pekka          |&#xA;| 2  | AI first database            | Pekka          |&#xA;| 3  | We are no more a sqlite-fork | Glauber        |&#xA;| 4  | Lets sync                    | Glauber        |&#xA;| 5  | SQLite in Rust               | Pekka, Glauber |&#xA;+----+------------------------------+----------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;That’s the basic idea of a many-to-many relation in SQLite, instead of stuffing multiple IDs into one table, we create a separate mapping table. Each row in that table ties one user to one post. If multiple users are tied to the same post, we just add more mapping rows.&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Self Join Relations</title>
      <link>https://meetgor.com/sqlite-self-join-relations</link>
      <description></description>
      <pubDate>Wed, 17 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Self Join Relations&#xA;&#xA;In the last post, we had defined a `one-to-many` relation between the `users` table and the `posts` table.&#xA;&#xA;Now, let&#39;s create a single table where we can define a `one-to-many` relationship. Yes, within a single table we can reference the primary key and it can act like a link. Since it isn&#39;t really about the table, it&#39;s more about the row relation form each other, we an connect any rows.&#xA;&#xA;Let&#39;s take a example of `comments`.&#xA;&#xA;```sql&#xA;CREATE TABLE comments (&#xA;    id INTEGER PRIMARY KEY,&#xA;    author TEXT NOT NULL,&#xA;    content TEXT NOT NULL,&#xA;    parent_id REFERENCES comments (id)&#xA;);&#xA;```&#xA;Here, we have created a table `comments`, it has a simple `id` as a `INTEGER PRIMARY KEY` (we know what that means right? check out 2 articles back to find out.). There are `author` and `content` columns that just hold some data, it could be any thing that actually stores the data. The final column is vital as it makes the `comments` table usable.&#xA;&#xA;We have defined `parent_id` as a `REFERENCES comments (id)`, this is the key to the `self-join` relationship. It will refer any other comment with its id.&#xA;&#xA;So, let&#39;s say, you have created a first comment `A`, here we don&#39;t have any previous comment, so that can be NULL. However, if someone comments `B` on my comment, then the parent_id will be of `A`. &#xA;&#xA;```sql&#xA;INSERT INTO comments (id, author, content, parent_id)&#xA;VALUES (1, &#39;Harry Potter&#39;, &#39;I think Snape is hiding something.&#39;, NULL);&#xA;&#xA;INSERT INTO comments (id, author, content, parent_id)&#xA;VALUES (2, &#39;Ron Weasley&#39;, &#39;What exactly? &#39;, 1);&#xA;&#xA;INSERT INTO comments (id, author, content, parent_id)&#xA;VALUES (3, &#39;Draco Malfoy&#39;, &#39;Potter, you just want attention.&#39;, 1);&#xA;&#xA;INSERT INTO comments (id, author, content, parent_id)&#xA;VALUES (4, &#39;Harry Potter&#39;, &#39;Attention is all you need&#39;, 3);&#xA;&#xA;INSERT INTO comments (id, author, content, parent_id)&#xA;VALUES (5, &#39;Ron Weasley&#39;, &#39;Calm down guys&#39;, 3);&#xA;```&#xA;&#xA;Ok, we have inserted a lot at once, let&#39;s break it down&#xA;&#xA;- Harry adds the first comment `I think Snape is hiding something.` (parent_id will be NULL, as that is the first comment)&#xA;- Ron replies to the first comment `What exactly?` (parent_id will be 1, as that is the id of the first comment)&#xA;- Draco replies to the first comment `Potter, you just want attention.` (parent_id will be 1, as that is the id of the first comment)&#xA;- Harry replies to Draco&#39;s comment `Attention is all you need` (parent_id will be 3, as that is the id of Draco&#39;s comment)&#xA;- Ron replies to Draco&#39;s comment `Calm down guys` (parent_id will be 3, as that is the id of Draco&#39;s comment)&#xA;&#xA;This is really cool, as it makes use of the same id or primary key of the table, referencing some other row.&#xA;&#xA;Let&#39;s query the data and help you understand better.&#xA;&#xA;To get the first comment (base comment), we can use the following query&#xA;&#xA;```sql&#xA;SELECT id, author, content FROM comments WHERE parent_id IS NULL;&#xA;```&#xA;&#xA;To get the replies for a given comment id, we can use the following query&#xA;&#xA;```sql&#xA;SELECT id, content, parent_id FROM comments WHERE parent_id = 1;&#xA;```&#xA;&#xA;To get all the comments for a given author, we can use the following query:&#xA;&#xA;```sql&#xA;SELECT id, author, content FROM comments WHERE author = &#39;Harry Potter&#39;;&#xA;```&#xA;&#xA;Here&#39;s a SQLog:&#xA;&#xA;```sqlite&#xA;sqlite&gt; CREATE TABLE comments (&#xA;    id INTEGER PRIMARY KEY,&#xA;    author TEXT NOT NULL,&#xA;    content TEXT NOT NULL,&#xA;    parent_id REFERENCES comments (id)&#xA;);&#xA;sqlite&gt; .mode table&#xA;&#xA;sqlite&gt; INSERT INTO comments (id, author, content, parent_id)&#xA;VALUES (1, &#39;Harry Potter&#39;, &#39;I think Snape is hiding something.&#39;, NULL),&#xA;(2, &#39;Ron Weasley&#39;, &#39;What exactly? &#39;, 1),&#xA;(3, &#39;Draco Malfoy&#39;, &#39;Potter, you just want attention.&#39;, 1),&#xA;(4, &#39;Harry Potter&#39;, &#39;Attention is all you need&#39;, 3),&#xA;(5, &#39;Ron Weasley&#39;, &#39;Calm down guys&#39;, 3);&#xA;&#xA;sqlite&gt; SELECT * FROM comments;&#xA;+----+--------------+------------------------------------+-----------+&#xA;| id |    author    |              content               | parent_id |&#xA;+----+--------------+------------------------------------+-----------+&#xA;| 1  | Harry Potter | I think Snape is hiding something. |           |&#xA;| 2  | Ron Weasley  | What exactly?                      | 1         |&#xA;| 3  | Draco Malfoy | Potter, you just want attention.   | 1         |&#xA;| 4  | Harry Potter | Attention is all you need          | 3         |&#xA;| 5  | Ron Weasley  | Calm down guys                     | 3         |&#xA;+----+--------------+------------------------------------+-----------+&#xA;&#xA;sqlite&gt; SELECT id, author, content FROM comments WHERE parent_id IS NULL;&#xA;+----+--------------+------------------------------------+&#xA;| id |    author    |              content               |&#xA;+----+--------------+------------------------------------+&#xA;| 1  | Harry Potter | I think Snape is hiding something. |&#xA;+----+--------------+------------------------------------+&#xA;&#xA;sqlite&gt; SELECT id, content, parent_id FROM comments WHERE author = &#39;Harry Potter&#39;;&#xA;+----+------------------------------------+-----------+&#xA;| id |              content               | parent_id |&#xA;+----+------------------------------------+-----------+&#xA;| 1  | I think Snape is hiding something. |           |&#xA;| 4  | Attention is all you need          | 3         |&#xA;+----+------------------------------------+-----------+&#xA;&#xA;sqlite&gt; SELECT id, content, parent_id FROM comments WHERE parent_id = 1;&#xA;+----+----------------------------------+-----------+&#xA;| id |             content              | parent_id |&#xA;+----+----------------------------------+-----------+&#xA;| 2  | What exactly?                    | 1         |&#xA;| 3  | Potter, you just want attention. | 1         |&#xA;+----+----------------------------------+-----------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;As you can see, we have created a `one-to-many` relation with the same single table.&#xA;&#xA;Here, one comment can have mulitple comments. This makes it a bit recursive but it is what it is.&#xA;&#xA;That&#39;s how certain systems are.&#xA;&#xA;Self referencing relations!&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: One to Many Relation with Foreign Key</title>
      <link>https://meetgor.com/sqlite-one-to-many-foreign-key</link>
      <description></description>
      <pubDate>Tue, 16 Sep 2025 00:00:00 UTC</pubDate>
      <content>## One to Many Relation with Foreign Key&#xA;&#xA;Back to the question that we raised in the [previous](https://www.meetgor.com/sqlog/sqlite-foreign-key-table-constraint/) post, &#34;What would happen if there are more than one row in the primary table that references the same id in the foreign table?&#34;&#xA;&#xA;This is what is precisely called the `one-to-many` relation, or what the foreign key is used for.&#xA;&#xA;- One row in the foreign(parent/other) table&#xA;- that can be referenced by many rows in the primary(child) table&#xA;&#xA;So, taking the example from the previous post of author and posts,&#xA;&#xA;Let&#39;s define the schema again:&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id)&#xA;);&#xA;```&#xA;&#xA;the analogy can be stated as:&#xA;&#xA;- One author can have many posts&#xA;- One post can have only one author&#xA;&#xA;Right?&#xA;&#xA;If you look at the schema, the posts table is having the foreign key `author_id` that is referencing the primary key `id` of the `users` table. So the author can be referenced by multiple posts, however one post record can be refer only one author. I mean that is the design, a post can have multiple authors if we wanted to but we then would have to change the design then, we check that in the next post.&#xA;&#xA;Let&#39;s keep the `Foreign Key` pragma/setting constraint on throughout this post.&#xA;&#xA;```sql&#xA;PRAGMA foreign_keys=on;&#xA;```&#xA;&#xA;Let&#39;s insert a few users and posts to get what we mean by the `one-to-many` relation.&#xA;&#xA;```sql&#xA;INSERT INTO users(name) VALUES(&#39;harry&#39;), (&#39;ron&#39;), (&#39;malfoy&#39;);&#xA;```&#xA;We are inserting 3 users, `harry`, `ron`, and `malfoy` which will have ids as `1`, `2`, `3` respectively.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;As you would see in the output, we have 3 users with ids `1`, `2`, and `3`.&#xA;&#xA;Now, let&#39;s insert a few posts.&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES&#xA;(&#39;hi, I am harry&#39;, 1),&#xA;(&#39;Expecto Patronum&#39;, 1),&#xA;(&#39;hi, I am ron&#39;, 2),&#xA;(&#39;hi, I am malfoy&#39;, 3);&#xA;```&#xA;&#xA;I am inserting the `2nd` post as `harry`&#39;s because it will confuse with the author_id and the `post.id`&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;As you would see in the output, we have 4 posts with ids `1`, `2`, `3`, `4` the first 2 are of `harry`, then the next ron and malfoy respectively.&#xA;&#xA;Below are some neat little queries to visualize it better.&#xA;&#xA;```sql&#xA;SELECT * FROM posts JOIN users ON posts.author_id = users.id;&#xA;```&#xA;&#xA;```sql&#xA;SELECT posts.*, users.name AS author FROM posts JOIN users ON posts.author_id = users.id;&#xA;```&#xA;&#xA;This is the sqlog for the things that we did so far.&#xA;&#xA;```sqlite&#xA;sqlite&gt; CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id)&#xA;);&#xA;sqlite&gt; PRAGMA foreign_keys=on;&#xA;sqlite&gt; INSERT INTO users(name) VALUES(&#39;harry&#39;), (&#39;ron&#39;), (&#39;malfoy&#39;);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+--------+&#xA;| id |  name  |&#xA;+----+--------+&#xA;| 1  | harry  |&#xA;| 2  | ron    |&#xA;| 3  | malfoy |&#xA;+----+--------+&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES&#xA;(&#39;hi, I am harry&#39;, 1),&#xA;(&#39;Expecto Patronum&#39;, 1),&#xA;(&#39;hi, I am ron&#39;, 2),&#xA;(&#39;hi, I am malfoy&#39;, 3);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+------------------+-----------+&#xA;| id |     content      | author_id |&#xA;+----+------------------+-----------+&#xA;| 1  | hi, I am harry   | 1         |&#xA;| 2  | Expecto Patronum | 1         |&#xA;| 3  | hi, I am ron     | 2         |&#xA;| 4  | hi, I am malfoy  | 3         |&#xA;+----+------------------+-----------+&#xA;sqlite&gt; SELECT * FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+------------------+-----------+----+--------+&#xA;| id |     content      | author_id | id |  name  |&#xA;+----+------------------+-----------+----+--------+&#xA;| 1  | hi, I am harry   | 1         | 1  | harry  |&#xA;| 2  | Expecto Patronum | 1         | 1  | harry  |&#xA;| 3  | hi, I am ron     | 2         | 2  | ron    |&#xA;| 4  | hi, I am malfoy  | 3         | 3  | malfoy |&#xA;+----+------------------+-----------+----+--------+&#xA;sqlite&gt; SELECT posts.*, users.name AS author_name FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+------------------+-----------+-------------+&#xA;| id |     content      | author_id | author_name |&#xA;+----+------------------+-----------+-------------+&#xA;| 1  | hi, I am harry   | 1         | harry       |&#xA;| 2  | Expecto Patronum | 1         | harry       |&#xA;| 3  | hi, I am ron     | 2         | ron         |&#xA;| 4  | hi, I am malfoy  | 3         | malfoy      |&#xA;+----+------------------+-----------+-------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Now, let&#39;s explore this:&#xA;&#xA;- Harry has 2 posts, which means one user can author multiple post by design.&#xA;- One post can be always be author by only one user.&#xA;&#xA;Let&#39;s assume all the `NULL` values are not allowed for now, we can see one post can only be by one author, that is a constraint of the `FOREIGN KEY`, as we are referencing only one foreign key in the posts table.&#xA;&#xA;This is what we call `one-author-many-posts` or `one-to-many` relation. You can also call it `many-to-one` but then you have to change it to `many-posts-one-author` that sounds a little wired. Its basically the same thing but from the different perspective, I prefer saying `one-to-many` since most of the times, the foreign/parent table needs to exist first inorder for the parent/primary table to reference any key from it.&#xA;&#xA;One is on the side of the parent table (foreign table) and the Many is usually on the primary or the place where the `foreign key` is placed (in this case it is placed in the posts table).&#xA;&#xA;&#xA;What about multiple foreign keys?&#xA;&#xA;Yes, you can have multiple foreign keys, but those will be different keys, you can&#39;t have `author_id_1`, `author_id_2` and then refer the same foreign key as `users.id`, that is possible. However, we need to define separate table for mapping users and posts and that will be called as `many-to-many` relations as will check in the next post.&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Foreign KEY table constraint</title>
      <link>https://meetgor.com/sqlite-foreign-key-table-constraint</link>
      <description></description>
      <pubDate>Mon, 15 Sep 2025 00:00:00 UTC</pubDate>
      <content>## The Foreign KEY Table constraint&#xA;&#xA;Foreign Keys are the fundamentals of any relational databases, as they are the ones that make the connection or the relations among the tables in our database system.&#xA;&#xA;&gt; Foreign key as the name suggest, this is a key referencing or pointing to a foreign (other) table, and that key could be a primary key for that table, hence referred to as key.&#xA;&#xA;So, with a foreign key we can connect the data/records/row from other table to the table in which the foreign key is linked.&#xA;&#xA;Think of it like a string(rope) attaching one record to the other. It is a link between two tables.&#xA;&#xA;Now, how we define the `FOREIGN KEY` constraint is what the rope will be tied to and how.&#xA;&#xA;Let&#39;s take a look at how the syntax of defining a `FOREIGN KEY` constraint looks like in SQLite.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id)&#xA;);&#xA;```&#xA;&#xA;You will need atleast two tables in order to map a foreign key constraint. In the above example, we have created a table `users` that will form the base table, and the table `posts` is what is linking the `id` from the `users` table to itself. &#xA;&#xA;This means one post can link to one user, we are using that reference in the current `posts` table with the alias of `author_id`. This way the `author_id` is the rope (string whatever you prefer saying, I think developers get confused when I say string) that connects a record in the post table to the record in the users table.&#xA;&#xA;We can conclude a few things from this:&#xA;- We need to define what that `author_id` is for, for each record we insert into the `posts` table.&#xA;- If we don&#39;t define the `author_id` then will it be automatically populated? Nope!&#xA;- The `FOREIGN KEY` at its core is just like any other column, its just that how we set that column is what is important for the linking part.&#xA;- It depends on how the actual key i.e. the column in the foreign key is defined in the foreign table.&#xA;&#xA;Might still not make sense, let me explain with a few example.&#xA;&#xA;Let&#39;s insert a bunch of users.&#xA;&#xA;```sql&#xA;INSERT INTO users(name) VALUES(&#39;harry&#39;), (&#39;ron&#39;), (&#39;malfoy&#39;);&#xA;```&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;This has 3 records each assigned ids from 1 to 3.&#xA;&#xA;Now, let&#39;s insert a bunch of posts.&#xA;&#xA;```sql&#xA;INSERT INTO posts(content) VALUES (&#39;hi, I am who?&#39;);&#xA;```&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;That `author_id` is `NULL` because we didn&#39;t inserted anythign against it.&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL&#xA;);&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id)&#xA;);&#xA;sqlite&gt; INSERT INTO users(name) VALUES(&#39;harry&#39;), (&#39;ron&#39;), (&#39;malfoy&#39;);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+--------+&#xA;| id |  name  |&#xA;+----+--------+&#xA;| 1  | harry  |&#xA;| 2  | ron    |&#xA;| 3  | malfoy |&#xA;+----+--------+&#xA;sqlite&gt; INSERT INTO posts(content) VALUES (&#39;hi, I am who?&#39;);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+---------------+-----------+&#xA;| id |    content    | author_id |&#xA;+----+---------------+-----------+&#xA;| 1  | hi, I am who? |           |&#xA;+----+---------------+-----------+&#xA;sqlite&gt; INSERT INTO users(name, id) VALUES(&#39;neville&#39;, NULL);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+---------------+-----------+&#xA;| id |    content    | author_id |&#xA;+----+---------------+-----------+&#xA;| 1  | hi, I am who? |           |&#xA;+----+---------------+-----------+&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+---------+&#xA;| id |  name   |&#xA;+----+---------+&#xA;| 1  | harry   |&#xA;| 2  | ron     |&#xA;| 3  | malfoy  |&#xA;| 4  | neville |&#xA;+----+---------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;We need to be careful while inserting anything in that `author_id` column, becuase think for a moment:&#xA;What do we insert in the `author_id` column?&#xA;&#xA;Well, we need to have a valid `users(id)` right, that is the id in the users table, that is what we are referencing by that `FOREIGN KEY` constraint.&#xA;&#xA;There are other questions that should arise now, like:&#xA;&#xA;- What happens if we link something that doesn&#39;t exist in the foreign table? (in this case the `users` table)&#xA;- What happens if we what we have linked is deleted or changed in the foreign table?&#xA;- What happend if multiple rows refer the same id in the foreign table?&#xA;&#xA;The `FOREIGN KEY` constraint will make sure we are linking the valid id and hence if we try to insert any invalid (non-existent) id of the foreign table (here the `users` table) we will fail this constraint and hence the record/row won&#39;t be inserted or updated.&#xA;&#xA;As I said, this is a rope, the one end of the rope is always the current table record and the other one is what you attach it when inserting or updating a record.&#xA;&#xA;So, for starters, we&#39;ll insert the users with the id that exist in the first place.&#xA;&#xA;In our case, we have 4 authors created with the id from 1 to 4 and names as `harry`, `ron`, `malfoy` and `neville` respectively.&#xA;&#xA;Now, let&#39;s insert a post with the `author_id` as 1, that is the id of the user with the name `harry` which will be the author of the post.&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;```&#xA;&#xA;This will set the `author_id` column of the `posts` table to 1, which is the id of the `harry` user.&#xA;&#xA;If you want to see some better results, just run some of these to get it clear:&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;Get both tables data:&#xA;&#xA;```sql&#xA;SELECT * FROM posts JOIN users ON author_id = id;&#xA;```&#xA;&#xA;Make column names clear and remove redundant columns:&#xA;&#xA;```sql&#xA;SELECT posts.*, users.name FROM posts JOIN users ON posts.author_id = users.id;&#xA;```&#xA;&#xA;&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+----------------+-----------+&#xA;| id |    content     | author_id |&#xA;+----+----------------+-----------+&#xA;| 1  | hi, I am who?  |           |&#xA;| 2  | hi, I am harry | 1         |&#xA;+----+----------------+-----------+&#xA;sqlite&gt; SELECT * FROM posts JOIN users ON author_id = id;&#xA;Parse error: ambiguous column name: id&#xA;sqlite&gt; SELECT * FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+----------------+-----------+----+-------+&#xA;| id |    content     | author_id | id | name  |&#xA;+----+----------------+-----------+----+-------+&#xA;| 2  | hi, I am harry | 1         | 1  | harry |&#xA;+----+----------------+-----------+----+-------+&#xA;sqlite&gt; SELECT posts.*, users.name FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+----------------+-----------+-------+&#xA;| id |    content     | author_id | name  |&#xA;+----+----------------+-----------+-------+&#xA;| 2  | hi, I am harry | 1         | harry |&#xA;+----+----------------+-----------+-------+&#xA;sqlite&gt; SELECT posts.*, users.name AS author FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+----------------+-----------+--------+&#xA;| id |    content     | author_id | author |&#xA;+----+----------------+-----------+--------+&#xA;| 2  | hi, I am harry | 1         | harry  |&#xA;+----+----------------+-----------+--------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Now, try inserting a post with the `author_id` which doesn&#39;t exist in the `users` table i.e. the id of the users above 4.&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am hermoine&#39;, 5);&#xA;```&#xA;&#xA;That inserted successfully? How can that be allowed? The user with id `5` doesn&#39;t exist and we are referencing the author (users) that doesn&#39;t exist.&#xA;&#xA;## Pragma Foreign keys&#xA;&#xA;Well, we have been lied to all along, the SQLite is so flexible by default, you need to nudge it inorder to be a little strict:&#xA;&#xA;We need to enable the foreign key constraint checking by setting the `PRAGMA foreign_keys=on;`&#xA;&#xA;```&#xA;PRAGMA foreign_keys=on;&#xA;```&#xA;This setting is off by default due to backward compatibility reasons.&#xA;&#xA;You can check if the foreign key constraint checking is enabled by running the following command:&#xA;&#xA;```&#xA;PRAGMA foreign_keys;&#xA;```&#xA;&#xA;If it returns `1` then its enabled, or `0` if not.&#xA;&#xA;Now, now if we run the query where the author id is `5` which means the `user` referenced by that id doesn&#39;t exist, we will get the following error:&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am hermoine&#39;, 5);&#xA;```&#xA;&#xA;&gt; Runtime error: FOREIGN KEY constraint failed&#xA;&#xA;Exactly as we expected.&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am hermoine&#39;, 5);&#xA;sqlite&gt; SELECT posts.*, users.name AS author FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+----------------+-----------+--------+&#xA;| id |    content     | author_id | author |&#xA;+----+----------------+-----------+--------+&#xA;| 2  | hi, I am harry | 1         | harry  |&#xA;+----+----------------+-----------+--------+&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+-------------------+-----------+&#xA;| id |      content      | author_id |&#xA;+----+-------------------+-----------+&#xA;| 1  | hi, I am who?     |           |&#xA;| 2  | hi, I am harry    | 1         |&#xA;| 3  | hi, I am hermoine | 5         |&#xA;+----+-------------------+-----------+&#xA;sqlite&gt; PRAGMA foreign_keys=on&#xA;   ...&gt; ;&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am hermoine&#39;, 5);&#xA;Runtime error: FOREIGN KEY constraint failed (19)&#xA;sqlite&gt;&#xA;```&#xA;However if we insert the `posts` record with a valid `author_id` then:&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;```&#xA;This will readily insert the record, since the `author_id` of 2 exists in the `users` table.&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;Neat.&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+-------------------+-----------+&#xA;| id |      content      | author_id |&#xA;+----+-------------------+-----------+&#xA;| 1  | hi, I am who?     |           |&#xA;| 2  | hi, I am harry    | 1         |&#xA;| 3  | hi, I am hermoine | 5         |&#xA;| 4  | hi, I am ron      | 2         |&#xA;+----+-------------------+-----------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Now, back to those three questions:&#xA;&#xA;- What happens if we link something that doesn&#39;t exist in the foreign table? (in this case the `users` table)&#xA;- What happens if we what we have linked is deleted or changed in the foreign table?&#xA;- What happend if multiple rows refer the same id in the foreign table?&#xA;&#xA;&#xA;Let&#39;s tackle one by one &#xA;&#xA;&gt; NOTE: We&#39;ll assume PRAGMA foreign_keys=on; from here on&#xA;&#xA;## Invalid Foreign Key&#xA;&#xA;We already covered this in the previous discussion, if we link something that doesn&#39;t exist in the foreign table (in this case the `users` table) then we will fail the `FOREIGN KEY` constraint and hence the record/row won&#39;t be inserted or updated. But for this to fail we need to make sure the `PRAGMA foreign_keys` is on or toggled on.&#xA;&#xA;## Deleted or Updated Foreign Key&#xA;&#xA;What happens, if we inserted a record to the primary table (here the `posts` table) the `author_id` was existing and valid at the time of insertion, however after a while the `user` got deleted, what happens to the record that the `posts` record/row  that still references the deleted user id that is the `author_id` alias.&#xA;&#xA;&#xA;Enter `ON DELETE` and `ON UPDATE` clause on the `FOREIGN KEY` constraint.&#xA;&#xA;It turns out, we can define the behaviour of the `FOREIGN KEY` constraint when the referenced row is deleted or updated in the foreign table (here the `users` table).&#xA;&#xA;So, we need to define, what happens to the record/row in the primary table (here the `posts` table) when the referenced row in the foreign table (here the `users` table) is deleted or updated.&#xA;&#xA;There are 5 options to choose from:&#xA;1. `NO ACTION`: Do nothing (default)&#xA;2. `RESTRICT`: Stop the foreign key table from deleting the record/key in the foreign table&#xA;3. `SET NULL`: Set the primary table&#39;s record foreign key to `NULL`&#xA;4. `SET DEFAULT`: Set the primary table&#39;s record foreign key to the default value.&#xA;5. `CASCADE`: Delete the primary table&#39;s record/row if the referenced row in the foreign table is deleted.&#xA;&#xA;Phew! This opens a lot of options to play with:&#xA;&#xA;We already know the `NO ACTION`, it will just let it happen, nothing will be done. It&#39;s not recommended though, but SQLite is flexible, how many times I have to say it? Double edged sword.&#xA;&#xA;### Restrict&#xA;&#xA;Let&#39;s drop the `posts` table and start a fresh with the `ON DELETE` and `ON UPDATE` as `RESTRICT` option on the `FOREIGN KEY`  constraint.&#xA;&#xA;#### Restrict on delete&#xA;&#xA;We can restrict the deletion of the foreign records referred by the primary record. We use the `ON DELETE RESTRICT` as the option on the `FOREIGN KEY` constraint.&#xA;&#xA;```sql&#xA;DROP TABLE posts;&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id) ON DELETE RESTRICT&#xA;);&#xA;```&#xA;This will now restrict the deletion of the foreign records referred by the primary record. In this case, if a record/row in `users` table which is refereced in the `posts` table is deleted, it will prevent it, it won&#39;t be deleted. However, any other record in the `users` table can be deleted.&#xA;&#xA;Let&#39;s first insert a few rows into the `posts` table since we dropped it.&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;```&#xA;&#xA;These are valid records, since the `author_id` of 1 and 2 exist in the `users` table.&#xA;&#xA;However the following query will fail, since the `author_id` of 5 doesn&#39;t exist in the `users` table. We already know this:&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am hermoine&#39;, 5);&#xA;```&#xA;&#xA;Now, Let&#39;s look at all the `posts` and their authors&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;This is the list of `users` that we have:&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;Now, let&#39;s try deleting a record in the `users` table.&#xA;&#xA;We know that `users` with id `1` and `2` are referenced in the `posts` table.&#xA;&#xA;```sql&#xA;DELETE FROM users WHERE id = 2;&#xA;```&#xA;&#xA;This will fail, since we are trying to delete a record that is referenced in the `posts` table.&#xA;&#xA;We can check if the `users` with `id` 2 is still there:&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;It is indeed ther, it restricted the deletion.&#xA;&#xA;However if we delete the `users` where id is `3` which is not referenced in the `posts` table, it will succeed.&#xA;&#xA;```sql&#xA;DELETE FROM users WHERE id = 3;&#xA;```&#xA;This deleted the `users` with `id` 3.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;As you can see the dirt `malfoy` was deleted.&#xA;&#xA;```&#xA;sqlite&gt; DROP TABLE posts;&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id) ON DELETE RESTRICT&#xA;);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+----------------+-----------+&#xA;| id |    content     | author_id |&#xA;+----+----------------+-----------+&#xA;| 1  | hi, I am harry | 1         |&#xA;| 2  | hi, I am ron   | 2         |&#xA;+----+----------------+-----------+&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am hermoine&#39;, 5);&#xA;Runtime error: FOREIGN KEY constraint failed (19)&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+---------+&#xA;| id |  name   |&#xA;+----+---------+&#xA;| 1  | harry   |&#xA;| 2  | ron     |&#xA;| 3  | malfoy  |&#xA;| 4  | neville |&#xA;+----+---------+&#xA;sqlite&gt; DELETE FROM users where id = 2;&#xA;Runtime error: FOREIGN KEY constraint failed (19)&#xA;sqlite&gt; DELETE FROM users where id = 3;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+---------+&#xA;| id |  name   |&#xA;+----+---------+&#xA;| 1  | harry   |&#xA;| 2  | ron     |&#xA;| 4  | neville |&#xA;+----+---------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;What about updates?&#xA;&#xA;#### Restrict on update&#xA;&#xA;What if we update the users record will it restrict it, nope, unless we set `ON UPDATE` to `RESTRICT`:&#xA;&#xA;&gt; This option of `UPDATE ON` is usually not needed, as this is referring to the `UPDATE ON` the `FOREIGN KEY` and not on the entire foreign table columns, so only if you update the foreign key it will restrict or any action will be performed.&#xA;&#xA;Which means, if you update the `name` of the `users` table of a record which is referenced in the `posts` table, it will allow it, however when you update the `users` id (which doen&#39;t happen unless you&#39;ve skewed up or it&#39;s by design), it will prevent that updation. Note, updating foreign keys which are usually the primary keys of the foreign table is very rare, and not done usually, as it might corrupt the existing data.&#xA;&#xA;So, unless you have a great usecase for updating the foreign key of a table, `UPDATE ON` is never used.&#xA;&#xA;```sql&#xA;DROP TABLE posts;&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id) ON DELETE RESTRICT ON UPDATE RESTRICT&#xA;);&#xA;```&#xA;&#xA;Here, we are adding the `ON UPDATE RESTRICT` option on the `FOREIGN KEY` constraint, the `ON DELETE RESTRICT` option won&#39;t affect the update option, so it&#39;s only triggered when we try to delete the record (hard delete).&#xA;&#xA;Let&#39;s add few more rows as usual:&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;```&#xA;&#xA;Now, let&#39;s try updating the `users` table:&#xA;&#xA;```sql&#xA;UPDATE users SET name = &#39;harry potter&#39; WHERE id = 1;&#xA;```&#xA;&#xA;This is allowed, nothing got restricted, as we didn&#39;t update the `id` in the `users` table which is a foreign key in the `posts` table, unless we update the `id` of the `users` table, the `update` option will allow any updates of the columns in the foreign table (users table)&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;This readily updated the row with `id` 1 to `harry potter` as it didn&#39;t mutate/change/update the foreign key `id` in the `users` table which is referenced as `author_id` in the `posts` table.&#xA;&#xA;&#xA;However, if we try to update the `id` of the `users` table, it will fail.&#xA;&#xA;```sql&#xA;UPDATE users SET id = 3 WHERE id = 2;&#xA;```&#xA;&#xA;We are updating the id of the `users` table to 3 which is not the id of the `users` table referenced in the `posts` table, so it will fail. The existing row of id = 2 is `ron`, hence it already has a posts entry which makes it a reference, as we have added a constraint to restrict on updation of the id the foreign key.&#xA;&#xA;Now, let&#39;s try to update the `id` of the `users` table to the id of the `users` table not referenced in the `posts` table&#xA;&#xA;```sql&#xA;UPDATE users SET id = 5 WHERE id = 4;&#xA;```&#xA;&#xA;The row with id = 4 in the `users` table is `neville` which doesn&#39;t have any posts entry, so it will succeed.&#xA;This will succeed, as we are updating the `id` of the `users` table to the id of the `users` table not referenced in the `posts` table&#xA;&#xA;&#xA;```&#xA;sqlite&gt; DROP TABLE posts;&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id) ON DELETE RESTRICT ON UPDATE RESTRICT&#xA;);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+----------------+-----------+&#xA;| id |    content     | author_id |&#xA;+----+----------------+-----------+&#xA;| 1  | hi, I am harry | 1         |&#xA;| 2  | hi, I am ron   | 2         |&#xA;+----+----------------+-----------+&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+---------+&#xA;| id |  name   |&#xA;+----+---------+&#xA;| 1  | harry   |&#xA;| 2  | ron     |&#xA;| 4  | neville |&#xA;+----+---------+&#xA;sqlite&gt; SELECT posts.*, users.name AS author FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+----------------+-----------+--------+&#xA;| id |    content     | author_id | author |&#xA;+----+----------------+-----------+--------+&#xA;| 1  | hi, I am harry | 1         | harry  |&#xA;| 2  | hi, I am ron   | 2         | ron    |&#xA;+----+----------------+-----------+--------+&#xA;sqlite&gt; UPDATE users SET name = &#39;harry potter&#39; where id = 1;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+--------------+&#xA;| id |     name     |&#xA;+----+--------------+&#xA;| 1  | harry potter |&#xA;| 2  | ron          |&#xA;| 4  | neville      |&#xA;+----+--------------+&#xA;sqlite&gt; SELECT posts.*, users.name AS author FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+----------------+-----------+--------------+&#xA;| id |    content     | author_id |    author    |&#xA;+----+----------------+-----------+--------------+&#xA;| 1  | hi, I am harry | 1         | harry potter |&#xA;| 2  | hi, I am ron   | 2         | ron          |&#xA;+----+----------------+-----------+--------------+&#xA;sqlite&gt; UPDATE users SET name = &#39;harry&#39; where id = 1;&#xA;sqlite&gt; UPDATE users SET id = 3 where id = 2;&#xA;Runtime error: FOREIGN KEY constraint failed (19)&#xA;sqlite&gt; UPDATE users SET id = 5 where id = 4;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+---------+&#xA;| id |  name   |&#xA;+----+---------+&#xA;| 1  | harry   |&#xA;| 2  | ron     |&#xA;| 5  | neville |&#xA;+----+---------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;### Set NULL&#xA;&#xA;For the rest of this post, we&#39;ll only be looking at the `ON DELETE` constraint, the `ON UPDATE` is very rarely used and we have explored already when it is used.&#xA;&#xA;In this option, when the record in the foreign table is deleted, the foreign key reference of the  record in the primary table will be set to `NULL`.&#xA;&#xA;For our example, if we set `ON DELETE SET NULL` to the `FOREIGN KEY` constraint, when the `users` record with id = 2 is deleted, the `author_id` of the `posts` record with id = 3 will be set to `NULL`.&#xA;&#xA;```sql&#xA;DROP TABLE posts;&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id) ON DELETE SET NULL&#xA;);&#xA;```&#xA;&#xA;Now, let&#39;s add few more rows as usual:&#xA;NOTE: I have added one more post for harry to avoid the 1-1 mapping of posts and users in the data&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;Expecto Patronum&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;```&#xA;&#xA;Let&#39;s take a look at the posts table.&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA; &#xA;Now, let&#39;s delete the `users` record with id = 2:&#xA;&#xA;```sql&#xA;DELETE FROM users WHERE id = 2;&#xA;```&#xA;This will allow and should, as there is no restriction on the `posts` table, the `FOREIGN KEY` constraint is `SET NULL` when the reference in the `users` table is deleted.&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;As you can see, the `author_id` of the `posts` record with id = 3 has been set to `NULL`&#xA;&#xA;```&#xA;sqlite&gt; DROP TABLE posts;&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id) ON DELETE SET NULL&#xA;);&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;Expecto Patronum&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+------------------+-----------+&#xA;| id |     content      | author_id |&#xA;+----+------------------+-----------+&#xA;| 1  | hi, I am harry   | 1         |&#xA;| 2  | Expecto Patronum | 1         |&#xA;| 3  | hi, I am ron     | 2         |&#xA;+----+------------------+-----------+&#xA;sqlite&gt; SELECT posts.*, users.name AS author FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+------------------+-----------+--------+&#xA;| id |     content      | author_id | author |&#xA;+----+------------------+-----------+--------+&#xA;| 1  | hi, I am harry   | 1         | harry  |&#xA;| 2  | Expecto Patronum | 1         | harry  |&#xA;| 3  | hi, I am ron     | 2         | ron    |&#xA;+----+------------------+-----------+--------+&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+---------+&#xA;| id |  name   |&#xA;+----+---------+&#xA;| 1  | harry   |&#xA;| 2  | ron     |&#xA;| 5  | neville |&#xA;+----+---------+&#xA;sqlite&gt; DELETE FROM users WHERE id = 2;&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+------------------+-----------+&#xA;| id |     content      | author_id |&#xA;+----+------------------+-----------+&#xA;| 1  | hi, I am harry   | 1         |&#xA;| 2  | Expecto Patronum | 1         |&#xA;| 3  | hi, I am ron     |           |&#xA;+----+------------------+-----------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;&#xA;### Set Default&#xA;&#xA;In this option, when the record in the foreign table is deleted, the foreign key reference of the  record in the primary table will be set to the default value of the foreign key.&#xA;&#xA;NOTE: We have not set the default value for the `author_id` column in the `posts` table, so it will be set to `NULL` by default. We can add normal constraints like `DEFAULT`, `UNIQUE`, `NOT NULL`, `CHECK`, etc on the foreign key as and when required.&#xA;&#xA;```sql&#xA;DROP TABLE posts;&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER DEFAULT 1,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id) ON DELETE SET DEFAULT&#xA;);&#xA;```&#xA;We are setting default foreign key as `1` which means the `users` record with id = 1 will be the default reference for the `posts` table. If you don&#39;t provide the `author_id`, all post will be authored by `harry` what a funny quirk of the posts.&#xA;&#xA;Let&#39;s add rows as usual:&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;Expecto Patronum&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;```&#xA;&#xA;Now, let&#39;s take a look at the posts table:&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;We can now try deleting the `users` record with id = 2, Since it is already tied / referenced by the `posts` table, the users record will be deleted, but the `posts` record with `author_id` 2 will be set to the default value `1` which is the id of the `users` record with name `harry`.&#xA;&#xA;```sql&#xA;DELETE FROM users WHERE id = 2;&#xA;```&#xA;It ran successfully, but the `posts` record with `author_id` 2 will be set to the default value `1` which is the id of the `users` record with name `harry`.&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;Let&#39;s view more closely:&#xA;&#xA;```sql&#xA;SELECT posts.*, users.name AS author FROM posts JOIN users ON posts.author_id = users.id;&#xA;```&#xA; &#xA; View the SQLog :)&#xA;&#xA;```&#xA;sqlite&gt; DROP TABLE posts;&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER DEFAULT 1,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id) ON DELETE SET DEFAULT&#xA;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+---------+&#xA;| id |  name   |&#xA;+----+---------+&#xA;| 1  | harry   |&#xA;| 2  | ron     |&#xA;| 5  | neville |&#xA;+----+---------+&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;Expecto Patronum&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+------------------+-----------+&#xA;| id |     content      | author_id |&#xA;+----+------------------+-----------+&#xA;| 1  | hi, I am harry   | 1         |&#xA;| 2  | Expecto Patronum | 1         |&#xA;| 3  | hi, I am ron     | 2         |&#xA;+----+------------------+-----------+&#xA;sqlite&gt; SELECT posts.*, users.name AS author FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+------------------+-----------+--------+&#xA;| id |     content      | author_id | author |&#xA;+----+------------------+-----------+--------+&#xA;| 1  | hi, I am harry   | 1         | harry  |&#xA;| 2  | Expecto Patronum | 1         | harry  |&#xA;| 3  | hi, I am ron     | 2         | ron    |&#xA;+----+------------------+-----------+--------+&#xA;sqlite&gt; DELETE FROM users where id = 2;&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+------------------+-----------+&#xA;| id |     content      | author_id |&#xA;+----+------------------+-----------+&#xA;| 1  | hi, I am harry   | 1         |&#xA;| 2  | Expecto Patronum | 1         |&#xA;| 3  | hi, I am ron     | 1         |&#xA;+----+------------------+-----------+&#xA;sqlite&gt; SELECT posts.*, users.name AS author FROM posts JOIN users ON posts.author_id = users.id;&#xA;+----+------------------+-----------+--------+&#xA;| id |     content      | author_id | author |&#xA;+----+------------------+-----------+--------+&#xA;| 1  | hi, I am harry   | 1         | harry  |&#xA;| 2  | Expecto Patronum | 1         | harry  |&#xA;| 3  | hi, I am ron     | 1         | harry  |&#xA;+----+------------------+-----------+--------+&#xA;sqlite&gt;&#xA;```&#xA;Let&#39;s take a look at the `CASCADE` option&#xA;&#xA;### Cascade&#xA;&#xA;If we set `ON DELETE CASCADE` to the `FOREIGN KEY` constraint, when the `users` record with id = 2 is deleted, the `posts` record with `author_id` 2 will be deleted as well.&#xA;&#xA;We can set the `CASCADE` option to the `FOREIGN KEY` constraint as follows:&#xA;&#xA;```sql&#xA;DROP TABLE posts;&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id) ON DELETE CASCADE&#xA;);&#xA;```&#xA;&#xA;Now, let&#39;s add few more rows as usual&#xA;&#xA;```sql&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;Expecto Patronum&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;```&#xA;&#xA;We now have 3 posts, associated with 2 users.&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;Now, let&#39;s delete the `users` record with id = 2&#xA;&#xA;```sql&#xA;DELETE FROM users WHERE id = 2;&#xA;```&#xA;&#xA;This will not only delete the `users` record with id = 2, but it will also delete the `posts` record with `author_id` 2.&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;Cascade as the name suggest, when the foreign key in the foreign table is deleted, the primary row is cascaded or deleted.&#xA;&#xA;```sql&#xA;sqlite&gt; DROP TABLE posts;&#xA;&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT NOT NULL,&#xA;    author_id INTEGER,&#xA;    FOREIGN KEY (author_id) REFERENCES users (id) ON DELETE CASCADE&#xA;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+---------+&#xA;| id |  name   |&#xA;+----+---------+&#xA;| 1  | harry   |&#xA;| 2  | ron     |&#xA;| 5  | neville |&#xA;+----+---------+&#xA;sqlite&gt; INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am harry&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;Expecto Patronum&#39;, 1);&#xA;INSERT INTO posts(content, author_id) VALUES (&#39;hi, I am ron&#39;, 2);&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+------------------+-----------+&#xA;| id |     content      | author_id |&#xA;+----+------------------+-----------+&#xA;| 1  | hi, I am harry   | 1         |&#xA;| 2  | Expecto Patronum | 1         |&#xA;| 3  | hi, I am ron     | 2         |&#xA;+----+------------------+-----------+&#xA;sqlite&gt; DELETE FROM users where id = 2;&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+------------------+-----------+&#xA;| id |     content      | author_id |&#xA;+----+------------------+-----------+&#xA;| 1  | hi, I am harry   | 1         |&#xA;| 2  | Expecto Patronum | 1         |&#xA;+----+------------------+-----------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;## Many Foreign Keys&#xA;&#xA;What would happen if there are more than one row in the primary table that references the same id in the foreign table?&#xA;&#xA;That is a question for another post.&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: PRIMARY KEY table constraint</title>
      <link>https://meetgor.com/sqlite-primary-key-table-constraint</link>
      <description></description>
      <pubDate>Sun, 14 Sep 2025 00:00:00 UTC</pubDate>
      <content>## The PRIMARY KEY Table constraint&#xA;&#xA;The PRIMARY KEY constraint is not actually a column constraint, it is a table constraint. In the previous section we learnt about how to handle single column-level `PRIMARY KEY`. In this section we&#39;ll understand how to use `PRIMARY KEY` as table constraint, with that we can use multiple columns to combine the key.&#xA;&#xA;Since, `PRIMARY KEY` is a table level constraint, it only can be defined once for the table, as it needs to be unique for each record inserted in that table. So, we can define it with the column or define it at the end, doesn&#39;t matter, but it needs to be defined only once.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    user_id INTEGER PRIMARY KEY,&#xA;    username TEXT NOT NULL,&#xA;    email TEXT NOT NULL&#xA;);&#xA;```&#xA;This is equivalent to:&#xA;&#xA;```&#xA;CREATE TABLE users (&#xA;    user_id INTEGER,&#xA;    username TEXT NOT NULL,&#xA;    email TEXT NOT NULL,&#xA;    PRIMARY KEY (user_id)&#xA;);&#xA;```&#xA;&#xA;Both of these are setting the column `user_id` as the `PRIMARY KEY` for the table `users`.&#xA;&#xA;This will do the same thing, we saw the first one in the previous blog post, in this we will do something different.&#xA;&#xA;## Multiple column PRIMARY KEY&#xA;&#xA;The schem design looks a little fragile, we can have `username` and `email` as duplicates right? But we have `user_id` as unique.&#xA;&#xA;Rather, we want a combination of the `username` and `email` as unique, do we care about the `user_id` as the `PRIMARY KEY`?&#xA;&#xA;It depends:&#xA;- If your application logic only wants to use `username` and `email` as unique, then the `user_id` is not required.&#xA;- If your applicaation logic only requires the `user_id` then it doesn&#39;t matter if the `username` of `email` are duplicated, the `user_id` will be unique.&#xA;&#xA;So, assuming the 1st scenario, let&#39;s change the users table schema:&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    username TEXT NOT NULL,&#xA;    email TEXT NOT NULL,&#xA;    PRIMARY KEY (username, email)&#xA;);&#xA;```&#xA;&#xA;Here we have defined the `username` and `email` as `PRIMARY KEY` for the table `users`. This will take a combination of the `username` and the `email` coluns, and add a `UNIQUE` constraint to it, here there is one more addition that we did which is `NOT NULL` since both the columns are `TEXT` we need to add teh `NOT NULL` constraint, for `INTEGER` and `PRIMARY KEY` it will be handled for us.&#xA;&#xA;Let&#39;s try inserting a few default values:&#xA;&#xA;```sql&#xA;INSERT INTO users DEFAULT VALUES;&#xA;```&#xA;&#xA;This won&#39;t work as the `username` and `email` columns are `NULL` and there is no `NOT NULL` constraint defined on them.&#xA;&#xA;Let&#39;s try inserting actual values:&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;john&#39;, &#39;john@abc.com&#39;);&#xA;```&#xA;&#xA;This successfully inserts the row into the table.&#xA;&#xA;And if we try to insert it again, the duplicate combination of `username` and `email` will throw an error:&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;john&#39;, &#39;john@abc.com&#39;);&#xA;```&#xA;&#xA;So, we either need the `username` or `email` to be unique, but not necessarily both.&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;john&#39;, &#39;john_new@abc.com&#39;);&#xA;```&#xA;&#xA;This successfully inserts the row into the table, as the `username` is same but `email` is unique. Since the PRIMARY key is a combination of `username` and `email` we can allow the combinational unique values into a new record.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;Here&#39;s the SQLog :)&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE users (&#xA;    username TEXT NOT NULL,&#xA;    email TEXT NOT NULL,&#xA;    PRIMARY KEY (username, email)&#xA;);&#xA;sqlite&gt; INSERT INTO users DEFAULT VALUES;&#xA;Runtime error: NOT NULL constraint failed: users.username (19)&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;john&#39;, &#39;john@abc.com&#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----------+--------------+&#xA;| username |    email     |&#xA;+----------+--------------+&#xA;| john     | john@abc.com |&#xA;+----------+--------------+&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+--------------+&#xA;| rowid | username |    email     |&#xA;+-------+----------+--------------+&#xA;| 1     | john     | john@abc.com |&#xA;+-------+----------+--------------+&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;john&#39;, &#39;john@abc.com&#39;);&#xA;Runtime error: UNIQUE constraint failed: users.username, users.email (19)&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;john&#39;, &#39;john_new@abc.com&#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----------+------------------+&#xA;| username |      email       |&#xA;+----------+------------------+&#xA;| john     | john@abc.com     |&#xA;| john     | john_new@abc.com |&#xA;+----------+------------------+&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+------------------+&#xA;| rowid | username |      email       |&#xA;+-------+----------+------------------+&#xA;| 1     | john     | john@abc.com     |&#xA;| 2     | john     | john_new@abc.com |&#xA;+-------+----------+------------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;&#xA;I think that is all we need about `PRIMARY KEY` for the moment, if you need any specific example, we will be exploring `AUTOINCREMENT`, `NOT NULL` cases for `PRIMARY KEY`s and other schema design principles in separate sections.&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: PRIMARY KEY column constraint</title>
      <link>https://meetgor.com/sqlite-primary-key-column-constraint</link>
      <description></description>
      <pubDate>Sat, 13 Sep 2025 00:00:00 UTC</pubDate>
      <content>## The PRIMARY KEY column constraint&#xA;&#xA;The PRIMARY KEY constraint is not actually a column constraint, it is a table constraint. But in this section, we&#39;ll only learn about how to handle single column-level `PRIMARY KEY`.&#xA;&#xA;The [PRIMARY KEY](https://sqlite.org/lang_createtable.html#the_primary_key) column constraint is a constraint that ensures that a column contains unique values and is the `PRIMARY` way to distinguish between all the rows of that table.&#xA;&#xA;From the documentation:&#xA;&#xA;&gt; Each table in SQLite may have at most one PRIMARY KEY. If the keywords PRIMARY KEY are added to a column definition, then the primary key for the table consists of that single column. Or, if a PRIMARY KEY clause is specified as a table-constraint, then the primary key of the table consists of the list of columns specified as part of the PRIMARY KEY clause. The PRIMARY KEY clause must contain only column names — the use of expressions in an indexed-column of a PRIMARY KEY is not supported. An error is raised if more than one PRIMARY KEY clause appears in a CREATE TABLE statement. The PRIMARY KEY is optional for ordinary tables but is required for WITHOUT ROWID tables.&#xA;&gt; If a table has a single column primary key and the declared type of that column is &#34;INTEGER&#34; and the table is not a WITHOUT ROWID table, then the column is known as an INTEGER PRIMARY KEY. See below for a description of the special properties and behaviors associated with an INTEGER PRIMARY KEY.&#xA;&gt; Each row in a table with a primary key must have a unique combination of values in its primary key columns. For the purposes of determining the uniqueness of primary key values, NULL values are considered distinct from all other values, including other NULLs. If an INSERT or UPDATE statement attempts to modify the table content so that two or more rows have identical primary key values, that is a constraint violation.&#xA;&gt; According to the SQL standard, PRIMARY KEY should always imply NOT NULL. Unfortunately, due to a bug in some early versions, this is not the case in SQLite. Unless the column is an INTEGER PRIMARY KEY or the table is a WITHOUT ROWID table or a STRICT table or the column is declared NOT NULL, SQLite allows NULL values in a PRIMARY KEY column. SQLite could be fixed to conform to the standard, but doing so might break legacy applications. Hence, it has been decided to merely document the fact that SQLite allows NULLs in most PRIMARY KEY columns.&#xA;&#xA;Here is what I think in short:&#xA;&#xA;- Used to identify the rows of a table. Hence must be unique&#xA;- At most one primary key per table (default rowid, multiple primary key not allowed)&#xA;- Primary key can be a combination of multiple columns or even single column&#xA;- Only column names allowed (not expressions)&#xA;- Required for WITHOUT ROWID&#xA;- INTEGER PRIMARY KEY special behavior&#xA;- NULL behavior (SQLite quirk vs SQL standard)&#xA;&#xA;## Creating a simple table&#xA;&#xA;By default, if you don&#39;t  create a column in a table as a `PRIMARY KEY`, it is automatically assumed that `rowid` will be used as the unique identifier for that table.&#xA;&#xA;Let&#39;s create a simple table with columns like `username` and `email`, non of which are `PRIMARY KEY` explicitly mentioned.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    username TEXT NOT NULL,&#xA;    email TEXT NOT NULL&#xA;);&#xA;```&#xA;Now, let&#39;s insert a few columns and check what we can observe.&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;jim&#39;, &#39;jim@abc.com&#39;);&#xA;INSERT INTO users(username, email) VALUES(&#39;jack&#39;, &#39;jack@abc.com&#39;);&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;As, you can see, we have populated the table with `username` and `email` columns.&#xA;&#xA;But wait, there should be `rowid` right? It is there but its a hidden column (do not touch it). &#xA;&#xA;```sql&#xA;SELECT rowid, * FROM users;&#xA;```&#xA;You can see the `rowid` column in the output.&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE users (&#xA;    username TEXT NOT NULL,&#xA;    email TEXT NOT NULL&#xA;);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;jim&#39;, &#39;jim@abc.com&#39;);&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;jack&#39;, &#39;jack@abc.com&#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----------+--------------+&#xA;| username |    email     |&#xA;+----------+--------------+&#xA;| jim      | jim@abc.com  |&#xA;| jack     | jack@abc.com |&#xA;+----------+--------------+&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+--------------+&#xA;| rowid | username |    email     |&#xA;+-------+----------+--------------+&#xA;| 1     | jim      | jim@abc.com  |&#xA;| 2     | jack     | jack@abc.com |&#xA;+-------+----------+--------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;The rowid is used as a primary key for the table, this means it will take the max of the current state of the table and use the next number as its rowid.&#xA;&#xA;We can verify that if we try to insert a duplicate value/record/row in the `users` table:&#xA;&#xA;Let&#39;s insert the `jack` as the user and check if it inserts it, as it would have errored if the username or the email was the primary key, as this value is duplicated. But the `username` and `email` are not the `PRIMARY KEY` in this table, hence it will happily insert it.&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;jack&#39;, &#39;jack@abc.com&#39;);&#xA;SELECT rowid, * FROM users;&#xA;```&#xA;&#xA;As, you can see it inserted the value and the `rowid` is now `3`.&#xA;&#xA;```&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+--------------+&#xA;| rowid | username |    email     |&#xA;+-------+----------+--------------+&#xA;| 1     | jim      | jim@abc.com  |&#xA;| 2     | jack     | jack@abc.com |&#xA;+-------+----------+--------------+&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;jack&#39;, &#39;jack@abc.com&#39;);&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+--------------+&#xA;| rowid | username |    email     |&#xA;+-------+----------+--------------+&#xA;| 1     | jim      | jim@abc.com  |&#xA;| 2     | jack     | jack@abc.com |&#xA;| 3     | jack     | jack@abc.com |&#xA;+-------+----------+--------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;What would happen if the middle values are deleted?&#xA;&#xA;let&#39;s delete the row with `rowid` `2`:&#xA;&#xA;```sql&#xA;DELETE FROM users WHERE rowid = 2;&#xA;```&#xA;&#xA;```sql&#xA;SELECT rowid, * FROM users;&#xA;```&#xA;&#xA;As, you can see, the `rowid` `2` is deleted. The `rowid` will still take the max of the current state of the table, and will use the next number as the `rowid` which in this state should be `4`.&#xA;&#xA;Let&#39;s insert a new record and check if the `rowid` is the max of the current state of the table.&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;jill&#39;, &#39;jill@abc.com&#39;);&#xA;```&#xA;&#xA;```sql&#xA;SELECT rowid, * FROM users;&#xA;```&#xA;&#xA;As you can see, the `rowid` is now `4`.&#xA;&#xA;Let&#39;s delete that and insert one more.&#xA;&#xA;```sql&#xA;DELETE FROM users WHERE rowid = 4;&#xA;```&#xA;&#xA;```sql&#xA;SELECT rowid, * FROM users;&#xA;```&#xA;&#xA;Now, that the max row of the table is `3` but we had `4` earlier, we need to check what could be the next rowid?&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;jill&#39;, &#39;jill@abc.com&#39;);&#xA;SELECT rowid, * FROM users;&#xA;```&#xA;&#xA;Ok, as you can see, the `rowid` is now `4`. It is reusing the previous `rowid` value, which might be an issue, very rarely but this is a expected behaviour.&#xA;&#xA;Which gives us the answer that there is maybe a quirk or a limitation of `rowid` that it can insert values which are max of the rowid in the current state.&#xA;&#xA;```&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+--------------+&#xA;| rowid | username |    email     |&#xA;+-------+----------+--------------+&#xA;| 1     | jim      | jim@abc.com  |&#xA;| 2     | jack     | jack@abc.com |&#xA;| 3     | jack     | jack@abc.com |&#xA;+-------+----------+--------------+&#xA;sqlite&gt; DELETE FROM users WHERE rowid = 2;&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+--------------+&#xA;| rowid | username |    email     |&#xA;+-------+----------+--------------+&#xA;| 1     | jim      | jim@abc.com  |&#xA;| 3     | jack     | jack@abc.com |&#xA;+-------+----------+--------------+&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;jill&#39;, &#39;jill@abc.com&#39;);&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+--------------+&#xA;| rowid | username |    email     |&#xA;+-------+----------+--------------+&#xA;| 1     | jim      | jim@abc.com  |&#xA;| 3     | jack     | jack@abc.com |&#xA;| 4     | jill     | jill@abc.com |&#xA;+-------+----------+--------------+&#xA;sqlite&gt; DELETE FROM users WHERE rowid = 4;&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+--------------+&#xA;| rowid | username |    email     |&#xA;+-------+----------+--------------+&#xA;| 1     | jim      | jim@abc.com  |&#xA;| 3     | jack     | jack@abc.com |&#xA;+-------+----------+--------------+&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;joe&#39;, &#39;joe@abc.com&#39;);&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+--------------+&#xA;| rowid | username |    email     |&#xA;+-------+----------+--------------+&#xA;| 1     | jim      | jim@abc.com  |&#xA;| 3     | jack     | jack@abc.com |&#xA;| 4     | joe      | joe@abc.com  |&#xA;+-------+----------+--------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Ok, that was a wired tangent, but worth noting.&#xA;We will check how to fix it with the `AUTOINCREMENT` clause in the future posts.&#xA;&#xA;Now, let&#39;s create a `PRIMARY KEY` column that we can safely call a primary key.&#xA;&#xA;## Creating a column as primary key&#xA;&#xA;To create a column as a `PRIMARY KEY` we need to simply add the `PRIMARY KEY` constraint to the column. &#xA;&#xA;Let&#39;s create a simple table with columns like `username` and `email`, and here `email` is the primary key.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    username TEXT NOT NULL,&#xA;    email TEXT PRIMARY KEY&#xA;);&#xA;```&#xA;&#xA;Mentioning `PRIMARY KEY` with email means that each record needs to have a unique `email`.&#xA;&#xA;If you attach a `PRIMARY KEY` to a column, the `UNIQUE` constraint is also added automatically. So, saying `email TEXT PRIMARY KEY UNIQUE` is redundant.&#xA;&#xA;Let&#39;s try inserting default values to the users.&#xA;&#xA;```sql&#xA;INSERT INTO users DEFAULT VALUES;&#xA;```&#xA;As you can see, this will fail as the `username` is a `NOT NULL` column.&#xA;&#xA;OK, let&#39;s just satisfy that `NOT NULL` constraint for username.&#xA;&#xA;```sql&#xA;INSERT INTO users(username) VALUES(&#39;james&#39;);&#xA;```&#xA;OK, that inserted the value.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;But, the email is empty! Becuase we didn&#39;t specify it? Yes, it is a text field, and a primary key, so you need to handle that. What about the rowid?&#xA;&#xA;```sql&#xA;SELECT rowid, * FROM users;&#xA;```&#xA;&#xA;As you can see, the rowid is `1` and email is empty.&#xA;&#xA;That&#39;s worth noting that `rowid` will be populated independently of the `PRIMARY KEY` column. But if speicifed as `WITHOUT ROWID` in the table creation, it won&#39;t be there.&#xA;&#xA;Now, let&#39;s insert the same record again. We have said the `email` is a `PRIMARY KEY`, so it will be unique right? RIGHT?&#xA;&#xA;```sql&#xA;INSERT INTO users(username) VALUES(&#39;james&#39;);&#xA;```&#xA;&#xA;Surprisingly, it inserted that too.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;The email is empty for both the rows, but the username is same, so the `email` is NULL, and you guessed it right, `NULL` is identified as `UNIQUE`. That is a bad schema design. The users table had a text key as a primary key, and we need to add `NOT NULL` to the `PRIMARY KEY` column.&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE users (&#xA;    username TEXT NOT NULL,&#xA;    email TEXT PRIMARY KEY&#xA;);&#xA;sqlite&gt; INSERT INTO users DEFAULT VALUES;&#xA;Runtime error: NOT NULL constraint failed: users.username (19)&#xA;sqlite&gt; INSERT INTO users(username) VALUES(&#39;james&#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----------+-------+&#xA;| username | email |&#xA;+----------+-------+&#xA;| james    |       |&#xA;+----------+-------+&#xA;sqlite&gt; INSERT INTO users(username) VALUES(&#39;james&#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----------+-------+&#xA;| username | email |&#xA;+----------+-------+&#xA;| james    |       |&#xA;| james    |       |&#xA;+----------+-------+&#xA;sqlite&gt; INSERT INTO users(username) VALUES(&#39;jack&#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----------+-------+&#xA;| username | email |&#xA;+----------+-------+&#xA;| james    |       |&#xA;| james    |       |&#xA;| jack     |       |&#xA;+----------+-------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;&gt; NOTE: NOT NULL is only added automatically for `INTEGER PRIMARY KEY` column, which means the column becomes an alias for the `rowid` table.&#xA; &#xA;## PRIMARY KEY with NOT NULL&#xA;&#xA;It turns out that `NOT NULL` is only added automatically for `INTEGER PRIMARY KEY` column, so for rest of the combination of `PRIMARY KEY` columns we need to explicitly add the `NOT NULL` constraint. &#xA;&#xA;So, let&#39;s add that:&#xA;&#xA;```sql&#xA;DROP TABLE users;&#xA;CREATE TABLE users (&#xA;    username TEXT NOT NULL,&#xA;    email TEXT PRIMARY KEY NOT NULL&#xA;);&#xA;```&#xA;&#xA;Now, let&#39;s try inserting default values to the users.&#xA;&#xA;```sql&#xA;INSERT INTO users DEFAULT VALUES;&#xA;```&#xA;&#xA;As you can see, this will fail as the `username` is a `NOT NULL` column. As we knew in the first attempt.&#xA;&#xA;```sql&#xA;INSERT INTO users(username) VALUES(&#39;james&#39;);&#xA;```&#xA;OK, that is what we expected, it should fail, as have not specified the `email` column, as that is a primary key and it cannot be null. I mean it could be if we wanted to, but that is not expected to behave.&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;james&#39;, &#39;james@abc.com&#39;);&#xA;```&#xA;Ok, this should insert it successfully. &#xA;&#xA;```sql&#xA;SELECT rowid, * FROM users;&#xA;```&#xA;As you can see, we have populated the table with `username` and `email` columns. This is the perfect thing to setup.&#xA;&#xA;The `rowid` will still be there as discussed, the `email` now is the `PRIMARY KEY` which means any duplicate string email will be constraint violation.&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;james&#39;, &#39;james@abc.com&#39;);&#xA;```&#xA;As you can see, this will fail, as we have already inserted a record with the same email. This is expected as we noted that the `PRIMARY KEY` automatically adds the `UNIQUE` constraint to the column.&#xA;&#xA;Similary, we can check a few other things.&#xA;&#xA;Like if we try to insert a record with the same username but different email:&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;james&#39;, &#39;james_new@abc.com&#39;);&#xA;```&#xA;&#xA;This will succeed, as we have not specified the `username` as primary key, and it is ok to not have unique values for it.&#xA;&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE users (&#xA;    username TEXT NOT NULL,&#xA;    email TEXT PRIMARY KEY NOT NULL&#xA;);&#xA;&#xA;sqlite&gt; INSERT INTO users DEFAULT VALUES;&#xA;Runtime error: NOT NULL constraint failed: users.username (19)&#xA;&#xA;sqlite&gt; INSERT INTO users(username) VALUES(&#39;james&#39;);&#xA;Runtime error: NOT NULL constraint failed: users.email (19)&#xA;&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;james&#39;, &#39;james@abc.com&#39;);&#xA;&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+---------------+&#xA;| rowid | username |     email     |&#xA;+-------+----------+---------------+&#xA;| 1     | james    | james@abc.com |&#xA;+-------+----------+---------------+&#xA;&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;james&#39;, &#39;james@abc.com&#39;);&#xA;Runtime error: UNIQUE constraint failed: users.email (19)&#xA;&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;james&#39;, &#39;james_new@abc.com&#39;);&#xA;&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+-------------------+&#xA;| rowid | username |       email       |&#xA;+-------+----------+-------------------+&#xA;| 1     | james    | james@abc.com     |&#xA;| 2     | james    | james_new@abc.com |&#xA;+-------+----------+-------------------+&#xA;&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;jill&#39;, &#39;james_new@abc.com&#39;);&#xA;Runtime error: UNIQUE constraint failed: users.email (19)&#xA;&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;jill&#39;, &#39;jill@abc.com&#39;);&#xA;&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+-------+----------+-------------------+&#xA;| rowid | username |       email       |&#xA;+-------+----------+-------------------+&#xA;| 1     | james    | james@abc.com     |&#xA;| 2     | james    | james_new@abc.com |&#xA;| 3     | jill     | jill@abc.com      |&#xA;+-------+----------+-------------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;That is how we primary key works, atleast the basic of it.&#xA;&#xA;## INTEGER PRIMARY KEY&#xA;&#xA;This is a special case where the column defined as `PRIMARY KEY` with INTEGER type becomes an alias to the `rowid` and hence we will have both `UNIQUE` and `NOT NULL` constraints added to it.&#xA;&#xA;Let&#39;s create a table with `INTEGER PRIMARY KEY` column.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    user_id INTEGER PRIMARY KEY,&#xA;    username TEXT NOT NULL,&#xA;    email TEXT NOT NULL&#xA;);&#xA;```&#xA;In this table `users` we have `user_id` which is `INTEGER PRIMARY KEY` column. It is an alias for the `rowid` table as we&#39;ll see.&#xA;&#xA;Now, let&#39;s insert some data and check what we can observe.&#xA;&#xA;```sql&#xA;INSERT INTO users DEFAULT VALUES;&#xA;```&#xA;Obivously, this will fail, as we have not specified the `username` and `email` as `NOT NULL`, and we haven&#39;t specified in the insertion.&#xA;&#xA;Let&#39;s specify both and check if it can violate any constraints.&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;james&#39;, &#39;james@abc.com&#39;);&#xA;```&#xA;&#xA;As you can see, we successfully inserted the record, as we have specified the `username` and `email` as `NOT NULL` and the primary key which is `user_id` and it will automatically get populated. The `user_id` will be automatically populated as it will be a alias to the `rowid` column, and we know it will populate automatically for each inserted value for each row, by incrementing the max row id at that point.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;As you can see, the `user_id` is `1` and `username` is `james` and `email` is `james@abc.com`. But what is `rowid`?&#xA;&#xA;Let&#39;s check that too.&#xA;&#xA;```sql&#xA;SELECT rowid, * FROM users;&#xA;```&#xA;&#xA;As you can see, the `user_id` is `1` but the rowid has become the `user_id` which is basically an alias for the `rowid`.&#xA;&#xA;Let&#39;s see if we can add more records.&#xA;&#xA;Let&#39;s try adding the same record again.&#xA;&#xA;```sql&#xA;INSERT INTO users(username, email) VALUES(&#39;james&#39;, &#39;james@abc.com&#39;);&#xA;```&#xA;Interestingly, this works, because we have not specified the `user_id` as `PRIMARY KEY` and inserting duplicate username and email should not violate any constraints unless we have specified as `UNIQUE` or others.&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE users (&#xA;    user_id INTEGER PRIMARY KEY,&#xA;    username TEXT NOT NULL,&#xA;    email TEXT NOT NULL&#xA;);&#xA;sqlite&gt; INSERT INTO users DEFAULT VALUES;&#xA;Runtime error: NOT NULL constraint failed: users.username (19)&#xA;sqlite&gt; INSERT INTO users(username) VALUES(&#39;james&#39;);&#xA;Runtime error: NOT NULL constraint failed: users.email (19)&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;james&#39;, &#39;james@abc.com&#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+---------+----------+---------------+&#xA;| user_id | username |     email     |&#xA;+---------+----------+---------------+&#xA;| 1       | james    | james@abc.com |&#xA;+---------+----------+---------------+&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+---------+---------+----------+---------------+&#xA;| user_id | user_id | username |     email     |&#xA;+---------+---------+----------+---------------+&#xA;| 1       | 1       | james    | james@abc.com |&#xA;+---------+---------+----------+---------------+&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;james&#39;, &#39;james@abc.com&#39;);&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+---------+---------+----------+---------------+&#xA;| user_id | user_id | username |     email     |&#xA;+---------+---------+----------+---------------+&#xA;| 1       | 1       | james    | james@abc.com |&#xA;| 2       | 2       | james    | james@abc.com |&#xA;+---------+---------+----------+---------------+&#xA;sqlite&gt; INSERT INTO users(username, email) VALUES(&#39;jill&#39;, &#39;jill@abc.com&#39;);&#xA;sqlite&gt; SELECT rowid, * FROM users;&#xA;+---------+---------+----------+---------------+&#xA;| user_id | user_id | username |     email     |&#xA;+---------+---------+----------+---------------+&#xA;| 1       | 1       | james    | james@abc.com |&#xA;| 2       | 2       | james    | james@abc.com |&#xA;| 3       | 3       | jill     | jill@abc.com  |&#xA;+---------+---------+----------+---------------+&#xA;sqlite&gt;&#xA;```&#xA;So that is how `INTEGER PRIMARY KEY` works.&#xA;&#xA;You can add `PRIMARY KEY` to any column, but you need to ensure that it doesn&#39;t violate the constraint of allowing duplicate enties.&#xA;&#xA;We know that the `PRIMARY KEY` is not a column specific constraint. It is table wide constraint, we&#39;ll check out the table wide constraint that is combinational constraint in the next section.&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: CHECK column constraint</title>
      <link>https://meetgor.com/sqlite-check-column-constraint</link>
      <description></description>
      <pubDate>Fri, 12 Sep 2025 00:00:00 UTC</pubDate>
      <content>## The CHECK column constraint&#xA;&#xA;The [CHECK](https://sqlite.org/lang_createtable.html#check_constraints) clause is a column constraint that allows us to define certain conditions that we want to evaluate before inserting the column for the row and populate it accordingly. In this post, we will check, what this check is and when it is performed.&#xA;&#xA;## What it checks&#xA;&#xA;The `CHECK` constraint basically acts a validator, we define the condition and if the condition is not met (is false) then the row is not inserted or updated.&#xA;&#xA;Let&#39;s take a simplest example with our good-ol users table:&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    id INTEGER PRIMARY KEY,&#xA;    name TEXT NOT NULL,&#xA;    age INTEGER CHECK(age &gt;= 18)&#xA;);&#xA;```&#xA;&#xA;Let&#39;s insert a user:&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age) VALUES (&#39;John&#39;, 21);&#xA;```&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;This rightly populates with the user `John` with age `21`.&#xA;&#xA;If we try to insert a user with age less than 18, it will fail:&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age) VALUES (&#39;Alice&#39;, 17);&#xA;```&#xA;This should fail the constraint as the age is less than 18.&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO users (name, age) VALUES (&#39;Alice&#39;, 17);&#xA;Runtime error: CHECK constraint failed: age &gt;= 18 (19)&#xA;sqlite&gt;&#xA;```&#xA;As you would see, the insertion query failed as a `CHECK` constraint failed.&#xA;&#xA;Let&#39;s add one more valid user:&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age) VALUES (&#39;Bob&#39;, 20);&#xA;```&#xA;&#xA;This is fine, and now, let&#39;s try to update the age of a user:&#xA;&#xA;```sql&#xA;UPDATE users SET age = 17 WHERE id = 2;&#xA;```&#xA;&#xA;This should fail the constraint as the age is less than 18.&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO users (name, age) VALUES (&#39;Bob&#39;, 20);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+------+-----+&#xA;| id | name | age |&#xA;+----+------+-----+&#xA;| 1  | John | 21  |&#xA;| 2  | Bob  | 20  |&#xA;+----+------+-----+&#xA;&#xA;sqlite&gt; UPDATE users SET age = 17 where id = 2;&#xA;Runtime error: CHECK constraint failed: age &gt;= 18 (19)&#xA;sqlite&gt;&#xA;```&#xA;&#xA;As you would see, the update query failed as a `CHECK` constraint failed.&#xA;&#xA;## When it is checked?&#xA;&#xA;As we saw it is checked before the row is inserted or updated.&#xA;&#xA;## Disabling CHECK constraint&#xA;&#xA;We can disable the `CHECK` constraint on all the tables in the database by setting the `PRAGMA` of `ignore_check_constraints` to `TRUE`:&#xA;&#xA;```sql&#xA;PRAGMA ignore_check_constraints = TRUE;&#xA;```&#xA;&#xA;This will disable all the `CHECK` constraints on all the tables in the database.&#xA;&#xA;Let&#39;s try again updating the user&#39;s age with less then 18:&#xA;&#xA;```sql&#xA;UPDATE users SET age = 17 WHERE id = 2;&#xA;```&#xA;&#xA;This time, it readily updates the age to less then 18, without failing the constraint, which means the constraint was disable or shunned down.&#xA;&#xA;```&#xA;sqlite&gt; UPDATE users SET age = 17 where id = 2;&#xA;Runtime error: CHECK constraint failed: age &gt;= 18 (19)&#xA;sqlite&gt; PRAGMA ignore_check_constraints = TRUE;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+------+-----+&#xA;| id | name | age |&#xA;+----+------+-----+&#xA;| 1  | John | 21  |&#xA;| 2  | Bob  | 20  |&#xA;+----+------+-----+&#xA;sqlite&gt; UPDATE users SET age = 17 where id = 2;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+------+-----+&#xA;| id | name | age |&#xA;+----+------+-----+&#xA;| 1  | John | 21  |&#xA;| 2  | Bob  | 17  |&#xA;+----+------+-----+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Similarly the inserts will be allowed if the constraint is disabled.&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age) VALUES (&#39;Harry&#39;, 14);&#xA;```&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO users (name, age) VALUES (&#39;Harry&#39;, 14);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+----+-------+-----+&#xA;| id | name  | age |&#xA;+----+-------+-----+&#xA;| 1  | John  | 21  |&#xA;| 2  | Bob   | 17  |&#xA;| 3  | Harry | 14  |&#xA;+----+-------+-----+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;## Table level check constraint&#xA;&#xA;The `CHECK` constraint can be applied to a table too, in fact it doesn&#39;t really matter you add it to a column or a table, as it will be evaluated for insertion or updation of the column and it&#39;s not tied to a column.&#xA;&#xA;Let&#39;s take a better example:&#xA;&#xA;```sql&#xA;CREATE TABLE accounts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    account_type TEXT NOT NULL,&#xA;    balance INTEGER NOT NULL,&#xA;    CHECK (&#xA;        (account_type = &#39;savings&#39; AND balance &gt;= 0)&#xA;        OR (account_type = &#39;loan&#39; AND balance &lt;= 0)&#xA;    )&#xA;);&#xA;```&#xA;&#xA;Here, we have a `CHECK` constraint that checks if the account type is `savings` and balance is greater than or equal to 0, or if the account type is `loan` and balance is less than or equal to 0.&#xA;&#xA;So we are combining two columns to form a condition and check if the row is actually valid or not to be inserted.&#xA;&#xA;Let&#39;s insert a few rows:&#xA;&#xA;```sql&#xA;INSERT INTO accounts (account_type, balance) VALUES (&#39;savings&#39;, 1000);&#xA;INSERT INTO accounts (account_type, balance) VALUES (&#39;loan&#39;, -1000);&#xA;```&#xA;This will insert readily the `savings` and the `loan` account as the constraint passes.&#xA;&#xA;However if we try to do the opposite and make the constraint check fail.&#xA;&#xA;```sql&#xA;INSERT INTO accounts (account_type, balance) VALUES (&#39;savings&#39;, -1000);&#xA;```&#xA;&#xA;```sql&#xA;INSERT INTO accounts (account_type, balance) VALUES (&#39;loan&#39;, 1000);&#xA;```&#xA;&#xA;It will fail as the check condition is not TRUE anymore for both the cases.&#xA;&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO accounts (account_type, balance) VALUES (&#39;savings&#39;, 1000);&#xA;sqlite&gt; INSERT INTO accounts (account_type, balance) VALUES (&#39;loan&#39;, -1000);&#xA;sqlite&gt; INSERT INTO accounts (account_type, balance) VALUES (&#39;loan&#39;, 1000);&#xA;Runtime error: CHECK constraint failed: (account_type = &#39;savings&#39; AND balance &gt;= 0)&#xA;        OR (account_type = &#39;loan&#39; AND balance &lt;= 0) (19)&#xA;sqlite&gt; INSERT INTO accounts (account_type, balance) VALUES (&#39;savings&#39;, -1000);&#xA;Runtime error: CHECK constraint failed: (account_type = &#39;savings&#39; AND balance &gt;= 0)&#xA;        OR (account_type = &#39;loan&#39; AND balance &lt;= 0) (19)&#xA;sqlite&gt;&#xA;```&#xA;As you can see the `CHECK` condition failed for both the cases.&#xA;&#xA;&#xA;## Check constraint values&#xA;&#xA;Note, here the value will be either `TRUE` or `FALSE`. But what about other values? NULL, 0, ?&#xA;&#xA;That brings us to the fundamental of how `CHECK` considers the values as `TRUE` and `FALSE`.&#xA;&#xA;From the documentation:&#xA;&#xA;&gt; If the result is zero (integer value 0 or real value 0.0), then a constraint violation has occurred.&#xA;&gt; If the CHECK expression evaluates to NULL, or any other non-zero value, it is not a constraint violation&#xA;&#xA;&#xA;So, its not really `TRUE` or `FALSE` but:&#xA;- `TRUE`: is any non-zero value or `NULL` (if a condition is true, it is set as `1`)&#xA;- `FALSE`: is `0` (if a condition is false, it is set as `0`)&#xA;&#xA;So, let&#39;s create a few tables with different `CHECK` constraints having different values for the check constraint:&#xA;&#xA;```sql&#xA;CREATE TABLE test (&#xA;    val INTEGER,&#xA;    CHECK(val)&#xA;);&#xA;```&#xA;Now, let&#39;s insert some values&#xA;&#xA;The below query will evaluate to false, hence failing the constraint.&#xA;```sql&#xA;INSERT INTO test(val) VALUES (0);&#xA;```&#xA;&#xA;The value is `1` which is a non-zero value, hence passing the constraint.&#xA;```sql&#xA;INSERT INTO test(val) VALUES (1);&#xA;```&#xA;&#xA;Here the value is `0.000` which is still zero, hence failing the constraint.&#xA;```sql&#xA;INSERT INTO test(val) VALUES (0.000);&#xA;```&#xA;&#xA;The value here is `0.0001` which is a non-zero value, hence passing the constraint.&#xA;```sql&#xA;INSERT INTO test(val) VALUES (0.0001);&#xA;```&#xA;&#xA;The `FALSE` is alias for `0` hence failing the constraint.&#xA;```sql&#xA;INSERT INTO test(val) VALUES (FALSE);&#xA;```&#xA;&#xA;Similarly, `TRUE` is an alias for `1` hence passing the constraint.&#xA;&#xA;```sql&#xA;INSERT INTO test(val) VALUES (TRUE);&#xA;```&#xA;&#xA;&#xA;The empty string is casted as numeric, it evaluates to `0`, hence failing the constraint.&#xA;```sql&#xA;INSERT INTO test(val) VALUES (&#39;&#39;);&#xA;```&#xA;&#xA;Similarly, the string `&#39;a&#39;` is casted as numeric, it evaluates to `0`, hence failing the constraint.&#xA;```sql&#xA;INSERT INTO test(val) VALUES (&#39;a&#39;);&#xA;```&#xA;&#xA;Here&#39;s the log, the SQLog :)&#xA;&#xA;```sql&#xA;sqlite&gt; CREATE TABLE test (&#xA;    val INTEGER,&#xA;    CHECK(val)&#xA;);&#xA;sqlite&gt; INSERT INTO test(val) VALUES (0);&#xA;Runtime error: CHECK constraint failed: val (19)&#xA;sqlite&gt; INSERT INTO test(val) VALUES (1);&#xA;sqlite&gt; INSERT INTO test(val) VALUES (0.000);&#xA;Runtime error: CHECK constraint failed: val (19)&#xA;sqlite&gt; INSERT INTO test(val) VALUES (0.0001);&#xA;sqlite&gt; INSERT INTO test(val) VALUES (FALSE);&#xA;Runtime error: CHECK constraint failed: val (19)&#xA;sqlite&gt; INSERT INTO test(val) VALUES (TRUE);&#xA;sqlite&gt; INSERT INTO test(val) VALUES (&#39;&#39;);&#xA;Runtime error: CHECK constraint failed: val (19)&#xA;sqlite&gt; INSERT INTO test(val) VALUES (&#39;a&#39;);&#xA;Runtime error: CHECK constraint failed: val (19)&#xA;sqlite&gt; INSERT INTO test(val) VALUES (124);&#xA;sqlite&gt; SELECT * FROM test;&#xA;+--------+&#xA;|  val   |&#xA;+--------+&#xA;| 1      |&#xA;| 0.0001 |&#xA;| 1      |&#xA;| 124    |&#xA;+--------+&#xA;sqlite&gt;&#xA;&#xA;sqlite&gt; INSERT INTO test(val) VALUES (NULL);&#xA;sqlite&gt; INSERT INTO test DEFAULT VALUES;&#xA;sqlite&gt; SELECT * FROM test;&#xA;+--------+&#xA;|  val   |&#xA;+--------+&#xA;| 1      |&#xA;| 0.0001 |&#xA;| 1      |&#xA;| 124    |&#xA;|        |&#xA;|        |&#xA;+--------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Now, you might be wondering why the heck `&#39;a&#39;` failed? Well, becuase casting strings in numeric form, will evaluate to `0`&#xA;&#xA;```sql&#xA;SELECT CAST(&#39;a&#39; AS NUMERIC);&#xA;```&#xA;&#xA;A wired quirk but worth noting, so won&#39;t work with strings, need to cast or perform better checks for string related values.&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO test(val) VALUES (&#39;a&#39;);&#xA;Runtime error: CHECK constraint failed: val (19)&#xA;sqlite&gt; SELECT CAST(&#39;a&#39; AS NUMERIC);&#xA;+----------------------+&#xA;| CAST(&#39;a&#39; AS NUMERIC) |&#xA;+----------------------+&#xA;| 0                    |&#xA;+----------------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;So that is it from the basic walkthrough of the `CHECK` constraint.&#xA;&#xA;Some TLDRs:&#xA;1. The `CHECK` clause is a column constraint that allows us to define certain conditions that we want to evaluate on the column(s) before inserting/updating the row.&#xA;2. The constraint is table wide, as it boils down to inserting/updating or not inserting/updating the row.&#xA;3. The `CHECK` constraint is evaluated before the row is inserted/updated.&#xA;4. The value of the conditions is evaluated as a `NUMERIC` value so any value is `TRUE` if it is not `0`, even `NULL` is true, and `FALSE` if it is `0`.&#xA;5. The `CHECK` constraint can be disabled using the `PRAGMA` command `PRAGMA ignore_check_constraints = TRUE;` or `PRAGMA ignore_check_constraints = ON;` `ON`, `TRUE`, either works.&#xA; &#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: GENERATED column constraint</title>
      <link>https://meetgor.com/sqlite-generated-column-constraint</link>
      <description></description>
      <pubDate>Thu, 11 Sep 2025 00:00:00 UTC</pubDate>
      <content>## The GENERATED column constraint&#xA;&#xA;We saw certain limitations of the `DEFAULT` column constraint clause, that it can&#39;t generate dynamic values based on other columns or some other dynamic popularities. For overcomming those kind of constraints, there is one more specific constraint, the [GENERATED](https://sqlite.org/gencol.html) column constraint.&#xA;&#xA;You can think of it as a `DEFAULT` but having more than static values, it is evaluated and computed each time a new row is inserted. However they come with one catch, you can&#39;t later update the values, you need to update the values of the dependent columns first, so it will generate **ALWAYS** a update is made to the row(relevant columns in that row).&#xA;&#xA;Let&#39;s create a simple table to understand the `GENERATED` column constraint:&#xA;&#xA;```sql&#xA;CREATE TABLE posts (&#xA;    id INTEGER PRIMARY KEY,&#xA;    content TEXT,&#xA;    word_count INTEGER GENERATED ALWAYS AS (length(content) - length(replace(content, &#39; &#39;, &#39;&#39;)) + 1),&#xA;    read_time_minutes INTEGER GENERATED ALWAYS AS (ceil(word_count / 200.0))&#xA;);&#xA;```&#xA;&#xA;The syntax of the `GENERATED` constraint is &#xA;&#xA;```&#xA;column_name &lt;type&gt; GENERATED ALWAYS AS &lt;expression&gt;&#xA;```&#xA;&#xA;Nothing fancy, just a content field as a text, then based on that value, the `word_count` and `read_time_minutes` is always calculated/generated based on the value of the `content` and the `read_time_minutes` is inturn dependent on the `word_count` value. So, the change in `content` will make a update on the `word_count` that will inturn update the `read_time_minutes`, like a chain reaction of sorts.&#xA;&#xA;Let&#39;s insert a sample post, note, we can&#39;t insert a generated value.&#xA;&#xA;```sql&#xA;INSERT INTO posts(content) VALUES(&#39;A sample post&#39;);&#xA;```&#xA;&#xA;This will create a record with the `id` as 1, the `content` as `A sample post`, and the `word_count` will be generated/calculated as the `(length(content) - length(replace(content, &#39; &#39;, &#39;&#39;))+1)` as the number of spaces + 1. The `read_time_minutes` is generated with the `word_count` divided by 200 which is the average word read in a minute by a human (let&#39;s not go into the nity-grity) but you can get the point of this. These are just mathematical values, and those are dependent on the value of the other columns of the same record/row.&#xA;&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;As, you can see here, the value of `word_count` is `3` and the value of `read_time_minutes` is `1`.&#xA;&#xA;Let&#39;s insert a few more values and check how these generated values behave.&#xA;&#xA;&#xA;Let&#39;s insert a bit longer text.&#xA;&#xA;```sql&#xA;INSERT INTO posts(content) VALUES(&#39;A SQLITE Post for the generated column constraint.&#39;);&#xA;```&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;As, you can see the value of the `word_count` is `8` and the value of `read_time_minutes` is `1`.&#xA;&#xA;Let&#39;s update the `content` and check if the `word_count` and the `read_time_minutes` are updated.&#xA;&#xA;```sql&#xA;UPDATE posts SET content = content || &#39;New content&#xA;some more content&#39; where id = 2;&#xA;&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;As you can see the value of the `word_count` is `11` and the value of `read_time_minutes` is `1` still. That is because, until we write `200` words it will ceil off to 1.&#xA;&#xA;Let&#39;s add a record with more than `200` words, and check if the `read_time_minutes` is updated.&#xA;&#xA;```sql&#xA;INSERT INTO posts(content) VALUES(&#39;New post&#39;);&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;The current value of the `word_count` is `2` and the `read_time_minutes` is `1`, let&#39;s update it by adding the value of `Adding some extra words here.`.&#xA;&#xA;```sql&#xA;UPDATE posts &#xA;    SET content = content || replace(&#xA;        printf(&#39;%200c&#39;, &#39; &#39;),&#xA;        &#39; &#39;,&#xA;        &#39; Adding some extra words here.&#39;&#xA;    )&#xA;WHERE id = 3;&#xA;```&#xA;&#xA;Ok, this might be too much, but let&#39;s break it down:&#xA;&#xA;- First, we are updating the `content` by adding the value of `Adding some extra words here.` to the end of the existing value of `content`.&#xA;- In the replace function, the parameters are original string, the value to replace, and the value to replace it with.&#xA;- So in this case, we are taking the string `printf(&#39;%200c&#39;, &#39; &#39;)`, which is a string of 200 spaces, basically adding a single space character, but it will be right-justified within a field of 200 characters.&#xA;- The second parameter is the character to replace, in this case it is single white space or `&#39; &#39;` character.&#xA;- The third parameter is the text to replace that `&#39; &#39;` space character with, here it is ` Adding some extra words here`.&#xA;- So, essentially we are taking `200` white spaces and adding ` Adding some extra words here.` for each space to the end of the existing value of `content`.&#xA;&#xA;Hence we will have around ~`200 * 5` words i.e. 1000 words, this way we can check the value of the `read_time_minutes` is updated.&#xA;&#xA;```sql&#xA;SELECT * FROM posts;&#xA;```&#xA;&#xA;As you can see the value of the `word_count` is `1002` and the value of `read_time_minutes` is `6`. That is perfect. And it is getting updated for each updation to the `content` column.&#xA;&#xA;Here&#39;s a step by step output log: Its a SQLog :)&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE posts (&#xA;   id INTEGER PRIMARY KEY,&#xA;   content TEXT,&#xA;   word_count INTEGER GENERATED ALWAYS AS (length(content) - length(replace(content, &#39; &#39;, &#39;&#39;)) + 1),&#xA;   read_time_minutes INTEGER GENERATED ALWAYS AS (ceil(word_count / 200.0))&#xA;);&#xA;sqlite&gt; .mode table&#xA;&#xA;sqlite&gt; INSERT INTO posts(content) VALUES(&#39;A sample post&#39;);&#xA;&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+---------------+------------+-------------------+&#xA;| id |    content    | word_count | read_time_minutes |&#xA;+----+---------------+------------+-------------------+&#xA;| 1  | A sample post | 3          | 1                 |&#xA;+----+---------------+------------+-------------------+&#xA;sqlite&gt; INSERT INTO posts(content) VALUES(&#39;A SQLITE Post for the generated column constraint.&#39;);&#xA;&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+----------------------------------------------------+------------+-------------------+&#xA;| id |                      content                       | word_count | read_time_minutes |&#xA;+----+----------------------------------------------------+------------+-------------------+&#xA;| 1  | A sample post                                      | 3          | 1                 |&#xA;| 2  | A SQLITE Post for the generated column constraint. | 8          | 1                 |&#xA;+----+----------------------------------------------------+------------+-------------------+&#xA;&#xA;sqlite&gt; UPDATE posts SET content = content || &#39;New content&#xA;&#39;  ...&gt; some more content&#39; where id = 2;&#xA;&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| id |                           content                            | word_count | read_time_minutes |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| 1  | A sample post                                                | 3          | 1                 |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| 2  | A SQLITE Post for the generated column constraint.New conten | 11         | 1                 |&#xA;|    | t                                                            |            |                   |&#xA;|    | some more content                                            |            |                   |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;&#xA;sqlite&gt; INSERT INTO posts(content) VALUES(&#39;New post&#39;);&#xA;&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| id |                           content                            | word_count | read_time_minutes |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| 1  | A sample post                                                | 3          | 1                 |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| 2  | A SQLITE Post for the generated column constraint.New conten | 11         | 1                 |&#xA;|    | t                                                            |            |                   |&#xA;|    | some more content                                            |            |                   |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| 3  | New post                                                     | 2          | 1                 |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;&#xA;sqlite&gt; UPDATE posts SET content = content || replace(printf(&#39;%200c&#39;, &#39; &#39;), &#39; &#39;, &#39; Adding some extra words here.&#39;) WHERE id = 3;&#xA;&#xA;sqlite&gt; SELECT * FROM posts;&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| id |                           content                            | word_count | read_time_minutes |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| 1  | A sample post                                                | 3          | 1                 |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| 2  | A SQLITE Post for the generated column constraint.New conten | 11         | 1                 |&#xA;|    | t                                                            |            |                   |&#xA;|    | some more content                                            |            |                   |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;| 3  | New post Adding some extra words here. Adding some extra wor | 1002       | 6                 |&#xA;|    | ds here. Adding some extra words here. Adding some extra wor |            |                   |&#xA;|    | ds here. Adding some extra words here. Adding some extra wor |            |                   |&#xA;|    |..............................................................|            |                   |&#xA;|    | ds here. Adding some extra words here. Adding some extra wor |            |                   |&#xA;|    | ds here.                                                     |            |                   |&#xA;+----+--------------------------------------------------------------+------------+-------------------+&#xA;&#xA;```&#xA;&#xA;## Generated columns cannot be updated manually&#xA;&#xA;If you tried to update the columns with `GENERATED ALWAYS` constraint, you will get a `constraint failed` error. As the constraint itself says, it is **GENERATED ALWAYS**, hence not to be updated or inserted.&#xA;&#xA;```sql&#xA;UPDATE posts SET word_count = 10 WHERE id = 1;&#xA;```&#xA;&#xA;It will fail with `cannot UPDATE generated column &#34;word_count&#34;` as mentioned.&#xA;&#xA;&#xA;```sql&#xA;UPDATE posts SET read_time_minutes = 10 WHERE id = 1;&#xA;```&#xA;&#xA;Similarly, this will also fail, as it is also a `GENERATED ALWAYS` constrained column.&#xA;&#xA;```&#xA;sqlite&gt; UPDATE posts SET word_count = 10 WHERE id = 1;&#xA;Parse error: cannot UPDATE generated column &#34;word_count&#34;&#xA;&#xA;sqlite&gt; UPDATE posts SET read_time_minutes = 10 WHERE id = 1;&#xA;Parse error: cannot UPDATE generated column &#34;read_time_minutes&#34;&#xA;```&#xA;&#xA;## STORED VS VIRTUAL &#xA;&#xA;Now, the Generated columns can be `STORED` as in stored in the database to the disk file, or they could be `VIRTUAL` as in computed (generated,calculated each time). There are trade-offs and I will definitely add the meme here `IT ACTUALLY DEPENDS`!&#xA;&#xA;The `STORED` column will take up space but the queries will be quick, since it doesn&#39;t need to calculate it each time, only it needs to do it at each updation (that can&#39;t be avoided).&#xA;The `VIRTUAL` column will not take up space but the queries will be a little slower, depending on the number of data to compute, since it doesn&#39;t store the column values, it will have to compute each time and it as well need to update it each time.&#xA;&#xA;&gt; The default is `VIRTUAL` if not specified.&#xA;&#xA;The commonality of `STORED` and `VIRTUAL` is that they are both updated at the updation of the column it relates to or the updation of the row, the only difference is that one stores it the other calculates it for each query made to it.&#xA;&#xA;We&#39;ll see the difference how is that the case, it generates each time in the case of the `VIRTUAL` column `GENERATED` constraint.&#xA;&#xA;I&#39;ll show the most basic example continuing with the same table, but with the `VIRTUAL` clause on the `GENERATED ALWAYS` constraint.&#xA;&#xA;### Virtual generated column&#xA;&#xA;By default, it is `VIRTUAL` it doesn&#39;t matter if you add it or not (let&#39;s add it to make it clear).&#xA;&#xA;I&#39;ll specify the `word_count` as the `VIRTUAL` column with the `GENERATED ALWAYS` constraint with the same formula to get the word count and at the end specify the `VIRTUAL` keyword (its optional).&#xA;&#xA;&gt; Let&#39;s skip the `read_time_minutes` for now, you can add it won&#39;t make it any difference (it was a little extreme example to use 200 words to update its value)&#xA;&#xA;```sql&#xA;CREATE TABLE posts_virtual (&#xA;   id INTEGER PRIMARY KEY,&#xA;   content TEXT,&#xA;   word_count INTEGER GENERATED ALWAYS AS (&#xA;     length(content) - length(replace(content, &#39; &#39;, &#39;&#39;)) + 1&#xA;   ) VIRTUAL&#xA;);&#xA;```&#xA;Now, we&#39;ll add some data to the table and check the value of the `word_count` column.&#xA;&#xA;```sql&#xA;INSERT INTO posts_virtual(content) VALUES(&#39;A sample post&#39;);&#xA;INSERT INTO posts_virtual(content) VALUES(&#39;A SQLITE Post for the virtual generated column constraint.&#39;);&#xA;SELECT * FROM posts_virtual;&#xA;```&#xA;&#xA;This we already know, the plain old `word_count` is `3` and `9` for the two posts respectively.&#xA;&#xA;But let&#39;s see how is the `word_count` column is actually stored and how slow or fast it actually is.&#xA;&#xA;```sql&#xA;PRAGMA table_info(posts_virtual);&#xA;```&#xA;&#xA;HH? There is no `word_count` column here, it is not stored, it is a `VIRTUAL` column.&#xA;&#xA;```&#xA;sqlite&gt; PRAGMA table_info(posts_virtual);&#xA;+-----+---------+---------+---------+------------+----+&#xA;| cid |  name   |  type   | notnull | dflt_value | pk |&#xA;+-----+---------+---------+---------+------------+----+&#xA;| 0   | id      | INTEGER | 0       |            | 1  |&#xA;| 1   | content | TEXT    | 0       |            | 0  |&#xA;+-----+---------+---------+---------+------------+----+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;What about extra info?&#xA;&#xA;```sql&#xA;PRAGMA table_xinfo(posts_virtual);&#xA;```&#xA;Yes, that is indeed there, and its hidden? Nope, its `generated` a special type.&#xA;- `0` is not hidden&#xA;- `1` is hidden&#xA;- `2` is generated&#xA;&#xA;```&#xA;sqlite&gt; PRAGMA table_xinfo(posts_virtual);&#xA;+-----+------------+---------+---------+------------+----+--------+&#xA;| cid |    name    |  type   | notnull | dflt_value | pk | hidden |&#xA;+-----+------------+---------+---------+------------+----+--------+&#xA;| 0   | id         | INTEGER | 0       |            | 1  | 0      |&#xA;| 1   | content    | TEXT    | 0       |            | 0  | 0      |&#xA;| 2   | word_count | INTEGER | 0       |            | 0  | 2      |&#xA;+-----+------------+---------+---------+------------+----+--------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;It&#39;s time to benchmark it then, let&#39;s bulk insert 100000 posts.&#xA;&#xA;&#xA;```sql&#xA;WITH RECURSIVE cnt(x) AS (&#xA;  SELECT 1&#xA;  UNION ALL&#xA;  SELECT x+1 FROM cnt WHERE x &lt; 100000&#xA;)&#xA;INSERT INTO posts_virtual(content)&#xA;SELECT &#39;This is a sample post number &#39; || x || &#39; with some words repeated multiple times.&#39;&#xA;FROM cnt;&#xA;```&#xA;&#xA;If we see now the `posts_virtual` table has over 100000 rows.&#xA;&#xA;```sql&#xA;SELECT COUNT(*) FROM posts_virtual;&#xA;```&#xA;&#xA;We already had `2` records, and we added `100000` more, so the total is `100002`.&#xA;&#xA;Let&#39;s check the sum of the `word_count` to be sure it inserted it right.&#xA;&#xA;```sql&#xA;SELECT SUM(word_count) FROM posts_virtual;&#xA;```&#xA;&#xA;Ok that shows the sum of the `word_count` is `1300012`.&#xA;&#xA;Let&#39;s check with the timer on and evaluate the query.&#xA;&#xA;```&#xA;sqlite&gt; WITH RECURSIVE cnt(x) AS (&#xA;  SELECT 1&#xA;  UNION ALL&#xA;  SELECT x+1 FROM cnt WHERE x &lt; 100000&#xA;)&#xA;INSERT INTO posts_virtual(content)&#xA;SELECT &#39;This is a sample post number &#39; || x || &#39; with some words repeated multiple times.&#39;&#xA;FROM cnt;&#xA;&#xA;sqlite&gt; PRAGMA table_xinfo(posts_virtual);&#xA;+-----+------------+---------+---------+------------+----+--------+&#xA;| cid |    name    |  type   | notnull | dflt_value | pk | hidden |&#xA;+-----+------------+---------+---------+------------+----+--------+&#xA;| 0   | id         | INTEGER | 0       |            | 1  | 0      |&#xA;| 1   | content    | TEXT    | 0       |            | 0  | 0      |&#xA;| 2   | word_count | INTEGER | 0       |            | 0  | 2      |&#xA;+-----+------------+---------+---------+------------+----+--------+&#xA;&#xA;sqlite&gt; .timer on&#xA;&#xA;sqlite&gt; SELECT COUNT(*) FROM posts_virtual;&#xA;+----------+&#xA;| COUNT(*) |&#xA;+----------+&#xA;| 100002   |&#xA;+----------+&#xA;Run Time: real 0.001 user 0.000352 sys 0.000103&#xA;&#xA;sqlite&gt; SELECT SUM(word_count) FROM posts_virtual;&#xA;+-----------------+&#xA;| SUM(word_count) |&#xA;+-----------------+&#xA;| 1300012         |&#xA;+-----------------+&#xA;Run Time: real 0.041 user 0.040682 sys 0.000418&#xA;&#xA;sqlite&gt; PRAGMA page_count;&#xA;+------------+&#xA;| page_count |&#xA;+------------+&#xA;| 2086       |&#xA;+------------+&#xA;Run Time: real 0.000 user 0.000000 sys 0.000078&#xA;&#xA;sqlite&gt; PRAGMA page_size;&#xA;+-----------+&#xA;| page_size |&#xA;+-----------+&#xA;| 4096      |&#xA;+-----------+&#xA;Run Time: real 0.000 user 0.000025 sys 0.000006&#xA;&#xA;sqlite&gt; UPDATE posts_virtual SET content = content || &#39; extra text&#39; WHERE id % 1000 = 0;&#xA;Run Time: real 0.010 user 0.009353 sys 0.000161&#xA;```&#xA;&#xA;I think we&#39;ll leave it here and move onto creating the `STORED` column as a generated value&#xA;&#xA;### Stored generated column&#xA;&#xA;Similar to the `VIRTUAL` column, we&#39;ll create the `STORED` column with the `GENERATED ALWAYS` constraint.&#xA;&#xA;This will be the same table named as `posts_stored` but with the `word_count` being a `STORED` column rather than a `VIRTUAL` column.&#xA;&#xA;```sql&#xA;CREATE TABLE posts_stored (&#xA;   id INTEGER PRIMARY KEY,&#xA;   content TEXT,&#xA;   word_count INTEGER GENERATED ALWAYS AS (&#xA;     length(content) - length(replace(content, &#39; &#39;, &#39;&#39;)) + 1&#xA;   ) STORED&#xA;);&#xA;```&#xA;Now, we&#39;ll add some data to the table.&#xA;&#xA;```sql&#xA;INSERT INTO posts_stored(content) VALUES(&#39;A sample post&#39;);&#xA;INSERT INTO posts_stored(content) VALUES(&#39;A SQLITE Post for the virtual generated column constraint.&#39;);&#xA;SELECT * FROM posts_stored;&#xA;```&#xA;This is cool, working as expected, we have already seen it, we need to take a look at how this values are stored now.&#xA;&#xA;Let&#39;s take a look at the `table_info` for the `posts_stored` table.&#xA;&#xA;```sql&#xA;PRAGMA table_info(posts_stored);&#xA;```&#xA;It still doesn&#39;t have the `GENERATED` column `word_count`.&#xA;&#xA;Let&#39;s take a look at the `table_xinfo` for the `posts_stored` table.&#xA;&#xA;```sql&#xA;PRAGMA table_xinfo(posts_stored);&#xA;```&#xA;&#xA;Ok, wiredly it has the `GENERATED ALWAYS` column `word_count` as well but the `hidden` value is `3`.&#xA;&#xA;We knew it was `2` for hidden but `3` is for? You guessed it right, stored and generated column.&#xA;&#xA;Now, let&#39;s also populate the `posts_stored` table with some data, bulk inserting the data.&#xA;&#xA;Let&#39;s add `100000` rows in it.&#xA;&#xA;```sql&#xA;WITH RECURSIVE cnt(x) AS (&#xA;  SELECT 1&#xA;  UNION ALL&#xA;  SELECT x+1 FROM cnt WHERE x &lt; 100000&#xA;)&#xA;INSERT INTO posts_stored(content)&#xA;SELECT &#39;This is a sample post number &#39; || x || &#39; with some words repeated multiple times.&#39;&#xA;FROM cnt;&#xA;```&#xA;This is the same query except its inserting in the `posts_stored` table.&#xA;&#xA;Let&#39;s check if it has inserted the right number of rows.&#xA;&#xA;```sql&#xA;SELECT COUNT(*) FROM posts_stored;&#xA;```&#xA;&#xA;Indeed there are `100000` rows in the `posts_stored` table.&#xA;&#xA;Now, let&#39;s verify that the inserted values are rightly populated.&#xA;&#xA;```sql&#xA;SELECT SUM(word_count) FROM posts_stored;&#xA;```&#xA;&#xA;This gives `1300012` as the sum of the `word_count` from the `posts_stored` table. Which matches the sum of the `word_count` from the `posts_virtual` table.&#xA;&#xA;```sql&#xA;sqlite&gt; CREATE TABLE posts_stored (&#xA;   id INTEGER PRIMARY KEY,&#xA;   content TEXT,&#xA;   word_count INTEGER GENERATED ALWAYS AS (&#xA;     length(content) - length(replace(content, &#39; &#39;, &#39;&#39;)) + 1&#xA;   ) STORED&#xA;);&#xA;Run Time: real 0.000 user 0.000258 sys 0.000027&#xA;&#xA;sqlite&gt; INSERT INTO posts_stored(content) VALUES(&#39;A sample post&#39;);&#xA;sqlite&gt; INSERT INTO posts_stored(content) VALUES(&#39;A SQLITE Post for the virtual generated column constraint.&#39;);&#xA;&#xA;SELECT * FROM posts_stored;&#xA;+----+------------------------------------------------------------+------------+&#xA;| id |                          content                           | word_count |&#xA;+----+------------------------------------------------------------+------------+&#xA;| 1  | A sample post                                              | 3          |&#xA;| 2  | A SQLITE Post for the virtual generated column constraint. | 9          |&#xA;+----+------------------------------------------------------------+------------+&#xA;Run Time: real 0.000 user 0.000224 sys 0.000000&#xA;&#xA;sqlite&gt; PRAGMA table_info(posts_stored);&#xA;+-----+---------+---------+---------+------------+----+&#xA;| cid |  name   |  type   | notnull | dflt_value | pk |&#xA;+-----+---------+---------+---------+------------+----+&#xA;| 0   | id      | INTEGER | 0       |            | 1  |&#xA;| 1   | content | TEXT    | 0       |            | 0  |&#xA;+-----+---------+---------+---------+------------+----+&#xA;&#xA;sqlite&gt; PRAGMA table_xinfo(posts_stored);&#xA;+-----+------------+---------+---------+------------+----+--------+&#xA;| cid |    name    |  type   | notnull | dflt_value | pk | hidden |&#xA;+-----+------------+---------+---------+------------+----+--------+&#xA;| 0   | id         | INTEGER | 0       |            | 1  | 0      |&#xA;| 1   | content    | TEXT    | 0       |            | 0  | 0      |&#xA;| 2   | word_count | INTEGER | 0       |            | 0  | 3      |&#xA;+-----+------------+---------+---------+------------+----+--------+&#xA;Run Time: real 0.000 user 0.000013 sys 0.000322&#xA;&#xA;sqlite&gt; SELECT COUNT(*) FROM posts_stored;&#xA;+----------+&#xA;| COUNT(*) |&#xA;+----------+&#xA;| 2        |&#xA;+----------+&#xA;Run Time: real 0.000 user 0.000108 sys 0.000012&#xA;&#xA;sqlite&gt; WITH RECURSIVE cnt(x) AS (&#xA;  SELECT 1&#xA;  UNION ALL&#xA;  SELECT x+1 FROM cnt WHERE x &lt; 100000&#xA;)&#xA;INSERT INTO posts_stored(content)&#xA;SELECT &#39;This is a sample post number &#39; || x || &#39; with some words repeated multiple times.&#39;&#xA;FROM cnt;&#xA;Run Time: real 0.071 user 0.067858 sys 0.002929&#xA;&#xA;sqlite&gt; SELECT COUNT(*) FROM posts_stored;&#xA;+----------+&#xA;| COUNT(*) |&#xA;+----------+&#xA;| 100002   |&#xA;+----------+&#xA;Run Time: real 0.000 user 0.000367 sys 0.000000&#xA;&#xA;sqlite&gt; SELECT SUM(word_count) FROM posts_stored;&#xA;+-----------------+&#xA;| SUM(word_count) |&#xA;+-----------------+&#xA;| 1300012         |&#xA;+-----------------+&#xA;Run Time: real 0.008 user 0.006492 sys 0.000941&#xA;```&#xA;&#xA;This is all setup for the comparison of both the tables.&#xA;&#xA;### The difference&#xA;&#xA;Now, let&#39;s check the difference between the `STORED` and `VIRTUAL` column.&#xA;&#xA;Let&#39;s sum the `word_count` from each of the tables `posts_stored` and `posts_virtual`&#xA;&#xA;First, lets set the timer on, which will give the breakdown of the time for each ran query.&#xA;&#xA;```&#xA;.timer on&#xA;```&#xA;The timer will give three time durations, the real, user and the system.&#xA;The breakdown is like this:&#xA;- real time : The full clock time form the start to the end of the query&#xA;- user time : The CPU time in the user space (I/O) operations on the sqlite side, computations on the obtained data, or preprocessing the data before inserting.&#xA;- system time: The CPU time in the kernel space (I/O) operations on the host side, it could be reading or writing to the actual db file, etc.&#xA;&#xA;And then run the query for the `posts_stored` table.&#xA;&#xA;```sql&#xA;SELECT SUM(word_count) FROM posts_stored;&#xA;```&#xA;&#xA;This is giving the result in around `~0.008` seconds might be approximately `0.01` in certain cases.&#xA;We can even get the breakdown of the time for each ran query.&#xA;- full query execution time: `0.008`&#xA;- user time: `0.006492`&#xA;- system time: `0.000941`&#xA;&#xA;So, here in this case, the system and user time are around the same, however there is some system time for reading from the database file.&#xA;&#xA;And then run the query for the `posts_virtual` table.&#xA;&#xA;```sql&#xA;SELECT SUM(word_count) FROM posts_virtual;&#xA;```&#xA;&#xA;This is giving the result in around `~0.039` seconds might be approximately `0.04` in certain cases.&#xA;&#xA;We can even get the breakdown of the time for each ran query.&#xA;- full query execution time: `0.039`&#xA;- user time: `0.039366`&#xA;- system time: `0.000000` this can go sometimes to `0.000652`, almost negligible, but if it happens, in that case the full query time will increase by a bit.&#xA;&#xA;So, it is taking a quite lot of time in the user space by the CPU right?&#xA;And almost 0 time in the kernel level (disk operation) to read from the database file.&#xA;&#xA;That is so clear, as this is a virtual column, and we are only reading a single column, and that too is a virtual column, we don&#39;t need to hit a read to the database file. Clever right? But that costs some CPU to compute the sum for the `100002` rows. &#xA;&#xA;This is the trade-off&#xA;&#xA;- Time spent on the CPU on the computation vs the time spent on the disk operation to read the data.&#xA;- These can be different depending on the query.&#xA;&#xA;```sql&#xA;sqlite&gt; SELECT SUM(word_count) FROM posts_stored;&#xA;+-----------------+&#xA;| SUM(word_count) |&#xA;+-----------------+&#xA;| 1300012         |&#xA;+-----------------+&#xA;Run Time: real 0.008 user 0.006492 sys 0.000941&#xA;&#xA;sqlite&gt; SELECT SUM(word_count) FROM posts_virtual;&#xA;+-----------------+&#xA;| SUM(word_count) |&#xA;+-----------------+&#xA;| 1300012         |&#xA;+-----------------+&#xA;Run Time: real 0.039 user 0.039366 sys 0.000000&#xA;```&#xA;&#xA;You can clearly see the difference, the `STORED` column is almost `4` to `5` times faster than the `VIRTUAL` column.&#xA;&#xA;### Key observations&#xA;&#xA;1. If you have lot of processing to do in the generated column, better to go with the `STORED` column.&#xA;2. If you have a lot of data to compute and not necessarily complex, better to go with the `VIRTUAL` column.&#xA;3. It really depends on the data too, and we cannot say which one is better over the other without knowing the structure and the design of the queries.&#xA;&#xA;&#xA;There are lot of details as well beyond this, it will require specific guides on how to do certain things and busting certain myths in the documentation.&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: DEFAULT column constraint</title>
      <link>https://meetgor.com/sqlite-default-column-constraint</link>
      <description></description>
      <pubDate>Wed, 10 Sep 2025 00:00:00 UTC</pubDate>
      <content>## DEFAULT Constraint&#xA;&#xA;The `DEFAULT` constraint in SQLite is used to specify a default value for a column, if not provided, then the column will be populated with the `NULL` value as the default value. &#xA;&#xA;According to the docs:&#xA;&#xA;&gt; The DEFAULT clause specifies a default value to use for the column if no value is explicitly provided by the user when doing an INSERT. If there is no explicit DEFAULT clause attached to a column definition, then the default value of the column is NULL. &#xA;&#xA;NOTE: This constraint doesn&#39;t guard a `NULL` value, it only prevents the initial insert (or new record creation) of a `NULL` value, you can update the column later with a `NULL` value. It only is used to override the default `NULL` value, by providing a different one.&#xA;&#xA;The `DEFAULT` constraint can only take constant values, and it can&#39;t deduce or dynamically store values at the time of creation, if you want that kind of default values, then the other constraint [GENERATED ALWAYS](https://sqlite.org/lang_createtable.html#the_generated_always_as_clause) would help.&#xA;&#xA;&gt; Also, DEFAULT might not be a constraint, its just a clause or a column constraint clause.&#xA;&#xA;## Creating a Table with a DEFAULT Constraint&#xA;&#xA;The general syntax for creating a default constraint is basically the `DEFAULT` keyword, followed by the actual literal value.&#xA;&#xA;In the below example, let&#39;s create a dummy users table, with the `country_code` and `followers` as the columns, and their default values as `US` and `0` respectively. Note that the value can be wrapped in a `()` but it&#39;s not a expression so we can avoid it. However, writing the value in the `()` makes it more redable I think.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    username TEXT NOT NULL UNIQUE,&#xA;    country_code TEXT DEFAULT &#39;US&#39;,&#xA;    followers INTEGER DEFAULT 0&#xA;);&#xA;```&#xA;&#xA;Once we have a table with columns having default values, we can avoid inserting the values each time, as the default values will be populated.&#xA;&#xA;```sql&#xA;INSERT INTO users(username) VALUES(&#39;alice&#39;);&#xA;```&#xA;&#xA;Now, we have inserted a row with the `username` as `alice`, and the `country_code` and `followers` will be populated as the default values as they are not specified as `US` and `0` respectively.&#xA;&#xA;```sql &#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;It doens&#39;t mean that you can&#39;t add any other values, the default values will be used when you don&#39;t provide any value while inserting the row. In other words, the problem of seeing empty values (`NULL` values) when you don&#39;t specify will be gone, unless you update the record later explicitly with the `NULL` or empty values.&#xA;&#xA;```sql&#xA;INSERT INTO users(username, country_code) VALUES(&#39;bob&#39;, &#39;UK&#39;);&#xA;INSERT INTO users(username, country_code, followers) VALUES(&#39;ronaldo&#39;, &#39;PT&#39;, 100000);&#xA;```&#xA;&#xA;In the above queries, we can set the `country_code` or the `followers` if we want to insert a specific value in the `country_code` or the `followers` column. &#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;As you can see, it populates the values if provided, else uses the default values.&#xA;&#xA;&#xA;## Inserting default values &#xA;&#xA;If you want to create a record with all default values, you can specify the `DEFAULT VALUES` as the statement clause in the `INSERT` statement.&#xA;&#xA;For this to work, we need to have a default value for every column. If not specified it will be `NULL`, but if there are columns with `NOT NULL` or other constraint that needs to have some value from the user then we won&#39;t be able to insert the record without providing at least one value.&#xA;&#xA;```sql&#xA;INSERT INTO users DEFAULT VALUES;&#xA;```&#xA;This above statement will fail because we don&#39;t have any default value for the `username` column and it has a `NOT NULL` constraint, as discussed in the [NOT NULL Constraint blog post](https://www.meetgor.com/sqlog/sqlite-not-null-column-constraint/), we need to provide a value for that column in order to create a new record.&#xA;&#xA;So, it will only we suited, for tables having all values with some or the other values default or generated.&#xA;&#xA;Like the example below:&#xA;&#xA;```sql&#xA;CREATE TABLE documents (&#xA;    id INTEGER PRIMARY KEY,&#xA;    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,&#xA;    title TEXT DEFAULT &#39;Untitled&#39;,&#xA;    content TEXT DEFAULT &#39;Here goes the content&#39;&#xA;);&#xA;```&#xA;&#xA;In the above table, all the columns have one or the other `default` value, like `PRIMARY KEY` this is a alias for the underlying `rowid` column (if not mentioned explicitly or with combinational columns). The default value for `created_at` at is `CURRENT_TIMESTAMP` which will look in a second, the `title` and `content` has default value of `Untitled` and `Here foes the content` respectively.&#xA;&#xA;```sql&#xA;INSERT INTO documents DEFAULT VALUES;&#xA;```&#xA;&#xA;Now, we can insert the `DEFAULT VALUES` without any value specified in the `VALUES` or columns mentioned in the statement.&#xA;&#xA;```sql&#xA;SELECT * FROM documents;&#xA;```&#xA;&#xA;As you can see, now we can insert multiple rows with default values, and the unique id will keep the records in the `documents` table unique.&#xA;&#xA;## Defaults for Date and Time related columns&#xA;&#xA;There are special values or constant expression that can be used as default expressions like &#xA;&#xA;- `CURRENT_TIME`  value in the format `HH:MM:SS`&#xA;- `CURRENT_DATE` value in the format `YYYY-MM-DD`&#xA;- `CURRENT_TIMESTAMP` value in the format `YYYY-MM-DD HH:MM:SS`&#xA;&#xA;These values can be used as default values relating to date and time related columns which are mostly text related fields.&#xA;&#xA;```sql&#xA;CREATE TABLE documents (&#xA;    id INTEGER PRIMARY KEY,&#xA;    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,&#xA;    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,&#xA;    title TEXT DEFAULT &#39;Untitled&#39;,&#xA;    content TEXT DEFAULT &#39;Here goes the content&#39;&#xA;);&#xA;```&#xA;&#xA;The various values can be used here, like for instance, `created_at`, `updated_at` which can either be `CURRENT_TIMESTAMP` or just `CURRENT_DATE` depending on the use case.&#xA;&#xA;```sql&#xA;INSERT INTO documents DEFAULT VALUES;&#xA;```&#xA;&#xA;Here, it will insert a record with the `created_at` and `updated_at` as the current date and time values.&#xA;&#xA;```sql&#xA;SELECT * FROM documents;&#xA;```&#xA;&#xA;```&#xA;sqlite&gt; SELECT * FROM documents;&#xA;+----+---------------------+---------------------+----------+-----------------------+&#xA;| id |     created_at      |     updated_at      |  title   |        content        |&#xA;+----+---------------------+---------------------+----------+-----------------------+&#xA;| 1  | 2025-09-10 17:04:43 | 2025-09-10 17:04:43 | Untitled | Here goes the content |&#xA;+----+---------------------+---------------------+----------+-----------------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;As you can see, now we can insert multiple rows with default values, and the unique id will keep the records in the `documents` table unique.&#xA;&#xA;That&#39;s the basic we can use the `DEFAULT` constraint, you can add any expression as long as it produces a constant value for each of the records.&#xA; &#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: UNIQUE column constraint</title>
      <link>https://meetgor.com/sqlite-unique-column-constraint</link>
      <description></description>
      <pubDate>Tue, 09 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Unique Constraint&#xA;&#xA;The `UNIQUE` constraint ensures that a column in a table contains no duplicate values. Like, if you add an `UNIQUE` constraint to a column, then no two rows can have the exact/same value for that column.&#xA;&#xA;The documentation is more nuanced.&#xA;&#xA;&gt; A `UNIQUE` constraint is similar to a `PRIMARY KEY` constraint, **except** that a single table may have any number of `UNIQUE` constraints. For each `UNIQUE` constraint on the table, each row must contain a unique combination of values in the columns identified by the `UNIQUE` constraint. For the purposes of `UNIQUE` constraints, `NULL` values are considered distinct from all other values, including other NULLs. As with `PRIMARY KEY`s, a `UNIQUE` table-constraint clause must contain only column names — the use of expressions in an indexed-column of a `UNIQUE` table-constraint is not supported.&#xA;&#xA;There are three points to note, I&#39;ll simplify the points:&#xA;1. If you add an `UNIQUE` constraint to a column, then no two rows can have the exact/same value for that column in that table.&#xA;2. The `UNIQUE` constraint considers `NULL` values as distinct i.e. it cannot distinguish between two rows having `NULL` values, hence two rows will pass the `UNIQUE` constraint. (Better to use `UNIQUE` and `NOT NULL`)&#xA;3. The `UNIQUE` constraint is tied to one or more columns, so you cannot add custom expressions to the `UNIQUE` constraint. (Better to use `UNIQUE INDEX` to create custom expression-based uniqueness or index for querying data.)&#xA;&#xA;&#xA;## Adding a UNIQUE constraint&#xA;&#xA;To add a unique constraint to a column, simply add the `UNIQUE` keyword to the column definition:&#xA;&#xA;Let&#39;s keep the table simple with just three fields: `name`, `email`, and `age`.&#xA;&#xA;```sql&#xA;CREATE TABLE users (&#xA;    name TEXT,&#xA;    email TEXT UNIQUE,&#xA;    age INTEGER CHECK (age &gt; 0)&#xA;);&#xA;```&#xA;&#xA;Now, lets insert a few records&#xA;&#xA;```sql&#xA;INSERT INTO users (name, email, age) VALUES(&#39;alice&#39;, &#39;alice@wonderland.com&#39;, 12);&#xA;INSERT INTO users (name, email, age) VALUES(&#39;bob&#39;, &#39;bob@wonderland.com&#39;, 13);&#xA;```&#xA;&#xA;Now, lets try to insert a record with the existing email value:&#xA;&#xA;```sql&#xA;INSERT INTO users (name, email, age) VALUES(&#39;charlie&#39;, &#39;alice@wonderland.com&#39;, 14);&#xA;```&#xA;&#xA;This will immediately fail the `UNIQUE` constraint on the email, and the record will not be inserted.&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO users (name, email, age) VALUES(&#39;charlie&#39;, &#39;alice@wonderland.com&#39;, 14);&#xA;Runtime error: UNIQUE constraint failed: users.email (19)&#xA;```&#xA;&#xA;Notice, as the constraint is only on the email column, it&#39;s not on the name or age columns.&#xA;&#xA;```sql&#xA;INSERT INTO users (name, email, age) VALUES(&#39;alice&#39;, &#39;charlie@wonderland.com&#39;, 12);&#xA;&#xA;```&#xA;&#xA;This will succeed, as the `UNIQUE` constraint is only on the email column. Hence, we can conclude that the `UNIQUE` constraint is on a column level when stated next to the column while creating the table.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;```&#xA;+-------+------------------------+-----+&#xA;| name  |         email          | age |&#xA;+-------+------------------------+-----+&#xA;| alice | alice@wonderland.com   | 12  |&#xA;| bob   | bob@wonderland.com     | 13  |&#xA;| alice | charlie@wonderland.com | 12  |&#xA;+-------+------------------------+-----+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Let&#39;s understand the problem first with `NULL` values in UNIQUE constraint.&#xA;&#xA;## Adding a UNIQUE constraint with NULL values&#xA;&#xA;What if I insert a record with a `NULL` value for the `email` column?&#xA;&#xA;```sql&#xA;INSERT INTO users (name, email, age) VALUES(&#39;charlie&#39;, NULL, 14);&#xA;--OR&#xA;INSERT INTO users (name, age) VALUES(&#39;charlie&#39;, 14);&#xA;```&#xA;&#xA;That went in, it created the record, which is fine, so far, as there was no previous entry with `NULL` email in the table, or rather the `email` column.&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;However, what happens if we try to insert another record with a `NULL` value for the `email` column?&#xA;&#xA;```sql&#xA;INSERT INTO users (name, email, age) VALUES(&#39;dave&#39;, NULL, 15);&#xA;-- OR&#xA;INSERT INTO users (name, age) VALUES(&#39;dave&#39;, 15);&#xA;```&#xA;&#xA;This goes in as well, Hhh? It shouldn&#39;t have right? If `alice@wonderland.com` is not allowed twice then why should `NULL` be allowed?&#xA;&#xA;That&#39;s what the documentation clearly stated:&#xA;&#xA;&gt; For the purposes of `UNIQUE` constraints, `NULL` values are considered distinct from all other values, including other NULLs.&#xA;&#xA;That is clear as crystal, SQLite won&#39;t distinguish between two `NULL` values in the `email` column. Hence, we can&#39;t have duplicate `NULL` values in the `email` column.&#xA;&#xA;For that we need to set email as `NOT NULL` as well as `UNIQUE` inorder to avoid populating `NULL` values in the `email` column.&#xA;&#xA;&#xA;## Adding UNIQUE Constraint on multiple columns&#xA;&#xA;If you wondered, can we add unique constraint on multiple columns? Yes, we can and there are subtle variations on how you interpret those as, multiple as in two or more columns unique independently or the combination of two or more columns being unique.&#xA;&#xA;1. Unique constraint independent of each other&#xA;2. Combinational Unique constraint&#xA;&#xA;### Unique constraint independent of each other&#xA;&#xA;Let&#39;s say we want to add constraint to the user table, which could have more than one column that needs to be unique, like example, the `phone_number` for two users cannot be same, and so on.&#xA;&#xA;```sql&#xA;DROP TABLE users;&#xA;CREATE TABLE users (&#xA;    name TEXT,&#xA;    email TEXT UNIQUE,&#xA;    phone_number TEXT UNIQUE,&#xA;    government_id TEXT UNIQUE,&#xA;    age INTEGER CHECK (age &gt; 0),&#xA;    bio TEXT&#xA;);&#xA;```&#xA;In the above table schema, we have three unique constraints, `email`, `phone_number`, and `government_id`. Each unique constraint is independent of each other. Let&#39;s take a look at a few cases in order to understand it better.&#xA;&#xA;```sql&#xA;INSERT INTO users (name, email, phone_number, government_id, age, bio) &#xA;    VALUES(&#39;alice&#39;, &#39;alice@wonderland.com&#39;, &#39;1234567890&#39;, &#39;ABC123&#39;, 12, &#39;I am alice&#39;);&#xA;INSERT INTO users (name, email, phone_number, government_id, age, bio)&#xA;    VALUES(&#39;bob&#39;, &#39;bob@wonderland.com&#39;, &#39;1234567891&#39;, &#39;DEF456&#39;, 13, &#39;I am bob&#39;);&#xA;```&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;That is the simple case, However what would happen if one user has the same `phone_number`, and `government_id` but different `email`?&#xA;&#xA;```sql&#xA;INSERT INTO users (name, email, phone_number, government_id, age, bio)&#xA;    VALUES(&#39;alice&#39;, &#39;new_alice@wonderland.com&#39;, &#39;1234567890&#39;, &#39;ABC123&#39;, 12, &#39;I am alice&#39;);&#xA;```&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO users (name, email, phone_number, government_id, age, bio)&#xA;    VALUES(&#39;alice&#39;, &#39;new_alice@wonderland.com&#39;, &#39;1234567890&#39;, &#39;ABC123&#39;, 12, &#39;I am alice&#39;);&#xA;&#xA;Runtime error: UNIQUE constraint failed: users.government_id (19)&#xA;```&#xA;&#xA;Nope, it is independent of each constraint, no two rows can have the same `government_id` or `phone_number` and even the `email` column.&#xA;&#xA;Now, what if we want to allow `phone_number`, `government_id` and `email_id` to have a unique combination? Like the three of the columns together should be unique across the table, now with that they won&#39;t be unique across the single column, they are combined.&#xA;&#xA;### Combinational Unique constraint&#xA;&#xA;In a combinational unique constraint, we can add two or more columns like `UNIQUE(colum_1, column_2, ... column_n)` as a combinational constraint.&#xA;&#xA;In this type of constraint:&#xA;- Not necessarily each column needs to be unique, the combination of the `N` columns should be unique&#xA;&#xA;```sql&#xA;DROP TABLE users;&#xA;CREATE TABLE users (&#xA;    name TEXT,&#xA;    email TEXT NOT NULL,&#xA;    phone_number TEXT NOT NULL,&#xA;    government_id TEXT NOT NULL,&#xA;    age INTEGER CHECK (age &gt; 0),&#xA;    bio TEXT,&#xA;    UNIQUE(email, phone_number, government_id)&#xA;);&#xA;&#xA;-- OR&#xA;&#xA;-- CREATE TABLE users(&#xA;--     name TEXT,&#xA;--     email TEXT NOT NULL,&#xA;--     phone_number TEXT NOT NULL,&#xA;--     age INTEGER CHECK (age &gt; 0),&#xA;--     bio TEXT,&#xA;--     UNIQUE(email, phone_number)&#xA;-- );&#xA;```&#xA;&#xA;I am just making it up, its not secure, like combination of `email`, `phone_number` and `government_id` is not secure, you can debate about that, but it&#39;s  not a data-integrity and schema-design class, this post is about understanding the `UNIQUE` column constraint with combination of two or more columns.&#xA;&#xA;```sql&#xA;INSERT INTO users (name, email, phone_number, government_id, age, bio) &#xA;    VALUES(&#39;alice&#39;, &#39;alice@wonderland.com&#39;, &#39;1234567890&#39;, &#39;ABC123&#39;, 12, &#39;I am alice&#39;);&#xA;INSERT INTO users (name, email, phone_number, government_id, age, bio)&#xA;    VALUES(&#39;bob&#39;, &#39;bob@wonderland.com&#39;, &#39;1234567891&#39;, &#39;DEF456&#39;, 13, &#39;I am bob&#39;);&#xA;INSERT INTO users (name, email, phone_number, government_id, age, bio)&#xA;    VALUES(&#39;alice&#39;, &#39;new_alice@wonderland.com&#39;, &#39;1234567890&#39;, &#39;ABC123&#39;, 12, &#39;I am alice&#39;);&#xA;```&#xA;&#xA;```sql&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;That works! We have `1234567890` as the `phone_number` and `ABC123` as the `government_id` which is same, but `email` is different. So, the combination of `email`, `phone_number` and `government_id` is unique.&#xA;&#xA;&#xA;```&#xA;sqlite&gt; SELECT * FROM users;&#xA;+-------+--------------------------+--------------+---------------+-----+------------+&#xA;| name  |          email           | phone_number | government_id | age |    bio     |&#xA;+-------+--------------------------+--------------+---------------+-----+------------+&#xA;| alice | alice@wonderland.com     | 1234567890   | ABC123        | 12  | I am alice |&#xA;| bob   | bob@wonderland.com       | 1234567891   | DEF456        | 13  | I am bob   |&#xA;| alice | new_alice@wonderland.com | 1234567890   | ABC123        | 12  | I am alice |&#xA;+-------+--------------------------+--------------+---------------+-----+------------+&#xA;sqlite&gt; INSERT INTO users (name, email, phone_number, government_id, age, bio)&#xA;    VALUES(&#39;bob&#39;, &#39;new_alice@wonderland.com&#39;, &#39;0987654321&#39;, &#39;ABC123&#39;, 12, &#39;I am alice&#39;);&#xA;sqlite&gt; SELECT * FROM users;&#xA;+-------+--------------------------+--------------+---------------+-----+------------+&#xA;| name  |          email           | phone_number | government_id | age |    bio     |&#xA;+-------+--------------------------+--------------+---------------+-----+------------+&#xA;| alice | alice@wonderland.com     | 1234567890   | ABC123        | 12  | I am alice |&#xA;| bob   | bob@wonderland.com       | 1234567891   | DEF456        | 13  | I am bob   |&#xA;| alice | new_alice@wonderland.com | 1234567890   | ABC123        | 12  | I am alice |&#xA;| bob   | new_alice@wonderland.com | 0987654321   | ABC123        | 12  | I am alice |&#xA;+-------+--------------------------+--------------+---------------+-----+------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;```sql&#xA;INSERT INTO users (name, email, phone_number, government_id, age, bio)&#xA;    VALUES(&#39;alice&#39;, &#39;new_alice@wonderland.com&#39;, &#39;1234567890&#39;, &#39;ABC123&#39;, 12, &#39;I am alice&#39;);&#xA;```&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO users (name, email, phone_number, government_id, age, bio)&#xA;    VALUES(&#39;bob&#39;, &#39;new_alice@wonderland.com&#39;, &#39;0987654321&#39;, &#39;ABC123&#39;, 12, &#39;I am alice&#39;);&#xA;Runtime error: UNIQUE constraint failed: users.email, users.phone_number, users.government_id (19)&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Now this will fail, as the `email`, `phone_number`, `government_id` combination is already unique.&#xA;&#xA;&#xA;## Primary key vs Unique Constraint&#xA;&#xA;Both of these do the same thing, but `UNIQUE` can be added to multiple columns however, the `PRIMARY KEY` should only be one, but it can contain multiple columns. In other words, UNIQUE constraint is column-level, however each table can only have one `PRIMARY KEY` that will be used to indentify the uniqueness among the rows.&#xA;&#xA;```&#xA;PRIMARY KEY = UNIQUE + NOT NULL&#xA;```&#xA;Primary key is also a shorthand for `UNIQUE` and `NOT NULL`, if you add a `PRIMARY KEY` to a column or combination of columns for a table, you needn&#39;t specify `UNIQUE` and `NOT NULL`, it already does that for you.&#xA;&#xA;So, that is the general difference of `UNIQUE` and `PRIMARY KEY`, we&#39;ll explore the `PRIMARY KEY` in later posts.&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: NOT NULL column constraint</title>
      <link>https://meetgor.com/sqlite-not-null-column-constraint</link>
      <description></description>
      <pubDate>Mon, 08 Sep 2025 00:00:00 UTC</pubDate>
      <content>## NOT NULL Column constraint&#xA;&#xA;The `NOT NULL` constraint is a column-level constraint that will prevent the insertion/updation of a `NULL` value in that column record.&#xA;&#xA;What is `NULL`?&#xA;&#xA;In SQLite, specifically, a `NULL` is a value indicating that a value is not known or just not there.&#xA;&#xA;&gt; NOTE: NULL is not equal to `&#39;&#39;` empty string, `0` or `0.0` (zero), it&#39;s just cannot be compared to any value.&#xA;&#xA;Some additional notes on the `NOT NULL` constraint:&#xA;- If a column has a `NOT NULL` constraint, and it doesn&#39;t have any other constraint like `DEFAULT`, `GENERATED`, `PRIMARY KEY`, or `FOREIGN KEY`, and there is no provided value, it will fail the constraint (i.e. error out the query).&#xA;- Only if any of the other constraint populate the column while inserting the `NOT NULL` constraint will be satisfied.&#xA;&#xA;So, to take a simple iterative example, let&#39;s take the `users` table.&#xA;&#xA;```sql&#xA;CREATE TABLE users(&#xA;    name TEXT NOT NULL,&#xA;    age INTEGER CHECK(age &gt;= 0) NOT NULL,&#xA;    username TEXT UNIQUE NOT NULL,&#xA;    language TEXT DEFAULT &#39;en&#39;,&#xA;    country_code TEXT DEFAULT &#39;US&#39; NOT NULL,&#xA;    email TEXT UNIQUE GENERATED ALWAYS AS (username || &#39;@myapp.com&#39;)&#xA;);&#xA;```&#xA;Here we have 5 fields&#xA;&#xA;- `name` which cannot be empty(`NULL`)&#xA;- `age` which cannot be less than 0 or `NULL`&#xA;- `username` which needs to be unique and cannot be `NULL`&#xA;- `language` which has a default value of `en` but it can be `NULL`&#xA;- `country_code` which has a default value of `US` but it cannot be `NULL`&#xA;- `email` which has a default value of `username || &#39;@myapp.com&#39;` and it will be unique.&#xA;&#xA;&#xA;Let&#39;s look at a few examples:&#xA;&#xA;### Correct values&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age, username) VALUES (&#39;Alice&#39;, 25, &#39;alice&#39;);&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;### Duplicate username&#xA;&#xA;Won&#39;t allow duplicate username and `NULL` name fields&#xA;&#xA;```sql&#xA;INSERT INTO users (age, username) VALUES (25, &#39;alice&#39;);&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;### Border case for age&#xA;&#xA;Just par case for the `age` field as `0`&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age, username) VALUES (&#39;Bob&#39;, 0, &#39;bob&#39;);&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;### Invalid age check constraint&#xA;&#xA;The `age` is inserted as `-1` which will fail the `CHECK` constraint.&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age, username) VALUES (&#39;Bob&#39;, -1, &#39;bob&#39;);&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;### Age as null&#xA;&#xA;The `age` is inserted as `NULL` which will fail the `NOT NULL` constraint&#xA;&#xA;```sql&#xA;INSERT INTO users (name, username) VALUES (&#39;Bob&#39;, &#39;bob&#39;);&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;### Correct Values&#xA;&#xA;Will correctly populate the values.&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age, username) VALUES (&#39;John&#39;, 30, &#39;john&#39;);&#xA;INSERT INTO users (name, age, username) VALUES (&#39;Jim&#39;, 18, &#39;jim&#39;); &#xA;```&#xA;&#xA;### Duplicate email&#xA;&#xA;The email inserted will lead to duplicate and fail the `UNIQUE` constraint.&#xA;&#xA;```sql&#xA; INSERT INTO users (name, age, username, language) VALUES (&#39;Jim&#39;, 18, &#39;jim&#39;, &#39;fr&#39;);&#xA;```&#xA;&#xA;### Different country code&#xA;&#xA;Will correctly populate the values.&#xA;&#xA;```sql&#xA;INSERT INTO users (name, age, username, language) VALUES (&#39;Jimmy&#39;, 18, &#39;jimmy&#39;, &#39;fr&#39;);&#xA;```&#xA;&#xA;So, that is some combination of `NOT NULL` constraints along with other constraints and the insert values.&#xA;&#xA;```&#xA;sqlite&gt; INSERT INTO users (name, age, username) VALUES (&#39;Alice&#39;, 25, &#39;alice&#39;);&#xA;sqlite&gt; .mode table&#xA;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;| name  | age | username | language | country_code |      email      |&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;| Alice | 25  | alice    | en       | US           | alice@myapp.com |&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;&#xA;sqlite&gt; INSERT INTO users (age, username) VALUES (25, &#39;alice&#39;);&#xA;Runtime error: NOT NULL constraint failed: users.name (19)&#xA;&#xA;sqlite&gt; INSERT INTO users (name, age, username) VALUES (&#39;Bob&#39;, 0, &#39;bob&#39;);&#xA;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;| name  | age | username | language | country_code |      email      |&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;| Alice | 25  | alice    | en       | US           | alice@myapp.com |&#xA;| Bob   | 0   | bob      | en       | US           | bob@myapp.com   |&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;&#xA;sqlite&gt; INSERT INTO users (name, age, username) VALUES (&#39;Bob&#39;, -1, &#39;bob&#39;);&#xA;Runtime error: CHECK constraint failed: age &gt;= 0 (19)&#xA;&#xA;sqlite&gt; INSERT INTO users (name, username) VALUES (&#39;Bob&#39;, &#39;bob&#39;);&#xA;Runtime error: NOT NULL constraint failed: users.age (19)&#xA;&#xA;sqlite&gt; INSERT INTO users (name, age, username) VALUES (&#39;John&#39;, 30, &#39;john&#39;);&#xA;sqlite&gt; INSERT INTO users (name, age, username) VALUES (&#39;Jim&#39;, 18, &#39;jim&#39;);&#xA;&#xA;sqlite&gt; INSERT INTO users (name, age, username, language) VALUES (&#39;Jim&#39;, 18, &#39;jim&#39;, &#39;fr&#39;);&#xA;Runtime error: UNIQUE constraint failed: users.email (19)&#xA;&#xA;sqlite&gt; INSERT INTO users (name, age, username, language) VALUES (&#39;Jimmy&#39;, 18, &#39;jimmy&#39;, &#39;fr&#39;);&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;| name  | age | username | language | country_code |      email      |&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;| Alice | 25  | alice    | en       | US           | alice@myapp.com |&#xA;| Bob   | 0   | bob      | en       | US           | bob@myapp.com   |&#xA;| John  | 30  | john     | en       | US           | john@myapp.com  |&#xA;| Jim   | 18  | jim      | en       | US           | jim@myapp.com   |&#xA;| Jimmy | 18  | jimmy    | fr       | US           | jimmy@myapp.com |&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;&#xA;sqlite&gt; INSERT INTO users (name, age, username) VALUES (&#39;Robin&#39;, 24, &#39;robin&#39;);&#xA;sqlite&gt; INSERT INTO users (name, age, username) VALUES (&#39;Robinson&#39;, 24, &#39;robin&#39;);&#xA;Runtime error: UNIQUE constraint failed: users.email (19)&#xA;&#xA;sqlite&gt; SELECT * FROM users;&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;| name  | age | username | language | country_code |      email      |&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;| Alice | 25  | alice    | en       | US           | alice@myapp.com |&#xA;| Bob   | 0   | bob      | en       | US           | bob@myapp.com   |&#xA;| John  | 30  | john     | en       | US           | john@myapp.com  |&#xA;| Jim   | 18  | jim      | en       | US           | jim@myapp.com   |&#xA;| Jimmy | 18  | jimmy    | fr       | US           | jimmy@myapp.com |&#xA;| Robin | 24  | robin    | en       | US           | robin@myapp.com |&#xA;+-------+-----+----------+----------+--------------+-----------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Create Table with column constraints</title>
      <link>https://meetgor.com/sqlite-create-table-column-constraint</link>
      <description></description>
      <pubDate>Sun, 07 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Create Table with column constraints&#xA;&#xA;We have seen the table creation with column types, we now need to look into the constraints or limitations that we can add to those columns, in order to make the data-model more robust and add some basic validations before doing any updation/mutation on the data itself.&#xA;&#xA;To add a constraint, we can specify it at the end of the column name, after the type, so there are a list of constraints that could be added to column, which are relevant to specific scenarios of the actual model of the column.&#xA;- `NOT NULL`: This will prevent insertion of `NULL` or empty values in the column field, even updating an existing filled value with `NULL` will prevent it from inserting a `NULL` value.&#xA;- `UNIQUE`: This will prevent insertion of duplicate value for an column field, same applies for updating an existing value with a duplicate will lead to violating the constraint.&#xA;- `DEFAULT`: This will add a default value to the column field, if not specified in the insertion of the value.&#xA;- `GENERATED ALWAYS AS`: A expression used to generate the value of the column field, this can be derived from the existing columns, or a constant value.&#xA;- `CHECK`: A custom check (numeric expression) can be added for that column before updating or inserting its value in the column.&#xA;- `PRIMARY KEY`: This will set the column as the primary identifier for the table, so essentially it will be like a `rowid` for the table, acting like a unique identifier among the other rows.&#xA;- `FOREIGN KEY`: This will set the column as a foreign key, and it will be a reference to the primary key of another table.&#xA;&#xA;Let&#39;s look at a basic example of each, I would go into details in each subsequent posts in the future as their is a lot of nitty-gritty details to be covered.&#xA;&#xA;## NOT NULL Constraint&#xA;&#xA;The `NOT NULL` constraint is a column-level constraint that can be added to a column in order to avoid getting a `NULL` or empty value being populated/inserted/updated in that column field for any row in the table.&#xA;&#xA;```sql&#xA;CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT,&#xA;    model_code TEXT&#xA;);&#xA;```&#xA;&#xA;```sql&#xA;INSERT INTO llm_models DEFAULT VALUES;&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;OOPs! `Runtime error: NOT NULL constraint failed: llm_models.name (19)`. The default value is `NULL` or empty if not explicitly constrained on the column. So, it tried to insert the `NULL` as the `name` of the `llm_models` record/row, and while doing so sqlite hit a error, at runtime, that the constraint of the column `llm_models.name` cannot be `NULL`. &#xA;&#xA;So, one of the solution to avoid this, could be explicitly passing a value, or setting a default value in the column setting (we will see that in the later section as the default constraint).&#xA;&#xA;Let&#39;s sepcify the value of the `name` column:&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name) VALUES(&#39;abc&#39;);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;This time it successfully ran, the thing to note here is that the `model_type` or `model_code` column is populated as `NULL` becuase they don&#39;t have any constraint, especially they don&#39;t have the `NOT NULL` constraint, and hence we need to provide a value to the `name` column but the `model_type` or `model_code` columns becomes optional.&#xA;&#xA;SQLite also treats `&#39;&#39;` empty string as not null, i.e. you can insert `&#39;&#39;` into the `name` column and it will work fine. This is a bit wired but again a flexibility being a double edged sword. We need to understand what is the difference between `NULL` and empty string in this case, those are both different values.&#xA;&#xA;## UNIQUE Constraint&#xA;&#xA;&#xA;Now, we will add a constraint to the `model_code` column that it should be unique, we don&#39;t want it to be a primary key just yet, but each row/record in this table should have a unique model_code.&#xA;&#xA;We cannot alter the table to add a constraint in sqlite, but is allowed in other databases like postgres, mysql, etc. however that is a bit risky as the previous data might become redundant and also would fail the constraints updated. So ideally we need to re-create the table, you can however alter table columns with a combination of constraints in order to maintain the backwards data correction.&#xA;&#xA;Let&#39;s drop the table `llm_models` so that we can start afresh.&#xA;&#xA;```sql&#xA;DROP TABLE llm_models;&#xA;CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT,&#xA;    model_code TEXT UNIQUE&#xA;);&#xA;```&#xA;&#xA;This way, we make sure the `model_code` column is unique, and we don&#39;t have any duplicate values in the column. When each new record is added to the table `llm_models` the `model_code` needs to be unique and even updation would fail if the new value is duplicated.&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name) VALUES(&#39;abc&#39;);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;Works fine, now notice here that the `model_code` is not provided and therefore it is `NULL`, let&#39;s add one more row with the same `name` and check if that fails the unique constraint on the `model_code` as it will now have the model_code duplicated `NULL` in both the rows, that should fail right? RIGHT?&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name) VALUES(&#39;abc&#39;);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;Nopes!&#xA;&#xA;`NULL` is not a value to be called as unique. NULL is like undefined, you can&#39;t really distinguish between one `NULL` and other `NULL`s. Hence, the constraint is often associated with the `NOT NULL` as well to prevent the `NULL` confusion.&#xA;&#xA;&#xA;Let&#39;s add the `model_code` now.&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name, model_code) VALUES (&#39;abc&#39;, &#39;llm-1&#39;);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;Ok, we added a record with `model_code` as `llm-1`. Now, let&#39;s add the same record again.&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name, model_code) VALUES (&#39;abc&#39;, &#39;llm-1&#39;);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;And, it broke, it gave a `Runtime error: UNIQUE constraint failed: llm_models.model_code (19)` error. So, we can&#39;t add the same `model_code` twice.&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT,&#xA;    model_code TEXT UNIQUE&#xA;);&#xA;sqlite&gt; INSERT INTO llm_models(name) VALUES(&#39;abc&#39;);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; SELECT * FROM llm_models;&#xA;+------+------------+------------+&#xA;| name | model_type | model_code |&#xA;+------+------------+------------+&#xA;| abc  |            |            |&#xA;+------+------------+------------+&#xA;sqlite&gt; INSERT INTO llm_models(name) VALUES(&#39;abc&#39;);&#xA;sqlite&gt; SELECT * FROM llm_models;&#xA;+------+------------+------------+&#xA;| name | model_type | model_code |&#xA;+------+------------+------------+&#xA;| abc  |            |            |&#xA;| abc  |            |            |&#xA;+------+------------+------------+&#xA;sqlite&gt; INSERT INTO llm_models(name, model_code) VALUES(&#39;abc&#39;, &#39;llm-1&#39;);&#xA;sqlite&gt; INSERT INTO llm_models(name, model_code) VALUES(&#39;abc&#39;, &#39;llm-1&#39;);&#xA;Runtime error: UNIQUE constraint failed: llm_models.model_code (19)&#xA;sqlite&gt; SELECT * FROM llm_models;&#xA;+------+------------+------------+&#xA;| name | model_type | model_code |&#xA;+------+------------+------------+&#xA;| abc  |            |            |&#xA;| abc  |            |            |&#xA;| abc  |            | llm-1      |&#xA;+------+------------+------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;So some tips for using the `UNIQUE` constraints in sqlite:&#xA;- You can&#39;t use `UNIQUE` constraint on the `NULL` values.&#xA;- Prefer using `NOT NULL` in addition to the `UNIQUE` constraint.&#xA;&#xA;&#xA;## DEFAULT Constraint&#xA;&#xA;The default constraint as the name suggest, will set a default value for a column if no value is provided in the insert statement. However, you need to provide the default value while creating the table. You can generate a default value (for that we can use the `GENERATED ALWAYS` constraint).&#xA;&#xA;```sql&#xA;DROP TABLE llm_models;&#xA;CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT DEFAULT &#39;text&#39;,&#xA;    model_code TEXT UNIQUE NOT NULL&#xA;);&#xA;```&#xA;&#xA;I have added a constraint of `model_type` as `DEFAULT &#39;text&#39;` which will set the value of `model_type` column to `text` if no value is provided in the insert statement.&#xA;&#xA;Also, the `model_code` column is updated with the constraints of `UNIQUE` and `NOT NULL`&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name, model_code) VALUES(&#39;abc&#39;, &#39;llm-1&#39;);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;And that works as expected, it populates the value of `model_type` as `text` by default.&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT DEFAULT &#39;text&#39;,&#xA;    model_code TEXT UNIQUE NOT NULL&#xA;);&#xA;sqlite&gt; INSERT INTO llm_models(name, model_code) VALUES(&#39;abc&#39;, &#39;llm-1&#39;);&#xA;sqlite&gt; SELECT * FROM llm_models;&#xA;+------+------------+------------+&#xA;| name | model_type | model_code |&#xA;+------+------------+------------+&#xA;| abc  | text       | llm-1      |&#xA;+------+------------+------------+&#xA;sqlite&gt; INSERT INTO llm_models(name, model_code) VALUES(&#39;abc&#39;, &#39;llm-1&#39;);&#xA;Runtime error: UNIQUE constraint failed: llm_models.model_code (19)&#xA;sqlite&gt;&#xA;```&#xA;&#xA;And if we try to insert the same `model_code` value again, it will fail with the `UNIQUE` constraint.&#xA;&#xA;## Generated Constraint&#xA;&#xA;The [Generated](https://sqlite.org/gencol.html) constraint can add a value to a column based on evaluated expression from the values of the other columns in that row.&#xA;&#xA;&#xA;```sql&#xA;DROP TABLE llm_models;&#xA;CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT DEFAULT &#39;text&#39;,&#xA;    model_code TEXT UNIQUE NOT NULL,&#xA;    display_name TEXT GENERATED ALWAYS AS (name || &#39; (&#39; || model_code || &#39;)&#39;) STORED&#xA;);&#xA;```&#xA;&#xA;We have added a `GENERATED ALWAYS AS STORED` constraint which will store the result of `name || &#39; (&#39; || model_code || &#39;)&#39;` in the `display_name` column.&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name, model_code) VALUES(&#39;abc&#39;, &#39;llm-1&#39;);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;There is a variant of `VIRTUAL` instead of `STORED`, we will explore this separately, I am just getting my hands on and getting familiarity with all the constraints available in SQL.&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT DEFAULT &#39;text&#39;,&#xA;    model_code TEXT UNIQUE NOT NULL,&#xA;    display_name TEXT GENERATED ALWAYS AS (name || &#39; (&#39; || model_code || &#39;)&#39;) STORED&#xA;);&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; INSERT INTO llm_models(name, model_code) VALUES(&#39;abc&#39;, &#39;llm-1&#39;);&#xA;sqlite&gt; SELECT * FROM llm_models;&#xA;+------+------------+------------+--------------+&#xA;| name | model_type | model_code | display_name |&#xA;+------+------------+------------+--------------+&#xA;| abc  | text       | llm-1      | abc (llm-1)  |&#xA;+------+------------+------------+--------------+&#xA;```&#xA;&#xA;Neat! It populated, or I should say `generated` the `display_name` column by evaluating the `name || &#39; (&#39; || model_code || &#39;)&#39;` expression.&#xA;&#xA;## Check Constraint&#xA;&#xA;The `CHECK` constraint is a column-level constraint that can be added to a column in order to add a custom check (numeric expression) before updating or inserting its value in the column. Just a simple expression or a validation check before inserting the value to the column in the row.&#xA;&#xA;Let&#39;s take the `model_type` constraint with the `CHECK` constraint by limiting the values of `model_type` to `text`, `conversational`, `multimodal`, `code`.&#xA;&#xA;```sql&#xA;DROP TABLE llm_models;&#xA;CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT CHECK(model_type IN (&#39;text&#39;, &#39;conversational&#39;, &#39;multimodal&#39;, &#39;code&#39;)) DEFAULT &#39;text&#39;,&#xA;    model_code TEXT UNIQUE NOT NULL,&#xA;    display_name TEXT GENERATED ALWAYS AS (name || &#39; (&#39; || model_code || &#39;)&#39;) STORED&#xA;);&#xA;```&#xA;Here, we have added the `CHECK` constraint to the `model_type` column. And we have limited the values of `model_type` to `text`, `conversational`, `multimodal`, `code`. It could be anything, but its just a true or false check that will either fail or work.&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name, model_code) VALUES(&#39;abc&#39;, &#39;llm-1&#39;);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;This will add the default value as `text` for the `model_type`.&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name, model_code, model_type) VALUES(&#39;abc&#39;, &#39;llm-1&#39;, &#39;visual&#39;);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;Here we try to add the column `model_type` as `visual` which is not allowed by the `CHECK` constraint.&#xA;&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name, model_code, model_type) VALUES(&#39;abc&#39;, &#39;llm-1&#39;, &#39;code&#39;);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;And we try to add the column `model_type` as `code` which is not allowed by the `CHECK` constraint.&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT CHECK(model_type IN (&#39;text&#39;, &#39;conversational&#39;, &#39;multimodal&#39;, &#39;code&#39;)) DEFAULT &#39;text&#39;,&#xA;    model_code TEXT UNIQUE NOT NULL,&#xA;    display_name TEXT GENERATED ALWAYS AS (name || &#39; (&#39; || model_code || &#39;)&#39;) STORED&#xA;);&#xA;sqlite&gt; INSERT INTO llm_models(name, model_code) VALUES(&#39;abc&#39;, &#39;llm-1&#39;);&#xA;sqlite&gt; SELECT * FROM llm_models&#xA;   ...&gt; ;&#xA;+------+------------+------------+--------------+&#xA;| name | model_type | model_code | display_name |&#xA;+------+------------+------------+--------------+&#xA;| abc  | text       | llm-1      | abc (llm-1)  |&#xA;+------+------------+------------+--------------+&#xA;sqlite&gt; INSERT INTO llm_models(name, model_code, model_type) VALUES(&#39;abc&#39;, &#39;llm-1&#39;, &#39;visual&#39;);&#xA;Runtime error: CHECK constraint failed: model_type IN (&#39;text&#39;, &#39;conversational&#39;, &#39;multimodal&#39;, &#39;code&#39;) (19)&#xA;sqlite&gt; INSERT INTO llm_models(name, model_code, model_type) VALUES(&#39;abc&#39;, &#39;llm-1&#39;, &#39;code&#39;);&#xA;Runtime error: UNIQUE constraint failed: llm_models.model_code (19)&#xA;sqlite&gt; INSERT INTO llm_models(name, model_code, model_type) VALUES(&#39;abc&#39;, &#39;llm-2&#39;, &#39;code&#39;);&#xA;sqlite&gt; SELECT * FROM llm_models;&#xA;+------+------------+------------+--------------+&#xA;| name | model_type | model_code | display_name |&#xA;+------+------------+------------+--------------+&#xA;| abc  | text       | llm-1      | abc (llm-1)  |&#xA;| abc  | code       | llm-2      | abc (llm-2)  |&#xA;+------+------------+------------+--------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Right! We checked that it failed the constraint `model_type IN (&#39;text&#39;, &#39;conversational&#39;, &#39;multimodal&#39;, &#39;code&#39;)` and we checked that it failed the constraint `UNIQUE` constraint.&#xA;&#xA;&#xA;## Primary Key Constraint&#xA;&#xA;The primary key constraint is a column-level constraint that is used to identify a unique row in a table.&#xA;It is a unique constraint that can be used to identify a row in a table using a single column.&#xA;&#xA;We can provide it right after the column name or at the bottom of all the table constraints.&#xA;&#xA;```sql&#xA;DROP TABLE llm_models;&#xA;CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT CHECK(model_type IN (&#39;text&#39;, &#39;conversational&#39;, &#39;multimodal&#39;, &#39;code&#39;)) DEFAULT &#39;text&#39;,&#xA;    model_code TEXT UNIQUE NOT NULL,&#xA;    display_name TEXT GENERATED ALWAYS AS (name || &#39; (&#39; || model_code || &#39;)&#39;) STORED,&#xA;    PRIMARY KEY(model_code)&#xA;);&#xA;```&#xA;&#xA;OR&#xA;&#xA;```sql&#xA;DROP TABLE llm_models;&#xA;CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT CHECK(model_type IN (&#39;text&#39;, &#39;conversational&#39;, &#39;multimodal&#39;, &#39;code&#39;)) DEFAULT &#39;text&#39;,&#xA;    model_code TEXT UNIQUE NOT NULL PRIMARY KEY,&#xA;    display_name TEXT GENERATED ALWAYS AS (name || &#39; (&#39; || model_code || &#39;)&#39;) STORED&#xA;);&#xA;```&#xA;&#xA;The `PRIMARY KEY` is a table level constraint, as it needs to unique across all the rows in the table.&#xA;&#xA;## Foreign Key Constraint&#xA;&#xA;The foreign key constraint is a column-level constraint that is used to establish a relationship between two tables.&#xA;&#xA;We will now create a separate table called `companies` for this example, this will be a table that stores the company information those will be creating or developing the LLM models.&#xA;&#xA;```sql&#xA;CREATE TABLE companies(&#xA;    id INTEGER PRIMARY KEY,&#xA;    company_name TEXT UNIQUE NOT NULL,&#xA;    founded_year INTEGER&#xA;);&#xA;```&#xA;Let&#39;s insert a few companies&#xA;&#xA;```sql&#xA;INSERT INTO companies (company_name, founded_year) VALUES(&#39;ABC&#39;, 1998);&#xA;INSERT INTO companies (company_name, founded_year) VALUES(&#39;ClosedAI&#39;, 2016);&#xA;INSERT INTO companies (company_name, founded_year) VALUES(&#39;Beta&#39;, 2014);&#xA;SELECT * FROM companies;&#xA;```&#xA;&#xA;Original companies right?&#xA;Now we will update the `llm_models` table that will store the LLM models information. We will add a foreign key, that will be a reference i.e. to make a relation for the row that will reference another row. So, the foreign key indicates a key (field/column) in another table that&#39;s why named as `FOREIGN KEY`. This foreign key will be referencing the `companies.id` column from the `companies` table.&#xA;&#xA;```sql&#xA;DROP TABLE llm_models;&#xA;CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT CHECK(model_type IN (&#39;text&#39;, &#39;conversational&#39;, &#39;multimodal&#39;, &#39;code&#39;)) DEFAULT &#39;text&#39;,&#xA;    model_code TEXT UNIQUE NOT NULL PRIMARY KEY,&#xA;    display_name TEXT GENERATED ALWAYS AS (name || &#39; (&#39; || model_code || &#39;)&#39;) STORED,&#xA;    company_id INTEGER,&#xA;    FOREIGN KEY(company_id) REFERENCES companies(id)&#xA;);&#xA;```&#xA;We insert the `llm_models` with the foreign key of 2 indicating the company `ClosedAI`.&#xA;&#xA;```sql&#xA;INSERT INTO llm_models(name, model_code, company_id) VALUES(&#39;abc&#39;, &#39;llm-1&#39;, 2);&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;Now, if we see, this has successfully inserted the row.&#xA;&#xA;```sql&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;We can join the two tables together, this will give us the combined sets form the tables.&#xA;&#xA;```sql&#xA;SELECT * FROM llm_models as llm INNER JOIN companies as comp ON comp.id = llm.company_id;&#xA;```&#xA;&#xA;That was a bit unclear, let&#39;s only keep what we needed.&#xA;&#xA;```sql&#xA;SELECT llm.*, comp.company_name  FROM llm_models as llm INNER JOIN companies as comp ON comp.id = llm.company_id;&#xA;```&#xA;&#xA;Cool, that is sweat.&#xA;&#xA;```&#xA;sqlite&gt; CREATE TABLE companies(&#xA;    id INTEGER PRIMARY KEY,&#xA;    company_name TEXT UNIQUE NOT NULL,&#xA;    founded_year INTEGER&#xA;);&#xA;sqlite&gt; INSERT INTO companies (company_name, founded_year) VALUES(&#39;ABC&#39;, 1998);&#xA;INSERT INTO companies (company_name, founded_year) VALUES(&#39;ClosedAI&#39;, 2016);&#xA;INSERT INTO companies (company_name, founded_year) VALUES(&#39;Beta&#39;, 2014);&#xA;SELECT * FROM companies;&#xA;+----+--------------+--------------+&#xA;| id | company_name | founded_year |&#xA;+----+--------------+--------------+&#xA;| 1  | ABC          | 1998         |&#xA;| 2  | ClosedAI     | 2016         |&#xA;| 3  | Beta         | 2014         |&#xA;+----+--------------+--------------+&#xA;sqlite&gt;&#xA;sqlite&gt; CREATE TABLE llm_models(&#xA;    name TEXT NOT NULL,&#xA;    model_type TEXT CHECK(model_type IN (&#39;text&#39;, &#39;conversational&#39;, &#39;multimodal&#39;, &#39;code&#39;)) DEFAULT &#39;text&#39;,&#xA;    model_code TEXT UNIQUE NOT NULL PRIMARY KEY,&#xA;    display_name TEXT GENERATED ALWAYS AS (name || &#39; (&#39; || model_code || &#39;)&#39;) STORED,&#xA;    company_id INTEGER,&#xA;    FOREIGN KEY(company_id) REFERENCES companies(id)&#xA;&#xA;);&#xA;sqlite&gt; SELECT * FROM llm_models;&#xA;sqlite&gt; INSERT INTO llm_models(name, model_code, model_type, company_id) VALUES(&#39;abc&#39;, &#39;llm-1&#39;, &#39;code&#39;, 2);&#xA;sqlite&gt; SELECT * FROM llm_models;&#xA;+------+------------+------------+--------------+------------+&#xA;| name | model_type | model_code | display_name | company_id |&#xA;+------+------------+------------+--------------+------------+&#xA;| abc  | code       | llm-1      | abc (llm-1)  | 2          |&#xA;+------+------------+------------+--------------+------------+&#xA;sqlite&gt; SELECT * FROM llm_models as llm INNER JOIN companies as comp ON comp.id = llm.company_id;&#xA;+------+------------+------------+--------------+------------+----+--------------+--------------+&#xA;| name | model_type | model_code | display_name | company_id | id | company_name | founded_year |&#xA;+------+------------+------------+--------------+------------+----+--------------+--------------+&#xA;| abc  | code       | llm-1      | abc (llm-1)  | 2          | 2  | ClosedAI     | 2016         |&#xA;+------+------------+------------+--------------+------------+----+--------------+--------------+&#xA;sqlite&gt; SELECT llm.*, comp.company_name  FROM llm_models as llm INNER JOIN companies as comp ON comp.id = llm.company_id;&#xA;+------+------------+------------+--------------+------------+--------------+&#xA;| name | model_type | model_code | display_name | company_id | company_name |&#xA;+------+------------+------------+--------------+------------+--------------+&#xA;| abc  | code       | llm-1      | abc (llm-1)  | 2          | ClosedAI     |&#xA;+------+------------+------------+--------------+------------+--------------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;That is it, a high level overview of adding constraints in SQLite, I will dig deep into each constraint in separate posts over the coming week.&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Create Table with column types</title>
      <link>https://meetgor.com/sqlite-create-table-column-types</link>
      <description></description>
      <pubDate>Sat, 06 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Creating a table with column types&#xA;&#xA;If you want to store values in a column with a specific type, you need to specify one of the following types in order to store that value in relatively type specific data.&#xA;&#xA;- `TEXT` (string or characters, bunch of text)&#xA;- `BLOB` (binary data, images, raw files, etc)&#xA;- `INTEGER` (numbers which are whole, like 1, 67, 986, etc)&#xA;- `REAL` (floating or decimal point numbers, like 3.14, 85.98, 999.99, etc)&#xA;- `NULL` (empty or not defined)&#xA;&#xA;Type affinity is what determines how a data is being stored and treated in sqlite, so we&#39;ll need to cover that separately. For now, let&#39;s assume that the data you give in is indeed valdiated before sending over to the database (that rarely is the case though) but for now we can avoid that discussion, and focus on creation of the structure and relations of the data.&#xA;&#xA;If you are curious, you can learn about types and affinity [here](https://www.sqlite.org/datatype3.html).&#xA;&#xA;Let&#39;s see how to create a table with a few columns having a specific type.&#xA;&#xA;Let&#39;s say we are creating a database system and a schema for storing LLMs and their history. How interesting!&#xA;&#xA;```sql&#xA;CREATE TABLE llm_models(&#xA;    name TEXT,&#xA;    model_type TEXT,&#xA;    description TEXT,&#xA;    no_parameters REAL,&#xA;    f1_score REAL,&#xA;    input_token_limit INTEGER,&#xA;    output_token_limit INTEGER,&#xA;    context_window_tokens INTEGER,&#xA;    release_date TEXT,&#xA;    knowledge_cutoff_date TEXT,&#xA;    weights_file BLOB,&#xA;    license TEXT&#xA;);&#xA;```&#xA;&#xA;As you can see, we have a few columns with specific types. The name, model type, description, licence could be plain text. The number of parameters and f1_score and others could be real, as those exact number of the parameters cannot be discrete values. Similarly, the `input_token_limit`, `output_token_limit`, `context_window_tokens` can be a discrete value hence used as integer. The `release_date` and `knowledge_cutoff_date` is a date value so could be used as numeric-affinity but we need to store it as text for now. The `weights_file` is a binary file, hence storing it as a blob i.e. binary large object.&#xA;&#xA;So, if we were to insert into these the default values, what do you think what will it populate with?&#xA;&#xA;```sql&#xA;INSERT INTO llm_models DEFAULT VALUES;&#xA;```&#xA;&#xA;```sql&#xA;SELECT * FROM llm_models;&#xA;```&#xA;&#xA;```&#xA;sqlite&gt; select * from llm_models;&#xA;+------+------------+-------------+---------------+-------------------+--------------------+-----------------------+--------------+-----------------------+--------------+---------+&#xA;| name | model_type | description | no_parameters | input_token_limit | output_token_limit | context_window_tokens | release_date | knowledge_cutoff_date | weights_file | license |&#xA;+------+------------+-------------+---------------+-------------------+--------------------+-----------------------+--------------+-----------------------+--------------+---------+&#xA;|      |            |             |               |                   |                    |                       |              |                       |              |         |&#xA;+------+------------+-------------+---------------+-------------------+--------------------+-----------------------+--------------+-----------------------+--------------+---------+&#xA;sqlite&gt;&#xA;```&#xA;&#xA;Well all is empty! That&#39;s becuase it is `None` or `NULL` by default, and we don&#39;t have any constraint on the columns as well as on the tables.&#xA;&#xA;We need to add some constraints on the columns as well as the tables. &#xA;&#xA;There are options to add contraints on the column like &#xA;&#xA;- `NOT NULL`&#xA;- `UNIQUE`&#xA;- `PRIMARY KEY`&#xA;- `CHECK`&#xA;- `DEFAULT`&#xA;- `COLLATE`&#xA;- `FOREIGN KEY`&#xA;&#xA;We&#39;ll explore those separately for now understand those as some restrictions on how the column values can be stored. For instance in our example, we can&#39;t store a record or a llm model without a name so we need to have it as `NOT NULL` which will prevent a record from being inserted as empty or NULL essentially.&#xA;&#xA;It turns out we can also add in a `STRICT` paramter to the end of the table to make sure the table doesn&#39;t allow `TEXT` values to be stored in `INTEGER` column.&#xA;&#xA;There are a lot of details I think I am going to leave it right here. We only need to add these for our conveniences, sqlite is so flexible that it can be a little intimidating to add these values and not get benefit right away, but imagine this. You have a quick experiment to run and test out how the data looks like, your data model works, you just need your crud app to be ready, no time in wasting which will be the primary key, which will be a not null column, what the default value is for each column, it can be skipped with SQLite. That&#39;s a double-edged sword, yes in some sense, but more powerful for most of the applications. It assumes you don&#39;t need validations unless you specify it, and believe me there are tons of validations you can add in sqlite to make it robust.&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Create Table Bare Bones Table</title>
      <link>https://meetgor.com/sqlite-create-table-bare-bones-table</link>
      <description></description>
      <pubDate>Fri, 05 Sep 2025 00:00:00 UTC</pubDate>
      <content>What if you only wanted one column. If you create specify a column name in create table, then there will be actually 2 columns created, one that you specified and the other which is hidden as `rowid`, unless you mentioned rowid as the column.&#xA;&#xA;```sql&#xA;CREATE TABLE users(name);&#xA;INSERT INTO users(name) VALUES (&#34;abc&#34;), (&#34;def&#34;);&#xA;&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;You would think, you have one column `name` in the table `users`. Nope!&#xA;&#xA;```sql&#xA;SELECT rowid, * from users;&#xA;```&#xA;&#xA;```&#xA;+-------+------+&#xA;| rowid | name |&#xA;+-------+------+&#xA;| 1     | abc  |&#xA;| 2     | def  |&#xA;+-------+------+&#xA;```&#xA;&#xA;Surprise!&#xA;Any user defined table in sqlite almost always has a [rowid column](https://www.sqlite.org/rowidtable.html)&#xA;&#xA;That tempts me to create a table with one column, and see what happens, how can we uniquely identify rows in that case.&#xA;&#xA;```sql&#xA;CREATE TABLE users(rowid);&#xA;&#xA;INSERT INTO users DEFAULT VALUES;&#xA;INSERT INTO users DEFAULT VALUES;&#xA;&#xA;.mode table&#xA;&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;NOTE: DEFAULT VALUES, this means, use the default values for the columns, if you didn&#39;t specify a type for the column, the default values are `NULL`.&#xA;&#xA;&#xA;```&#xA;sqlite&gt; create table users(rowid);&#xA;sqlite&gt; insert into users default values;&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; select * from users;&#xA;+-------+&#xA;| rowid |&#xA;+-------+&#xA;|       |&#xA;+-------+&#xA;sqlite&gt; insert into users default values;&#xA;sqlite&gt; select * from users;&#xA;+-------+&#xA;| rowid |&#xA;+-------+&#xA;|       |&#xA;|       |&#xA;+-------+&#xA;sqlite&gt; select distinct * from users;&#xA;+-------+&#xA;| rowid |&#xA;+-------+&#xA;|       |&#xA;+-------+&#xA;sqlite&gt; select distinct rowid from users;&#xA;+-------+&#xA;| rowid |&#xA;+-------+&#xA;|       |&#xA;+-------+&#xA;```&#xA;Here, its kind of hard to distinguish each row, so we have kind of skewed up. There is only one row and its not anymore served as a unique identifier in the table. &#xA;As you can insert multiple same values for the users table.&#xA;&#xA;```sql&#xA;DROP TABLE users;&#xA;```&#xA;&#xA;Let&#39;s create a table with a table that increments the rowid auto-incrementally.&#xA;&#xA;```sql&#xA;CREATE TABLE users(rowid INTEGER PRIMARY KEY AUTOINCREMENT);&#xA;INSERT INTO users DEFAULT VALUES;&#xA;INSERT INTO users DEFAULT VALUES;&#xA;SELECT * FROM users;&#xA;```&#xA;&#xA;Now it simply increments each time we add a row, that&#39;s a neat little table.&#xA;&#xA;I think this is far we can push sqlite, just one column.&#xA;&#xA;But wait, what&#39;s beneath this?&#xA;&#xA;Like why rowid? Why not name? Well, SQLite always creates this underlying rowid for structural reasons. When we name our column rowid, we&#39;re just making that hidden rowid visible. But if you create an `INTEGER PRIMARY KEY` (regardless of its name), that becomes an alias for the underlying `rowid` and not just any primary key, specifically `INTEGER PRIMARY KEY`&#xA;&#xA;But here, we ourselves defined the rowid, so when you create something like a `id` not `rowid` as a primary key, it will be a alias for that underlying `rowid`&#xA;&#xA;In the first example, the `CREATE TABLE users(rowid)` this is a violation of sqlite, as we now have created a table which cannot be distinctly identified with a column, as there is only one column, and that too is exposed to the user, and hence in the default case, the `rowid` is hidden column, unless the user/developer has added a primary key to a certain row. The user/developer is taking away the ownership of managing the primary key (unique identifier for a row/entry in a table) to him/herself rather than relying on the `rowid` solely.&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite SQL: Create Table Basic</title>
      <link>https://meetgor.com/sqlite-create-table</link>
      <description></description>
      <pubDate>Thu, 04 Sep 2025 00:00:00 UTC</pubDate>
      <content>We have explored enough sqlite dot commands, now I want to explore the actual nuts and bolts of SQL in SQLite, what better place then to create tables.&#xA;&#xA;## CREATE TABLE Statement&#xA;&#xA;The `CREATE TABLE` as the name suggest will create a table in a sqlite database. What is a table?&#xA;&#xA;&gt; Table is a set of relations&#xA;&#xA;The syntax for the create table might look something like this:&#xA;&#xA;```sql&#xA;CREATE [TEMP | TEMPORARY] TABLE [IF NOT EXISTS] [schema-name.]table-name&#xA;( column-def ( , column-def )* [, table-constraint]* )&#xA;[WITHOUT ROWID] [STRICT]&#xA;```&#xA;Check [this diagram](https://sqlite.org/lang_createtable.html) to make things clear for you, might even confuse you if you are absolutely new, so just stick around we will explore it one piece at a time, and as usual follow a exhaustive, all combination exploration of this statemnet.&#xA;&#xA;There are a lot of things, but we&#39;ll see each of them one by one, not all at once.&#xA;&#xA;The important and mandatory things to provide are table name and atleast one column name. Not even the type of the column is needed, just the name is sufficient, since the type is really not a thing in sqlite tables unless you add `STRICT` as the table option.&#xA;&#xA;So, the bare bones table creation statement might look something like this:&#xA;&#xA;```sql&#xA;CREATE TABLE users(name);&#xA;```&#xA;&#xA;Dead! Just the table name and one column name, can you even go with no columns (Except the rowid one that is automagically added?). You can actually, but you will have to specify the column as rowid (let’s keep that aside for now).&#xA;This is wired, but was juse exploring the possibilities of what the bare minimum is required for creating a table in sqlite.&#xA;&#xA;Now, if we want to insert this into the `users` table, we can simply do this:&#xA;&#xA;```sql&#xA;INSERT INTO users(name) VALUES (&#34;abc&#34;), (&#34;def&#34;), (100), (89.8);&#xA;SELECT * FROM users;&#xA;```&#xA;Simple right?&#xA;&#xA;Note that you can insert anything in the id column, not just numbers, but you can&#39;t insert anything in the name column, since that is a mandatory column. That is wired but that&#39;s what sqlite has a duct typing if not opted out of it.&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite dot commands: header command</title>
      <link>https://meetgor.com/sqlite-dot-command-header</link>
      <description></description>
      <pubDate>Wed, 03 Sep 2025 00:00:00 UTC</pubDate>
      <content>The `.headers` command is crucial as might effect the way the result set is displayed. The first row would be set to the name of the columns in the output of the relevant commands like `.output`, `.once`, or even your simple standard out queries if it is set on.&#xA;&#xA;```&#xA;.headers on&#xA;&#xA;OR&#xA;&#xA;.header on&#xA;```&#xA;&#xA;Some how either of them work. You need to set it to `on` to enable the headers in the output of the result set. And you can turn off with `.headers off`.&#xA;&#xA;Which modes are effected with this command if set on or off?&#xA;&#xA;Well we need to think about how effected means&#xA;1. Only added in the first row&#xA;2. Added in each row&#xA;3. No effect&#xA;&#xA;---&#xA;&#xA;1. Only added in the first row&#xA;    1. ascii&#xA;    2. column&#xA;    3. csv&#xA;    4. html&#xA;    5. list&#xA;    6. quote&#xA;    7. tabs&#xA;    8. tcl&#xA;2. Added in each row&#xA;    1. insert&#xA;3. No effect&#xA;    1. box&#xA;    2. json&#xA;    3. line&#xA;    4. markdown&#xA;    5. table&#xA;&#xA;&#xA;Reference table&#xA;&#xA;```sql&#xA;CREATE TABLE IF NOT EXISTS books(&#xA;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#xA;    title TEXT NOT NULL,&#xA;    author TEXT NOT NULL,&#xA;    pages INTEGER NOT NULL,&#xA;    release_date TEXT NOT NULL,&#xA;    price REAL NOT NULL&#xA;);&#xA;&#xA;INSERT INTO books(title, author, pages, release_date, price)&#xA;VALUES&#xA;(&#39;The Hobbit&#39;, &#39;J.R.R. Tolkien&#39;, 310, &#39;1937-09-21&#39;, 39.99),&#xA;(&#39;The Fellowship of the Ring&#39;, &#39;J.R.R. Tolkien&#39;, 423, &#39;1954-07-29&#39;, 49.99),&#xA;(&#39;The Two Towers&#39;, &#39;J.R.R. Tolkien&#39;, 352, &#39;1954-11-11&#39;, 49.99), &#xA;(&#39;The Return of the King&#39;, &#39;J.R.R. Tolkien&#39;, 416, &#39;1955-10-20&#39;, 49.99);&#xA;&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;Below are the outputs of each command&#xA;&#xA;### Added on the first row&#xA;&#xA;In the below modes, the headers command if set will add the column name as the header in the first row.&#xA;&#xA;1. ASCII&#xA;&#xA;```sqlite&#xA;.mode ascii&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;```&#xA;sqlite&gt; .mode ascii&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;idtitleauthorpagesrelease_dateprice1The HobbitJ.R.R. Tolkien3101937-09-2139.992The Fellowship of the RingJ.R.R. Tolkien4231954-07-2949.993The Two TowersJ.R.R. Tolkien3521954-11-1149.994The Return of the KingJ.R.R. Tolkien4161955-10-2049.99sqlite&gt;&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;1The HobbitJ.R.R. Tolkien3101937-09-2139.992The Fellowship of the RingJ.R.R. Tolkien4231954-07-2949.993The Two TowersJ.R.R. Tolkien3521954-11-1149.994The Return of the KingJ.R.R. Tolkien4161955-10-2049.99sqlite&gt;&#xA;sqlite&gt;&#xA;```&#xA;&#xA;2. Column&#xA;&#xA;```&#xA;.mode column&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output&#xA;&#xA;```&#xA;sqlite&gt; .mode column&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;id  title                       author          pages  release_date  price&#xA;--  --------------------------  --------------  -----  ------------  -----&#xA;1   The Hobbit                  J.R.R. Tolkien  310    1937-09-21    39.99&#xA;2   The Fellowship of the Ring  J.R.R. Tolkien  423    1954-07-29    49.99&#xA;3   The Two Towers              J.R.R. Tolkien  352    1954-11-11    49.99&#xA;4   The Return of the King      J.R.R. Tolkien  416    1955-10-20    49.99&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;1   The Hobbit                  J.R.R. Tolkien  310    1937-09-21    39.99&#xA;2   The Fellowship of the Ring  J.R.R. Tolkien  423    1954-07-29    49.99&#xA;3   The Two Towers              J.R.R. Tolkien  352    1954-11-11    49.99&#xA;4   The Return of the King      J.R.R. Tolkien  416    1955-10-20    49.99&#xA;sqlite&gt;&#xA;```&#xA;&#xA;3. CSV&#xA;&#xA;```sqlite&#xA;.mode csv&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode csv&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;id,title,author,pages,release_date,price&#xA;1,&#34;The Hobbit&#34;,&#34;J.R.R. Tolkien&#34;,310,1937-09-21,39.99&#xA;2,&#34;The Fellowship of the Ring&#34;,&#34;J.R.R. Tolkien&#34;,423,1954-07-29,49.99&#xA;3,&#34;The Two Towers&#34;,&#34;J.R.R. Tolkien&#34;,352,1954-11-11,49.99&#xA;4,&#34;The Return of the King&#34;,&#34;J.R.R. Tolkien&#34;,416,1955-10-20,49.99&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;1,&#34;The Hobbit&#34;,&#34;J.R.R. Tolkien&#34;,310,1937-09-21,39.99&#xA;2,&#34;The Fellowship of the Ring&#34;,&#34;J.R.R. Tolkien&#34;,423,1954-07-29,49.99&#xA;3,&#34;The Two Towers&#34;,&#34;J.R.R. Tolkien&#34;,352,1954-11-11,49.99&#xA;4,&#34;The Return of the King&#34;,&#34;J.R.R. Tolkien&#34;,416,1955-10-20,49.99&#xA;sqlite&gt;&#xA;```&#xA;&#xA;4. HTML&#xA;&#xA;```sqlite&#xA;.mode html&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode html&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;&lt;TR&gt;&lt;TH&gt;id&lt;/TH&gt;&#xA;&lt;TH&gt;title&lt;/TH&gt;&#xA;&lt;TH&gt;author&lt;/TH&gt;&#xA;&lt;TH&gt;pages&lt;/TH&gt;&#xA;&lt;TH&gt;release_date&lt;/TH&gt;&#xA;&lt;TH&gt;price&lt;/TH&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;1&lt;/TD&gt;&#xA;&lt;TD&gt;The Hobbit&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;310&lt;/TD&gt;&#xA;&lt;TD&gt;1937-09-21&lt;/TD&gt;&#xA;&lt;TD&gt;39.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;2&lt;/TD&gt;&#xA;&lt;TD&gt;The Fellowship of the Ring&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;423&lt;/TD&gt;&#xA;&lt;TD&gt;1954-07-29&lt;/TD&gt;&#xA;&lt;TD&gt;49.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;3&lt;/TD&gt;&#xA;&lt;TD&gt;The Two Towers&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;352&lt;/TD&gt;&#xA;&lt;TD&gt;1954-11-11&lt;/TD&gt;&#xA;&lt;TD&gt;49.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;4&lt;/TD&gt;&#xA;&lt;TD&gt;The Return of the King&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;416&lt;/TD&gt;&#xA;&lt;TD&gt;1955-10-20&lt;/TD&gt;&#xA;&lt;TD&gt;49.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;&lt;TR&gt;&lt;TD&gt;1&lt;/TD&gt;&#xA;&lt;TD&gt;The Hobbit&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;310&lt;/TD&gt;&#xA;&lt;TD&gt;1937-09-21&lt;/TD&gt;&#xA;&lt;TD&gt;39.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;2&lt;/TD&gt;&#xA;&lt;TD&gt;The Fellowship of the Ring&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;423&lt;/TD&gt;&#xA;&lt;TD&gt;1954-07-29&lt;/TD&gt;&#xA;&lt;TD&gt;49.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;3&lt;/TD&gt;&#xA;&lt;TD&gt;The Two Towers&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;352&lt;/TD&gt;&#xA;&lt;TD&gt;1954-11-11&lt;/TD&gt;&#xA;&lt;TD&gt;49.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;4&lt;/TD&gt;&#xA;&lt;TD&gt;The Return of the King&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;416&lt;/TD&gt;&#xA;&lt;TD&gt;1955-10-20&lt;/TD&gt;&#xA;&lt;TD&gt;49.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;sqlite&gt;&#xA;```&#xA;&#xA;5. List&#xA;&#xA;```sqlite&#xA;.mode list&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode list&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;id|title|author|pages|release_date|price&#xA;1|The Hobbit|J.R.R. Tolkien|310|1937-09-21|39.99&#xA;2|The Fellowship of the Ring|J.R.R. Tolkien|423|1954-07-29|49.99&#xA;3|The Two Towers|J.R.R. Tolkien|352|1954-11-11|49.99&#xA;4|The Return of the King|J.R.R. Tolkien|416|1955-10-20|49.99&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;1|The Hobbit|J.R.R. Tolkien|310|1937-09-21|39.99&#xA;2|The Fellowship of the Ring|J.R.R. Tolkien|423|1954-07-29|49.99&#xA;3|The Two Towers|J.R.R. Tolkien|352|1954-11-11|49.99&#xA;4|The Return of the King|J.R.R. Tolkien|416|1955-10-20|49.99&#xA;sqlite&gt;&#xA;```&#xA;&#xA;6. Quote&#xA;&#xA;```sqlite&#xA;.mode quote&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode quote&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;&#39;id&#39;,&#39;title&#39;,&#39;author&#39;,&#39;pages&#39;,&#39;release_date&#39;,&#39;price&#39;&#xA;1,&#39;The Hobbit&#39;,&#39;J.R.R. Tolkien&#39;,310,&#39;1937-09-21&#39;,39.99000000000000198&#xA;2,&#39;The Fellowship of the Ring&#39;,&#39;J.R.R. Tolkien&#39;,423,&#39;1954-07-29&#39;,49.99000000000000198&#xA;3,&#39;The Two Towers&#39;,&#39;J.R.R. Tolkien&#39;,352,&#39;1954-11-11&#39;,49.99000000000000198&#xA;4,&#39;The Return of the King&#39;,&#39;J.R.R. Tolkien&#39;,416,&#39;1955-10-20&#39;,49.99000000000000198&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;1,&#39;The Hobbit&#39;,&#39;J.R.R. Tolkien&#39;,310,&#39;1937-09-21&#39;,39.99000000000000198&#xA;2,&#39;The Fellowship of the Ring&#39;,&#39;J.R.R. Tolkien&#39;,423,&#39;1954-07-29&#39;,49.99000000000000198&#xA;3,&#39;The Two Towers&#39;,&#39;J.R.R. Tolkien&#39;,352,&#39;1954-11-11&#39;,49.99000000000000198&#xA;4,&#39;The Return of the King&#39;,&#39;J.R.R. Tolkien&#39;,416,&#39;1955-10-20&#39;,49.99000000000000198&#xA;sqlite&gt;&#xA;&#xA;```&#xA;&#xA;7. Tabs&#xA;&#xA;```sqlite&#xA;.mode tabs&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode tabs&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;id      title   author  pages   release_date    price&#xA;1       The Hobbit      J.R.R. Tolkien  310     1937-09-21      39.99&#xA;2       The Fellowship of the Ring      J.R.R. Tolkien  423     1954-07-29      49.99&#xA;3       The Two Towers  J.R.R. Tolkien  352     1954-11-11      49.99&#xA;4       The Return of the King  J.R.R. Tolkien  416     1955-10-20      49.99&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;1       The Hobbit      J.R.R. Tolkien  310     1937-09-21      39.99&#xA;2       The Fellowship of the Ring      J.R.R. Tolkien  423     1954-07-29      49.99&#xA;3       The Two Towers  J.R.R. Tolkien  352     1954-11-11      49.99&#xA;4       The Return of the King  J.R.R. Tolkien  416     1955-10-20      49.99&#xA;sqlite&gt;&#xA;```&#xA;&#xA;8. TCL&#xA;&#xA;```sqlite&#xA;.mode tcl&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode tcl&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;&#34;id&#34; &#34;title&#34; &#34;author&#34; &#34;pages&#34; &#34;release_date&#34; &#34;price&#34;&#xA;&#34;1&#34; &#34;The Hobbit&#34; &#34;J.R.R. Tolkien&#34; &#34;310&#34; &#34;1937-09-21&#34; &#34;39.99&#34;&#xA;&#34;2&#34; &#34;The Fellowship of the Ring&#34; &#34;J.R.R. Tolkien&#34; &#34;423&#34; &#34;1954-07-29&#34; &#34;49.99&#34;&#xA;&#34;3&#34; &#34;The Two Towers&#34; &#34;J.R.R. Tolkien&#34; &#34;352&#34; &#34;1954-11-11&#34; &#34;49.99&#34;&#xA;&#34;4&#34; &#34;The Return of the King&#34; &#34;J.R.R. Tolkien&#34; &#34;416&#34; &#34;1955-10-20&#34; &#34;49.99&#34;&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;&#34;1&#34; &#34;The Hobbit&#34; &#34;J.R.R. Tolkien&#34; &#34;310&#34; &#34;1937-09-21&#34; &#34;39.99&#34;&#xA;&#34;2&#34; &#34;The Fellowship of the Ring&#34; &#34;J.R.R. Tolkien&#34; &#34;423&#34; &#34;1954-07-29&#34; &#34;49.99&#34;&#xA;&#34;3&#34; &#34;The Two Towers&#34; &#34;J.R.R. Tolkien&#34; &#34;352&#34; &#34;1954-11-11&#34; &#34;49.99&#34;&#xA;&#34;4&#34; &#34;The Return of the King&#34; &#34;J.R.R. Tolkien&#34; &#34;416&#34; &#34;1955-10-20&#34; &#34;49.99&#34;&#xA;sqlite&gt;&#xA;```&#xA;&#xA;&#xA;### Added in each row&#xA;&#xA;In this type, each row has the column name as some form of the row.&#xA;&#xA;1. Insert&#xA;&#xA;```sqlite&#xA;.mode insert&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode insert&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;INSERT INTO &#34;table&#34;(id,title,author,pages,release_date,price) VALUES(1,&#39;The Hobbit&#39;,&#39;J.R.R. Tolkien&#39;,310,&#39;1937-09-21&#39;,39.99000000000000198);&#xA;INSERT INTO &#34;table&#34;(id,title,author,pages,release_date,price) VALUES(2,&#39;The Fellowship of the Ring&#39;,&#39;J.R.R. Tolkien&#39;,423,&#39;1954-07-29&#39;,49.99000000000000198);&#xA;INSERT INTO &#34;table&#34;(id,title,author,pages,release_date,price) VALUES(3,&#39;The Two Towers&#39;,&#39;J.R.R. Tolkien&#39;,352,&#39;1954-11-11&#39;,49.99000000000000198);&#xA;INSERT INTO &#34;table&#34;(id,title,author,pages,release_date,price) VALUES(4,&#39;The Return of the King&#39;,&#39;J.R.R. Tolkien&#39;,416,&#39;1955-10-20&#39;,49.99000000000000198);&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;INSERT INTO &#34;table&#34; VALUES(1,&#39;The Hobbit&#39;,&#39;J.R.R. Tolkien&#39;,310,&#39;1937-09-21&#39;,39.99000000000000198);&#xA;INSERT INTO &#34;table&#34; VALUES(2,&#39;The Fellowship of the Ring&#39;,&#39;J.R.R. Tolkien&#39;,423,&#39;1954-07-29&#39;,49.99000000000000198);&#xA;INSERT INTO &#34;table&#34; VALUES(3,&#39;The Two Towers&#39;,&#39;J.R.R. Tolkien&#39;,352,&#39;1954-11-11&#39;,49.99000000000000198);&#xA;INSERT INTO &#34;table&#34; VALUES(4,&#39;The Return of the King&#39;,&#39;J.R.R. Tolkien&#39;,416,&#39;1955-10-20&#39;,49.99000000000000198);&#xA;sqlite&gt;&#xA;&#xA;```&#xA;&#xA;&#xA;### No effect&#xA;&#xA;These modes show the headers or column names irrespective of the `.headers` flag, as for these modes the headers form quite a bit of structure to the output they are showing.&#xA;&#xA;1. Box&#xA;&#xA;```sqlite&#xA;.mode box&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode box&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;┌────┬────────────────────────────┬────────────────┬───────┬──────────────┬───────┐&#xA;│ id │           title            │     author     │ pages │ release_date │ price │&#xA;├────┼────────────────────────────┼────────────────┼───────┼──────────────┼───────┤&#xA;│ 1  │ The Hobbit                 │ J.R.R. Tolkien │ 310   │ 1937-09-21   │ 39.99 │&#xA;│ 2  │ The Fellowship of the Ring │ J.R.R. Tolkien │ 423   │ 1954-07-29   │ 49.99 │&#xA;│ 3  │ The Two Towers             │ J.R.R. Tolkien │ 352   │ 1954-11-11   │ 49.99 │&#xA;│ 4  │ The Return of the King     │ J.R.R. Tolkien │ 416   │ 1955-10-20   │ 49.99 │&#xA;└────┴────────────────────────────┴────────────────┴───────┴──────────────┴───────┘&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;┌────┬────────────────────────────┬────────────────┬───────┬──────────────┬───────┐&#xA;│ id │           title            │     author     │ pages │ release_date │ price │&#xA;├────┼────────────────────────────┼────────────────┼───────┼──────────────┼───────┤&#xA;│ 1  │ The Hobbit                 │ J.R.R. Tolkien │ 310   │ 1937-09-21   │ 39.99 │&#xA;│ 2  │ The Fellowship of the Ring │ J.R.R. Tolkien │ 423   │ 1954-07-29   │ 49.99 │&#xA;│ 3  │ The Two Towers             │ J.R.R. Tolkien │ 352   │ 1954-11-11   │ 49.99 │&#xA;│ 4  │ The Return of the King     │ J.R.R. Tolkien │ 416   │ 1955-10-20   │ 49.99 │&#xA;└────┴────────────────────────────┴────────────────┴───────┴──────────────┴───────┘&#xA;sqlite&gt;&#xA;```&#xA;&#xA;2. JSON&#xA;&#xA;```sqlite&#xA;.mode json&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode json&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;[{&#34;id&#34;:1,&#34;title&#34;:&#34;The Hobbit&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:310,&#34;release_date&#34;:&#34;1937-09-21&#34;,&#34;price&#34;:39.99000000000000198},&#xA;{&#34;id&#34;:2,&#34;title&#34;:&#34;The Fellowship of the Ring&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:423,&#34;release_date&#34;:&#34;1954-07-29&#34;,&#34;price&#34;:49.99000000000000198},&#xA;{&#34;id&#34;:3,&#34;title&#34;:&#34;The Two Towers&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:352,&#34;release_date&#34;:&#34;1954-11-11&#34;,&#34;price&#34;:49.99000000000000198},&#xA;{&#34;id&#34;:4,&#34;title&#34;:&#34;The Return of the King&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:416,&#34;release_date&#34;:&#34;1955-10-20&#34;,&#34;price&#34;:49.99000000000000198}]&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;[{&#34;id&#34;:1,&#34;title&#34;:&#34;The Hobbit&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:310,&#34;release_date&#34;:&#34;1937-09-21&#34;,&#34;price&#34;:39.99000000000000198},&#xA;{&#34;id&#34;:2,&#34;title&#34;:&#34;The Fellowship of the Ring&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:423,&#34;release_date&#34;:&#34;1954-07-29&#34;,&#34;price&#34;:49.99000000000000198},&#xA;{&#34;id&#34;:3,&#34;title&#34;:&#34;The Two Towers&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:352,&#34;release_date&#34;:&#34;1954-11-11&#34;,&#34;price&#34;:49.99000000000000198},&#xA;{&#34;id&#34;:4,&#34;title&#34;:&#34;The Return of the King&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:416,&#34;release_date&#34;:&#34;1955-10-20&#34;,&#34;price&#34;:49.99000000000000198}]&#xA;sqlite&gt;&#xA;```&#xA;&#xA;3. Line&#xA;&#xA;```sqlite&#xA;.mode line&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;```&#xA;sqlite&gt; .mode line&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;          id = 1&#xA;       title = The Hobbit&#xA;      author = J.R.R. Tolkien&#xA;       pages = 310&#xA;release_date = 1937-09-21&#xA;       price = 39.99&#xA;&#xA;          id = 2&#xA;       title = The Fellowship of the Ring&#xA;      author = J.R.R. Tolkien&#xA;       pages = 423&#xA;release_date = 1954-07-29&#xA;       price = 49.99&#xA;&#xA;          id = 3&#xA;       title = The Two Towers&#xA;      author = J.R.R. Tolkien&#xA;       pages = 352&#xA;release_date = 1954-11-11&#xA;       price = 49.99&#xA;&#xA;          id = 4&#xA;       title = The Return of the King&#xA;      author = J.R.R. Tolkien&#xA;       pages = 416&#xA;release_date = 1955-10-20&#xA;       price = 49.99&#xA;&#xA;&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;          id = 1&#xA;       title = The Hobbit&#xA;      author = J.R.R. Tolkien&#xA;       pages = 310&#xA;release_date = 1937-09-21&#xA;       price = 39.99&#xA;&#xA;          id = 2&#xA;       title = The Fellowship of the Ring&#xA;      author = J.R.R. Tolkien&#xA;       pages = 423&#xA;release_date = 1954-07-29&#xA;       price = 49.99&#xA;&#xA;          id = 3&#xA;       title = The Two Towers&#xA;      author = J.R.R. Tolkien&#xA;       pages = 352&#xA;release_date = 1954-11-11&#xA;       price = 49.99&#xA;&#xA;          id = 4&#xA;       title = The Return of the King&#xA;      author = J.R.R. Tolkien&#xA;       pages = 416&#xA;release_date = 1955-10-20&#xA;       price = 49.99&#xA;sqlite&gt;&#xA;```&#xA;&#xA;4. Markdown&#xA;&#xA;```sqlite&#xA;.mode markdown&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode markdown&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;| id |           title            |     author     | pages | release_date | price |&#xA;|----|----------------------------|----------------|-------|--------------|-------|&#xA;| 1  | The Hobbit                 | J.R.R. Tolkien | 310   | 1937-09-21   | 39.99 |&#xA;| 2  | The Fellowship of the Ring | J.R.R. Tolkien | 423   | 1954-07-29   | 49.99 |&#xA;| 3  | The Two Towers             | J.R.R. Tolkien | 352   | 1954-11-11   | 49.99 |&#xA;| 4  | The Return of the King     | J.R.R. Tolkien | 416   | 1955-10-20   | 49.99 |&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;| id |           title            |     author     | pages | release_date | price |&#xA;|----|----------------------------|----------------|-------|--------------|-------|&#xA;| 1  | The Hobbit                 | J.R.R. Tolkien | 310   | 1937-09-21   | 39.99 |&#xA;| 2  | The Fellowship of the Ring | J.R.R. Tolkien | 423   | 1954-07-29   | 49.99 |&#xA;| 3  | The Two Towers             | J.R.R. Tolkien | 352   | 1954-11-11   | 49.99 |&#xA;| 4  | The Return of the King     | J.R.R. Tolkien | 416   | 1955-10-20   | 49.99 |&#xA;sqlite&gt;&#xA;```&#xA;&#xA;5. Table&#xA;&#xA;```sqlite&#xA;.mode table&#xA;.headers on&#xA;select * from books;&#xA;.headers off&#xA;select * from books;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```&#xA;sqlite&gt; .mode table&#xA;sqlite&gt; .headers on&#xA;sqlite&gt; select * from books;&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;| id |           title            |     author     | pages | release_date | price |&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;| 1  | The Hobbit                 | J.R.R. Tolkien | 310   | 1937-09-21   | 39.99 |&#xA;| 2  | The Fellowship of the Ring | J.R.R. Tolkien | 423   | 1954-07-29   | 49.99 |&#xA;| 3  | The Two Towers             | J.R.R. Tolkien | 352   | 1954-11-11   | 49.99 |&#xA;| 4  | The Return of the King     | J.R.R. Tolkien | 416   | 1955-10-20   | 49.99 |&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;sqlite&gt; .headers off&#xA;sqlite&gt; select * from books;&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;| id |           title            |     author     | pages | release_date | price |&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;| 1  | The Hobbit                 | J.R.R. Tolkien | 310   | 1937-09-21   | 39.99 |&#xA;| 2  | The Fellowship of the Ring | J.R.R. Tolkien | 423   | 1954-07-29   | 49.99 |&#xA;| 3  | The Two Towers             | J.R.R. Tolkien | 352   | 1954-11-11   | 49.99 |&#xA;| 4  | The Return of the King     | J.R.R. Tolkien | 416   | 1955-10-20   | 49.99 |&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;sqlite&gt;&#xA;&#xA;```&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite dot commands: Output mode separator command</title>
      <link>https://meetgor.com/sqlite-mode-dot-command-separators</link>
      <description></description>
      <pubDate>Tue, 02 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Using the separator for the ouput&#xA;&#xA;If you wanted to use a specific separator for columns and rows while displaying the result set / table, you can use the `.separator` dot command which can take 2 arguments, first as the separator for the column and the second for the row.&#xA;&#xA;So, if we set use `.separator &#34;|&#34; &#34;---&#34;` then it will split the columns with `|` and each row with `---`. &#xA;&#xA;```&#xA;1|The Hobbit|J.R.R. Tolkien|310|1937-09-21|39.99---2|The Fellowship of the Ring|J.R.R. Tolkien|423|1954-07-29|49.99---3|The Two Towers|J.R.R. Tolkien|352|1954-11-11|49.99---4|The Return of the King|J.R.R. Tolkien|416|1955-10-20|49.99---&#xA;```&#xA;&#xA;The output looks wired but I was giving a example.&#xA;&#xA;The row separator is by default a `\n` character or `\r\n` on windows, which is for the list or any other mode. However if you want to add those, you need to specify it in the string like below:&#xA;&#xA;```&#xA;.separator &#34;|&#34; &#34;\n---&#34;&#xA;```&#xA;&#xA;```&#xA;&gt;sqlite&gt;.separator &#34;|&#34; &#34;\n---&#34;&#xA;sqlite&gt; select * from books;&#xA;1|The Hobbit|J.R.R. Tolkien|310|1937-09-21|39.99&#xA;---2|The Fellowship of the Ring|J.R.R. Tolkien|423|1954-07-29|49.99&#xA;---3|The Two Towers|J.R.R. Tolkien|352|1954-11-11|49.99&#xA;---4|The Return of the King|J.R.R. Tolkien|416|1955-10-20|49.99&#xA;---sqlite&gt;&#xA;```&#xA;&#xA;The `\n---` will add it at the end of each row, so the first row won&#39;t have it if you are seeing the above output and confused, then that&#39;s the expected result.&#xA;&#xA;You can also use `\r` or `\t` for the row separator, and for the column separator you can use `\n` or `\t` or `\r`.&#xA;&#xA;The modes that will respect the separator setting:&#xA;- list&#xA;- quote&#xA;&#xA;Sadly only two, since for changing the row separator you need to pass the column separator first, so that defeats the purpose of the change in the row separator, you&#39;ll have to override the column separator first and then the row.&#xA;&#xA;So, for the mode `tabs`, if you want to keep the columns separator as is, but change the row separator then you can do something like this:&#xA;```&#xA;.mode tabs&#xA;.separator &#34;\t&#34; &#34;\n\n&#34;&#xA;```&#xA;&#xA;This will keep the column separator as is and change the row separator to `\n\n`&#xA;&#xA;```&#xA;sqlite&gt; .mode tabs&#xA;sqlite&gt; .separator &#34;\t&#34; &#34;\n\n&#34;&#xA;sqlite&gt; select * from books;&#xA;id      title   author  pages   release_date    price&#xA;&#xA;1       The Hobbit      J.R.R. Tolkien  310     1937-09-21      39.99&#xA;&#xA;2       The Fellowship of the Ring      J.R.R. Tolkien  423     1954-07-29      49.99&#xA;&#xA;3       The Two Towers  J.R.R. Tolkien  352     1954-11-11      49.99&#xA;&#xA;4       The Return of the King  J.R.R. Tolkien  416     1955-10-20      49.99&#xA;&#xA;sqlite&gt;&#xA;```&#xA;Similarly for csv you would keep the separator as , and then pass the row separator&#xA;&#xA;Nice tricks to know.&#xA;&#xA;References:&#xA;- [SQLite dot commands: Changing output formats](https://www.sqlite.org/cli.html#changing_output_formats)&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite dot commands: Output mode</title>
      <link>https://meetgor.com/sqlite-mode-dot-command</link>
      <description></description>
      <pubDate>Mon, 01 Sep 2025 00:00:00 UTC</pubDate>
      <content>## Output mode dot command&#xA;&#xA;The SQLite shell is a great way to test out and run bunch of queries, but the output might be squished or cluttered. You might need to view the output in a specific way, and the creators of SQLite were already hearing your screams.&#xA;&#xA;They created not 5, not 10, but 14 different output modes, and to extend it even further, you can even use any delimiter/separator as well.&#xA;&#xA;The `.mode` will give you the currently configured/set output mode with some options which are default for certain type of modes.&#xA;&#xA;The default mode is `list`, with the option of `escape` with the ascii character set.&#xA;&#xA;```&#xA;current output mode: list --escape ascii&#xA;```&#xA;&#xA;The list mode defined in the [docs](https://www.sqlite.org/cli.html#changing_output_formats) as:&#xA;&#xA;&gt; In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&#34;|&#34;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.&#xA;&#xA;So, in short, the `list` output mode prints each row on a line with a `|` as the separator.&#xA;&#xA;You can get all the information you need with the `.help mode` command&#xA;&#xA;```&#xA;.mode ?MODE? ?OPTIONS?   Set output mode&#xA;   MODE is one of:&#xA;     ascii       Columns/rows delimited by 0x1F and 0x1E&#xA;     box         Tables using unicode box-drawing characters&#xA;     csv         Comma-separated values&#xA;     column      Output in columns.  (See .width)&#xA;     html        HTML \&lt;table\&gt; code&#xA;     insert      SQL insert statements for TABLE&#xA;     json        Results in a JSON array&#xA;     line        One value per line&#xA;     list        Values delimited by &#34;|&#34;&#xA;     markdown    Markdown table format&#xA;     qbox        Shorthand for &#34;box --wrap 60 --quote&#34;&#xA;     quote       Escape answers as for SQL&#xA;     table       ASCII-art table&#xA;     tabs        Tab-separated values&#xA;     tcl         TCL list elements&#xA;   OPTIONS: (for columnar modes or insert mode):&#xA;     --escape T     ctrl-char escape; T is one of: symbol, ascii, off&#xA;     --wrap N       Wrap output lines to no longer than N characters&#xA;     --wordwrap B   Wrap or not at word boundaries per B (on/off)&#xA;     --ww           Shorthand for &#34;--wordwrap 1&#34;&#xA;     --quote        Quote output text as SQL literals&#xA;     --noquote      Do not quote output text&#xA;     TABLE          The name of SQL table used for &#34;insert&#34; mode&#xA;```&#xA;&#xA;Let&#39;s set up with some sample data&#xA;&#xA;```sql&#xA;CREATE TABLE IF NOT EXISTS books(&#xA;    id INTEGER PRIMARY KEY AUTOINCREMENT,&#xA;    title TEXT NOT NULL,&#xA;    author TEXT NOT NULL,&#xA;    pages INTEGER NOT NULL,&#xA;    release_date TEXT NOT NULL,&#xA;    price REAL NOT NULL&#xA;);&#xA;&#xA;INSERT INTO books(title, author, pages, release_date, price)&#xA;VALUES&#xA;(&#39;The Hobbit&#39;, &#39;J.R.R. Tolkien&#39;, 310, &#39;1937-09-21&#39;, 39.99),&#xA;(&#39;The Fellowship of the Ring&#39;, &#39;J.R.R. Tolkien&#39;, 423, &#39;1954-07-29&#39;, 49.99),&#xA;(&#39;The Two Towers&#39;, &#39;J.R.R. Tolkien&#39;, 352, &#39;1954-11-11&#39;, 49.99), &#xA;(&#39;The Return of the King&#39;, &#39;J.R.R. Tolkien&#39;, 416, &#39;1955-10-20&#39;, 49.99);&#xA;&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```&#xA;1|The Hobbit|J.R.R. Tolkien|310|1937-09-21|39.99&#xA;2|The Fellowship of the Ring|J.R.R. Tolkien|423|1954-07-29|49.99&#xA;3|The Two Towers|J.R.R. Tolkien|352|1954-11-11|49.99&#xA;4|The Return of the King|J.R.R. Tolkien|416|1955-10-20|49.99&#xA;```&#xA;&#xA;Not the best way to look at the data, but handy in some cases. We can change it, we have 14 different modes to choose from.&#xA;Its like choosing a taste flovour for an ice-cream, you want something different each time, or you stick to the simple vanilla one. Which one are you? I am a vanilla guy (I like the table mode, but use csv heavily too).&#xA;&#xA;Let&#39;s change it to a table format with `.mode table` This will set the mode as `table`&#xA;&#xA;&gt; table       ASCII-art table&#xA;&#xA;This will show the result sets in a ascii-like table structure with the `+++` and `---` to separate the rows and columns.&#xA;&#xA;```&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;| id |           title            |     author     | pages | release_date | price |&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;| 1  | The Hobbit                 | J.R.R. Tolkien | 310   | 1937-09-21   | 39.99 |&#xA;| 2  | The Fellowship of the Ring | J.R.R. Tolkien | 423   | 1954-07-29   | 49.99 |&#xA;| 3  | The Two Towers             | J.R.R. Tolkien | 352   | 1954-11-11   | 49.99 |&#xA;| 4  | The Return of the King     | J.R.R. Tolkien | 416   | 1955-10-20   | 49.99 |&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;```&#xA;&#xA;That is soo nice looking! Crystal clear.&#xA;&#xA;You can even see the current set mode precisely with the `.mode` command&#xA;&#xA;Since I changed the mode to table, let&#39;s see what the mode is now set as?&#xA;```&#xA;sqlite&gt; .mode&#xA;current output mode: table --wrap 60 --wordwrap off --noquote --escape ascii&#xA;```&#xA;&#xA;It has a bunch of options like `wrap`, `wordwrap`, `noquote`, and `escape` etc. You can take a look at the help and tweak them as per your liking, I usually don&#39;t change the options, but it might be very rare to switch from the defaults.&#xA;&#xA;&#xA;## Output modes&#xA;&#xA;### ASCII &#xA;&#xA;This mode separates the columns with by `0x1F` and rows with `0x1E`.&#xA;&#xA;```&#xA;.mode ascii&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```&#xA;id�title�author�pages�release_date�price�1�The Hobbit�J.R.R. Tolkien�310�1937-09-21�39.99�2�The Fellowship of the Ring�J.R.R. Tolkien�423�1954-07-29�49.99�3�The Two Towers�J.R.R. Tolkien�352�1954-11-11�49.99�4�The Return of the King�J.R.R. Tolkien�416�1955-10-20�49.99�&#xA;```&#xA;&#xA;### Box&#xA;&#xA;The box mode renders the result set using unicode box-drawing characters.&#xA;&#xA;```&#xA;.mode box&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```&#xA;┌────┬────────────────────────────┬────────────────┬───────┬──────────────┬───────┐&#xA;│ id │           title            │     author     │ pages │ release_date │ price │&#xA;├────┼────────────────────────────┼────────────────┼───────┼──────────────┼───────┤&#xA;│ 1  │ The Hobbit                 │ J.R.R. Tolkien │ 310   │ 1937-09-21   │ 39.99 │&#xA;│ 2  │ The Fellowship of the Ring │ J.R.R. Tolkien │ 423   │ 1954-07-29   │ 49.99 │&#xA;│ 3  │ The Two Towers             │ J.R.R. Tolkien │ 352   │ 1954-11-11   │ 49.99 │&#xA;│ 4  │ The Return of the King     │ J.R.R. Tolkien │ 416   │ 1955-10-20   │ 49.99 │&#xA;└────┴────────────────────────────┴────────────────┴───────┴──────────────┴───────┘&#xA;```&#xA;&#xA;&#xA;### CSV&#xA;&#xA;The csv mode simply outputs the result in the comma-separated values for columns and newline character for rows.&#xA;&#xA;```&#xA;.mode csv&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```csv&#xA;1,&#34;The Hobbit&#34;,&#34;J.R.R. Tolkien&#34;,310,1937-09-21,39.99&#xA;2,&#34;The Fellowship of the Ring&#34;,&#34;J.R.R. Tolkien&#34;,423,1954-07-29,49.99&#xA;3,&#34;The Two Towers&#34;,&#34;J.R.R. Tolkien&#34;,352,1954-11-11,49.99&#xA;4,&#34;The Return of the King&#34;,&#34;J.R.R. Tolkien&#34;,416,1955-10-20,49.99&#xA;```&#xA;&#xA;&#xA;### Column&#xA;&#xA;The column mode simply outputs the result in columns with certain width. We can set the option `.width` to change the width.&#xA;&#xA;```&#xA;.mode column&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```&#xA;id  title                       author          pages  release_date  price&#xA;--  --------------------------  --------------  -----  ------------  -----&#xA;1   The Hobbit                  J.R.R. Tolkien  310    1937-09-21    39.99&#xA;2   The Fellowship of the Ring  J.R.R. Tolkien  423    1954-07-29    49.99&#xA;3   The Two Towers              J.R.R. Tolkien  352    1954-11-11    49.99&#xA;4   The Return of the King      J.R.R. Tolkien  416    1955-10-20    49.99&#xA;```&#xA;&#xA;&#xA;### HTML&#xA;&#xA;The html output mode simply renders the result set / tables into an table element in html.&#xA;&#xA;```&#xA;.mode html&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```html&#xA;&lt;TR&gt;&lt;TH&gt;id&lt;/TH&gt;&#xA;&lt;TH&gt;title&lt;/TH&gt;&#xA;&lt;TH&gt;author&lt;/TH&gt;&#xA;&lt;TH&gt;pages&lt;/TH&gt;&#xA;&lt;TH&gt;release_date&lt;/TH&gt;&#xA;&lt;TH&gt;price&lt;/TH&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;1&lt;/TD&gt;&#xA;&lt;TD&gt;The Hobbit&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;310&lt;/TD&gt;&#xA;&lt;TD&gt;1937-09-21&lt;/TD&gt;&#xA;&lt;TD&gt;39.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;2&lt;/TD&gt;&#xA;&lt;TD&gt;The Fellowship of the Ring&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;423&lt;/TD&gt;&#xA;&lt;TD&gt;1954-07-29&lt;/TD&gt;&#xA;&lt;TD&gt;49.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;3&lt;/TD&gt;&#xA;&lt;TD&gt;The Two Towers&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;352&lt;/TD&gt;&#xA;&lt;TD&gt;1954-11-11&lt;/TD&gt;&#xA;&lt;TD&gt;49.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;&lt;TR&gt;&lt;TD&gt;4&lt;/TD&gt;&#xA;&lt;TD&gt;The Return of the King&lt;/TD&gt;&#xA;&lt;TD&gt;J.R.R. Tolkien&lt;/TD&gt;&#xA;&lt;TD&gt;416&lt;/TD&gt;&#xA;&lt;TD&gt;1955-10-20&lt;/TD&gt;&#xA;&lt;TD&gt;49.99&lt;/TD&gt;&#xA;&lt;/TR&gt;&#xA;```&#xA;&#xA;&#xA;### Insert&#xA;&#xA;The insert mode simply outputs the result in SQL insert statements. This is really handy for bulk inserting or migrating data across databases or tables.&#xA;&#xA;```&#xA;.mode insert&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```&#xA;INSERT INTO &#34;table&#34;(id,title,author,pages,release_date,price) VALUES(1,&#39;The Hobbit&#39;,&#39;J.R.R. Tolkien&#39;,310,&#39;1937-09-21&#39;,39.99000000000000198);&#xA;INSERT INTO &#34;table&#34;(id,title,author,pages,release_date,price) VALUES(2,&#39;The Fellowship of the Ring&#39;,&#39;J.R.R. Tolkien&#39;,423,&#39;1954-07-29&#39;,49.99000000000000198);&#xA;INSERT INTO &#34;table&#34;(id,title,author,pages,release_date,price) VALUES(3,&#39;The Two Towers&#39;,&#39;J.R.R. Tolkien&#39;,352,&#39;1954-11-11&#39;,49.99000000000000198);&#xA;INSERT INTO &#34;table&#34;(id,title,author,pages,release_date,price) VALUES(4,&#39;The Return of the King&#39;,&#39;J.R.R. Tolkien&#39;,416,&#39;1955-10-20&#39;,49.99000000000000198);&#xA;```&#xA;&#xA;### JSON&#xA;&#xA;The json mode simply outputs the result in json format.&#xA;&#xA;```&#xA;.mode json&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```json&#xA;[&#xA;    {&#34;id&#34;:1,&#34;title&#34;:&#34;The Hobbit&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:310,&#34;release_date&#34;:&#34;1937-09-21&#34;,&#34;price&#34;:39.99000000000000198},&#xA;    {&#34;id&#34;:2,&#34;title&#34;:&#34;The Fellowship of the Ring&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:423,&#34;release_date&#34;:&#34;1954-07-29&#34;,&#34;price&#34;:49.99000000000000198},&#xA;    {&#34;id&#34;:3,&#34;title&#34;:&#34;The Two Towers&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:352,&#34;release_date&#34;:&#34;1954-11-11&#34;,&#34;price&#34;:49.99000000000000198},&#xA;    {&#34;id&#34;:4,&#34;title&#34;:&#34;The Return of the King&#34;,&#34;author&#34;:&#34;J.R.R. Tolkien&#34;,&#34;pages&#34;:416,&#34;release_date&#34;:&#34;1955-10-20&#34;,&#34;price&#34;:49.99000000000000198}&#xA;]&#xA;```&#xA;&#xA;&#xA;### List (The default)&#xA;&#xA;As we already know, the list mode is the default mode.&#xA;&#xA;```&#xA;.mode list&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```&#xA;id|title|author|pages|release_date|price&#xA;1|The Hobbit|J.R.R. Tolkien|310|1937-09-21|39.99&#xA;2|The Fellowship of the Ring|J.R.R. Tolkien|423|1954-07-29|49.99&#xA;3|The Two Towers|J.R.R. Tolkien|352|1954-11-11|49.99&#xA;4|The Return of the King|J.R.R. Tolkien|416|1955-10-20|49.99&#xA;```&#xA;&#xA;### Markdown&#xA;&#xA;The markdown mode simply outputs the result in markdown format. We can use this output in a markdown file and it will nicely draw the tables out.&#xA;&#xA;```&#xA;.mode markdown&#xA;SELECT * FROM books;&#xA;```&#xA;```md&#xA;| id |           title            |     author     | pages | release_date | price |&#xA;|----|----------------------------|----------------|-------|--------------|-------|&#xA;| 1  | The Hobbit                 | J.R.R. Tolkien | 310   | 1937-09-21   | 39.99 |&#xA;| 2  | The Fellowship of the Ring | J.R.R. Tolkien | 423   | 1954-07-29   | 49.99 |&#xA;| 3  | The Two Towers             | J.R.R. Tolkien | 352   | 1954-11-11   | 49.99 |&#xA;| 4  | The Return of the King     | J.R.R. Tolkien | 416   | 1955-10-20   | 49.99 |&#xA;```&#xA;&#xA;### Qbox&#xA;&#xA;The qbox mode simply outputs the result in box format with the option as `--wrap 60 --quote`.&#xA;&#xA;```&#xA;.mode qbox&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```&#xA;┌────┬──────────────────────────────┬──────────────────┬───────┬──────────────┬───────┐&#xA;│ id │            title             │      author      │ pages │ release_date │ price │&#xA;├────┼──────────────────────────────┼──────────────────┼───────┼──────────────┼───────┤&#xA;│ 1  │ &#39;The Hobbit&#39;                 │ &#39;J.R.R. Tolkien&#39; │ 310   │ &#39;1937-09-21&#39; │ 39.99 │&#xA;│ 2  │ &#39;The Fellowship of the Ring&#39; │ &#39;J.R.R. Tolkien&#39; │ 423   │ &#39;1954-07-29&#39; │ 49.99 │&#xA;│ 3  │ &#39;The Two Towers&#39;             │ &#39;J.R.R. Tolkien&#39; │ 352   │ &#39;1954-11-11&#39; │ 49.99 │&#xA;│ 4  │ &#39;The Return of the King&#39;     │ &#39;J.R.R. Tolkien&#39; │ 416   │ &#39;1955-10-20&#39; │ 49.99 │&#xA;└────┴──────────────────────────────┴──────────────────┴───────┴──────────────┴───────┘&#xA;```&#xA;&#xA;### Quote&#xA;&#xA;The quote mode simply outputs the result in SQL-string quote format.&#xA;&#xA;```&#xA;.mode quote&#xA;SELECT * FROM books;&#xA;```&#xA;```&#xA;&#39;id&#39;,&#39;title&#39;,&#39;author&#39;,&#39;pages&#39;,&#39;release_date&#39;,&#39;price&#39;&#xA;1,&#39;The Hobbit&#39;,&#39;J.R.R. Tolkien&#39;,310,&#39;1937-09-21&#39;,39.99000000000000198&#xA;2,&#39;The Fellowship of the Ring&#39;,&#39;J.R.R. Tolkien&#39;,423,&#39;1954-07-29&#39;,49.99000000000000198&#xA;3,&#39;The Two Towers&#39;,&#39;J.R.R. Tolkien&#39;,352,&#39;1954-11-11&#39;,49.99000000000000198&#xA;4,&#39;The Return of the King&#39;,&#39;J.R.R. Tolkien&#39;,416,&#39;1955-10-20&#39;,49.99000000000000198&#xA;```&#xA;&#xA;### Table&#xA;&#xA;The table mode simply outputs the result in table format. We saw this mode in the previous example.&#xA;&#xA;```&#xA;.mode table&#xA;SELECT * FROM books;&#xA;```&#xA;&#xA;```&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;| id |           title            |     author     | pages | release_date | price |&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;| 1  | The Hobbit                 | J.R.R. Tolkien | 310   | 1937-09-21   | 39.99 |&#xA;| 2  | The Fellowship of the Ring | J.R.R. Tolkien | 423   | 1954-07-29   | 49.99 |&#xA;| 3  | The Two Towers             | J.R.R. Tolkien | 352   | 1954-11-11   | 49.99 |&#xA;| 4  | The Return of the King     | J.R.R. Tolkien | 416   | 1955-10-20   | 49.99 |&#xA;+----+----------------------------+----------------+-------+--------------+-------+&#xA;```&#xA;&#xA;### Tabs&#xA;&#xA;The tabs mode simply outputs the result in tab-separated values.&#xA;&#xA;```&#xA;.mode tabs&#xA;SELECT * FROM books;&#xA;```&#xA;```&#xA;id      title   author  pages   release_date    price&#xA;1       The Hobbit      J.R.R. Tolkien  310     1937-09-21      39.99&#xA;2       The Fellowship of the Ring      J.R.R. Tolkien  423     1954-07-29      49.99&#xA;3       The Two Towers  J.R.R. Tolkien  352     1954-11-11      49.99&#xA;4       The Return of the King  J.R.R. Tolkien  416     1955-10-20      49.99&#xA;```&#xA;&#xA;### Tcl &#xA;&#xA;The Tcl mode simply outputs the result in Tcl format. Tcl or tool command language is a configuration friendly format.&#xA;```&#xA;.mode tcl&#xA;SELECT * FROM books;&#xA;```&#xA;```tcl&#xA;&#34;id&#34; &#34;title&#34; &#34;author&#34; &#34;pages&#34; &#34;release_date&#34; &#34;price&#34;&#xA;&#34;1&#34; &#34;The Hobbit&#34; &#34;J.R.R. Tolkien&#34; &#34;310&#34; &#34;1937-09-21&#34; &#34;39.99&#34;&#xA;&#34;2&#34; &#34;The Fellowship of the Ring&#34; &#34;J.R.R. Tolkien&#34; &#34;423&#34; &#34;1954-07-29&#34; &#34;49.99&#34;&#xA;&#34;3&#34; &#34;The Two Towers&#34; &#34;J.R.R. Tolkien&#34; &#34;352&#34; &#34;1954-11-11&#34; &#34;49.99&#34;&#xA;&#34;4&#34; &#34;The Return of the King&#34; &#34;J.R.R. Tolkien&#34; &#34;416&#34; &#34;1955-10-20&#34; &#34;49.99&#34;&#xA;```&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite dot commands: change directory command</title>
      <link>https://meetgor.com/sqlite-cd-dot-command</link>
      <description></description>
      <pubDate>Sun, 31 Aug 2025 00:00:00 UTC</pubDate>
      <content>## Change directory dot command&#xA;&#xA;If you are in a sqlite shell and forgot to change directory or want to navigate to a separate directory, you can do that with the `.cd` dot command.&#xA;&#xA;```sqlite&#xA;.cd /path/to/directory&#xA;```&#xA;&#xA;This is better than doing `.shell cd /path/to/directory` because it doesn&#39;t open a separate terminal process. So, the `.cd` is persistant throughout the session, whereas the `.shell cd &lt;path&gt;` will only within that command (subprocess).&#xA;&#xA;The `.cd` command changes the working directory of the SQLite shell itself, so the change persists for the rest of the session. This means commands like `.import`, `.read`, or `.output` will automatically look for files in the new directory.&#xA;&#xA;However, `.shell cd &lt;path&gt;` spawns a separate subprocess, and the directory change is discarded as soon as that command finishes. It does not affect SQLite’s own state of the current directory.&#xA;&#xA;So if you plan to read or write multiple files from a different location during your SQLite session, prefer the built-in `.cd` command.&#xA;&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
    <item>
      <title>SQLite dot commands: run system shell commands</title>
      <link>https://meetgor.com/sqlite-shell-dot-command</link>
      <description></description>
      <pubDate>Sat, 30 Aug 2025 00:00:00 UTC</pubDate>
      <content>## Shell dot command&#xA;&#xA;If you are in middle of a sqlite shell session, and you don&#39;t want to quit the shell to run arbitrary shell command, you can simply use the `.shell &lt;command&gt;` to execute any shell commands right from within the sqlite shell. How handy is this!&#xA;&#xA;```sqlite&#xA;.shell echo &#34;hello, world!&#34;&#xA;```&#xA;&#xA;That is a lame example, but it shows you the power of the `.shell` command.&#xA;&#xA;Let&#39;s say I want to run a golang project, I can do this:&#xA;&#xA;```sqlite&#xA;.shell go run main.go&#xA;```&#xA;&#xA;Its helpful if you want to do something but you don&#39;t want to quit the shell to do that:&#xA;- look up few files/datapoints from the local filesystem,&#xA;- run scripts to populate data&#xA;- populate database and then reopen the db shell&#xA;&#xA;This is are the things that I have stumbled upon, so far. Need more experience to see if there are more.&#xA;&#xA;&#xA;&#xA;&#xA;</content>
      <type>sqlog</type>
    </item>
  </channel>
</rss>