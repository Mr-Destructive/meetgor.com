<rss version="2.0">
  <channel>
    <title>Meet Gor - Tag: object-oriented-programming</title>
    <link>meetgor.com</link>
    <description>Posts tagged with object-oriented-programming</description>
    <language>en-us</language>
    <pubDate>Fri, 17 Oct 2025 16:57:38 UTC</pubDate>
    <item>
      <title>Object-Oriented Programming in C++: Constructors</title>
      <link>meetgor.com/oop-cpp-p3</link>
      <description></description>
      <pubDate>Thu, 23 Sep 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;After learning a bit about classes, objects, and access modifiers, we can move on to another important concept of Constructors and Destructors. This part will cover Constructors. We&#39;ll explore what are constructors, why we need them, types of constructors, and their semantics in C++ as usual. &#xA;&#xA;So without wasting any time, let&#39;s get started.&#xA;&#xA;## What is a constructor&#xA;&#xA;A constructor is a method just like another method in a class, but it has a special name for a reason. The name itself speaks, `Constructor`, which will get called just after the object gets created.  A constructor is just a method but it should only have the name same as of the class, that&#39;s the thing that distinguishes it from other methods. &#xA;&#xA;The main thing that stands out for a constructor is that you don&#39;t have to call it. It gets called automatically (just magically), yes you don&#39;t have to call it explicitly. That&#39;s a great feature in Object-Oriented Programming. We can control the flow of the program according to our needs. &#xA;&#xA;A constructor has certain features or principle that makes it different from the rest of the class methods:&#xA;&#xA;- There is no return type for a constructor.&#xA;- The name of the constructor should be the same as the class name.&#xA;- There can be multiple constructors for a class (depending on the parameters passed to it).&#xA;- A constructor gets called automatically when an object is instantiated (created).&#xA;&#xA;## Why do we need a constructor?&#xA;&#xA;Let&#39;s suppose you wanted to initialize some variables (properties) before the main loop of a program starts or initiates. This can be done manually by accessing them in the mail function but for many objects, this can get really boring to write every time. This is where the constructor comes in and just improves the overflow structure and manageability of the program.&#xA;&#xA;![oopcpp2-const.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1632390379922/V2avlZhzP.png)&#xA;&#xA;This looks silly but is actually used a lot just beyond initialization, you might want certain things to be done as soon as the object gets created. All ideas and flow of the program in a particular desired manner are all possible due to constructors. It is also a way of automating several repetitive tasks for better design and maintaining the codebase. &#xA;&#xA;## Define a constructor for a class in C++&#xA;&#xA;Now, it&#39;s time to get into code, and let&#39;s see how to define a constructor in a class using C++.&#xA;&#xA;```cpp&#xA;#include &#34;iostream&#34;&#xA;using namespace std;&#xA;&#xA;class blog&#xA;{&#xA;public:&#xA;    // defining a constructor for the blog class&#xA;    blog()&#xA;    {&#xA;         cout&lt;&lt;&#34;Call from constructor&#xA;&#34;;&#xA;     }&#xA;};&#xA;&#xA;int main(){&#xA;&#xA;&#x9;blog post1;&#xA;&#x9;&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;```&#xA;&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1632392596021/MY5H0maqx.png)&#xA;This is how you define a class in C++. A constructor doesn&#39;t even have a return type of void, literally, it doesn&#39;t return anything.  A Constructor can do anything another normal method can do except to return anything. We can also pass certain parameters to it as well. &#xA;&#xA;The thing here is that, the constructor should be public if you want to call it from the main function or anywhere else outside the class(class itself / friend class / derived class). You can make it private or protected as per your needs and the hierarchy of your application. If you want to know more about those access modifiers(public/private/protected), you can check the previous part of this series.&#xA;&#xA;&gt; Remember, you cannot call the constructor from the main function if it is not public.&#xA;&#xA;We can actually create some good examples where the constructor plays a vital role in the design and the feasibility of the actual idea.&#xA;&#xA;Let&#39;s say we want to create three objects, each taking the same input of properties from the user but the value will be different as obvious and also determine another property based on an input. Should we write those inputs for every object or write a function for the same. The latter will be the best choice, but which function are you thinking of? If that&#39;s a constructor then you are correct! Ya we can even write a normal method but we have a print function called up already, that might create some undesired behavior like unreferenced variables and segmentation fault while dealing with complex data structures or large applications.&#xA;&#xA;```cpp&#xA;#include &#34;iostream&#34;&#xA;#include &#34;string&#34;&#xA;using namespace std;&#xA;&#xA;class Animal&#xA;{&#xA;&#x9;public:&#xA;&#x9;&#x9;int legs;&#xA;&#x9;&#x9;string name;&#xA;&#x9;&#x9;string type;&#xA;&#xA;&#x9;&#x9;Animal()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;&#34;Who is the Animal? &#34;;&#xA;&#x9;&#x9;&#x9;cin&gt;&gt;type;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;&#34;Enter the name of Animal? &#34;;&#xA;&#x9;&#x9;&#x9;cin&gt;&gt;name;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;endl;&#xA;&#x9;&#x9;&#x9;if(type.compare(&#34;dog&#34;)==0)&#xA;&#x9;&#x9;&#x9;&#x9;legs=4;&#xA;&#x9;&#x9;&#x9;else if(type.compare(&#34;monkey&#34;)==0)&#xA;&#x9;&#x9;&#x9;&#x9;legs=2;&#xA;&#x9;&#x9;&#x9;else&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;legs=0;&#xA;&#x9;&#x9;}&#xA;&#x9;    &#x9;void print()&#xA;        &#x9;{&#xA;&#x9;&#x9;&#x9;if(legs==0)&#xA;&#x9;&#x9;&#x9;&#x9;cout&lt;&lt;type&lt;&lt;&#34;&#39;s name is &#34;&lt;&lt;name&lt;&lt;endl;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;    cout&lt;&lt;name&lt;&lt;&#34; has &#34;&lt;&lt;legs&lt;&lt;&#34; legs.&#xA;&#34;;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;endl;&#xA;&#x9;    &#x9;}&#xA;};&#xA;&#xA;int main(){&#xA;&#xA;&#x9;Animal obj1,obj2,obj3;&#x9;&#xA;&#x9;obj1.print();&#xA;&#x9;obj2.print();&#xA;&#x9;obj3.print();&#xA;&#x9;return 0;&#xA;}&#xA;```&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1632396836336/b6NLE-8287.png)&#xA;&#xA;We can see how well this can scale for creating many objects. This is just one of the examples where the constructor just single-handedly takes care of many things.  We can always create an array of objects but to keep things simple here, we have hardcoded the object names. &#xA;&#xA;## Types of Constructors&#xA;&#xA;Well, won&#39;t it be nice to pass the values to the constructor and then do certain computations? There is a solution to that, we can overload functions i.e we can create multiple constructors each having a unique combination of parameters associated with it. &#xA;&#xA;The following are the types of constructors:&#xA;&#xA;1. Default Constructors&#xA;2. Copy Constructors&#xA;3. Parameterized Constructor&#xA;&#xA;### Default Constructor&#xA;&#xA;This is the constructor which we have used so far, even if we don&#39;t define a constructor, the C++ compiler automatically creates one which does nothing. &#xA;&#xA;We have already seen the normal constructors without any parameters, just a simple function that does some I/O to the console. &#xA;&#xA;### Copy Constructor&#xA;&#xA;This is a great feature of constructors, you can copy certain properties of previously created objects or define new ones and pass them to the constructor. This is why I said we can have multiple constructors depending on the number of parameters or the type of parameters passes to it. &#xA;&#xA;So, with that said, we can basically define constructors for different purposes with different requirements and conditions. This just opens up a new dimension of creating complex functions and programs with great flexibility and adaptivity. &#xA;&#xA;```cpp&#xA;#include &#34;iostream&#34;&#xA;#include &#34;string&#34;&#xA;using namespace std;&#xA;&#xA;class Animal&#xA;{&#xA;&#x9;public:&#xA;&#x9;&#x9;int legs;&#xA;&#x9;&#x9;string name;&#xA;&#x9;&#x9;string type;&#xA;&#xA;&#x9;&#x9;Animal()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;&#34;Who is the Animal? &#34;;&#xA;&#x9;&#x9;&#x9;cin&gt;&gt;type;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;&#34;Enter the name of Animal? &#34;;&#xA;&#x9;&#x9;&#x9;cin&gt;&gt;name;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;endl;&#xA;&#x9;&#x9;&#x9;if(type.compare(&#34;dog&#34;)==0)&#xA;&#x9;&#x9;&#x9;&#x9;legs=4;&#xA;&#x9;&#x9;&#x9;else if(type.compare(&#34;monkey&#34;)==0)&#xA;&#x9;&#x9;&#x9;&#x9;legs=2;&#xA;&#x9;&#x9;&#x9;else&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;legs=0;&#xA;&#x9;&#x9;}&#xA;&#xA;        // copy constructor with reference of an object of the same class&#xA;&#x9;&#x9;Animal(Animal &amp;obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;&#34;This is my pet &#34;&lt;&lt;obj.type&lt;&lt;&#34;, &#34;&lt;&lt;obj.name&lt;&lt;endl;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;    &#x9;void print()&#xA;        &#x9;{&#xA;&#x9;&#x9;&#x9;if(legs==0)&#xA;&#x9;&#x9;&#x9;&#x9;cout&lt;&lt;type&lt;&lt;&#34;&#39;s name is &#34;&lt;&lt;name&lt;&lt;endl;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;    cout&lt;&lt;name&lt;&lt;&#34; has &#34;&lt;&lt;legs&lt;&lt;&#34; legs.&#xA;&#34;;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;endl;&#xA;&#x9;    &#x9;}&#xA;};&#xA;&#xA;int main(){&#xA;&#xA;&#x9;Animal obj1;&#x9;&#xA;&#x9;Animal obj4(obj1);&#xA;&#x9;obj1.print();&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;```&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1632403268364/cfjwyvgUeN.png)&#xA;&#xA;In the above example, we have defined another constructor that accepts a parameter that is a reference to another created object and basically does some I/O operations. &#xA;&#xA;Why would we need this?&#xA;&#xA;Well, the name itself says it all. `To copy the values of existing objects` with slight or minor modifications. It basically depends on how you want to copy the object into another. This can also be applied to additional class properties and just change the copy constructor and there it is, big tasks performed with minimal changes. We can also be used to modify the existing objects (though it can get a security issue, still pretty cool) by accessing the properties of that object in the copy constructor. &#xA; &#xA;&#xA;### Parameterized Constructor&#xA;&#xA;Now, we know that we can pass parameters to our constructors, let&#39;s exploit that functionality to create all sorts of constructors. No, I&#39;m just kidding, you can create multiple constructors by passing in various combinations of parameters to it.&#xA;&#xA;Let&#39;s take an example, instead of taking input from the default constructor we can pass in the values while creating the object, and the constructor which matches the parameters gets called. &#xA;&#xA;```cpp&#xA;#include &#34;iostream&#34;&#xA;#include &#34;string&#34;&#xA;using namespace std;&#xA;&#xA;class Animal&#xA;{&#xA;&#x9;public:&#xA;&#x9;&#x9;int legs;&#xA;&#x9;&#x9;string name;&#xA;&#x9;&#x9;string type;&#xA;&#xA;        // default constructor&#xA;&#x9;&#x9;Animal()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;&#34;Who is the Animal? &#34;;&#xA;&#x9;&#x9;&#x9;cin&gt;&gt;type;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;&#34;Enter the name of Animal? &#34;;&#xA;&#x9;&#x9;&#x9;cin&gt;&gt;name;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;endl;&#xA;&#x9;&#x9;&#x9;if(type.compare(&#34;dog&#34;)==0)&#xA;&#x9;&#x9;&#x9;&#x9;legs=4;&#xA;&#x9;&#x9;&#x9;else if(type.compare(&#34;monkey&#34;)==0)&#xA;&#x9;&#x9;&#x9;&#x9;legs=2;&#xA;&#x9;&#x9;&#x9;else&#x9;&#xA;&#x9;&#x9;&#x9;&#x9;legs=0;&#xA;&#x9;&#x9;}&#xA;&#xA;        // constructor with two parameters (both String)&#xA;&#x9;&#x9;Animal(string type, string name)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;&#34;This is my pet &#34;&lt;&lt;type&lt;&lt;&#34;, &#34;&lt;&lt;name&lt;&lt;endl;&#xA;&#x9;&#x9;}&#xA;&#xA;        // constructor with one parameter(String)&#xA;&#x9;&#x9;Animal(string name)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;&#34;Hello, &#34;&lt;&lt;name&lt;&lt;endl;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;    &#x9;void print()&#xA;        &#x9;{&#xA;&#x9;&#x9;&#x9;if(legs==0)&#xA;&#x9;&#x9;&#x9;&#x9;cout&lt;&lt;type&lt;&lt;&#34;&#39;s name is &#34;&lt;&lt;name&lt;&lt;endl;&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;    cout&lt;&lt;name&lt;&lt;&#34; has &#34;&lt;&lt;legs&lt;&lt;&#34; legs.&#xA;&#34;;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;endl;&#xA;&#x9;    &#x9;}&#xA;};&#xA;&#xA;int main(){&#xA;&#xA;&#x9;Animal obj1;&#x9;&#xA;&#x9;Animal obj2(&#34;dog&#34;, &#34;scooby&#34;);&#xA;&#x9;Animal obj3(&#34;Pomello&#34;);&#xA;&#x9;obj1.print();&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;```&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1632402898960/mc1D2S_iQ.png)&#xA;&#xA;We created the first object without any specification but the second object was passed with two parameters and we indeed called the correct constructor. The third object was just given a single parameter and again called the required constructor. &#xA;&#xA;So, we can see that a particular constructor is called which matches the parameters passed to it. That&#39;s quite an intelligent and smart design. This just improves the overall diversity and adaptability hand in hand. &#xA;&#xA;#### Function/Constructor Overloading&#xA;&#xA;&gt; When a single function(same name) has different implementations depending on the parameters passed to it is called Function overloading.&#xA;&#xA;The thing above i.e Parameterized Constructors is technically called Function Overloading (Constructor in this case). We will look into this topic in much detail when we cover more on methods. But this might be enough to get your head around the concept of overloading in OOP. &#xA;&#xA;Let&#39;s say we have a function that takes two parameters by default but also can take three parameters when given. We can process them by having a different implementation. This creates a lot of freedom and broadens the scope of customization in complex applications. &#xA;&#xA;```cpp&#xA;#include &#34;iostream&#34;&#xA;using namespace std;&#xA;&#xA;void intro(string name, int age)&#xA;{&#xA;&#x9;cout&lt;&lt;name&lt;&lt;&#34; is &#34;&lt;&lt;age&lt;&lt;&#34; years old.&#xA;&#34;;&#xA;}&#xA;&#xA;void intro(string name)&#xA;{&#xA;&#x9;cout&lt;&lt;&#34;Hello, &#34;&lt;&lt;name&lt;&lt;endl;&#xA;}&#xA;&#xA;&#xA;int main(){&#xA;&#xA;&#x9;intro(&#34;Ash&#34;,10);&#xA;&#x9;intro(&#34;Brock&#34;);&#xA;&#x9;&#x9;&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;```&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1632404708549/4h1izLpdS.png)&#xA;&#xA;In this example, we have a single function `intro` but it has two implementations, one has a two-parameter and the other has just one. This is called Function Overloading. We just applied this in the functions in classes called constructors but the concept is the same. We&#39;ll dive into Overloading in the next few sections. &#xA;&#xA;## Conclusion&#xA;&#xA;That is it from this part. We&#39;ll see `Destructors` in the next one. From this part, we learnt about constructors and how important they are in creating the desired flow to our application.  We also touched on the types of constructors and function overloading a bit, which are also important aspects of OOP. That&#39;s it from this one.&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Object-Oriented Programming in C++: Access Modifiers</title>
      <link>meetgor.com/oop-cpp-p2</link>
      <description></description>
      <pubDate>Sat, 18 Sep 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Moving on to Part 2 of Object-Oriented Programming in C++, we will look into the concept of access modifiers which we skipped in the first section. This won&#39;t be a comprehensive guide on access modifiers as it requires some other concepts like `Inheritance` which we will introduce in the next few sections. This series will be like connecting the pieces of OOP together and building a good foundation.  &#xA;&#xA;In this part, we will discuss the access modifiers and their related concepts. The below is a gist of what will be covered in this part. &#xA;&#xA;- Understanding Access Modifiers&#xA;- Type of Access Modifiers&#xA;    1. Private&#xA;        - Getters &#xA;        - Setters&#xA;    2. Public&#xA;    3. Protected&#xA;        - Introduction to Derived and Friend classes&#xA; &#xA;Without wasting any time, let&#39;s roll in.&#xA;&#xA;## What are Access Modifiers&#xA;&#xA;Access Modifiers as the name suggests they are used to change the accessibility of properties and methods in a Class. That means if we want a certain scope of our code to access the class members we can specify that using `access modifiers`. Access Modifiers form the basics or the pillar for `Data Encapsulation` in OOP.&#xA;&#xA;### Data Encapsulation&#xA;&#xA;Data Encapsulation is terminology in OOP to keep all the components in a single entity or unit. Here the components are `properties` and `methods` and they are contained in a single unit called `Class`.  We need to carefully use the class members i.e. properties and methods in order to avoid security and limiting certain members to be available for a specific scope or block of code.&#xA;&#xA; Hence, the Encapsulation of class members helps in structuring the class in a secure and allows access in a particular expected way. &#xA;&#xA; &#xA;## Types of Access Modifiers in C++&#xA;&#xA;We do have certain modifiers or limiters for accessing class members in C++. We can either keep the class members limited to the class itself (and friend class), keep them open to the global scope, or restrict them to certain classes only(derived and friend classes). &#xA;&#xA;Let&#39;s discuss them one by one.&#xA;&#xA;- ### Private&#xA;&#xA;This access modifier allows us to access the class members only to the class methods and the friend functions and classes. We will discuss what friend classes are in the next few parts of the series. This restricts the usage of the class members directly from the main function or other scopes in our program. You can use `private:` to indicate the below declared properties and methods are private to the class. &#xA;&#xA;```cpp&#xA;class Name&#xA;{ &#xA;    private:&#xA;        int name;&#xA;        //other properties and methods&#xA;}&#xA;```&#xA;&#xA;OR (don&#39;t specify anything it **is private by default**)&#xA;&#xA;```cpp&#xA;class Name&#xA;{ &#xA;    int name;&#xA;    //other properties and methods&#xA;}&#xA;```&#xA;&#xA;This is assigned to every member of the class by default. So that is why we explicitly told to make it public in an example in the previous part of the series. Let&#39;s see what happens if we do not make it public. &#xA;&#xA;```cpp&#xA;#include&lt;iostream&gt;&#xA;using namespace std;&#xA;&#xA;class Animal{&#xA;&#x9;int legs;&#xA;&#x9;string name;&#xA;&#x9;void print()&#xA;    &#x9;{&#xA;&#x9;&#x9;cout&lt;&lt;name&lt;&lt;&#34; has &#34;&lt;&lt;legs&lt;&lt;&#34; legs.&#xA;&#34;;&#xA;&#x9;}&#xA;};&#xA;&#xA;int main()&#xA;{&#xA;&#xA;&#x9;Animal dog;&#xA;&#x9;dog.name=&#34;Floyd&#34;;&#xA;&#x9;dog.legs=4;&#xA;&#x9;dog.print();&#xA;&#x9;&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;```&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631940306089/l4zOKB-RY.png)&#xA;&#xA;You can see we cannot directly use those properties and methods which are set as private. It is a convention to keep properties private and create public methods to access those from the rest of the program. The public methods used to access and modify the value of the private properties are called `getters` and `setters` respectively.&#xA;&#xA;#### Getters&#xA;&#xA;Getters are the public methods of a class that are used to access a value to the private properties of that class. It is a function that returns the data of that particular property. We access the function as normally as we access the public functions.&#xA;&#xA;We define the getter function as:&#xA;&#xA;```cpp&#xA;datatype getpropertyname()&#xA;{&#xA;    return propertyname;&#xA;}&#xA;```&#xA;&#xA;We can access the getter function as a normal public function, but this function returns a value, so we can store it in a variable and do all sorts of things.&#xA;&#xA;```cpp&#xA;classname objname;&#xA;court&lt;&lt;objname.getpropertyname()&lt;&lt;endl;&#xA;```&#xA;&#xA;#### Setters&#xA;&#xA;Setters are the public methods of a class that are used to assign/modify the value of the private properties of that class. It is a function that simply assigns the private properties to data of the data which is passed in as an argument to the function. We access the function as normally as we access the public functions. We have to pass in the value to assign the property to the function.&#xA;&#xA;We define the setter function as:&#xA;&#xA;```cpp&#xA;datatype setpropertyname(datatype x)&#xA;{&#xA;    propertyname = x;&#xA;}&#xA;```&#xA;&#xA;We can access the setter function as a normal public function, but this function takes in a parameter, so need to pass in the value to assign it the same as the correspondent data type of that property.&#xA;&#xA;```cpp&#xA;classname objname;&#xA;objname.setpropertyname(data);&#xA;```&#xA;&#xA;So, after applying the getter and setter concept to our example, we can use them and make the properties private without any issues.&#xA;&#xA;&#xA;```cpp&#xA;#include&lt;iostream&gt;&#xA;using namespace std;&#xA;&#xA;class Animal{&#xA;&#x9;int legs;&#xA;&#x9;string name;&#xA;&#x9;public:&#xA;&#xA;    // take in a parameter of type same as of the property &#xA;&#x9;void setName(string dogname)   &#xA;&#x9;{&#xA;&#x9;&#x9;name=dogname; &#xA;        // assign the property a value same as of the parameter       &#xA;&#x9;}&#xA;&#xA;    // return type should be same as of the property &#xA;&#x9;string getName()   &#xA;&#x9;{&#xA;&#x9;&#x9;return name;&#xA;&#x9;}&#xA;&#xA;&#x9;void setleg(int noflegs)&#xA;&#x9;{&#xA;&#x9;&#x9;legs=noflegs;&#xA;&#x9;}&#xA;&#xA;&#x9;int getleg()&#xA;&#x9;{&#xA;&#x9;&#x9;return legs;&#xA;&#x9;}&#xA;};&#xA;&#xA;int main()&#xA;{&#xA;&#x9;Animal dog;&#xA;&#x9;dog.setName(&#34;Flyod&#34;);&#xA;&#x9;dog.setleg(4);&#xA;&#x9;cout&lt;&lt;dog.getName()&lt;&lt;endl;&#xA;&#x9;cout&lt;&lt;dog.getleg()&lt;&lt;endl;&#xA;&#x9;&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;```&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631949135706/zVd5cMPKa.png)&#xA;&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631956955383/MKp5YDMv5.png)&#xA;&#xA;The above code runs successfully, and hence we make our program more secure and provide limited access to the rest of the components. You can see how we have passed the data as the parameter to the setter function, it should be the appropriate data-type with the property you are trying to set and also the same return type for the getter function.&#xA;&#xA;The code is also much readable and structured for others to read and understand. It might seem a silly thing but it really improves the maintainability in the longer run. &#xA;&#xA;&#xA;- ### Public&#xA;&#xA;This might be familiar till now, we have been using this access modifier till now and it is quite straightforward to understand. We have created the getter and setter function using this access modifier.&#xA;&#xA;So, the `public` access modifier makes the class members be accessible anywhere in the program. This might be OK for many small applications but it is not ideal to use them for production-level applications as it might cause undesired consequences i.e. BUGS.&#xA;&#xA;We need to explicitly write public in the class definition, as `private` is set by default. So, as a simple example, as we saw in the previous part, it can be a lot easier to go with the public to understand OOP but the main OOP really shines in aspects like Encapsulation and Inheritance of Classes, which we will surely see in the upcoming parts.&#xA;&#xA;This is the example from the previous part:&#xA;&#xA;```cpp&#xA;#include&lt;iostream&gt;&#xA;using namespace std;&#xA;&#xA;class Animal&#xA;{&#xA;&#x9;public:&#xA;&#x9;&#x9;int legs;&#xA;&#x9;&#x9;string name;&#xA;&#x9;    &#x9;void print()&#xA;        &#x9;{&#xA;&#x9;&#x9;    cout&lt;&lt;name&lt;&lt;&#34; has &#34;&lt;&lt;legs&lt;&lt;&#34; legs.&#xA;&#34;;&#xA;&#x9;    &#x9;}&#xA;};&#xA;&#xA;int main()&#xA;{&#xA;&#x9;Animal dog;            // create an object of class Animal&#xA;&#xA;&#x9;dog.name=&#34;Floyd&#34;;     // assign the class property to actual data in memory&#xA;&#x9;dog.legs=4;                 &#xA;&#x9;dog.print();          // call a method(function) associated to object&#39;s class&#xA;&#x9;&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;```&#xA;![public-class](https://cdn.hashnode.com/res/hashnode/image/upload/v1631795000896/kUvcfVU7Y.png)&#xA;&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631958067712/yU8uvd5KQ.png)&#xA;&#xA;As explained earlier, it is accessible to the main function or other scopes as well. We can access them using the dot separator(`.`) to assign it or to call the method.&#xA;&#xA;- ### Protected&#xA;&#xA;This is quite a handy access modifier, as it allows us to have the flexibility to keep the class members private and accessible to its derived or friend class. We will see the derived and friend classes in the next few parts. But for now, let&#39;s understand in an abstracted way.&#xA;&#xA;#### Derived Class(Child Class/ Sub Class)&#xA;&#xA;This is a concept in Inheritance, i.e. to pass the members of a class to another. So, there has to be two classes, the main(parent class) and another class that will inherit or take in the members from the parent class. So, the derived class has access to its public and protected members only.&#xA;&#xA;&#xA;#### Friend class&#xA;&#xA;A friend class is a class that is allowed to access its **private** and protected properties or methods. It is kind of a special tag assigned to a class that it can access certain class&#39; members. We will see it in detail afterward, right now, it&#39;s enough to understand, friend class is a class that can access a particular class&#39; members may it be private or protected. &#xA;&#xA;The difference between a friend and a derived class is that a friend class can access the private members of the class to which it is a friend, but a derived class can&#39;t. Friend class also can&#39;t be inherited. Again, we will see this is in detail. &#xA;&#xA;So, it doesn&#39;t make sense for me to explain protected here. But just assume friend classes and derived classes are a thing.&#xA;&#xA;```cpp&#xA;#include&lt;iostream&gt;&#xA;using namespace std;&#xA;&#xA;class Animal&#xA;{&#xA;&#x9;public:&#xA;&#x9;&#x9;int legs;&#xA;&#x9;&#x9;string type;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;void print()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;type&lt;&lt;&#34; has &#34;&lt;&lt;legs&lt;&lt;&#34; legs.&#xA;&#34;;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;protected:&#xA;&#x9;&#x9;string name;&#xA;};&#xA;&#xA;&#xA;int main()&#xA;{&#xA;&#xA;&#x9;Animal dog;&#xA;&#x9;dog.type=&#34;dog&#34;;&#xA;&#x9;dog.legs=4;&#xA;    &#x9;dog.name=&#34;Floyd&#34;;&#xA;&#x9;dog.print();&#xA;&#x9;&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;```&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631956345308/epOckpl6X.png)&#xA;&#xA;This gives an error as protected members can be accessed only by derived or friend classes since we are accessing it from the main function, it&#39;s not allowed in the global scope. We can only access the protected members from the derived or friend classes. &#xA;&#xA;So, let&#39;s derive a class from the base class(Animal), and after that, we can see protected members in action.&#xA;&#xA;```cpp&#xA;#include&lt;iostream&gt;&#xA;using namespace std;&#xA;&#xA;class Animal&#xA;{&#xA;&#x9;public:&#xA;&#x9;&#x9;int legs;&#xA;&#x9;&#x9;string type;&#xA;&#x9;&#x9;&#xA;&#x9;&#x9;void print()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;type&lt;&lt;&#34; has &#34;&lt;&lt;legs&lt;&lt;&#34; legs.&#xA;&#34;;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;protected:&#xA;&#x9;&#x9;string name;&#xA;};&#xA;&#xA;class Pet:public Animal &#xA;{&#xA;&#x9;public:&#xA;&#x9;&#x9;void print()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;name=&#34;Floyd&#34;;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;name&lt;&lt;&#34; is a &#34;&lt;&lt;type&lt;&lt;endl;&#xA;&#x9;&#x9;&#x9;cout&lt;&lt;type&lt;&lt;&#34; has &#34;&lt;&lt;legs&lt;&lt;&#34; legs.&#xA;&#34;;&#xA;&#x9;&#x9;}&#xA;&#xA;};&#xA;&#xA;int main()&#xA;{&#xA;&#xA;&#x9;Pet dog;&#xA;&#x9;dog.type=&#34;dog&#34;;&#xA;&#x9;dog.legs=4;&#xA;&#x9;dog.print();&#xA;&#x9;&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;&#xA;```&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631956708698/HJTOZN9sw.png)&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631956815750/a2y5QLiPT.png)&#xA;&#xA;We have accessed the protected property `name` in the derived class `Pet`. Yes, this is how we derive a class in C++, &#xA;&#xA;```cpp&#xA;// A child class serived from base class&#xA;class NewClassName: public BaseClassName&#xA;{&#xA;     // properties and methods&#xA;};&#xA;```&#xA;So, after deriving the `Pet` class from `Animal` class, we have access to its public and protected class as well. We simply assigned one of the protected members from its base class i.e. `name` and used it in the function `print`. &#xA;&#xA;This is how you can use protected members in a derived class, also you can do it in friend class, but we will look at that in a separate part. Remember you can **use getters and setters as well to assign and access those protected members**.  Keeping it simple and easy to understand is what a protected access modifier can provide. &#xA;&#xA;**Protected access modifiers are quite great and provide much more flexibility than `private` and more privacy than `public` access modifiers.**&#xA;&#xA;## Which to use when?&#xA;&#xA;It is often a good practice to use private members, but it might be not possible to make everything private, so we can use certain properties as private, some methods as public and protected as well as per requirement and complexity. &#xA;&#xA;&#xA;![acmod.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631953460021/_4WlLGDI_.png)&#xA;&#xA;Looking at the above chart, you can analyze your problem and work a way around to find the perfect secure match for your application. &#xA;&#xA;Remember to use public members only when you have to explicitly use through the program. If you find that, this member shouldn&#39;t be introduced in certain scope then use make it private or protected.&#xA;&#xA;If there is some kind of hierarchy in the program and its components, analyze and make a structure of it to have a better understanding of the program flow.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this part, we were able to understand the access modifiers and got somewhat of a dive into Inheritance. There were some concepts like Friend and Derived classes, Inheritance, Encapsulation which were just explained in short, but they are a topic that deserves separate attention. We&#39;ll discuss them in the upcoming parts.&#xA;&#xA;Thanks for reading. Hope you understood the concepts in a better way. Until then, as always, Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Object-Oriented Programming in C++: Classes and Objects</title>
      <link>meetgor.com/oop-cpp-p1</link>
      <description></description>
      <pubDate>Thu, 16 Sep 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;We all know that C++ is famously known for Object-Oriented Programming, but what is Object-Oriented Programming? Well, this is the article, where we will explore the basics of Object-Oriented Programming, its building blocks i.e Classes and Objects, and get familiar with its basic semantics in C++. Let&#39;s get into it straight away!&#xA;&#xA;## What is Object-Oriented Programming?&#xA;&#xA;Object-Oriented Programming(OOP) is a way to structure and design a program or an application. Object-Oriented Programming deals with creating classes and objects and it&#39;s related terminologies. OOP helps in following the principles like DRY(Don&#39;t Repeat Yourself) and KISS(Keep it Simple Stupid). Using OOP certain applications and problems can be solved in a simple and efficient way. It helps in better understanding and readability of the code.&#xA;&#xA;&gt; Virus is a class and COIVD-19 is an object of the Virus class XD&#xA;&#xA;In OOP we create a collection of the data and functionalities by organizing in a structure called `Class`. We then instantiate or create the actual data by creating an `object` of the particular class. Once we have created a class, we can simply create as many objects as we need to. Objects are basically the storage of the actual data in memory. Let&#39;s explore them in the next few sections.&#xA;&#xA;NOTE: There are a lot of terminologies in OOP, just remember the basics of those terms and not the different names of those terms.&#xA;&#xA;## What are Classes&#xA;&#xA;Classes are the structure or template of the data and its associated behavior. The data or the variables in the classes are called `properties` or `attributes`(also `data members`). We also have functions that define the behavior of the properties or the data present in the class and are called `methods`.&#xA;&#xA; A Class in C++ should be defined outside of the main function. In C++, `class` is a reserved word and hence it is used to declare and define a class. It has a general structure like:&#xA;```cpp&#xA;class Name&#xA;{&#xA;    // properties and methods&#xA;};&#xA;```&#xA;&#xA;It&#39;s a convention to use the initial letter of a Class Name Uppercased. We can define class methods outside the class body as well, we will see it in the next few parts of the series.  &#xA;&#xA;Let&#39;s create a basic class in C++,&#xA;```cpp&#xA;class Animal&#xA;{&#xA;&#x9;public:&#xA;&#x9;&#x9;int legs;&#xA;&#x9;&#x9;string name;&#xA;&#x9;void print()&#xA;    {&#xA;&#x9;&#x9;cout&lt;&lt;name&lt;&lt;&#34; has &#34;&lt;&lt;legs&lt;&lt;&#34; legs.&#xA;&#34;;&#xA;&#x9;}&#xA;};&#xA;&#xA;```&#xA;Here in the above code, we have a class called `Animal` and it has 2 properties called `legs` which is an int and `name` a string. We also have a method called `print` which displays the current object&#39;s name and the leg count. We will see what is the current object in the next section. &#xA;&#xA;![oopcpp1-class.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631797771422/6jCNpCYz_q.png)&#xA;&#xA;We use those properties or the variables defined in the class in our application either by accessing them through the objects or in the methods of that class. The variables or properties in classes are not assigned to any memory address i.e. they are just kind of a blueprint or placeholder tags to match for the data.&#xA;&#xA;### Access Specifier&#xA;We have written `public` before the definition of the properties of the class, it is an access modifier. Don&#39;t worry we will see it in detail in the next few parts of the series, just for time being understand that we can change whether we want the main function(or any function globally) to access the class&#39; properties or not. &#xA;&#xA;We are saying `public` which means we can access the properties of this class anywhere outside the class. This is not a good practice but just for simplicity of understanding, we are using public. **If you do not specify anything like `public`, it is by default `private`, which means the properties of the class are not accessed anywhere outside the class**. Let keep it simple right now.&#xA;&#xA;We also have other concepts like defining the methods outside/inside the class, header files, constructors, destructors, and many others related to a class definition, we will cover it in the next few parts.&#xA;&#xA;## What are Objects&#xA;&#xA;Now, we have created a class but where is the data actually? It will be in `objects`, We actually assign the data or properties to a memory address by creating the objects of that particular class. &#xA;&#xA;We can create objects of a particular class in C++ by writing the name of the class that this object will belong to and the name of the object,`classname objectname;`. This will create or assign memory to the properties of the class to the object. &#xA;&#xA;After the object has been created, we can assign the value to the properties of the class in the object. We can access the properties of the class by referencing the name of the object with `.` and the name of the property or variable of the class, `objectname.propertyname`, we can assign the value simply by using the assignment operator `=` and give the properties the value, input from the user or however you like it.  &#xA;&#xA;```cpp&#xA;#include&lt;iostream&gt;&#xA;using namespace std;&#xA;&#xA;class Animal&#xA;{&#xA;&#x9;public:&#xA;&#x9;&#x9;int legs;&#xA;&#x9;&#x9;string name;&#xA;&#x9;void print()&#xA;    {&#xA;&#x9;&#x9;cout&lt;&lt;name&lt;&lt;&#34; has &#34;&lt;&lt;legs&lt;&lt;&#34; legs.&#xA;&#34;;&#xA;&#x9;}&#xA;};&#xA;&#xA;int main(){&#xA;&#xA;&#x9;Animal dog;            // create an object of class Animal&#xA;&#xA;&#x9;dog.name=&#34;Floyd&#34;;     // assign the class property to actual data in memory&#xA;&#x9;dog.legs=4;                 &#xA;&#x9;dog.print();          // call a method(function) associated to object&#39;s class&#xA;&#x9;&#xA;&#x9;return 0;&#xA;}&#xA;&#xA;```&#xA;&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631795000896/kUvcfVU7Y.png)&#xA;&#xA;If Animal is the class, then the dog here is the object. As simple as you can think. We are technically **instantiating an object** when we say `Animal dog`.  We assign the variables the memory as defined in the class. We give some value to the properties using the `.`(dot syntax), after the class name. &#xA;&#xA;So `dog.legs = 4;` will assign the value of 4 in the memory address of the object&#39;s property(dog is the class and legs is the property).&#xA;&#xA;Similarly, we can call the function associated with the class as we do for properties but we use `()` to indicate to calling the function.&#xA;&#xA;&#xA;![oopcpp1-obj.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1631799152681/UhNDYdEXK.png)&#xA;&#xA;So that is how we create objects in C++.&#xA;&#xA;## Why and When to use OOP&#xA;&#xA;Object-Oriented programming makes quite complex problems and applications structure and scale quite easily and enhances the readability of the codebase. We can use OOP to create the applications for bigger and real-life applications, it allows us to add new features quite easily and thereby improving the maintaining ability.&#xA;&#xA;The following might be the reasons to use OOP in an application:&#xA;&#xA;- If the application cannot be stated in a single sentence, you need to create the components into classes and hence use OOP.&#xA;&#xA;- It is quite easy to maintain OOP applications even if there are a lot of maintainers to the project.&#xA;&#xA;- If you see certain parts of the code repeating in many places, OOP is the way to go.&#xA;&#xA;- If you want your application to be secure in terms of data from the rest of the components, OOP is again a great option as you can use Encapsulation to the advantage.&#xA;&#xA;&#xA;## Conclusion&#xA;&#xA;So, we have studied the concept of Object-Oriented Programming and how to define classes and create objects in C++. There are a lot of concepts in OOP to grab up in the next few parts of the series, but this should build the foundation of OOP as a paradigm or a way of thinking when it comes to problem-solving and programming.&#xA;&#xA;I hope you have got a good introduction to the basics of Object-Oriented Programming and its semantics in C++. Thank you for reading. In the next part, we will explore the Access Modifiers/Specifiers in the Classes. Until then Happy Coding :) &#xA;</content>
      <type>posts</type>
    </item>
  </channel>
</rss>