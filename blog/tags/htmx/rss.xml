<rss version="2.0">
  <channel>
    <title>Meet Gor - Tag: htmx</title>
    <link>meetgor.com</link>
    <description>Posts tagged with htmx</description>
    <language>en-us</language>
    <pubDate>Fri, 17 Oct 2025 16:57:38 UTC</pubDate>
    <item>
      <title>Creating a Chat Application with Django and HTMX</title>
      <link>meetgor.com/django-htmx-chat-app</link>
      <description>Building a async, websocket based chat application using django, channels and htmx. With this chat application, the user can create and join rooms and send and recieve messages.</description>
      <pubDate>Sun, 05 Feb 2023 00:00:00 UTC</pubDate>
      <content>&#xA;# Django + HTMX Chat application&#xA;&#xA;## Introduction&#xA;&#xA;In this article, we will be creating a Django project, which will be a chat-room kind of application. The user needs to authenticate to the app and then and there he/she can create or join rooms, every room will have some name and URL associated with it. So, the user simply needs to enter the name of the room, which will be unique. The user can then simply enter the messages in the chat room. This is a core chat application that uses web sockets.&#xA;&#xA;The unique thing about this app will be that, we don&#39;t have to write a javascript client. It will all be handled by some HTMX magic. The web socket in the backend will definitely handle using Django channels.&#xA;&#xA;Demo:&#xA;&#xA;![Demonstration of the Chat App](https://meetgor-cdn.pages.dev/django-htmx/chat-app-demo.webm)&#xA;&#xA;[GitHub Repository](https://github.com/Mr-Destructive/django-htmx-chat)&#xA;&#xA;### Requirements:&#xA;&#xA;* Django&#xA;    &#xA;* Django-channels&#xA;    &#xA;* daphne&#xA;    &#xA;* HTMX&#xA;    &#xA;* SQLite or any relational database&#xA;    &#xA;&#xA;Also if we want to use the application on a large and production scale:&#xA;&#xA;* Redis&#xA;    &#xA;* channels_redis&#xA;&#xA;The code for this chat app is provided in the [GitHub repository](https://github.com/Mr-Destructive/django-htmx-chat).&#xA;&#xA;## Setup for Django project&#xA;&#xA;We will create a simple Django project to start with. The project can have two apps, one for auth and the other for the chat. You can customize the way you want your existing project accordingly. This project is just a demonstration of the use of the chat application with websockets and Django channels.&#xA;&#xA;I&#39;ll call the project `backchat`, you can call it whatever you want. We will create a virtual environment and install Django in that virtual environment&#xA;&#xA;```bash&#xA;virtualenv .venv&#xA;&#xA;For Linux/macOS:&#xA;source .venv/bin/activate&#xA;&#xA;For Windows:&#xA;.venv\scriptsï¿½ctivate&#xA;&#xA;pip install django&#xA;django-admin startproject backchat&#xA;cd backchat&#xA;```&#xA;&#xA;This will set up a base Django project. We can now work on the actual implementation of the Django project. Firstly, we will start with authentication.&#xA;&#xA;## Adding basic Authentication and Authorization&#xA;&#xA;### Creating the accounts app&#xA;&#xA;We can separate the authentication of the user from the rest of the project, by creating a separate app called `user` or `accounts` app.&#xA;&#xA;```bash&#xA;python manage.py startapp accounts&#xA;```&#xA;&#xA;### Creating a base user model&#xA;&#xA;We&#39;ll start by inheriting the [AbstractUser](https://docs.djangoproject.com/en/4.1/topics/auth/customizing/#using-a-custom-user-model-when-starting-a-project) the model provided in the `django.contrib.auth.models` module. The model has base fields like `username` and `password` which are required fields, and `email`, `first_name`, `last_name`, etc. which are not mandatory. It is better to create a custom model by inheriting the `AbstractUser` because if in the longer run, we need to make custom fields in the user model, it becomes a breeze.&#xA;&#xA;```python&#xA;# accounts/models.py&#xA;&#xA;&#xA;from djnago.contrib.auth.models import AbstractUser&#xA;&#xA;&#xA;class User(AbstractUser):&#xA;    pass&#xA;```&#xA;&#xA;This creates a basic custom user rather than using the Django built-in user. Next, we need to make sure, Django understands the default user is the one we defined in the `accounts` app and not the default `User`. So, we just need to add a field called `AUTH_USER_MODEL` in the `settings.py` file. The value of this field will be the app name or the module name and the model in that python module that we need our custom user model to be set as the default user model.&#xA;&#xA;```python&#xA;# backchat/settings.py&#xA;&#xA;&#xA;INSALLED_APPS = [&#xA;    ...&#xA;    ...&#xA;    &#34;accounts&#34;,&#xA;]&#xA;&#xA;# Append to the end of file&#xA;AUTH_USER_MODEL = &#39;accounts.User&#39;&#xA;```&#xA;&#xA;### Initial migrations for the Django project&#xA;&#xA;Now, this will get picked up as the default user model while referring to any processing related to the user. We can move into migrating the changes for the basic Django project and the user model.&#xA;&#xA;```bash&#xA;python manage.py makemigrations&#xA;python manage.py migrate&#xA;```&#xA;&#xA;![initial migration for base django and user model](https://meetgor-cdn.pages.dev/django-htmx/chat-accounts-migrations.png)&#xA;&#xA;### Creating register view&#xA;&#xA;Further, we can add the views like register and profile for the accounts app that can be used for the basic authentication. The Login and Logout views are provided in the `django.contrib.auth.views` module, we only have to write our own register view. I will be using function-based views to keep it simple to understand but it can simply be a class-based view as well.&#xA;&#xA;To define a view first, we need to have form, a user registration form. The form will inherit from the [UserCreationForm](https://docs.djangoproject.com/en/4.1/topics/auth/default/#django.contrib.auth.forms.UserCreationForm) form which will make the bulk of the task for us at the user registration. We can simply then override the Meta class with the fields that we want to display, so hence we just keep the `username` and the `password` fields. The form can be customized by adding in the widget attribute and specifying the classes used in them.&#xA;&#xA;```python&#xA;# accounts/forms.py&#xA;&#xA;&#xA;from accounts.models import User&#xA;from django.contrib.auth.forms import UserCreationForm&#xA;&#xA;class UserRegisterForm(UserCreationForm):&#xA;&#xA;    class Meta:&#xA;        model= User&#xA;        fields = [&#39;username&#39;, &#39;password1&#39;, &#39;password2&#39;]&#xA;```&#xA;&#xA;This will give us the `UserRegisterForm` form that can be used for displaying in the register view that we will create in the next step.&#xA;&#xA;We will have to create the register view that will render the form for user registration and will also process the form submission.&#xA;&#xA;```python&#xA;# accounts/views.py&#xA;&#xA;&#xA;from django.contrib import messages&#xA;from django.shortcuts import redirect, render&#xA;from accounts.forms import UserRegisterForm&#xA;&#xA;def register(request):&#xA;    if request.method == &#34;POST&#34;:&#xA;        form = UserRegisterForm(request.POST)&#xA;        if form.is_valid():&#xA;            form.save()&#xA;            username = form.cleaned_data.get(&#34;username&#34;)&#xA;            messages.success(&#xA;                request, f&#34;Your account has been created! You are now able to log in&#34;&#xA;            )&#xA;            return redirect(&#34;login&#34;)&#xA;    else:&#xA;        form = UserRegisterForm()&#xA;        return render(request, &#34;accounts/register.html&#34;, {&#34;form&#34;: form})&#xA;```&#xA;&#xA;The above register view has two cases, one for the user requesting the registration form and the second request when the user submits the form. So, when the user makes a get request, we load an empty form `UserRegisterForm` and render the `register` template with the form. We will make the templates later.&#xA;&#xA;So, the template is just rendered when the user wants to register and when the user submits the form(sends a post request) we get the details from the post request and make it an instance of `UserRegisterForm` and save the form if it is valid. We then redirect the user to the login view (will use the default one in the next section). We parse the message as the indication that the user was created.&#xA;&#xA;### Adding URLs for Authentication and Authorization&#xA;&#xA;Once, we have the register view setup, we can also add login and logout views in the app. But, we don&#39;t have to write it ourselves, we can override them if needed, but we&#39;ll keep the default ones. We will use the [LoginView](https://docs.djangoproject.com/en/4.1/topics/auth/default/#django.contrib.auth.views.LoginView) and the [LogoutView](https://docs.djangoproject.com/en/4.1/topics/auth/default/#django.contrib.auth.views.LogoutView) view which are class-based views provided in the `django.contrib.auth.views` module. We will provide the respective templates for each of these views.&#xA;&#xA;```python&#xA;# accounts/urls.py&#xA;&#xA;&#xA;from django.urls import path&#xA;from django.contrib.auth import views as auth_views&#xA;import user.views as user_views&#xA;&#xA;urlpatterns = [&#xA;    path(&#34;register/&#34;, user_views.register, name=&#34;register&#34;),&#xA;    path(&#xA;        &#34;login/&#34;,&#xA;        auth_views.LoginView.as_view(template_name=&#34;accounts/login.html&#34;),&#xA;        name=&#34;login&#34;,&#xA;    ),&#xA;    path(&#xA;        &#34;logout/&#34;,&#xA;        auth_views.LogoutView.as_view(template_name=&#34;accounts/logout.html&#34;),&#xA;        name=&#34;logout&#34;,&#xA;    ),&#xA;]&#xA;```&#xA;&#xA;We have named the URLs as `register`, `login`, and `logout` so that we can use them while rendering the links for them in the templates. Now, we also need to include the URLs from the accounts app in the project URLs. We can do that by using the `include` method and specifying the app name with the module where the urlpatterns are located.&#xA;&#xA;```python&#xA;# backchat/urls.py&#xA;&#xA;&#xA;from django.contrib import admin&#xA;from django.urls import include, path&#xA;&#xA;urlpatterns = [&#xA;    path(&#34;admin/&#34;, admin.site.urls),&#xA;    path(&#34;auth/&#34;, include(&#34;accounts.urls&#34;)),&#xA;]&#xA;```&#xA;&#xA;So, we have routed the `/auth` path to include all the URLs in the accounts app. So, the login view will be at the URL `/auth/login/` , and so on.&#xA;&#xA;Also, we need to add the `LOGIN_REDIRECT_URL` and `LOGIN_URL` for specifying the url name which will be redirected once the user is logged in and the default login url name respectively.&#xA;&#xA;```python&#xA;# backchat / settings.py&#xA;&#xA;&#xA;LOGIN_REDIRECT_URL = &#34;index&#34;&#xA;LOGIN_URL = &#34;login&#34;&#xA;```&#xA;&#xA;We are now almost done with the view and routing part of the accounts app and can move into the creation of templates.&#xA;&#xA;### Adding Templates for authentication views&#xA;&#xA;We need a few templates that we have been referencing in the views and the URLs of the accounts app in the project. So there are a couple of ways to use templates in a Django project. I prefer to have a single templates folder in the root of the project and have subfolders as the app which will have the templates specific to those apps.&#xA;&#xA;I usually create a `base.html` file in the templates folder and use that for inheriting other templates. So, we will have to change one setting in the project to make sure it looks at `templates/` from the root of the project.&#xA;&#xA;```bash&#xA;# backchat/settings.py&#xA;&#xA;import os&#xA;&#xA;...&#xA;...&#xA;&#xA;TEMPLATES = [&#xA;    {&#xA;        &#34;BACKEND&#34;: &#34;django.template.backends.django.DjangoTemplates&#34;,&#xA;        &#34;DIRS&#34;: [ os.path.join(BASE_DIR, &#34;templates&#34;), ],&#xA;        &#34;APP_DIRS&#34;: True,&#xA;        &#34;OPTIONS&#34;: {&#xA;            &#34;context_processors&#34;: [&#xA;                &#34;django.template.context_processors.debug&#34;,&#xA;                &#34;django.template.context_processors.request&#34;,&#xA;                &#34;django.contrib.auth.context_processors.auth&#34;,&#xA;                &#34;django.contrib.messages.context_processors.messages&#34;,&#xA;            ],&#xA;        },&#xA;    },&#xA;]&#xA;```&#xA;&#xA;Then create the folder in the same path as you see your `manage.py` file.&#xA;&#xA;```bash&#xA;mkdir templates&#xA;```&#xA;&#xA;![Template Set Up](https://meetgor-cdn.pages.dev/django-htmx/chat-mkdir-templates.png)&#xA;&#xA;#### Creating the base template&#xA;&#xA;The below will be the base template used for the chat application, you can custmize it as per your needs.&#xA;&#xA;```html&#xA;&lt;!DOCTYPE html&gt;&#xA;&lt;html&gt;&#xA;    &lt;head&gt;&#xA;        &lt;meta charset=&#34;utf-8&#34; /&gt;&#xA;        &lt;title&gt;Chat App&lt;/title&gt;&#xA;        {% load static %}&#xA;        &lt;script src=&#34;https://unpkg.com/htmx.org@1.8.5&#34;&gt;&lt;/script&gt;&#xA;    &lt;/head&gt;&#xA;    &lt;body&gt;&#xA;        {% if user.is_authenticated %}&#xA;            &lt;a href=&#34;{% url &#39;logout&#39; %}&#34;&gt;Logout&lt;/a&gt;&#xA;        {% else %}&#xA;            &lt;a href=&#34;{% url &#39;login&#39; %}&#34;&gt;Login&lt;/a&gt;&#xA;        {% endif %}&#xA;        &lt;h1&gt;Back Chat&lt;/h1&gt;&#xA;        {% block base %}&#xA;        {% endblock %}&#xA;    &lt;/body&gt;&#xA;&lt;/html&gt;&#xA;```&#xA;&#xA;We have included the [htmx](https://htmx.org/docs/#installing) package as the script into this template as we will be using it in the actual part of chat application.&#xA;&#xA;#### Creating the Register Template&#xA;&#xA;```html&#xA;# templates / accounts / register.html&#xA;&#xA;&#xA;{% extends &#39;base.html&#39; %}&#xA;{% block base %}&#xA;    &lt;div class=&#34;content-section&#34;&gt;&#xA;        &lt;form method=&#34;POST&#34;&gt;&#xA;            {% csrf_token %}&#xA;            &lt;fieldset class=&#34;form-group&#34;&gt;&#xA;                &lt;legend class=&#34;border-bottom mb-4&#34;&gt;Register Now&lt;/legend&gt;&#xA;                {{ form.as_p }}&#xA;            &lt;/fieldset&gt;&#xA;            &lt;div class=&#34;form-group&#34;&gt;&#xA;                &lt;button class=&#34;btn btn-outline-info&#34; type=&#34;submit&#34;&gt;Sign Up&lt;/button&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/form&gt;&#xA;        &lt;div class=&#34;border-top pt-3&#34;&gt;&#xA;            &lt;small class=&#34;text-muted&#34;&gt;&#xA;&#x9;&#x9;    Already Have An Account? &lt;a class=&#34;ml-2&#34; href=&#34;{% url &#39;login&#39; %}&#34;&gt;Log In&lt;/a&gt;&#xA;            &lt;/small&gt;&#xA;        &lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;{% endblock %}&#xA;```&#xA;&#xA;![User Registration Page](https://meetgor-cdn.pages.dev/django-htmx/chat-register-page.png)&#xA;&#xA;#### Creating the Login Template&#xA;&#xA;```html&#xA;# templates / accounts / login.html    &#xA;&#xA;&#xA;{% extends &#39;base.html&#39; %}&#xA;{% block base %}&#xA;    &lt;div class=&#34;content-section&#34; id=&#34;login&#34;&gt;&#xA;        &lt;form method=&#34;POST&#34; &gt;&#xA;            {% csrf_token %}&#xA;            &lt;fieldset class=&#34;form-group&#34;&gt;&#xA;                &lt;legend class=&#34;border-bottom mb-4&#34;&gt;LOG IN&lt;/legend&gt;&#xA;                {{ form.as_p }}&#xA;            &lt;/fieldset&gt;&#xA;            &lt;div class=&#34;form-group&#34;&gt;&#xA;                &lt;button class=&#34;btn btn-outline-info&#34; type=&#34;submit&#34;&gt;Log In&lt;/button&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/form&gt;&#xA;        &lt;div class=&#34;border-top pt-3&#34;&gt;&#xA;            &lt;small class=&#34;text-muted&#34;&gt;&#xA;                Register Here &lt;a class=&#34;ml-2&#34; href=&#34;{% url &#39;register&#39; %}&#34;&gt;Sign Up&lt;/a&gt;&#xA;            &lt;/small&gt;&#xA;        &lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;{% endblock %}&#xA;```&#xA;&#xA;![User Login Page](https://meetgor-cdn.pages.dev/django-htmx/chat-login-page.png)&#xA;&#xA;Creating the Logout Template&#xA;&#xA;```html&#xA;# templates / accounts / logout.html    &#xA;&#xA;&#xA;{% extends &#39;base.html&#39; %}&#xA;{% block base %}&#xA;    &lt;h2&gt;You have been logged out&lt;/h2&gt;&#xA;    &lt;div class=&#34;border-top pt-3&#34;&gt;&#xA;        &lt;small class=&#34;text-muted&#34;&gt;&#xA;            &lt;a href=&#34;{% url &#39;login&#39; %}&#34;&gt;Log In Again&lt;/a&gt;&#xA;        &lt;/small&gt;&#xA;    &lt;/div&gt;&#xA;{% endblock %}&#xA;```&#xA;&#xA;## Install and setup channels&#xA;&#xA;We will be using channels to create long-running connections, it is a wrapper around Django&#39;s asynchronous components and allows us to incorporate other protocols like web sockets and other asynchronous protocols.&#xA;&#xA;So, we will be using the Django channels package that will allow us to use the WebSocket protocol in the chat application. [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) is a communication protocol(set of rules and standards to be followed) that allows both the client and server to send and receive messages(communication).&#xA;&#xA;To install Django channels, we can use pip and install channels with daphne which will be used as the web server gateway interface for asynchronous web applications.&#xA;&#xA;```bash&#xA;pip install -U channels[&#34;daphne&#34;]&#xA;```&#xA;&#xA;So this will install the latest version of channels and daphne. We now have [channels](https://channels.readthedocs.io/en/stable/installation.html) in our Django project, we simply need to configure the `CHANNEL_LAYER` config for specifying the backend used that can be `Redis`, `In-Memory`, or others. We need to add `channels` , `daphne` to the `INSALLED_APPS` config of the project. Make sure the `daphne` app is on top of the applications list.&#xA;&#xA;```bash&#xA;# backchat/settings.py&#xA;&#xA;...&#xA;...&#xA;&#xA;INSALLED_APPS = [&#xA;    &#34;daphne&#34;,&#xA;    ...&#xA;    ...&#xA;    &#34;channels&#34;,&#xA;]&#xA;&#xA;&#xA;ASGI_APPLICATION = &#34;backchat.asgi.application&#34;&#xA;&#xA;...&#xA;...&#xA;&#xA;# For InMemory channels&#xA;&#xA;CHANNEL_LAYERS = {&#xA;    &#39;default&#39;: {&#xA;        &#34;BACKEND&#34;: &#34;channels.layers.InMemoryChannelLayer&#34;,&#xA;    }&#xA;}&#xA;&#xA;&#xA;# For Redis&#xA;&#xA;CHANNEL_LAYERS = {&#xA;    &#34;default&#34;: {&#xA;        &#34;BACKEND&#34;: &#34;asgi_redis.RedisChannelLayer&#34;,&#xA;        &#34;CONFIG&#34;: {&#xA;            &#34;hosts&#34;: [(&#34;redis-host-url&#34;, 6379)],&#xA;        },&#xA;    },&#xA;}&#xA;```&#xA;&#xA;### Redis Configuration (Optional)&#xA;&#xA;You can either use the [InMemoryChannelLayer](https://channels.readthedocs.io/en/latest/topics/channel_layers.html) or you can use them `RedisChannelLayer` for the backend of the chat app. There are other types of backends like `Amazon SQS` services, `RabbitMQ`, `Kafka`, `Google Cloud Pub/Sub`, etc. I will be creating the app with only the `InMemoryChannelLayer` but will provide a guide for redis as well, both are quite similar and only have a few nuances.&#xA;&#xA;We need to install [channels_redis](https://github.com/django/channels_redis/) it for integrating redis in the Django project with channels.&#xA;&#xA;```bash&#xA;pip install channels_redis&#xA;```&#xA;&#xA;So, this will make the `channels_redis` package available in the project, we use this package for real-time storage, in the case of the chat app, we might use it for storing messages or room details, etc.&#xA;&#xA;## Creating the Chat App&#xA;&#xA;Further, we now can create another app for handling the rooms and chat application logic. This app will have its own models, views, and URLs. Also, we will define consumers and routers just like views and URLs but for asynchronous connections. More on that soon.&#xA;&#xA;So, let&#39;s create the `chat` app.&#xA;&#xA;```bash&#xA;python manage.py startapp chat&#xA;```&#xA;&#xA;Then we will add the chat app to the `INSALLED_APPS` config.&#xA;&#xA;```python&#xA;# backchat/settings.py&#xA;&#xA;INSALLED_APPS = [&#xA;    ...&#xA;    ...,&#xA;    &#34;chat&#34;,&#xA;]&#xA;```&#xA;&#xA;So, this will make sure to load the chat app in the project. Whenever we run any commands like migrations or running the server, it keeps the app in the `INSALLED_APPS` checked up.&#xA;&#xA;### Defining models&#xA;&#xA;This is optional, but we&#39;ll do it for since we are making a Django app. We already have an auth system configured, adding rooms and authorizing the users will become easier then.&#xA;&#xA;So, let&#39;s create the models for the chat app which will be the `Room`.&#xA;&#xA;```python&#xA;# chat/models.py&#xA;&#xA;&#xA;from django.db import models&#xA;from accounts.models import User&#xA;&#xA;class Room(models.Model):&#xA;    name = models.CharField(max_length=128)&#xA;    slug = models.SlugField(unique=True)&#xA;    users = models.ManyToManyField(User)&#xA;&#xA;    def __str__(self):&#xA;        return self.name&#xA;&#xA;&#xA;class Message(models.Model):&#xA;    room = models.ForeignKey(Room, on_delete=models.CASCADE)&#xA;    user = models.ForeignKey(User, on_delete=models.CASCADE)&#xA;    message = models.TextField()&#xA;    created_at = models.DateTimeField(auto_now_add=True)&#xA;&#xA;    def __str__(self):&#xA;        return (&#xA;            self.room.name + &#34; - &#34; +&#xA;            str(self.user.username) + &#34; : &#34; +&#xA;            str(self.message)&#xA;        )&#xA;```&#xA;&#xA;So, we simply have the name which will be taken from the user, and the slug which will be served as the URL to the room. The users are set as [ManyToManyField](https://docs.djangoproject.com/en/4.1/ref/models/fields/#django.db.models.ManyToManyField) since one room can have multiple users and a user can be in multiple rooms. Also we are creating the model `Message` that will be storing the room and the user as the foreign key and the actual text as the message, we can improve the security by encrypting the text but it&#39;s not the point of this article.&#xA;&#xA;We have set the `created_at` the field which will set the time when the object was created. Finally, the dunder string method is used for representing the message object as a price of the concatenation of strings of room name, username, and the message. This is useful for admin stuff as it makes it easier to read the object rather than the default id.&#xA;&#xA;Now, once the models are designed we can migrate the models into the database.&#xA;```&#xA;python manage.py makemigrations&#xA;python manage.py migrate&#xA;```&#xA;&#xA;![Chat app migrations](https://meetgor-cdn.pages.dev/django-htmx/chat-migrations.png)&#xA;&#xA;We now have a decent model structure for the chat application. We can now start the crux of the application i.e. consumers and routing with channels.&#xA;&#xA;### Writing consumers and routers for WebSockets&#xA;&#xA;So, we start with the bare bones provided in the tutorial on the channel [documentation](https://channels.readthedocs.io/en/stable/tutorial/part_3.html). We create a class (consumer) called `ChatConsumer` which inherits from the `AsyncWebsocketConsumer` provided by the `channels.generic.websocket` module. This has a few methods like `connect`, `disconnect`, and `receive`. These are the building blocks of a consumer. We define these methods as they will be used for communication via the WebSocket protocol through the channels interface.&#xA;&#xA;In the following block of code, we are essentially doing the following:&#xA;&#xA;* Accepting connection on the requested room name&#xA;    &#xA;* Sending and Receiving messages on the room/group&#xA;    &#xA;* Closing the WebSocket connection and removing the client from the room/group&#xA;    &#xA;&#xA;```python&#xA;# chat/consumers.py&#xA;&#xA;&#xA;import json&#xA;&#xA;from asgiref.sync import sync_to_async&#xA;from channels.generic.websocket import AsyncWebsocketConsumer&#xA;&#xA;from chat.models import Room, Message&#xA;&#xA;&#xA;class ChatConsumer(AsyncWebsocketConsumer):&#xA;    async def connect(self):&#xA;        self.room_name = self.scope[&#34;url_route&#34;][&#34;kwargs&#34;][&#34;room_slug&#34;]&#xA;        self.room_group_name = f&#34;chat_{self.room_name}&#34;&#xA;        self.user = self.scope[&#34;user&#34;]&#xA;&#xA;        await self.channel_layer.group_add(&#xA;            self.room_group_name, self.channel_name&#xA;        )&#xA;&#xA;        await self.accept()&#xA;&#xA;    async def disconnect(self, close_code):&#xA;        await self.channel_layer.group_discard(&#xA;            self.room_group_name, self.channel_name&#xA;        )&#xA;&#xA;    async def receive(self, text_data):&#xA;        text_data_json = json.loads(text_data)&#xA;        message = text_data_json[&#34;message&#34;]&#xA;        username = self.user.username&#xA;        &#xA;        await self.channel_layer.group_send(&#xA;            self.room_group_name, &#xA;            {&#xA;                &#34;type&#34;: &#34;chat_message&#34;,&#xA;                &#34;message&#34;: message,&#xA;                &#34;username&#34;: username,&#xA;            }&#xA;        )&#xA;&#xA;    async def chat_message(self, event):&#xA;        message = event[&#34;message&#34;]&#xA;        username = event[&#34;username&#34;]&#xA;&#xA;        await self.send(&#xA;            text_data=json.dumps(&#xA;                {&#xA;                    &#34;message&#34;: message,&#xA;                    &#34;username&#34;: username&#xA;                }&#xA;            )&#xA;        )&#xA;```&#xA;&#xA;#### Accept the WebSocket connection&#xA;&#xA;Here, room and group more or less mean the same thing but are different in different contexts. For instance, the group refers to the collection of clients which are connected to a channel(communication between consumer and web socket) and the Room is referring to the collection of clients connected to a single connection stream like a literal room. So we can say, the group is a technical term and the room is more of a layman&#39;s term for the same thing.&#xA;&#xA;The method `connect` is called when the client establishes a websocket connection. When that happens, the function gets the room slug from the URL of the client and stores `room_name` which is a string. It creates a separate variable called `room_group_name` by prepending the `chat_` string to the `room_name`, it also gets the currently logged-in user from the request. It then adds the `channel_name` to the group named `room_group_name`. The `channel_name` is a unique identifier to the connection/consumer in the channel. By adding the `channel_name`, the consumer then can broadcast the message to all the channels within the group. Finally, the function accepts the connection, and a **webcoket connection is established from both ends, connection is sent from the client and is now accepted from the backend.**&#xA;&#xA;#### Disconnect from the WebSocket connection&#xA;&#xA;When the client sends a close connection request to the server, the `disconnect` method is triggered and it basically removes the `channel_name` from the group i.e. the group name `room_group_name` whatever the string it happens to be. So, it basically removes the client from the broadcast group and hence it can&#39;t receive or send messages through the websocket since it has been closed from both ends.&#xA;&#xA;If you would have paid attention to the `close_code` in-method parameter, it is not being used currently. However, we can use it for checking why the connection was closed, as the `close_code` is a numeric value just like the status code in the web request for letting the server know the reason for disconnecting from the client.&#xA;&#xA;#### Receive a message from the WebSocket connection&#xA;&#xA;The `recieve` method is the core of the consumer as it is responsible for all the logic and parsing of the message and broadcasting of the messages from the clients to the group channels. The function takes in a parameter called `text_data` and it is sent from the client through websocket, so it is JSON content. We need to get the actual message from the JSON object or any other piece of content from the client. So, we deserialize (convert the JSON object to python objects) the received payload, and get the value from the key `message`. The key is the input name or id from the client sending the request through the web socket, so it can be different depending on the frontend template(we&#39;ll see the front end soon as well).&#xA;&#xA;We get the user from the scope of the consumer as we previously initialized it in the connect method. This can be used for understanding which user has sent the message, it will be used later on as we send/broadcast the message to the group.&#xA;&#xA;Now, the final piece in the receive method is the `channel_layer.group_send` method, this method as the name suggests is used to send or broadcast the received message to the entire group. The method has two parameters:&#xA;&#xA;1. The name of the group&#xA;    &#xA;2. The JSON body containing the message and other details&#xA;    &#xA;&#xA;The method is not directly sending the message but it has a type key in the JSON body which will be the function name to call. The function will simply call the other funciton mentioned in the type key in the dict. The following keys in the dict will be the parameters of that funciton. In this case, the funciton specified in the `type` key is `chat_message` which takes in the `event` as the parameter. This event will have all the parameters from the `group_send` method.&#xA;&#xA;So, the `chat_message` will load in this message, username, and the room name and then call the `send` method which actually sends the message as a JSON payload to the WebSocket connection which will be received by all the clients in the same group as provided in the `room_group_name` string.&#xA;&#xA;### Adding Routers for WebSocket connections&#xA;&#xA;So, till this point have consumers, which are just like views in terms of channels. Now, we need some URL routes to map these consumers to a path. So, we will create a file/module called `routing.py` which will look quite similar to the `urls.py` file. It will have a list called `websocket_urlpatterns` just like `urlpatterns` with the list of `path`. These paths however are not `http` routes but will serve for the `WebSocket` path.&#xA;&#xA;&#xA;```python&#xA;# chat / routing.py&#xA;&#xA;&#xA;from django.urls import path&#xA;&#xA;from chat import consumers&#xA;&#xA;websocket_urlpatterns = [&#xA;    path(&#39;chat/&lt;str:room_slug&gt;/&#39;, consumers.ChatConsumer.as_asgi()),&#xA;]&#xA;```&#xA;&#xA;In the above code block, we have defined a URL for the web socket with the path as `/chat/&lt;room_slug&gt;` where room_name will be the `slug` for the room. The path is bound with the consumer-defined in the `consumers.py` module as `ChatConsumer`. The `as_asgi` method is used for converting a view into an ASGI-compatible view for the WebSocket interface.&#xA;&#xA;### Setting up ASGI Application&#xA;&#xA;We are using the ASGI application config rather than a typical WSGI application which only works one request at a time. We want the chat application to be asynchronous because multiple clients might send and receive the messages at the same time, we don&#39;t want to make a client wait before the server process a message from another client, that&#39;s just the reason we are using WebSocket protocol.&#xA;&#xA;So, we need to also make sure, it makes the http request and also add our websocket config from the chat app we created in the previous sections. So, inside the `asgi.py` file in the project config module, we need to make some changes to include the chat application configurations.&#xA;&#xA;```python&#xA;# backchat / asgi.py&#xA;&#xA;&#xA;import os&#xA;from django.core.asgi import get_asgi_application&#xA;from channels.auth import AuthMiddlewareStack&#xA;from channels.routing import ProtocolTypeRouter, URLRouter&#xA;&#xA;os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;backchat.settings&#39;)&#xA;&#xA;from chat import routing&#xA;&#xA;&#xA;application = ProtocolTypeRouter({&#xA;    &#39;http&#39;: get_asgi_application(),&#xA;    &#34;websocket&#34;:AuthMiddlewareStack(&#xA;        URLRouter(&#xA;            routing.websocket_urlpatterns&#xA;        )&#xA;    )&#xA;})&#xA;```&#xA;&#xA;We will override the `application` config which is a component used for routing different types of protocols for the `ASGI` application. We have set the two keys, `http` and `websocket` in our application. The `http` type of requests will be served with the `get_asgi_application` application which is used for running the application in an ASGI environment.&#xA;&#xA;For `websocket` type of requests, we are setting the [AuthMiddlewareStack](https://channels.readthedocs.io/en/latest/topics/authentication.html) which helps in authenticating the users requesting the WebSocket connection and allows only authorized users to make a connection to the application. The [URLRouter](https://channels.readthedocs.io/en/stable/topics/routing.html) is used for mapping the list of URL patterns with the incoming request. So, this basically serves the request URL with the appropriate consumer in the application. We are parsing in the `websocket_urlpatterns` as the list of URLs that will be used for the WebSocket connections.&#xA;&#xA;Now, we run the server, we should be seeing the `ASGI` server serving our application rather than the plain WSGI application.&#xA;&#xA;```&#xA;$ python manage.py runserver&#xA;&#xA;Watching for file changes with StatReloader&#xA;Performing system checks...&#xA;&#xA;System check identified no issues (0 silenced).&#xA;February 05, 2023 - 09:22:45&#xA;Django version 4.1.5, using settings &#39;backchat.settings&#39;&#xA;Starting ASGI/Daphne version 4.0.0 development server at http://127.0.0.1:8000/&#xA;Quit the server with CONTROL-C.&#xA;```&#xA;&#xA;&#xA;The application is not complete yet, it might not have most components working functional yet. So, we&#39;ll now get into making the user interfaces for the application, to create, join, and view rooms in the application.&#xA;&#xA;### Adding Views for Chat Rooms&#xA;&#xA;We will have a couple of views like create room page, the join room page, and the chat room page. We will define each view as a distinct view and all of them will require authenticated users.&#xA;&#xA;```python&#xA;# chat / views.py&#xA;&#xA;&#xA;import string&#xA;import random&#xA;from django.contrib.auth.decorators import login_required&#xA;from django.shortcuts import render, reverse, redirect&#xA;from django.utils.text import slugify&#xA;from chat.models import Room&#xA;&#xA;&#xA;@login_required&#xA;def index(request, slug):&#xA;    room = Room.objects.get(slug=slug)&#xA;    return render(request, &#39;chat/room.html&#39;, {&#39;name&#39;: room.name, &#39;slug&#39;: room.slug})&#xA;&#xA;@login_required&#xA;def room_create(request):&#xA;    if request.method == &#34;POST&#34;:&#xA;        room_name = request.POST[&#34;room_name&#34;]&#xA;        uid = str(&#39;&#39;.join(random.choices(string.ascii_letters + string.digits, k=4)))&#xA;        room_slug = slugify(room_name + &#34;_&#34; + uid)&#xA;        room = Room.objects.create(name=room_name, slug=room_slug)&#xA;        return redirect(reverse(&#39;chat&#39;, kwargs={&#39;slug&#39;: room.slug}))&#xA;    else:&#xA;        return render(request, &#39;chat/create.html&#39;)&#xA;&#xA;@login_required&#xA;def room_join(request):&#xA;    if request.method == &#34;POST&#34;:&#xA;        room_slug = request.POST[&#34;room_slug&#34;]&#xA;        room = Room.objects.get(slug=room_slug)&#xA;        return redirect(reverse(&#39;chat&#39;, kwargs={&#39;slug&#39;: room.slug}))&#xA;    else:&#xA;        return render(request, &#39;chat/join.html&#39;)&#xA;```&#xA;&#xA;In the above views module, we have added 3 views namely `index` as the room page, `room_create` for the room creation page, and the `room_join` for the room join page. The index view is a simple get request to the provided slug of the room, it gets the slug from the URL from the request and fetches an object of the room associated with that slug. Then it renders the room template with the context variables like the name of the room and the slug associated with that room.&#xA;&#xA;The `room_create` view is a simple two-case view that either can render the room creation page or process the submitted form and create the room. Just like we used in the `register` view in the accounts app. When the user will send a `GET` request to the URL which we will map to `/create/` shortly after this, the user will be given a form. So, we will render the `create.html` template. We will create the html template shortly. &#xA;If the user has sent a `POST` request to the view via the `/create` URL, we will fetch the name field in the sent request and create a unique identifier with the name of the room. We will slugify the concatenation of the name with the uid and will set it as the slug of the room. We will then simply create the room and redirect the user to the `room` page.&#xA;&#xA;The `room_join` view also is a two-case view, where the user can either request the join room form or send a slug with the form submission. If the user is requesting a form, we will render the `join.html` template. If the user is submitting the form, we will fetch the room based on the slug provided and redirect the user to the `room` page.&#xA;&#xA;So, the `room_join` and `room_create` views are quite similar, we are fetching an already existing room in the case of the join view and creating a new instance of room in the create view. Now, we will connect the views to the URLs and finally get to the templates.&#xA;&#xA;### Connecting Views and URLs&#xA;&#xA;We have three views to route to a URL. But we will also have one additional URL which will be the home page for the application, on that page the user can choose to either join or create a room. We have the room creation, join the room and the room view to be mapped in this URL routing of the app.&#xA;&#xA;```python&#xA;# chat / urls.py&#xA;&#xA;&#xA;from django.urls import path&#xA;from django.views.generic import TemplateView&#xA;from chat import views&#xA;&#xA;&#xA;urlpatterns = [&#xA;    path(&#34;&#34;, TemplateView.as_view(template_name=&#34;base.html&#34;), name=&#39;index&#39;),&#xA;    path(&#34;room/&lt;str:slug&gt;/&#34;, views.index, name=&#39;chat&#39;),&#xA;    path(&#34;create/&#34;, views.room_create, name=&#39;room-create&#39;),&#xA;    path(&#34;join/&#34;, views.room_join, name=&#39;room-join&#39;),&#xA;]&#xA;```&#xA;&#xA;So, the first route is the home page view called `index`, we have used the [TemplateView](https://docs.djangoproject.com/en/4.1/ref/class-based-views/base/#templateview) which will simply render the template provided. We don&#39;t have to create a separate view for just rendering a template. We already have defined the `base.html` template while setting up the `accounts` app. This will be the same template, we will add some more content to the template later on. The URL mapped is the `/` since we will add the URLs of this app to the project URLs with an empty `&#34;&#34;` path.&#xA;&#xA;The second route is used for the room index page, i.e. where the user will be able to send and receive messages. The path is assigned as `/room/&lt;str:slug&gt;/` indicating a parameter called slug of type string will be used in accessing a particular room. The URL will be bound to the index view that we created in the views file, which fetches the room based on the slug, so here is where the slug will be coming from. The name of the URL-View route will be `chat` but you can keep it as per your requirements. The URL name is really handy for use in the templates.&#xA;&#xA;The third route is for the room creation page. The `/create/` URL will be bound to the `room_create` view, as we discussed, it will serve two purposes, one to render the form for creating the room, and the other for sending a `POST` request to the same path for the creating the Room with the name provided. The name is not required but helps in identifying and making it user-friendly. The name of this URL is set as `room-create`.&#xA;&#xA;The final route is for joining the room, the `/join/` URL will be triggering the `room_join` view. Similar to the `room-create` URL, the URL will render the join room form on a `GET` request, fetch the room with the provided slug and redirect to the room page. Here, the slug field in the form will be required for actually finding the matching room. The name of the URL route is set as `room-join`.&#xA;&#xA;We now add the URLs from the chat app to the project URLs. This will make the `/` as the entry point for the chat application URLs.&#xA;&#xA;```python&#xA;# backchat / urls.py&#xA;&#xA;&#xA;from django.contrib import admin&#xA;from django.urls import path, include&#xA;&#xA;urlpatterns = [&#xA;    path(&#34;admin/&#34;, admin.site.urls),&#xA;    path(&#34;auth/&#34;, include(&#39;accounts.urls&#39;)),&#xA;    path(&#34;&#34;, include(&#39;chat.urls&#39;)),&#xA;]&#xA;```&#xA;&#xA;Hence the process is completed for the backend to process the message, it then is dependent on the client to process and render the message.&#xA;&#xA;Till HTMX was not a thing!&#xA;&#xA;We won&#39;t have to write a single line of javascript to receive and handle the WebSocket connection!&#xA;&#xA;### Creating Templates and adding htmx&#xA;&#xA;We now move into the actual frontend or creating the template for actually working with the rooms and user interaction. We will have three pieces of templates, a room creates the page, a room join page, and a room chat page. As these template names suggest, they will be used for creating a room with the name, joining the room with the slug, and the room chat page where the user will send and receive messages.&#xA;&#xA;Let/s modify the base template first.&#xA;&#xA;```html&#xA;&lt;!DOCTYPE html&gt;&#xA;&lt;html&gt;&#xA;    &lt;head&gt;&#xA;        &lt;meta charset=&#34;utf-8&#34; /&gt;&#xA;        &lt;title&gt;Chat App&lt;/title&gt;&#xA;        {% load static %}&#xA;        &lt;script src=&#34;https://unpkg.com/htmx.org@1.8.5&#34;&gt;&lt;/script&gt;&#xA;    &lt;/head&gt;&#xA;    &lt;a href=&#34;{% url &#39;index&#39; %}&#34;&gt;Home&lt;/a&gt;&#xA;        {% if user.is_authenticated %}&#xA;            &lt;a href=&#34;{% url &#39;logout&#39; %}&#34;&gt;Logout&lt;/a&gt;&#xA;        {% else %}&#xA;            &lt;a href=&#34;{% url &#39;login&#39; %}&#34;&gt;Login&lt;/a&gt;&#xA;        {% endif %}&#xA;    &lt;body hx-ext=&#34;ws&#34;&gt;&#xA;        &lt;h1&gt;Back Chat&lt;/h1&gt;&#xA;        {% block base %}&#xA;            &lt;a href=&#34;{% url &#39;room-join&#39; %}&#34;&gt;Join Room&lt;/a&gt;&#xA;            &lt;a href=&#34;{% url &#39;room-create&#39; %}&#34;&gt;Create Room&lt;/a&gt;&#xA;        {% endblock %}&#xA;    &lt;/body&gt;&#xA;&lt;/html&gt;&#xA;```&#xA;&#xA;![Chat App Home Page](https://meetgor-cdn.pages.dev/django-htmx/chat-home-page.png)&#xA;&#xA;#### Create Room Template&#xA;&#xA;We will have to render the form with a field like `name` for setting it as the name of the room, it is not required but again, it makes it easier for the user to find the name of the room a bit more friendly than random characters.&#xA;&#xA;```html&#xA;# templates / chat / create.html&#xA;&#xA;&#xA;{% extends &#39;base.html&#39; %}&#xA;&#xA;{% block base %}&#xA;    &lt;form method=&#39;post&#39; action=&#39;{% url &#39;room-create&#39; %}&#39;&gt;&#xA;        {% csrf_token %}&#xA;        &lt;input name=&#39;room_name&#39; id=&#39;room_name&#39; placeholder=&#39;Room Name&#39;&gt;&#xA;        &lt;input type=&#39;submit&#39; id=&#34;submit&#34;&gt;&#xA;    &lt;/form&gt;&#xA;{% endblock %}&#xA;```&#xA;&#xA;![Chat Room Create Page](https://meetgor-cdn.pages.dev/django-htmx/chat-create-room-page.png)&#xA;&#xA;The template is inherited from the `base.html` template and we render a form with the `room_name` input. The form will be submitted to the URL named `room-create` hence it will send a `POST` request to the server where it will create the room and further process the request.&#xA;&#xA;#### Join Room Template&#xA;&#xA;The join room template is similar to the create room template except it gets the slug of the room from the user rather than the name which is not a unique one to join the room.&#xA;&#xA;```html&#xA;# templates / chat / join.html&#xA;&#xA;&#xA;{% extends &#39;base.html&#39; %}&#xA;&#xA;{% block base %}&#xA;    &lt;form method=&#39;post&#39; action=&#39;{% url &#39;room-join&#39; %}&#39;&gt;&#xA;        {% csrf_token %}&#xA;        &lt;input name=&#39;room_slug&#39; id=&#39;room_slug&#39; required=&#39;true&#39; placeholder=&#39;Room Code&#39;&gt;&#xA;        &lt;input type=&#39;submit&#39; id=&#34;submit&#34;&gt;&#xA;    &lt;/form&gt;&#xA;{% endblock %}&#xA;```&#xA;&#xA;![Chat Room Join Page](https://meetgor-cdn.pages.dev/django-htmx/chat-join-room-page.png)&#xA;&#xA;The form will be submitted to the URL named `room-join` hence it will send a `POST` request to the server where it will fetch the room and further process the request.&#xA;&#xA;### Room Template (HTMX code)&#xA;&#xA;Now, time for the actual ingredient in the application, some HTMX magic!&#xA;&#xA;This template, as the two templates above inherit from the base template, that&#39;s the same thing. But it has a special `div` with the attribute [hx-ws](https://htmx.org/attributes/hx-ws/) which is used for using attributes related to the web socket in the htmx library. The `connect` value is used for connecting to a WebSocket. The value of the attribute must be set to the URL of the WebSocket to be connected. In our case, it is the URL path from the `routing` app as `/chat/&lt;room_slug&gt;/`. This simply will connect the client to the WebSocket from the backend. The other important attribute is the `send` which is used for sending a message to the connected web socket.&#xA;&#xA;```html&#xA;# templates / chat / room.html&#xA;&#xA;&#xA;{% extends &#39;base.html&#39; %}&#xA;&#xA;{% block base %}&#xA;    &lt;h2&gt;{{ name }}&lt;/h2&gt;&#xA;    &lt;div hx-ws=&#34;connect:/chat/{{ slug }}/&#34;&gt;&#xA;        &lt;form hx-ws=&#34;send:submit&#34;&gt;&#xA;            &lt;input name=&#34;message&#34;&gt;&#xA;            &lt;input type=&#34;submit&#34;&gt;&#xA;        &lt;/form&gt;&#xA;     &lt;/div&gt;&#xA;     &lt;div id=&#39;messages&#39;&gt;&lt;/div&gt;&#xA;{% endblock %}&#xA;```&#xA;&#xA;![Chat Room Page](https://meetgor-cdn.pages.dev/django-htmx/chat-room-page.png)&#xA;&#xA;NOTE: The template has a div with the id `messages` which will be very important for sending the messages from the WebSocket to the client, so more on that when we use the HTMX part.&#xA;&#xA;For testing this template, you can create a room, and that will redirect you to the room template as we have seen in the views for the room creation. If you see something like `WebSocket CONNECT` it means, that the application has been able to establish a WebSocket connection to the backend, and we can be ready to accept messages and other stuff.&#xA;&#xA;```&#xA;HTTP GET /chat/room/def_teas/ 200 [0.03, 127.0.0.1:38660]&#xA;WebSocket HANDSHAKING /chat/def_teas/ [127.0.0.1:38666]&#xA;WebSocket CONNECT /chat/def_teas/ [127.0.0.1:38666]&#xA;```&#xA;&#xA;![Django ASGI server websocket connection](https://meetgor-cdn.pages.dev/django-htmx/chat-asgi-server.png)&#xA;&#xA;Till this point, we should have a running and almost complete application, though we just have a minor part missing that will be the most important part.&#xA;&#xA;### Sending HTML response from backend for htmx&#xA;&#xA;We will be sending a fragment of HTML from the backend when the user sends a message, to broadcast it to the group. Let&#39;s make some changes to the application, especially to the receive method in the `ChatConsumer` of the chat application.&#xA;&#xA;```python&#xA;# chat / consumers.py&#xA;    &#xA;&#xA;    ...&#xA;    ...&#xA;&#xA;    async def receive(self, text_data):&#xA;        text_data_json = json.loads(text_data)&#xA;        message = text_data_json[&#34;message&#34;]&#xA;        user = self.user&#xA;        username = user.username&#xA;&#xA;        await self.channel_layer.group_send(&#xA;            self.room_group_name, &#xA;            {&#xA;                &#34;type&#34;: &#34;chat_message&#34;,&#xA;                &#34;message&#34;: message,&#xA;                &#34;username&#34;: username,&#xA;            }&#xA;        )&#xA;&#xA;    async def chat_message(self, event):&#xA;        message = event[&#34;message&#34;]&#xA;        username = event[&#34;username&#34;]&#xA;&#xA;        # This is the crucial part of the application&#xA;        message_html = f&#34;&lt;div hx-swap-oob=&#39;beforeend:#messages&#39;&gt;&lt;p&gt;&lt;b&gt;{username}&lt;/b&gt;: {message}&lt;/p&gt;&lt;/div&gt;&#34;&#xA;        await self.send(&#xA;            text_data=json.dumps(&#xA;                {&#xA;                    &#34;message&#34;: message_html,&#xA;                    &#34;username&#34;: username&#xA;                }&#xA;            )&#xA;        )&#xA;```&#xA;&#xA;![Chat Room Message](https://meetgor-cdn.pages.dev/django-htmx/chat-room-msg-1.png)&#xA;![Chat Room Message 2 Users](https://meetgor-cdn.pages.dev/django-htmx/chat-room-msg-2.png)&#xA;![Chat Room Message](https://meetgor-cdn.pages.dev/django-htmx/chat-room-msg-3.png)&#xA;&#xA;&#xA;In the above snippet, we are just changing the final message object to include some HTML just simple. The HTML however has home htmx attributes like [hx-swap-oob](https://htmx.org/attributes/hx-swap-oob/) which will just update the specified DOM element to the content in the div. In this case, the DOM element is `#message` which is the id message present in the room template. We basically add the username and the message into the same id by appending it to the element. That&#39;s it, it would work and it would start showing the messages from the connected clients and broadcast them as well.&#xA;&#xA;There are some things to keep in mind while using htmx in the long run especially when the htmx 2.0 is released, it will have `ws` as a separate extension. It will have a bit of a different syntax than above. I have tried the latest version but doesn&#39;t seem to work. I&#39;ll just leave a few snippets for your understanding of the problem.&#xA;&#xA;&#xA;```html&#xA;# templates / chat / room.html&#xA;&#xA;&#xA;{% extends &#39;base.html&#39; %}&#xA;&#xA;{% block base %}&#xA;    &lt;h2&gt;{{ name }}&lt;/h2&gt;&#xA;    &lt;div hx-ext=&#34;ws&#34; ws-connect=&#34;/chat/{{ slug }}/&#34;&gt;&#xA;        &lt;form ws-send&gt;&#xA;            &lt;input name=&#34;message&#34;&gt;&#xA;        &lt;/form&gt;&#xA;    &lt;/div&gt;&#xA;    &lt;div id=&#39;messages&#39;&gt;&lt;/div&gt;&#xA;{% endblock %}&#xA;```&#xA;&#xA;I have added, the `hx-ext` as `ws` which is a htmx [extension for websocket](https://htmx.org/extensions/web-sockets/). This extension has websocket-specific attributes like `ws-connect` and `ws-send`. I have tried a combination like changing the htmx versions, adding submit value as the `ws-send` attribute, etc, but no results yet. I have opened a [discussion](https://github.com/bigskysoftware/htmx/discussions/1231) on GitHub for this issue, you can express your solution or views there.&#xA;&#xA;### Adding some utility features for the chat app&#xA;&#xA;We can save messages, add and remove the users from the room according to the connection, and other stuff that can make this a fully-fledged app. So, I have made a few changes to the chat consumers for saving the messages and also updating the room with the users in the room.&#xA;&#xA;```python&#xA;# chat / consumers.py&#xA;&#xA;&#xA;import json&#xA;&#xA;from asgiref.sync import sync_to_async&#xA;from channels.generic.websocket import AsyncWebsocketConsumer&#xA;&#xA;from chat.models import Room, Message&#xA;&#xA;&#xA;class ChatConsumer(AsyncWebsocketConsumer):&#xA;    async def connect(self):&#xA;        self.room_name = self.scope[&#34;url_route&#34;][&#34;kwargs&#34;][&#34;room_slug&#34;]&#xA;        self.room_group_name = &#34;chat_%s&#34; % self.room_name&#xA;        self.user = self.scope[&#34;user&#34;]&#xA;&#xA;        await self.channel_layer.group_add(&#xA;            self.room_group_name, self.channel_name&#xA;        )&#xA;&#xA;        # Add the user when the client connects&#xA;        await self.add_user(self.room_name, self.user)&#xA;&#xA;        await self.accept()&#xA;&#xA;    async def disconnect(self, close_code):&#xA;&#xA;        # Remove the user when the client disconnects&#xA;        await self.remove_user(self.room_name, self.user)&#xA;&#xA;        await self.channel_layer.group_discard(&#xA;            self.room_group_name, self.channel_name&#xA;        )&#xA;&#xA;    async def receive(self, text_data):&#xA;        text_data_json = json.loads(text_data)&#xA;        message = text_data_json[&#34;message&#34;]&#xA;        user = self.user&#xA;        username = user.username&#xA;        room = self.room_name&#xA;&#xA;        # Save the message on recieving&#xA;        await self.save_message(room, user, message)&#xA;&#xA;        await self.channel_layer.group_send(&#xA;            self.room_group_name, &#xA;            {&#xA;                &#34;type&#34;: &#34;chat_message&#34;,&#xA;                &#34;message&#34;: message,&#xA;                &#34;username&#34;: username,&#xA;            }&#xA;        )&#xA;&#xA;    async def chat_message(self, event):&#xA;        message = event[&#34;message&#34;]&#xA;        username = event[&#34;username&#34;]&#xA;&#xA;&#xA;        message_html = f&#34;&lt;div hx-swap-oob=&#39;beforeend:#messages&#39;&gt;&lt;p&gt;&lt;b&gt;{username}&lt;/b&gt;: {message}&lt;/p&gt;&lt;/div&gt;&#34;&#xA;        await self.send(&#xA;            text_data=json.dumps(&#xA;                {&#xA;                    &#34;message&#34;: message_html,&#xA;                    &#34;username&#34;: username&#xA;                }&#xA;            )&#xA;        )&#xA;&#xA;    @sync_to_async&#xA;    def save_message(self, room, user, message):&#xA;        room = Room.objects.get(slug=room)&#xA;        Message.objects.create(room=room, user=user, message=message)&#xA;&#xA;    @sync_to_async&#xA;    def add_user(self, room, user):&#xA;        room = Room.objects.get(slug=room)&#xA;        if user not in room.users.all():&#xA;            room.users.add(user)&#xA;            room.save()&#xA;&#xA;    @sync_to_async&#xA;    def remove_user(self, room, user):&#xA;        room = Room.objects.get(slug=room)&#xA;        if user in room.users.all():&#xA;            room.users.remove(user)&#xA;            room.save()&#xA;```&#xA;&#xA;So, we have created a few methods like `save_message`, `add_user`, and `remove_user` which all are `synchronous` methods but we are using an asynchronous web server, so we add in the `sync_to_async` decorator which wraps a synchronous method to an asynchronous method. Inside the methods, we simply perform the database operations like creating a message object, and adding or removing the user from the room.&#xA;&#xA;That&#39;s only a few features that I have added, you can add to this application and customize them as per your needs.&#xA;&#xA;The code for this chat app is provided in the [GitHub repository](https://github.com/Mr-Destructive/django-htmx-chat).&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this post, we were able to create a simple chat app (frontendless) with Django and htmx. We used Django channels and HTMX to make a chat application without the need to write javascript for the client-side connection. Hope you found this tutorial helpful, do give your feedback and thoughts on it, I&#39;ll be eager to improve this post. Thank you for your patient listening. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Django Blog DevLog: Load Frontmatter data into Template/Model Form Fields</title>
      <link>meetgor.com/django-form-load-frontmatter</link>
      <description>Rendering frontatter from content field into the Template Form field using HTMX and frontmatter libraries</description>
      <pubDate>Mon, 01 Aug 2022 00:00:00 UTC</pubDate>
      <content>## Introduction&#xA;&#xA;I have an Article Form where I load my post into it directly, it might have frontmatter. So what I wish to achieve is when I paste in the content, the frontmatter should be picked up and it should render the form fields like `title`, `description`, and then also remove the frontmatter from the content.&#xA;&#xA;To do that, we will require a model to work with and a form based on that model. We will exclude a few fields from that model so as to process these attributes on the server side. I am working on my Blog project which is a simple Django application.  You can get the source code for the project on the [GitHub repository](https://github.com/mr-destructive/techstructive-blog/).&#xA;&#xA;## Django Project Context&#xA;&#xA;The techstructive-blog is a django project, which has a couple of applications currently, not in a good situation. There are apps like `article`, `blog`, and `user`. This project has templates and static folder in the base directory. The project is deployed on [railway](https://www.railway.app) this is an always under development project, you can check out the [techstructive-blog](https://django-blog.up.railway.app). We can get the bits and pieces of the project details required for understanding what I want to do with the following sections.&#xA;&#xA;### Article Model&#xA;&#xA;We have an `Article` model with attributes like `title`, `description`,  `author` as a Foreign Key to the user model, and a few other attributes which is not related to what we are trying to achieve right now or at least don&#39;t require an explanation. We have a model method called `get_absolute_url` for getting a URL in order to redirect the client when the model instance is created or updated from the backend. You can definitely check out the details of these small components or templates in the project repository. &#xA;&#xA;```python&#xA;# articles/models.py&#xA;&#xA;&#xA;class Article(TimeStampedModel):&#xA;    class Article_Status(models.TextChoices):&#xA;        DRAFT = (&#xA;            &#34;DRAFT&#34;,&#xA;            _(&#34;Draft&#34;),&#xA;        )&#xA;        PUBLISHED = (&#xA;            &#34;PUBLISHED&#34;,&#xA;            _(&#34;Published&#34;),&#xA;        )&#xA;&#xA;    title = models.CharField(max_length=128)&#xA;    description = models.CharField(max_length=256)&#xA;    content = models.TextField(default=&#34;&#34;, null=False, blank=False)&#xA;    status = models.CharField(&#xA;        max_length=16,&#xA;        choices=Article_Status.choices,&#xA;        default=Article_Status.DRAFT,&#xA;    )&#xA;    blog = models.ForeignKey(Blog, on_delete=models.CASCADE, null=True, blank=True)&#xA;    author = models.ForeignKey(User, on_delete=models.CASCADE, related_name=&#34;author&#34;)&#xA;&#xA;    def __str__(self):&#xA;        return self.title&#xA;&#xA;    def get_absolute_url(self):      &#xA;        return reverse(&#39;articles:article-detail&#39;, args=[str(self.id)])&#xA;```&#xA;&#xA;In the below snippet, we have the forms defined in the article application for creating or updating of article instance.  We will be using model forms as our form data should contain fields related to a model in this case the `Article` model. So when we inherit the `forms.ModelForm` in our custom `ArticleForm` we simply need to specify the model and it will take in all the attributes of that model by default, but if we specify the `fields` or `exclude` tuples, it will include only or exclude only the provided list of attributes from the model. &#xA;&#xA;We have also added the widgets for the form fields which will allow us to customize the way the fields in the template/form will render. We can specify the HTML attributes like `width`, `height`, `style`, etc.  &#xA;&#xA;### Article Form&#xA;&#xA;```python&#xA;# article/forms.py&#xA;&#xA;&#xA;from django import forms&#xA;from .models import Article&#xA;&#xA;&#xA;class ArticleForm(forms.ModelForm):&#xA;    class Meta:&#xA;        model = Article&#xA;        exclude = (&#xA;            &#34;created&#34;,&#xA;            &#34;updated&#34;,&#xA;            &#34;author&#34;,&#xA;        )&#xA;        widgets = {&#xA;            &#34;title&#34;: forms.TextInput(&#xA;                attrs={&#xA;                    &#34;class&#34;: &#34;form-control&#34;,&#xA;                    &#34;style&#34;: &#34;max-width: 450px; align: center;&#34;,&#xA;                    &#34;placeholder&#34;: &#34;Title&#34;,&#xA;                }&#xA;            ),&#xA;            &#34;description&#34;: forms.TextInput(&#xA;                attrs={&#xA;                    &#34;class&#34;: &#34;form-control&#34;,&#xA;                    &#34;style&#34;: &#34;max-width: 900px; &#34;,&#xA;                    &#34;placeholder&#34;: &#34;Description&#34;,&#xA;                }&#xA;            ),&#xA;            &#34;content&#34;: forms.Textarea(&#xA;                attrs={&#xA;                    &#34;class&#34;: &#34;form-control post-body&#34;,&#xA;                    &#34;id&#34;: &#34;text-content&#34;,&#xA;                    &#34;style&#34;: &#34;max-width:900px;&#34;,&#xA;                    &#34;hx-post&#34;: &#34;/article/meta/&#34;,&#xA;                    &#34;placeholder&#34;: &#34;Content&#34;,&#xA;                }&#xA;            ),&#xA;            &#34;blog&#34;: forms.Select(&#xA;                attrs={&#xA;                    &#34;class&#34;: &#34;form-control&#34;,&#xA;                    &#34;placeholder&#34;: &#34;Blog Publication&#34;,&#xA;                }&#xA;            ),&#xA;        }&#xA;&#xA;```&#xA;&#xA;So, these are my models and form files in the article app. Using htmx and without any javascript I want to update the form so that it picks up the front matter in the content field which is a text area and fills the title, description other attributes automatically for me. &#xA;&#xA;This can be done in a lot of ways, but I will be sharing one of the ways that I recently used in my blog project. This process involves creating a class-based view and adding a `POST` method that won&#39;t post any data to the backend but will send necessary data to the view.&#xA;&#xA;&#xA;Let&#39;s see the process before diving into any of the code:&#xA;&#xA;## Gist of the Process&#xA;&#xA;- Attach a `hx-post` attribute to the form field for sending the request to a view&#xA;- When the request is sent, the data is loaded with `request.POST`, it is cleaned and converted in python-readable format with json.&#xA;- Once we have the data, we try to use the `frontmatter.loads` function that will load the content and if we have a frontmatter in the text, it will load it as a `frontmatter.POST` object.&#xA;- We will extract `title`, `description`, and other data fields from the object.&#xA;- We will initialize a Form instance of Article, with the initial data values as the extracted data from the frontmatter.&#xA;- Now we have two options:&#xA;    - If the article instance already exists i.e. we are updating the article&#xA;   - Else we are creating a new article&#xA;&#xA;Accordingly, we will load the form in the respective templates i.e. `update.html` for updating the existing articles and `article-form.html` for a new article.&#xA;&#xA;## Adding HTMX Magic&#xA;&#xA;If you&#39;d have seen we have a `hx-post` attribute in the `article/forms.py` file, the `content` widget has a `hx-post` attribute which sends a post request to the `article/meta/` URL route. This route we will bind to the `ArticleMetaView` which we will define in a few moments. This is usually sent once we change a certain text in the content field, so we can modify it as per your requirement with `hx-trigger` that can enable us to specify the trigger event or the type of trigger we want. Further, you can read from the [htmx docs](https://htmx.org/docs/#trigger-modifiers) about these triggers and other attributes. &#xA;&#xA;```python&#xA;# article/urls.py&#xA;&#xA;from django.urls import path&#xA;from . import views&#xA;&#xA;app_name = &#34;articles&#34;&#xA;&#xA;urlpatterns = [&#xA;    path(&#34;&#34;, views.ArticleCreateView.as_view(), name=&#34;article-create&#34;),&#xA;    path(&#34;&lt;int:pk&gt;/&#34;, views.ArticleDetailView.as_view(), name=&#34;article-detail&#34;),&#xA;    path(&#34;delete/&lt;int:pk&gt;/&#34;, views.ArticleDetailView.as_view(), name=&#34;article-delete&#34;),&#xA;    path(&#34;edit/&lt;int:pk&gt;&#34;, views.ArticleDetailView.as_view(), name=&#34;article-update&#34;),&#xA;&#xA;    # the new view that we will create&#xA;    path(&#34;meta/&#34;, views.ArticleMetaView.as_view(), name=&#34;article-meta&#34;),&#xA;]&#xA;```&#xA;&#xA;## Capture Frontmatter Meta-data View &#xA;&#xA;Along with the Create, Detail/List, Update, Delete View, I will create a separate class called `ArticleMetaView` that will fetch the form fields and render the templates again but this time it will fill in the frontmatter meta-data in the fields if the content is parsed with the relvant frontmatter.&#xA;&#xA;```python&#xA;# articles/view.py&#xA;&#xA;class ArticleMetaView(View):&#xA;    model = Article&#xA;&#xA;    def post(self, request, *args, **kwargs):&#xA;        &#xA;        data = json.loads(json.dumps(dict(request.POST)))&#xA;        loaded_frontmatter = frontmatter.loads(data[&#39;content&#39;][0])&#xA;&#xA;       # frontmatter has keys i.e. attributes like title, description, etc.&#xA;        if dict(loaded_frontmatter):&#xA;            article_title = loaded_frontmatter[&#39;title&#39;]&#xA;            article_description = loaded_frontmatter[&#39;description&#39;]&#xA;            form = ArticleForm(initial={&#39;title&#39;: article_title, &#xA;            &#39;description&#39;: article_description, &#39;content&#39;: loaded_frontmatter.content})&#xA;            context = {&#39;form&#39;: form}&#xA;            article_list = Article.objects.filter(title=article_title)&#xA;            if article_list:&#xA;                article = article_list.last()&#xA;                context[&#39;article&#39;] = article&#xA;                return render(request, &#39;articles/edit_article.html&#39;, context)&#xA;            return render(request, &#39;articles/article_form.html&#39;, context)&#xA;&#xA;        article_list = Article.objects.filter(title=data[&#39;title&#39;][0])&#xA;       &#xA;       # if the article title has been already taken i.e. we are updating an article&#xA;&#xA;        if article_list:&#xA;            article = article_list.last()&#xA;            form = ArticleForm(data=request.POST)&#xA;            context = {&#39;form&#39;: form}&#xA;            context[&#39;article&#39;] = article&#xA;            return render(request, &#39;articles/edit_article.html&#39;, context)&#xA;&#xA;        form = ArticleForm(data=request.POST)&#xA;        context = {&#39;form&#39;: form}&#xA;        return render(request, &#39;articles/article_form.html&#39;, context)&#xA;&#xA;```&#xA;&#xA;In the above `ArticleMetaView` we have created a `post` method as we want to get hold of the content from the form. So, we start by extracting and converting the `request.body` data into an appropriate type for easily working with python. So, the `request.body` will contain the data like `csrf_token`, `form_data`, etc. received from the frontend template. We store the received data as `data` and now from this data, we can load the content field which will have the content information.&#xA;&#xA;Firstly we will extract the `request.body` which will contain the data from the form as we have made a `POST` request to this endpoint. For doing that we need to parse the content in a apropriate format such that it is python friendly. So we wrap the `request.body` into json format and then decode it back into the json string. This will give us the dict of the request data.&#xA;&#xA;```python&#xA;data = json.loads(json.dumps(dict(request.POST)))&#xA;```&#xA;&#xA;```&#xA;{&#39;csrfmiddlewaretoken&#39;: [&#39;bSYJxD39XH509tD1tZGd0WU21PUaKaLeqjjGbyzRvLXF4P8iIxb5l0fmTWVFjELQ&#39;], &#39;title&#39;: [&#39;test2&#39;], &#39;description&#39;: [&#39;test&#39;], &#39;content&#39;: [&#39;test something&#39;], &#39;status&#39;: [&#39;DRAFT&#39;], &#39;blog&#39;: [&#39;&#39;]}&#xA;```&#xA;&#xA;So, this will grab the request data as a dict, we can then extract the data from this as it has data from the Form fields. We are interested in the content field in the Form, so we can get it by specifying the key `content` from the extracted data. But as we can see the data doesn&#39;t contain the actual data instead it is wrapped in a list i.e. `[&#39;test something&#39;]`, so we will have to index it and then fetch it.&#xA;&#xA;```python&#xA;content_string = data[&#39;content&#39;][0]&#xA;```&#xA;&#xA;This will give us the exact content field as a string. So, we can now move into extracting the frontmatter from the fields. &#xA;&#xA;Now, we can use the [frontmatter](https://python-frontmatter.readthedocs.io/en/latest/index.html) library to parse the content into the [loads](https://python-frontmatter.readthedocs.io/en/latest/api.html#frontmatter.loads) funciton and extract the frontmatter if it is present in the content field. The frontmatter library has a `loads` function which takes in a string and can give out a [frontmatter.Post](https://python-frontmatter.readthedocs.io/en/latest/api.html#post-objects) object. The loads function is differnet from the [load](https://python-frontmatter.readthedocs.io/en/latest/api.html#frontmatter.load) function as the load frunciton is for reading data from a stream of bytes i.e. a file or othe related byte object. The differnece is subtle but it took a read at the [documentation](https://python-frontmatter.readthedocs.io/en/latest/api.html#module-frontmatter).&#xA;&#xA;```python&#xA;post = data[&#39;content&#39;][0]&#xA;loaded_frontmatter = frontmatter.loads(post)&#xA;```&#xA;&#xA;This wil load the content and give us a `frontmatter.Post` as said earlier. This will contain a dict with all the frontmatter if it has any and will by default parse the non-frontmatter data i.e. the remaining text into the `content` key. We need a chack if the Form field had any fronmatter this can be checked by the `dict(loaded_frontmatter)` which will return None if it cannot load the frontmatter.&#xA;&#xA;```python&#xA;loaded_frontmatter = frontmatter.loads(data[&#39;content&#39;][0])&#xA;if dict(loaded_frontmatter):&#xA;  print(loaded_frontmatter.keys())&#xA;```&#xA;&#xA;```&#xA;dict_keys([&#39;templateKey&#39;, &#39;title&#39;, &#39;description&#39;, &#39;date&#39;, &#39;status&#39;])&#xA;```&#xA;&#xA;So once we have the frontmatter loaded we can get specific keys from it and initialize the form vaues to them. But we have made clear distictions that we want to perform a specific task if we have frontmatter keys in the content field of the Form else we can do something else.&#xA;&#xA;First let&#39;s handle the loading of the frontmatter into the form. For doing that we will get all the required attributes from the frontmatter like `title`, `description`, `content`, etc which can be accessed normally as we extract the value from a key in a dict.&#xA;&#xA;Once we have got those keys, we can start filling in the Form data with initial values. The [Django Model form](https://docs.djangoproject.com/en/4.0/topics/forms/modelforms/) takes in a parameter like [initial](https://docs.djangoproject.com/en/4.0/topics/forms/modelforms/#providing-initial-values) which can be a dict of the fiields along with the value that can be used for rendering the form initially when we load the template.&#xA;&#xA;```python&#xA;article_title = loaded_frontmatter[&#39;title&#39;]&#xA;article_description = loaded_frontmatter[&#39;description&#39;]&#xA;&#xA;form = ArticleForm(initial={&#39;title&#39;: article_title, &#39;description&#39;: article_description, &#39;content&#39;: loaded_frontmatter.content})&#xA;```&#xA;&#xA;This will take in a `ArticleForm` and fill the initial values like `title`, `description`, etc which we have provided in the dict with the values. Now, we need to parse this form in the current template or re-render the template. But before that, we need to parse this context into the template. We will create a dict with `form` as the key which can be used to render in the template.&#xA;&#xA;Also, we have a two ways here, either the user is creating a new article or it is updating a existing article. We need to make sure that we preserve the initial fields in the form as we are updating the existing article. So, we can filter the article objects as per the title of the current title and then if we find a article with that title, we will parse the context with that article object.&#xA;&#xA;```python&#xA;article_list = Article.objects.filter(title=article_title)&#xA;if article_list:&#xA;    article = article_list.last()&#xA;    context{&#xA;      &#39;form&#39;: form,&#xA;      &#39;article&#39;: article&#xA;    }&#xA;    return render(request, &#39;articles/edit_article.html&#39;, context)&#xA;context = {&#39;form&#39;: form}&#xA;return render(request, &#39;articles/article_form.html&#39;, context)&#xA;```&#xA;&#xA;Now, we have form data along with the article instance used for rendering the form with appropriate content. So, this will work for editing an already existing article. For a new article, we have to simply parse the form to the template and it will render the title picked from the fotnmatter or leave it empty.&#xA;&#xA;Similarly, for the article with no frontmatter we will iterate over the article and if the article&#39;s title already exist, we will render the article data with the form else render the form with the parsed title and other meta-data in the form.&#xA;&#xA;&#xA;&lt;video width=&#34;800&#34; height=&#34;450&#34; controls&gt;&#xA;  &lt;source src=&#34;https://res.cloudinary.com/techstructive-blog/video/upload/v1659370006/blog-media/frontmatter-load-htmx.mp4&#34; type=&#34;video/mp4&#34;&gt;&#xA;&lt;/video&gt;&#xA;&#xA;So that is how we render the form data with frontmatter into appropriate meta-data in the form. We have used Django forms and make use of HTMX for the dynamic updation of form.&#xA;</content>
      <type>til</type>
    </item>
    <item>
      <title>Django + HTMX CRUD application</title>
      <link>meetgor.com/django-htmx-crud</link>
      <description>Creating a basic CRUD application with Django and HTMX</description>
      <pubDate>Sun, 31 Jul 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Gone are the days of writing Ajax requests with javascript, just add a few parameters to the HTML content tags and you will be ready for sending requests to your backend. So, we are going back in time and correcting the way we think of APIs and client/server-side rendering. We are referring to the [Hypermedia model](https://en.wikipedia.org/wiki/Hypermedia) for levering the server-side processing of data. Let&#39;s get our feets wet with this ancient but revolutionary methodology of development with [HTMX](https://htmx.org/).&#xA;&#xA;Yes, HTMX can be used for the API/server-side calls directly in the HTML. We will be exploring the basis of HTMX by creating a basic CRUD application.&#xA;&#xA;&#xA;## What is HTMX?&#xA;&#xA;The first question that might come up is what and why HTMX? Htmx is a great library, it&#39;s a javascript library but wait. It is a javascript library designed to allow us to write less or no javascript at all. It acts as a way to send AJAX requests without you writing any javascript. It uses native browser features directly from HTML.&#xA;&#xA;So, we can use HTMX to create interactive templates in our Django application. We can dynamically call and fetch data from the server by using simple HTML attributes like `hx-get`, `hx-post`, etc. We&#39;ll cover those in this article.&#xA;&#xA;You can check the source code used in this article on this [GitHub repository](https://github.com/Mr-Destructive/htmx-blog-django).&#xA;&#xA;## Setup Django Project&#xA;&#xA;We&#39;ll be creating a Django project from scratch and designing a basic blog kind of app. We will be creating a quite simple project with a couple of apps like `user` for authentication and `article` for the CRUD part of our blog application.&#xA;&#xA;To set up a django project, we can run the following commands to quickly get up and running with a base django project.&#xA;&#xA;```&#xA;mkdir htmx_blog&#xA;python3 -m venv .venv&#xA;source .venv/bin/activate&#xA;pip install django&#xA;django-admin startproject htmx_blog .&#xA;```&#xA;&#xA;I have a base user model that I use for a simple authentication system in some basic django projects, you can define your own user app or get the app from [here](https://github.com/Mr-Destructive/django-todo/tree/master/user).&#xA;&#xA;So, that being said, we will be using the user model for the article model which we will be defined next. By creating a basic signup functionality, you are good to go!&#xA;&#xA;### Create the Article app&#xA;&#xA;We will need at least an app to work with htmx as we will define models, views, and URLs later as we configure the htmx.&#xA;&#xA;```&#xA;django-admin startapp article&#xA;```&#xA;&#xA;After the app has been created, you can add those app labels into the `INSTALLED_APPS` config in the `settings.py` file. The `user` app and the `article` app need to be added to the installed apps for the django to pick those up for various contexts related to the project.&#xA;&#xA;```&#xA;# htmx_blog/settings.py&#xA;&#xA;INSTALLED_APPS = [&#xA;    ...&#xA;    ...&#xA;    ...&#xA;&#xA;    &#39;article&#39;,  &#xA;    &#39;user&#39;,&#xA;]&#xA;```&#xA;&#xA;We are sone with the base setup, we also would require a few more configs for the proper working of the project.&#xA;&#xA;### Setup Templates and Static files&#xA;&#xA;Templates will play an important role in the htmx part, so it is equally important to configure them properly before dabbling into the htmx and client-side rendering of data.&#xA;&#xA;I like to keep all the templates in a single folder in the `BASE_DIR` with separate sub-folders for specific apps. Also a single `static` folder with `css`, `js`, and `images` as the sub-folfers for a larger project.&#xA;&#xA;```&#xA;mkdir templates static&#xA;```&#xA;&#xA;Further, configure the created static and templates in the settings.&#xA;&#xA;```python&#xA;&#xA;TEMPLATES = [&#xA;    {&#xA;        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,&#xA;        &#39;DIRS&#39;: [os.path.join(BASE_DIR, &#34;templates&#34;)],&#xA;        &#39;APP_DIRS&#39;: True,&#xA;        &#39;OPTIONS&#39;: {&#xA;            &#39;context_processors&#39;: [&#xA;                &#39;django.template.context_processors.debug&#39;,&#xA;                &#39;django.template.context_processors.request&#39;,&#xA;                &#39;django.contrib.auth.context_processors.auth&#39;,&#xA;                &#39;django.contrib.messages.context_processors.messages&#39;,&#xA;            ],&#xA;        },&#xA;    },&#xA;]&#xA;&#xA;STATIC_URL = &#39;static/&#39;&#xA;STATICFILES_DIRS = [str(BASE_DIR/ &#34;static&#34;)]&#xA;STATIC_ROOT = BASE_DIR / &#34;staticfiles&#34;&#xA;```&#xA;&#xA;### Initial migration&#xA;&#xA;Run migration command for the user model and default model in the django project.&#xA;&#xA;```&#xA;python manage.py makemigrations&#xA;python manage.py migrate&#xA;```&#xA;&#xA;So, this project will also include authentication simple registration, and login/logout routes. We will be using the default Django User model by creating an abstract user just in case we require any additional attributes. &#xA;&#xA;## Setup HTMX&#xA;&#xA;We don&#39;t have to configure much for using HTMX as it is a javascript library, we can call it via a CDN or manually install it and link up the static javascript files. Either way, both are equally good, you may like the one I might like the other. &#xA;&#xA;If you already have a base template, you can simply put the below script inside the head tag of the template. This will make us the htmx attributes available.&#xA;&#xA;```html&#xA;&lt;script src=&#34;https://unpkg.com/htmx.org@1.8.0&#34;&gt;&lt;/script&gt;&#xA;```&#xA;&#xA;If you don&#39;t have a base template, you can create one by creating an HTML file inside the `templates` directory. The name can be anything but be careful for following up as it might be different for me. I will choose `base.html` as the template for this project. It will look something like as follows:&#xA;&#xA;```html&#xA;&lt;!-- tempaltes/base.html --&gt;&#xA;&#xA;&lt;!DOCTYPE html&gt;&#xA;&lt;html lang=&#34;en&#34;&gt;&#xA;&lt;head&gt;&#xA;    &lt;meta charset=&#34;UTF-8&#34;&gt;&#xA;    &lt;title&gt;HTMX Blog&lt;/title&gt;&#xA;    {% load static %}&#xA;    &lt;link rel=&#34;stylesheet&#34; href=&#34;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&#34; integrity=&#34;sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm&#34; crossorigin=&#34;anonymous&#34;&gt;&#xA;    &lt;script src=&#34;https://unpkg.com/htmx.org@1.8.0&#34;&gt;&lt;/script&gt;&#xA;&lt;/head&gt;&#xA;&lt;body &gt;&#xA;        &lt;nav&gt;&#xA;        &lt;h2&gt;HTMX Blog&lt;/h2&gt;&#xA;        &lt;div class=&#34;navbar&#34;&gt;&#xA;          {% if user.is_authenticated %}&#xA;            &lt;a class=&#34;nav-item nav-link&#34; href=&#34;{% url &#39;logout&#39; %}&#34;&gt;&lt;button class=&#34;btn btn-link&#34;&gt;Logout&lt;/button&gt;&lt;/a&gt;&#xA;          {% else %}&#xA;            &lt;a class=&#34;nav-item nav-link&#34; href=&#34;{% url &#39;login&#39; %}&#34;&gt;&lt;button class=&#34;btn btn-link&#34;&gt;Login&lt;/button&gt;&lt;/a&gt;&#xA;            &lt;a class=&#34;nav-item nav-link&#34; href=&#34;{% url &#39;register&#39; %}&#34;&gt;&lt;button class=&#34;btn btn-link&#34;&gt;Register&lt;/button&gt;&lt;/a&gt;&#xA;          {% endif %}&#xA;        &lt;/div&gt;&#xA;        &lt;/nav&gt;&#xA;&#xA;    {% block body %}&#xA;    {% endblock %}&#xA;&lt;/body&gt;&#xA;&lt;/html&gt;&#xA;```&#xA;&#xA;I have a nav bar with my user authentication views, simply a login or signup button if the user is not logged in and a log-out button if the user is authenticated. We have added the htmx script file from the CDN just before the end of the head tag. We also have included the bootstrap CSS file for a decent UI which we will be creating in this post.&#xA;&#xA;That is one of the ways, htmx can be injected into an HTML template, you can even download the javascript file from the [htmx cdn](https://unpkg.com/browse/htmx.org/dist/). Further, this can be downloaded or pasted into your local folder and served as a static file or embedded directly into an HTML template.&#xA;&#xA;## Defining Models&#xA;&#xA;We will start the tutorial by defining the model of the application we are creating. Here, we will create a simple Article model with a few parameters like `title`, `content`, `author`, etc. &#xA;&#xA;```python&#xA;from django.db import models&#xA;from user.models import Profile&#xA;&#xA;class Article(models.Model):&#xA;    Article_Status = (&#xA;        (&#34;DRAFT&#34;, &#34;Draft&#34;),&#xA;        (&#34;PUBLISHED&#34;, &#34;Published&#34;),&#xA;    )&#xA;    title = models.CharField(max_length=128, unique=True)&#xA;    content = models.TextField()&#xA;    author = models.ForeignKey(Profile, on_delete=models.CASCADE)&#xA;    status = models.CharField(&#xA;        max_length=16,&#xA;        choices=Article_Status,&#xA;        default=Article_Status[0],&#xA;    )&#xA;&#xA;    def __str__(self):&#xA;        return self.title&#xA;```&#xA;&#xA;In the above model `Article`, we have a few fields like `title` simple Character Field, `content` as a text field as it will be a large text as the post body, `author` which is a ForeignKey to the User Model. We also have the status, which is defined as a character field but with a few choices like `draft` or `published`, we can further modify this status as public or private. But just keeping it simple and easy to understand.&#xA;&#xA;The object reference name for this model is the title as we have defined in the dunder string method. So, that is a simple model created, we can now migrate the changes into the database for adding the tables and attributes.&#xA;&#xA;```&#xA;python manage.py makemigrations&#xA;python manage.py migrate&#xA;```&#xA;&#xA;This will make migrations to the database i.e. convert the python model class into database tables and attributes. So, once the migration process is completed successfully, we can move into the crust of this article which is to actually design the views. In the next section, we will be utilizing the models in our views for representing the data on the templates.&#xA;&#xA;&#xA;## Creating Article Form&#xA;&#xA;Before diving into the views section, we need a few things like the Article Form, which will be a Django Model-based form. It will help us a lot in creating or updating the fields for the article model. We can define a form in a python file called `forms.py`, it&#39;s not necessary to keep your forms in the `forms.py` but if you have a lot of forms and models, it becomes a good practice to organize the components of our app. So, I&#39;ll be creating a new file inside of the `article` app called `forms.py` and defining the `ArticleForm`.&#xA;&#xA;```python&#xA;# article/forms.py&#xA;&#xA;from django import forms&#xA;from .models import Article&#xA;&#xA;&#xA;class ArticleForm(forms.ModelForm):&#xA;    class Meta:&#xA;        model = Article&#xA;        exclude = (&#xA;            &#34;created&#34;,&#xA;            &#34;updated&#34;,&#xA;            &#34;author&#34;,&#xA;        )&#xA;        widgets = {&#xA;            &#34;title&#34;: forms.TextInput(&#xA;                attrs={&#xA;                    &#34;class&#34;: &#34;form-control&#34;,&#xA;                    &#34;style&#34;: &#34;max-width: 450px; align: center;&#34;,&#xA;                    &#34;placeholder&#34;: &#34;Title&#34;,&#xA;                }&#xA;            ),&#xA;            &#34;content&#34;: forms.Textarea(&#xA;                attrs={&#xA;                    &#34;class&#34;: &#34;form-control&#34;,&#xA;                    &#34;style&#34;: &#34;max-width: 900px;&#34;,&#xA;                    &#34;placeholder&#34;: &#34;Content&#34;,&#xA;                }&#xA;            ),&#xA;        }&#xA;```&#xA;&#xA;So, the forms are inherited from the [ModelForm] which allows us to create forms based on our model. So, we specify the model name which in our case is `Article` and further we can have `exclude` or `fields` tuples. To exclude certain fields in the actual form, just parse the tuple of those attributes and if you want to only select a few attributes, you can specify the `fields` tuple and mention the required fields for the form.&#xA;&#xA;So, if we have a lot of things to be included in the form, we can specify only the attributes to be excluded with the `exclude` tuple. And if we have a lot of fields to be excluded, we can use the `fields` tuple to specify which attributes to use in the form.&#xA;&#xA;Let&#39;s take an example: For the above ArticleForm, if we wanted to specify the required fields to be included in the form, then we might use the `fields` tuple like below the rest will be not rendered in the form fields.&#xA;&#xA;```&#xA;class ArticleForm(forms.ModelForm):&#xA;    class Meta:&#xA;        model = Article&#xA;        fields = (&#xA;            &#34;title&#34;,&#xA;            &#34;content&#34;,&#xA;            &#34;status&#34;,&#xA;        )&#xA;```&#xA;&#xA;Both of them can be used, it just depends on how many fields you have to exclude or include in the rendered form.&#xA;&#xA;We have also specified the `widgets` attribute which gives a bit more control on how we need to display the form in a template. So I have specified the type of input it needs to render like a simple text input for the title, text area for content, etc. The cool thing about this is it can automatically set these by knowing the type of field in the model, but sometimes it can be a bit undesired mostly with complex relationships and attributes.&#xA;&#xA;## Creating Views&#xA;&#xA;Let&#39;s start creating views for creating, reading, updating, and deleting articles from the database. I will be using function-based views just because we are understanding the flow of how HTMX and Django can be integrated so we need to dive in deeper and understand the actual flow of the process.&#xA;&#xA;### Create View&#xA;&#xA;So, creating articles seems like a good way to start off. We can create a simple function-based view which will initially load in an empty `ArticleForm` and if the request is `GET` we will render the form in the `create.html` template. If the request is `POST` which will be after we submit the form, we will validate the form and attach the current user as the author of the article and save the for instance which will create an article record and this object will be rendered to the detail template.&#xA;&#xA;```python&#xA;from django.shortcuts import render&#xA;from .models import Article&#xA;from .forms import ArticleForm&#xA;&#xA;def createArticle(request):&#xA;    form = ArticleForm()&#xA;    context = {&#xA;        &#39;form&#39;: form,&#xA;    }&#xA;    return render(request, &#39;articles/create.html&#39;, context)&#xA;```&#xA;&#xA;#### Rendering the Form&#xA;&#xA;We are creating an empty instance of `ArticleForm` and rendering it in the template. So, this will render the empty form in the `create.html` template.&#xA;&#xA;```html&#xA;&lt;!-- templates/articles/create.html --&gt;&#xA;&#xA;{% extends &#39;base.html&#39; %}&#xA;&#xA;{% block body %}&#xA;&lt;div hx-target=&#34;this&#34; hx-swap=&#34;outerHTML&#34;&gt;&#xA;  &lt;form&gt;&#xA;    {% csrf_token %}&#xA;    {{ form.as_p }}&#xA;    &lt;button hx-post=&#34;.&#34; class=&#34;btn btn-success&#34;&#xA;      type=&#34;submit&#34;&gt;Save&lt;/button&gt;&#xA;  &lt;/form&gt;&#xA;&lt;/div&gt;&#xA;{% endblock %}&#xA;```&#xA;&#xA;Now, here we are inheriting from the base template and creating a form tag in HTML with the `{{ form}}` for rendering the form fields, we finally have the `button` element for submitting the form. We have used the `hx-post` attribute. More on this in just a minute. So, this is we create a template for rendering the article form.&#xA;&#xA;We have used the `hx-post` attribute here, which will send a `POST` request to the current `URL` represented by `hx-post=&#34;.&#34;`. You might have noticed the `div` attributes, the `hx-target` and `hx-swap`, so these are some of the many attributes provided by the htmx library for controlling the reactivity of the requests made. The `hx-target` allow us to specify the element or tag to which the data will be rendered. The `hx-swap` goes hand-in-hand for specifying the target DOM like `innerHTML`, `outerHTML`, etc. You can see the various options on the [htmx docs](https://htmx.org/docs/#swapping). By specifying the `hx-swap` as  `outerHTML`, we are saying to replace the entire element with the incoming content from the request which we will send with nearby request triggers.&#xA;&#xA;We need to map the view to a URL in order to get a good idea about the request and parsed content.&#xA;&#xA;We&#39;ll create a `create/` route and bind it to the `createArticle` view with the name `article-create`.&#xA;&#xA;```python&#xA;# article/urls.py&#xA;&#xA;from django.urls import path&#xA;from . import views&#xA;&#xA;urlpatterns = [&#xA;    path(&#39;create/&#39;, views.createArticle, name=&#39;article-create&#39;), &#xA;]&#xA;```&#xA;&#xA;This URL will be mapped to the global URL in the project, here we can simply specify the prefix for the URLs in the `article` app and include those URLs.&#xA;&#xA;```python&#xA;# htmx_blog/urls.py&#xA;&#xA;from django.contrib import admin&#xA;from django.urls import path, include&#xA;&#xA;urlpatterns = [&#xA;    path(&#39;admin/&#39;, admin.site.urls),&#xA;    path(&#39;user/&#39;, include(&#39;user.urls&#39;), name=&#39;auth&#39;),&#xA;    path(&#39;&#39;, include(&#39;article.urls&#39;), name=&#39;home&#39;),&#xA;]&#xA;```&#xA;Feel, free to add any other URL pattern like for instance, the article app is at `/` i.e. `127.0.01.:8000/`, you can add any other name like `127.0.0.1:8000/article/` by adding `path(&#39;article/&#39;, include(&#39;article.urls&#39;))`.&#xA;&#xA;![Django HTMX Create view Form Template](https://res.cloudinary.com/techstructive-blog/image/upload/v1659252089/blog-media/django-htmx-create-view.png)&#xA;&#xA;So, finally, we are sending a `GET` request to the `127.0.0.1:8000/create/` and this will output the form. As we have a `POST` request embedded in the button inside the form, we will send the `POST` request to the same URL -&gt; `127.0.0.1:8000/create/`.&#xA;&#xA;#### Submitting the Form&#xA;&#xA;Let&#39;s handle the `POST` request in the create view.&#xA;&#xA;```python&#xA;from django.shortcuts import render&#xA;from .models import Article&#xA;from .forms import ArticleForm&#xA;&#xA;def createArticle(request):&#xA;    form = ArticleForm(request.POST or None)&#xA;    if request.method == &#39;POST&#39;:&#xA;        if form.is_valid():&#xA;            form.instance.author = request.user&#xA;            article = form.save()&#xA;            return render(request, &#39;articles/detail.html&#39;, {&#39;article&#39;: article})&#xA;    context = {&#xA;        &#39;form&#39;: form,&#xA;    }&#xA;    return render(request, &#39;articles/create.html&#39;, context)&#xA;```&#xA;&#xA;**Simple explanation**&#xA;&#xA;- Create a form instance of ArticleForm with the request data or empty -&gt; `ArticleForm(request.POST or None)`&#xA;- If it&#39;s a POST request, validate and create the article, render the article object in `detail.html` template.&#xA;- If it&#39;s a GET request, render the empty form in `create.html`&#xA;&#xA;&#xA;There are a few changes in the view, instead of initializing the form to empty i.e. `ArticleForm()`, we are initializing with `ArticleForm(request.POST or None)`. This basically means that if we are having something in the `request.POST` dict, we will initialize the Form with that data or else an empty form instance.&#xA;&#xA;Next, we check if the request if `POST`, if it is then we check if the form is valid i.e. the form fields are not empty or if any other constraint on the model attributes is satisfied or not. If the form data is valid, we attach the author as the currently logged-in User/user who sent the request. Finally, we save the form which in turn creates the article record in the database. We then render the created article in the `detail.html` template which is not yet created.&#xA;&#xA;So, the `htmx-post` attribute has worked and it will send a post request to the same URL i.e. `127.0.0.1:8000/create` and this will again trigger the view `createArticle` this time we will have `request.POST` data. So, we will validate and save the form.&#xA;&#xA;### Detail View&#xA;&#xA;The detail view is used for viewing the details of an article. This will be rendered after the article has been created or updated. This is quite simple, we need an `id` or `primary key(pk)` of an article and render the `title` and `content` of the article in the template.&#xA;&#xA;We pass in a primary key along with the request as a parameter to the view, the `pk` will be passed via the URL. We fetch the Article object with the id as the parsed `pk` and finally render the `detail.html` template with the article object. The `context[&#39;article&#39;]` can be accessed from the template to render the specific attributes like `title`, `content`, etc.&#xA;&#xA;```python&#xA;# article/views.py&#xA;&#xA;def detailArticle(request, pk):&#xA;    article = Article.objects.get(id=pk)&#xA;    context = {&#39;article&#39;: article}&#xA;    return render(request, &#39;articles/detail.html&#39;, context)&#xA;&#xA;```&#xA;&#xA;We can now bind the view to a URL and parse the required parameter `pk` to the view. &#xA;&#xA;```python&#xA;from django.urls import path&#xA;from . import views&#xA;&#xA;urlpatterns = [&#xA;    path(&#39;create/&#39;, views.createArticle, name=&#39;article-create&#39;), &#xA;    path(&#39;&lt;int:pk&gt;&#39;, views.detailArticle, name=&#39;article-detail&#39;), &#xA;]&#xA;```&#xA;&#xA;We have parsed the `pk` as `int` to the URL parameter, so for an article with id=4, the URL will be, `127.0.0.1:8000/4/`.&#xA;&#xA;We need to create the template for rendering the context from the `detailArticle` view. So, we create the `detail.html` in the `templates/articles` folder. We inherit the base template and render the `article.title` and the `article.content` with a linebreaks template filter so as to display the content properly.&#xA;&#xA;```html&#xA;&lt;!-- templates/articles/detail.html --&gt;&#xA;&#xA;&#xA;{% extends &#39;base.html&#39; %}&#xA;{% block body %}&#xA;&lt;div id=&#34;article-card&#34;&gt;&#xA;  &lt;h2&gt;{{ article.title }}&#xA;  &lt;p&gt;{{ article.content|linebreaks|safe }}&lt;/p&gt;&#xA;&lt;div&gt;&#xA;{% endblock %}&#xA;&#xA;```&#xA;&#xA;![Detail View Template](https://res.cloudinary.com/techstructive-blog/image/upload/v1659252227/blog-media/django-htmx-detail-view.png)&#xA;&#xA;So, we can now use `createArticle` view as well as `detailArticle` view, this both are configured properly, so (CR) or CRUD is completed. We can add `listArticle` for listing out all the author&#39;s(logged-in user) articles.&#xA;&#xA;### List View&#xA;&#xA;Listview of the articles is much similar to the detail view as it will return a list of articles rather than a single article.&#xA;&#xA;So in the `listArticle` view, we will return all the articles with the author as the user who sent the request/logged-in user. We will parse this object list into the template as `base.html` or `articles/list.html`.&#xA;&#xA;```python&#xA;# article/views.py&#xA;&#xA;&#xA;def listArticle(request):&#xA;    articles = Article.objects.filter(author=request.user.id)&#xA;    context = {&#xA;        &#39;articles&#39;: articles,&#xA;    }&#xA;    return render(request, &#39;base.html&#39;, context)&#xA;```&#xA;&#xA;We will add the URL route for this as the `/` route that is on `127.0.0.1:8000/` this is the base URL for the article app and is the route for the `listArticle` view. So, we will display the list of articles on the homepage.&#xA;&#xA;```python&#xA;# article/urls.py&#xA;&#xA;&#xA;from django.urls import path&#xA;from . import views&#xA;&#xA;urlpatterns = [&#xA;    path(&#39;&lt;int:pk&gt;&#39;, views.detailArticle, name=&#39;article-detail&#39;), &#xA;    path(&#39;create/&#39;, views.createArticle, name=&#39;article-create&#39;), &#xA;    path(&#39;&#39;, views.listArticle, name=&#39;article-list&#39;), &#xA;]&#xA;```&#xA;&#xA;Let&#39;s create the template for the list view which will iterate over the articles and display the relevant data like the title and link to the article.&#xA;&#xA;```html&#xA;&lt;!-- templates/articles/list.html --&gt;&#xA;&#xA;&lt;ul id=&#34;article-list&#34;&gt;&#xA;  {% for article in articles %}&#xA;  &lt;li&gt;&#xA;    &lt;div class=&#34;card&#34; style=&#34;width: 18rem;&#34;&gt;&#xA;      &lt;div class=&#34;card-body&#34;&gt;&#xA;        &lt;h5 class=&#34;card-title&#34;&gt;{{ article.title }}&lt;/h5&gt;&#xA;        &lt;p class=&#34;card-text&#34;&gt;{{ article.content|truncatewords:5  }}&lt;/p&gt;&#xA;        &lt;a href=&#34;{% url &#39;article-detail&#39; article.id %}&#34; class=&#34;card-link&#34;&gt;Read more&lt;/a&gt;&#xA;      &lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;  &lt;/li&gt;&#xA;  {% endfor %}&#xA;&lt;/ul&gt;&#xA;```&#xA;&#xA;We have used the `truncatewords:5` template filter for only displaying the content of the articles till the first 5 words as it is just a list view, we don&#39;t want to display every detail of the article here.&#xA;&#xA;![List view Template](https://res.cloudinary.com/techstructive-blog/image/upload/v1659252293/blog-media/django-htmx-list-view.png)&#xA;&#xA;We can use this template to render in the `base.html` file.&#xA;&#xA;```html&#xA;&lt;!DOCTYPE html&gt;&#xA;&lt;html lang=&#34;en&#34;&gt;&#xA;&lt;head&gt;&#xA;    &lt;meta charset=&#34;UTF-8&#34;&gt;&#xA;    &lt;title&gt;HTMX Blog&lt;/title&gt;&#xA;    {% load static %}&#xA;    &lt;link rel=&#34;stylesheet&#34; href=&#34;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&#34; integrity=&#34;sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm&#34; crossorigin=&#34;anonymous&#34;&gt;&#xA;    &lt;script src=&#34;https://unpkg.com/htmx.org@1.8.0&#34;&gt;&lt;/script&gt;&#xA;&lt;/head&gt;&#xA;&lt;body hx-target=&#34;this&#34; hx-swap=&#34;outerHTML&#34; hx-headers=&#39;{&#34;X-CSRFToken&#34;: &#34;{{ csrf_token }}&#34;}&#39;&gt;&#xA;        &lt;nav&gt;&#xA;        &lt;h2&gt;HTMX Blog&lt;/h2&gt;&#xA;        &lt;div class=&#34;navbar&#34;&gt;&#xA;          {% if user.is_authenticated %}&#xA;            &lt;a class=&#34;nav-item nav-link&#34; href=&#34;{% url &#39;article-list&#39; %}&#34;&gt;&lt;button class=&#34;btn btn-link&#34;&gt;Home&lt;/button&gt;&lt;/a&gt;&#xA;            &lt;a class=&#34;nav-item nav-link&#34; href=&#34;{% url &#39;logout&#39; %}&#34;&gt;&lt;button class=&#34;btn btn-link&#34;&gt;Logout&lt;/button&gt;&lt;/a&gt;&#xA;          {% else %}&#xA;            &lt;a class=&#34;nav-item nav-link&#34; href=&#34;{% url &#39;login&#39; %}&#34;&gt;&lt;button class=&#34;btn btn-link&#34;&gt;Login&lt;/button&gt;&lt;/a&gt;&#xA;            &lt;a class=&#34;nav-item nav-link&#34; href=&#34;{% url &#39;register&#39; %}&#34;&gt;&lt;button class=&#34;btn btn-link&#34;&gt;Register&lt;/button&gt;&lt;/a&gt;&#xA;          {% endif %}&#xA;        &lt;/div&gt;&#xA;        &lt;/nav&gt;&#xA;&#xA;    {% block body %}&#xA;    &lt;a href=&#34;{% url &#39;article-create&#39; %}&#34;&gt;&lt;button class=&#34;btn btn-success&#34; &gt;Create&lt;/button&gt;&lt;/a&gt;&#xA;    {% include &#39;articles/list.html&#39; %}&#xA;    {% endblock %}&#xA;&lt;/body&gt;&#xA;&lt;/html&gt;&#xA;```&#xA;&#xA;We have now included the `list.html` template on the homepage and also added the `create` button as the link to the `article-create` URL.&#xA;&#xA;### Delete View&#xA;&#xA;For deleting an article, we will simply rely on htmx for sending the request and on that request, we will delete the current article and render the updated list of articles.&#xA;&#xA;With the `deleteArticle` view, we will take in two parameters the request which is by default for a Django function-based view, and the primary key as `pk`. Again we will parse the `pk` from the URL. We will delete the article object and get the latest list of articles. Finally, render the updated list of articles in the base template which is our list view.&#xA;&#xA;```python&#xA;# article/views.py&#xA;&#xA;&#xA;def deleteArticle(request, pk):&#xA;    Article.objects.get(id=pk).delete()&#xA;    articles = Article.objects.filter(author=request.user)&#xA;    context = {&#39;article&#39;: articles}&#xA;    return render(request, &#34;base.html&#34;, context)&#xA;&#xA;```&#xA;&#xA;We will add the `deleteArticle` into the URL patterns and call it `article-delete` with the URL of `delete/&lt;int:pk&gt;`. This will allow us to send a request to the URL `127.0.0.1:8000/delete/4` for deleting the article with id `4`.&#xA;&#xA;```python&#xA;# article/urls.py&#xA;&#xA;&#xA;from django.urls import path&#xA;from . import views&#xA;&#xA;urlpatterns = [&#xA;    path(&#39;&#39;, views.listArticle, name=&#39;article-list&#39;), &#xA;    path(&#39;&lt;int:pk&gt;&#39;, views.detailArticle, name=&#39;article-detail&#39;), &#xA;    path(&#39;create/&#39;, views.createArticle, name=&#39;article-create&#39;), &#xA;    path(&#39;delete/&lt;int:pk&gt;&#39;, views.deleteArticle, name=&#39;article-delete&#39;), &#xA;]&#xA;```&#xA;&#xA;In the delete view, the template is important as we want to send a request appropriately to the defined URL. To do that, we will have a form but it won&#39;t have any inputs as such just a button that indicates to delete the current article. We will add the `hx-delete` attribute as the URL to the `deleteArticle` view. with the id of the article. This will send a request to the `article-delete` URL which will, in turn, trigger the view with the given id and delete the article.&#xA;&#xA;We have added the `hx-confirm` attribute for showing a pop-up of confirmation of deleting the article. As you can see we have added a little script for adding `csrf_token` into the HTML, this is important in order to submit a form with a valid `CSRFToken`.&#xA;&#xA;```html&#xA;&lt;!-- templates/article/delete.html --&gt;&#xA;&#xA;&lt;script&gt;&#xA;  document.body.addEventListener(&#39;htmx:configRequest&#39;, (event) =&gt; {&#xA;    event.detail.headers[&#39;X-CSRFToken&#39;] = &#39;{{ csrf_token }}&#39;;&#xA;  })&#xA;&lt;/script&gt;&#xA;&lt;div &gt;&#xA;  &lt;form method=&#34;post&#34; &gt;&#xA;  {% csrf_token %}&#xA;    &lt;button class=&#34;btn btn-danger&#34;&#xA;      hx-delete=&#34;{% url &#39;article-delete&#39; article.id %}&#34;&#xA;      hx-confirm=&#34;Are you sure, You want to delete this article?&#34;&#xA;      type=&#34;submit&#34;&gt;&#xA;      Delete&#xA;    &lt;/button&gt;&#xA;  &lt;/form&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;&#xA;Do you have a question like how do we access the `article.id`? we are not rendering the `delete.html` template from the view, so there is no context to pass. We will include this snippet into the detail view template, so as to have the option of deleting the current article.&#xA;&#xA;We will modify the `articles/detail.html` template and include the `delete.html` template. This includes simply adding an HTML template in the specified location. So, we will basically inject the delete form into the detail template.&#xA;&#xA;```html&#xA;{% extends &#39;base.html&#39; %}&#xA;{% block body %}&#xA;&lt;div hx-target=&#34;this&#34; hx-swap=&#34;outerHTML&#34;&gt;&#xA;  &lt;h2&gt;{{ article.title }}&#xA;  {% include &#39;articles/delete.html&#39; %}&#xA;  &lt;p&gt;{{ article.content|linebreaks|safe }}&lt;/p&gt;&#xA;&lt;div&gt;&#xA;{% endblock %}&#xA;```&#xA;&#xA;Hence, we will have a nice option to delete the article in the detail section, this can be placed anywhere but remember, we need to add the `hx-target=&#34;this&#34;` and `hx-swap=&#34;outerHTML&#34;` in the div so as to correctly swap the HTML content after the request has been made.&#xA;&#xA;### Update View&#xA;&#xA;We can now move into the final piece of the CRUD i.e. `Update`. This will be similar to the `createArticle` with a couple of changes. We will parse parameters like `pk` to this view as well because we want to update a specific article. So, we will have to get the primary key of the article from the URL slug.&#xA;&#xA;Inside the `updateArticle` view, we will first grab the article object from the parsed primary key. We will have two kinds of requests here, one will be for fetching the `form` with the current article data, and the next request will be the `PUT` request for actually saving the changes in the article.&#xA;&#xA;The first request is simple as we need to parse the form data with the instance of the article object. We will call the `ArticleForm` with the instance of `article` this will load the data of the article into the form ready to render into the template. So once the `GET` request has been sent, we will render the template with the form pre-filled with the values of the article attributes.&#xA; &#xA; ```python&#xA;# article/views.py&#xA;&#xA;&#xA;def updateArticle(request, pk):&#xA;    article = Article.objects.get(id=pk)&#xA;    form = ArticleForm(instance=article)&#xA;    context = {&#xA;        &#39;form&#39;: form,&#xA;        &#39;article&#39;: article,&#xA;    }&#xA;    return render(request, &#39;articles/update.html&#39;, context)&#xA;```&#xA;&#xA;We will create a template in the `templates/articles/` folder as  `update.html` which will have a simple form for rendering the form fields and a button for sending a `PUT` request. We will render the `form` and then add a button element with the attribute `hx-put` for sending the `PUT` request to save changes to the article record. We will parse in the `article.id` for the primary key parameter to the view.&#xA;&#xA;```html&#xA;&lt;!-- templates/articles/update.html --&gt;&#xA;&#xA;&lt;div hx-target=&#34;this&#34; hx-swap=&#34;outerHTML&#34;&gt;&#xA;  &lt;form&gt;&#xA;    {% csrf_token %}&#xA;    {{ form.as_p }}&#xA;    &lt;button hx-put=&#34;{% url &#39;article-update&#39; article.id %}&#34;&#xA;      type=&#34;submit&#34;&gt;Update&lt;/button&gt;&#xA;  &lt;/form&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;&#xA;We are yet to link the `updateArticle` into the URLs. We will add the view `updateArticle` into the URLs with the name as `article-update` and `update/&lt;int:pk` as the slug pattern. This URL pattern will trigger the `updateArticle` when we send an HTTP request to the `127.0.0.1:8000/update/4` for updating the article with id as `4`.&#xA;&#xA;```python&#xA;# article/urls.py&#xA;&#xA;&#xA;from django.urls import path&#xA;from . import views&#xA;&#xA;urlpatterns = [&#xA;    path(&#39;&#39;, views.listArticle, name=&#39;article-list&#39;), &#xA;    path(&#39;&lt;int:pk&gt;&#39;, views.detailArticle, name=&#39;article-detail&#39;), &#xA;    path(&#39;create/&#39;, views.createArticle, name=&#39;article-create&#39;), &#xA;    path(&#39;delete/&lt;int:pk&gt;&#39;, views.deleteArticle, name=&#39;article-delete&#39;), &#xA;    path(&#39;update/&lt;int:pk&gt;&#39;, views.updateArticle, name=&#39;article-update&#39;), &#xA;]&#xA;```&#xA;&#xA;This is not done yet, we will need to handle the `PUT` request as well i.e. when the form details have been modified and we are about to save changes to the form data. So, we will check for the request method&#39;s type. If it is a `PUT` request, we will have to process a few things.&#xA;&#xA;```python&#xA;# article/views.py&#xA;&#xA;&#xA;from django.http import QueryDict&#xA;&#xA;def updateArticle(request, pk):&#xA;    article = Article.objects.get(id=pk)&#xA;    if request.method == &#39;PUT&#39;:&#xA;        qd = QueryDict(request.body)&#xA;        form = ArticleForm(instance=article, data=qd)&#xA;        if form.is_valid():&#xA;            article = form.save()&#xA;            return render(request, &#39;articles/detail.html&#39;, {&#39;article&#39;: article})&#xA;    form = ArticleForm(instance=article)&#xA;    context = {&#xA;        &#39;form&#39;: form,&#xA;        &#39;article&#39;: article,&#xA;    }&#xA;    return render(request, &#39;articles/update.html&#39;, context)&#xA;```&#xA;&#xA;In the above `updateArticle` view, we have to check for a `PUT` request, if we are sending a `PUT` request, the form instance needs to be loaded from the request object. We use the `request.body` to access the data sent in the request. The incoming data received from the `request.body` object is not a valid format to parse it to the form instance, so we will parse it using `QueryDict`. This will allow us to modify the `request.body` object into valid python serializable data.&#xA;&#xA;So, we import the `QueryDict` from `django.http` module. We parse the data as the parameter to `QueryDict` and store it in a variable. We then have to get the `ArticleForm` for fetching the data as per the form details, so we parse the instance and also the `data` parameter. The instance is the article object and the data is the received form data which we have stored in `qd` as `QueryDict(request.body)`. This will load the new form data and then we can validate it the form.&#xA;&#xA;After we have verified the form details, we can save the form and this will update the article record. Thereby we can render the updated article in the `detail` view with the updated `article` object as the context.&#xA;&#xA;![Update View Form Template](https://res.cloudinary.com/techstructive-blog/image/upload/v1659252091/blog-media/django-htmx-update-view.png)&#xA;&#xA;So, this will set up the update view as well, we can now create, read, update, and delete an article instance with HTMX in templates and Django function-based views without writing any javascript.&#xA;&#xA;## Summary&#xA;&#xA;We were able to create a basic CRUD application in Django with HTMX. We used simple function-based views to demonstrate the inner details of how we can work with HTMX and handle requests from the templates. By creating simple standalone templates, we can connect those together to make a fully functional and responsive webpage. The UI is not great but the purpose of this tutorial was to make a barebone CRUD app to work with the backend using HTMX, so hopefully, you would have got a good overview of how HTMX can be integrated into a Django application.&#xA;&#xA;Overall HTMX is a great library that can be used to enhance or even create a new web application for making the site responsive and without writing any javascript.&#xA;&#xA;![Django HTMX CRUD Application Demo GIF](https://res.cloudinary.com/techstructive-blog/image/upload/v1659252296/blog-media/django-htmx-demo.gif)&#xA;&#xA;You can check out the source code for this project and blog on the [htmx-blog GitHub](https://github.com/Mr-Destructive/htmx-blog-django) repository.&#xA;&#xA;## Conclusion&#xA;&#xA;From this post, we were able to understand the basics of HTMX and how we can integrate it into a Django application. Hopefully, you enjoyed the post, if you have any queries or feedback, please let me know in the comments or on my social handles. Thank you for reading. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>BackChat</title>
      <link>meetgor.com/</link>
      <description>A simple chat app with django-channels and HTMX</description>
      <pubDate>Mon, 31 Jan 2022 00:00:00 UTC</pubDate>
      <content>A simple chat/messaging app created for exploring HTMX and django-channels.&#xA;&#xA;Tech Stack:&#xA;- Django&#xA;- Django-Channels&#xA;- Daphne&#xA;- HTMX&#xA;&#xA;</content>
      <type>projects</type>
    </item>
  </channel>
</rss>