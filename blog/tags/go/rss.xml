<rss version="2.0">
  <channel>
    <title>Meet Gor - Tag: go</title>
    <link>meetgor.com</link>
    <description>Posts tagged with go</description>
    <language>en-us</language>
    <pubDate>Fri, 17 Oct 2025 16:57:38 UTC</pubDate>
    <item>
      <title>Golang Web: DELETE Method</title>
      <link>meetgor.com/golang-web-delete-method</link>
      <description>Exploring the fundamentals of a DELETE method in golang. How to request a resource, parse body, headers, etc. in a HTTP DELETE request.</description>
      <pubDate>Sun, 12 Jan 2025 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;We have explored GET, POST, PUT, and PATCH methods in our previous entries for this series. It is the final entry for all the HTTP methods which is going to be the `DELETE` method. In this entry of the series, we will take a view on how to construct and request an HTTP DELETE Method to an API Endpoint.&#xA;&#xA;The DELETE Method is quite simple. You just provide the URI of the resource. Most often, the request body is not needed. That request will simply delete the request entity from the server (in the database or wherever the resource is stored).&#xA;&#xA;Let’s understand it in a more detailed way.&#xA;&#xA;## What is a DELETE Method&#xA;&#xA;The DELETE method requests that the server remove the association between the target resource and its URI (Uniform Resource Identifier). This doesn&#39;t necessarily mean the underlying data is physically deleted; it means the resource is no longer accessible through that specific URL. DELETE can also be used to remove relationships between resources, effectively &#34;delinking&#34; them.&#xA;&#xA;According to the RFC:&#xA;&#xA;&gt; The DELETE method requests that the origin server remove the association between the target resource and its current functionality.&#xA;&#xA;Examples:&#xA;&#xA;* **Social Media** (Deleting a Tweet): When you delete a tweet, you&#39;re sending a DELETE request to the server. This removes the tweet from your timeline and makes it inaccessible via its URL. While the data might be archived or retained for a period, the key action is removing the public association between the tweet and its online presence. This is closer to a true deletion than the cart example.&#xA;    &#xA;* **E-Commerce** (Removing an Item from a Cart): When you remove an item from your online shopping cart, you&#39;re sending a request (often a DELETE) to remove the item from your cart. The actual product remains available in the store&#39;s inventory. This is a clear example of delinking. You&#39;re deleting the link between your cart and the product, not the product itself.&#xA;    &#xA;&#xA;Let’s start constructing a simple DELETE Request in Golang.&#xA;&#xA;## A Simple DELETE Request&#xA;&#xA;We don’t have a specific method for `DELETE` in `net/http` as we have for `GET` and `POST`, so we need to create a request and use a client to send the request.&#xA;&#xA;### Constructing the URL&#xA;&#xA;We would need to define the endpoint that we are hitting. We can directly use the API URL or construct the API URL on the fly, depending on the ID and dynamic parameters. DELETE requests usually delete a particular entity. We would generally have some form of identifier for that entity/object on the database, etc. So, in this case, it is the user&#39;s ID, so we can pass the post to the URL.&#xA;&#xA;```go&#xA;// define URL to hit the API&#xA;apiURL := &#34;https://reqres.in/api/users/4&#34;&#xA;&#xA;// OR&#xA;&#xA;baseURL := &#34;https://reqres.in&#34;&#xA;userID := 4&#xA;apiURL := fmt.Sprintf(&#34;%s/api/users/%d&#34;, baseURL, userID)&#xA;```&#xA;&#xA;We can either directly define the URL or dynamically construct the URL, that is quite straightforward. The latter one is the one we usually use and design.&#xA;&#xA;The DELETE Request doesn’t usually require a request body, however, if your server requires some specifications, you can construct the body as we did with the previous examples in POST, PUT, or PATCH method requests.&#xA;&#xA;### Constructing and sending the DELETE Request&#xA;&#xA;We can simply construct the request by specifying the http.MethodDelete as the request method, the URL to hit, and a body(optional) just like a `GET` request. Once we have the request, we can create the default client and send the request.&#xA;&#xA;```go&#xA;// create a DELETE request&#xA;req, err := http.NewRequest(http.MethodDelete, apiURL, nil)&#xA;if err != nil {&#xA;&#x9;log.Fatal(err)&#xA;}&#xA;&#xA;// construct the default http client and send the request&#xA;client := &amp;http.Client{}&#xA;resp, err := client.Do(req)&#xA;if err != nil {&#xA;&#x9;log.Fatal(err)&#xA;}&#xA;```&#xA;&#xA;This is the normal code used for constructing an HTTP request in Golang, we create a request using the NewRequest function that takes in the method type, the URL to send the request, and the body if any. Then we need to create a http.Client for sending the request, we usually create a client with default values and send the request using the Do method on the created client using the request that we constructed earlier.&#xA;&#xA;### Fetching the Response&#xA;&#xA;Once the request is sent, we can fetch the response and read the body as bytes, and check the status if that succeeded or failed.&#xA;&#xA;```go&#xA;fmt.Println(&#34;Response Status:&#34;, resp.Status)&#xA;respBody, err := io.ReadAll(resp.Body)&#xA;if err != nil {&#xA;    log.Fatal(err)&#xA;}&#xA;fmt.Println(&#34;Response Body:&#34;, string(respBody))&#xA;```&#xA;&#xA;We can grab the Status field for checking the status code and message for the request. Usually, the body would be empty since there is no resource we are expecting after deletion of the object. However, if the server is implemented in a way to return the deleted object, you can read the bytes of the body and unmarshal it to the desired struct.&#xA;&#xA;So, that is the entire code to create a simple Delete request with Go, simply construct the URL with the identifier for the resource to be deleted, create the request, and send the request, and if the status code is 204 (usually) then we can assume it succeeded.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;baseURL := &#34;https://reqres.in&#34;&#xA;&#x9;userID := 2&#xA;&#x9;apiURL := fmt.Sprintf(&#34;%s/api/users/%d&#34;, baseURL, userID)&#xA;&#xA;&#x9;req, err := http.NewRequest(http.MethodDelete, apiURL, nil)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;client := &amp;http.Client{}&#xA;&#x9;resp, err := client.Do(req)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;fmt.Println(&#34;Response Status:&#34;, resp.Status)&#xA;&#x9;respBody, err := io.ReadAll(resp.Body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#x9;fmt.Println(&#34;Response Body:&#34;, string(respBody))&#xA;}&#xA;```&#xA;&#xA;## Facts about the DELETE Method&#xA;&#xA;* DELETE Method is idempotent: Similar requests will result in identical behavior or response since once the resource is deleted, the resource won’t exist and hence the behavior would not hinder any other parts.&#xA;    &#xA;* DELETE Method is not safe: The operation is quite dangerous as it could literally remove a resource from a database/storage. Hence it is called not safe as it is making changes on the server.&#xA;    &#xA;&#xA;I have also included some more examples of DELETE requests [**here**](https://github.com/Mr-Destructive/100-days-of-golang/blob/main/web/methods/delete/).&#xA;&#xA;That&#39;s it from the 36th part of the series, all the source code for the examples are linked in the GitHub on the [**100 days of Golang**](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/web/methods/delete/) repository.&#xA;&#xA;[**100-days-of-golang**](https://github.com/Mr-Destructive/100-days-of-golang)&#xA;&#xA;## Conclusion&#xA;&#xA;That would be it from the DELETE Method in Golang. We can use this method just like a normal `GET` request however a bit more carefully.&#xA;&#xA;Hope you found this article, helpful, leave some feedback or any suggestions if you have any. Thank you for reading.&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang Web: PATCH Method</title>
      <link>meetgor.com/golang-web-patch-method</link>
      <description>Exploring the fundamentals of a PATCH method in golang. How to request a resource, parse body, headers, etc. in a HTTP PATCH request.</description>
      <pubDate>Sat, 11 Jan 2025 00:00:00 UTC</pubDate>
      <content>&#xA;&#xA;## Introduction&#xA;&#xA;In previous sections of this series, we&#39;ve covered the GET, POST, and PUT methods. Now, we will explore the PATCH method, which differs from the others in several key ways. The PATCH method is somewhat more flexible and depends on how the server or API you&#39;re working with is designed.&#xA;&#xA;In this section, we&#39;ll focus on understanding what the PATCH method is and how to use it. While we will dive deeper into building and structuring a full CRUD API later in the series, the focus here will be on the what and why of the PATCH method, not the how.&#xA;&#xA;## What is the PATCH Method?&#xA;&#xA;The PATCH method is often compared to the PUT method, but with one important distinction: PATCH is used to perform partial updates on a resource. Unlike PUT, which typically requires you to send the entire resource to update it, PATCH allows you to send only the fields that need to be updated. This makes it a more efficient option when updating a subset of a resource.&#xA;&#xA;In a PATCH request, the body usually contains instructions in a format like JSON, which specifies the fields to update. These instructions define the changes to be applied to the resource. For example, you may only want to change one field of a user&#39;s profile, such as their email address, while leaving the rest of the data untouched.&#xA;&#xA;## PATCH vs. PUT&#xA;&#xA;Key Differences While both PATCH and PUT are used to modify resources, there are significant differences in their behavior:&#xA;&#xA;* PUT replaces the entire resource. When you send a PUT request, you must include the full representation of the resource, even if you&#39;re only changing a small part of it.&#xA;    &#xA;* PATCH, on the other hand, is for partial updates. You only need to include the fields that are changing, not the entire resource.&#xA;    &#xA;&#xA;If the update involves more fields than just the ones you&#39;re changing, PUT may be the better choice. However, the scope of this article is to focus solely on the PATCH method.&#xA;&#xA;## How Does a PATCH Request Work?&#xA;&#xA;In the simplest terms, a PATCH request allows you to perform a partial update on a resource. It is similar to a PUT request, but more specific in how it updates the resource. According to the HTTP specification, an ideal PATCH request should:&#xA;&#xA;* Accept a &#34;patch document&#34; in the request body, which contains the list of operations to apply (e.g., &#34;replace&#34;, &#34;add&#34;, &#34;remove&#34;).&#xA;    &#xA;* Apply these updates to the target resource.&#xA;    &#xA;* If the update cannot be applied correctly, the operation should fail without applying any of the changes.&#xA;    &#xA;&#xA;This ensures that no partial or inconsistent updates are left behind&#xA;&#xA;For example, if you&#39;re updating a user&#39;s email address and something goes wrong in the middle of the operation, the PATCH request should ensure that the email isn&#39;t updated partially. If there’s an error, none of the updates should be applied, ensuring data consistency.&#xA;&#xA;Also, the patch method is not idempotent, meaning that if you send the same input/request, it need not necessarily return the same output. Because we are not sending the actual original entity, we are sending the partial data fields that need to be updated, so it might update the original entity on subsequent requests since there is no original request sent in the request; it only identifies the resource from the URI and fields to update in the request body.&#xA;&#xA;Now, let’s sum up the patch request in a few words&#xA;&#xA;* Updates specific fields mentioned in the patch document&#xA;    &#xA;* Can be partial (only the fields that need to be updated are sent, unlike PUT, which typically replaces the entire resource)&#xA;    &#xA;* Not necessarily idempotent (depends on the implementation)&#xA;    &#xA;* Not Safe (since resources will be updated on the server side)&#xA;    &#xA;&#xA;## Basic PATCH request&#xA;&#xA;Let’s start with the basic PATCH request that we can create in Golang. The \[net/http\]() package will be used to construct the request, and will be using `encoding/json` and some other utilities for string and byte parsing.&#xA;&#xA;So, first we will construct a HTTP request using the \[http.NewRequest\]() with the parameters like the http method to use, the URL to hit, and the request body if any. We will then need to send the json body which would consist of the fields to be updated.&#xA;&#xA;### Defining the API/Server Endpoint URL&#xA;&#xA;We would need to define the endpoint that we are hitting, we can directly use the API URL or we can construct the API URL on the fly depending on the id, and parameter that will be dynamic. As PATCH request, usually modify a particular entity, we would generally have some form of identifier for that entity/object on the database, etc. So in this case, it is `id` of the post, so, we can pass the post in the URL.&#xA;&#xA;```go&#xA;// define URL to hit the API&#xA;apiURL := &#34;https://jsonplaceholder.typicode.com/posts/4&#34;&#xA;&#xA;// OR&#xA;// baseURL := &#34;https://jsonplaceholder.typicode.com&#34;&#xA;// postId := 4&#xA;// postURL := fmt.Sprintf(&#34;%s/posts/%d&#34;, baseURL, postId)&#xA;```&#xA;&#xA;We can either directly define the URL or dynamically construct the URL, that is quite straightforward. The later one is the one we usually use and design.&#xA;&#xA;### Constructing the JSON Body&#xA;&#xA;This section is a little dependent on the context as you might have a direct json string that you can directly pass to the API or you might have a golang object that you need to Marshal in order to convert that object into string/bytes.&#xA;&#xA;1. Direct JSON String&#xA;    &#xA;    So, there is nothing to do here, since the object is already in the form of a json string.&#xA;    &#xA;    ```go&#xA;    reqBody := `{&#34;body&#34;: &#34;new body&#34;}`&#xA;    ```&#xA;    &#xA;    However, if you have certain fields that you need to exclude or omit, you have to construct a struct and then marshal it&#xA;    &#xA;2. Marshalling (converting object into bytes/string)&#xA;    &#xA;    We need to convert the Golang native object into some form of a json string or bytes that could be sent over the network. That process is called [marshalling](https://en.wikipedia.org/wiki/Marshalling_\(computer_science\)) or serialisation.&#xA;    &#xA;&#xA;```go&#xA;type Post struct {&#xA;&#x9;ID     int    `json:&#34;id,omitempty&#34;`&#xA;&#x9;Title  string `json:&#34;title,omitempty&#34;`&#xA;&#x9;Body   string `json:&#34;body,omitempty&#34;`&#xA;&#x9;UserId int    `json:&#34;userId,omitempty&#34;`&#xA;}&#xA;&#xA;userObj := Post{&#xA;    Body: &#34;New Body&#34;,&#xA;}&#xA;&#xA;var reqBody []byte&#xA;reqBody, err := json.Marshal(userObj)&#xA;if err != nil {&#xA;&#x9;log.Fatal(err)&#xA;}&#xA;&#xA;log.Println(&#34;New body:&#34;, string(reqBody))&#xA;// New body: {&#34;body&#34;:&#34;New Body&#34;}&#xA;```&#xA;&#xA;In the above snippet, we have defined a `Post` struct with the fields like `ID`, `Title`, `Body`, `UserID` , and those have `omitempty` tag along with the json fields that we want to marshal into. The omitempty will omit or ignore the fields if they are empty or not present in the object/instance of this structure. So in the example, `userObj` is the instance of the `Post` struct and it only has the `Body` populated, so the reqBody will only contain one field `body` in the json representation. The \[json.Marshal\]() is the function that we use to convert the object/instance into a byte form.&#xA;&#xA;This `reqBody` will serve as the request body for the request that will be a `PATCH` method to the mentioned endpoint / API URL.&#xA;&#xA;### Constructing the HTTP PATCH Request&#xA;&#xA;Now, we have the parts that we need to construct the request, we can combine the parts and hit the endpoint. However, it is a bit different compared to `GET` and `POST` request that we do in Golang, the HTTP package has built in methods for the `GET` and `POST` methods, however for methods like `PUT`, `PATCH`, `DELETE` and others, we need to construct a [Request](https://pkg.go.dev/net/http#Request) object and then send that request.&#xA;&#xA;```go&#xA;req, err := http.NewRequest(&#34;PATCH&#34;, postURL, strings.NewReader(reqBody))&#xA;if err != nil {&#xA;&#x9;log.Fatal(err)&#xA;}&#xA;req.Header.Set(&#34;Content-Type&#34;, &#34;application/json&#34;)&#xA;&#xA;// in case of wired utf-8 characters appear in the body&#xA;//req.Header.Set(&#34;Content-Type&#34;, &#34;application/json; charset=utf-8&#34;)&#xA;```&#xA;&#xA;To do that, we call the [NewRequest](https://pkg.go.dev/net/http#NewRequest) method with the parameters like the HTTP method, the URL, and the request Body all of which we have at the moment.&#xA;&#xA;* The method is `PATCH`&#xA;    &#xA;* The URL is `postURL`&#xA;    &#xA;* The body is `strings.NewReader(reqBody)` as we need a `io.Reader` object instead of string or byte slice&#xA;    &#xA;&#xA;So, once we have that, we would also set the `Header` with the field of `Content-Type` and the value as `application/json` since the request body has json representation of the patch document that will be sent.&#xA;&#xA;### Sending the Request&#xA;&#xA;Once, the `req` object is created, we also need a [Client](https://pkg.go.dev/net/http#Client) to send the request, so we create the client as default http.Client object with defaults and call the [Do](https://pkg.go.dev/net/http#Client.Do) method with the `req` as the request parameter in order to send the request with the default client.&#xA;&#xA;This method returns the response object, and an error if any.&#xA;&#xA;We also add the `defer resp.Body.Close()` in order to avoid leaks and safely access the response body.&#xA;&#xA;```go&#xA;client := &amp;http.Client{}&#xA;resp, err := client.Do(req)&#xA;if err != nil {&#xA;&#x9;log.Fatal(err)&#xA;}&#xA;defer resp.Body.Close()&#xA;```&#xA;&#xA;At this point, we can now start consuming the response and use it for further processing as per the needs.&#xA;&#xA;### Unmarshalling the Response&#xA;&#xA;We first read the response into a string or byte representation using the io.ReadAll method and then use the json.Unmarshal to convert the bytes into golang object/instance.&#xA;&#xA;```go&#xA;var updatedPost Post&#xA;&#xA;respBody, err := io.ReadAll(resp.Body)&#xA;if err != nil {&#xA;&#x9;log.Fatal(err)&#xA;}&#xA;    &#xA;// convert the response json bytes to Post object in golang&#xA;err = json.Unmarshal(respBody, &amp;updatedPost)&#xA;if err != nil {&#xA;&#x9;log.Fatal(err)&#xA;}&#xA;&#xA;fmt.Println(updatedPost)&#xA;fmt.Println(updatedPost.Title)&#xA;```&#xA;&#xA;In the above example, we have read the response Body which can be accessed as the `Body` field in the [Response](https://pkg.go.dev/net/http#Response) object via the `resp` variable. So, the function will return the `respBody` as a string or an error if any. Then using this string object, we can use the json.Unmarshal function to send this string and create this `updatedPost` object of Post struct. This method will mutate this object as we have passed it by reference indicated by `&amp;updatedPost` . So, this will do two things, one update / mutate the `updatedPost` instance from the `respBody` and give any error if any arrises during the [deserialsation](https://developer.mozilla.org/en-US/docs/Glossary/Deserialization) of the response .&#xA;&#xA;Now, we have the object in golang from the response bytes, we can use it as per requirements.&#xA;&#xA;So, that is the example in the entirety.&#xA;&#xA;Let’s simplify the steps which are similar to the POST/PUT method as well&#xA;&#xA;* Define/construct URL&#xA;    &#xA;* Marshal the object into JSON string as the request body&#xA;    &#xA;* Construct the request object (method, URL and the body)&#xA;    &#xA;* Send the request with the default client&#xA;    &#xA;* Read the response and deserialise/unmarshall&#xA;    &#xA;* Access the object in golang&#xA;    &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;type Post struct {&#xA;&#x9;ID     int    `json:&#34;id,omitempty&#34;`&#xA;&#x9;Title  string `json:&#34;title,omitempty&#34;`&#xA;&#x9;Body   string `json:&#34;body,omitempty&#34;`&#xA;&#x9;UserId int    `json:&#34;userId,omitempty&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;// define URL to hit the API&#xA;    baseURL := &#34;https://jsonplaceholder.typicode.com&#34;&#xA;    postId := 4&#xA;    postURL := fmt.Sprintf(&#34;%s/posts/%d&#34;, baseURL, postId)&#xA;&#xA;    // define the body -&gt; with the field to update&#xA;&#x9;reqBody := `{&#34;body&#34;: &#34;new body&#34;}`&#xA;&#x9;fmt.Println(&#34;New body:&#34;, reqBody)&#xA;&#xA;    // send a new request, with the `PATCH` method, url and the body&#xA;&#x9;req, err := http.NewRequest(&#34;PATCH&#34;, postURL, strings.NewReader(reqBody))&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;    // set the header content type to json&#xA;&#x9;req.Header.Set(&#34;Content-Type&#34;, &#34;application/json&#34;)&#xA;&#xA;&#x9;client := &amp;http.Client{}&#xA;&#x9;resp, err := client.Do(req)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#x9;defer resp.Body.Close()&#xA;&#x9;fmt.Println(&#34;Response status code:&#34;, resp.StatusCode)&#xA;&#x9;fmt.Println(&#34;Response Status:&#34;, resp.Status)&#xA;&#x9;&#xA;    var updatedPost Post&#xA;&#xA;&#x9;respBody, err := io.ReadAll(resp.Body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;    &#xA;    // convert the response json bytes to Post object in golang&#xA;&#x9;err = json.Unmarshal(respBody, &amp;updatedPost)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;fmt.Println(updatedPost)&#xA;&#x9;fmt.Println(updatedPost.Title)&#xA;&#xA;}&#xA;```&#xA;&#xA;```plaintext&#xA;New body: {&#34;body&#34;: &#34;new body&#34;}&#xA;Response status code: 200&#xA;Response Status: 200 OK&#xA;{4 eum et est occaecati new body 1}&#xA;&#xA;title: eum et est occaecati                                                                         &#xA;body: new body&#xA;id: 4&#xA;user id: 1&#xA;```&#xA;&#xA;As you would see, it has only updated the `body` and has not updated the other fields.&#xA;&#xA;If you would have sent a similar body with a `PUT` method, the results would have been different. That would have been dependent on the implementation of the API of course, but if there is only a few fields in the request body for a PUT method, it would have replaced the values with the empry values which are not present in the request body.&#xA;&#xA;That is the difference between a `PUT` and a `PATCH` method, the `PATCH` method, ideally should only update the fields of the entity which are mentioned in the request body, whereas the `PUT` method has to update the entire resource whether the fields are provided or not. Again, the implementation of these API on the server plays a vital role in how the behaviour defers and the method in itself would perform.&#xA;&#xA;This is also called as `JSON Merge Patch`&#xA;&#xA;## JSON Merge PATCH&#xA;&#xA;The above API is implementing a [Merge PATCH](https://datatracker.ietf.org/doc/html/rfc7386) which is to say, merge the changes in the actual entity.&#xA;&#xA;Let’s say there is a Blog post Entity on a Server, you have a post that you are writing as an author. The post has a id of `4` let’s say and you are constantly changing the body of the post.&#xA;&#xA;So, you don’t want to send the `title` or `author_id` or any field that is not changing from the client again and again while saving, so the `MERGE PATCH` endpoint will be helpful in that case, where the client only sends the required fields to be updated.&#xA;&#xA;In this example, the user would only send the `body` of the post to the API every time it makes changes or saves the draft. In some cases, it might also want to change the title, so it will include the title, but not all the fields. The API will know it is a `PATCH` request and the content type is `json` so it will only change or update the fields that are provided in the request body to the actual entity in the database or wherever it is stored on the server.&#xA;&#xA;So, that is what is the JSON Merge PATCH or Merge PATCH in general. JSON Merge PATCH is specific to the JSON based document APIs.&#xA;&#xA;Below is the example, the same steps but a different endpoint. A user API that I have specifically created for demonstrating the difference in a PUT vs Merge PATCH vs JSON PATCH requests.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;type User struct {&#xA;&#x9;ID    int    `json:&#34;id,omitempty&#34;`&#xA;&#x9;Name  string `json:&#34;name,omitempty&#34;`&#xA;&#x9;Email string `json:&#34;email,omitempty&#34;`&#xA;&#x9;Roles string `json:&#34;roles,omitempty&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;    baseURL := &#34;https://dummy-json-patch.netlify.app/.netlify/functions&#34;&#xA;    userID := 2&#xA;&#x9;apiURL := fmt.Sprintf(&#34;%s/users/?id=%d&#34;, baseURL, userID)&#xA;    &#xA;    userObj := User{&#xA;&#x9;&#x9;Name:  &#34;dummy name&#34;,&#xA;&#x9;&#x9;Roles: &#34;dummy role&#34;,&#xA;&#x9;}&#xA;&#xA;&#x9;var jsonPatchBody []byte&#xA;&#x9;jsonPatchBody, err := json.Marshal(userObj)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;    &#xA;    // OR directly define the json as string&#xA;&#x9;//jsonMergePatchBody := `{&#xA;    //    &#34;name&#34;: &#34;new dummy name&#34;,&#xA;    //    &#34;roles&#34;: &#34;new dummy role&#34;&#xA;    //}`&#xA;&#xA;&#x9;req, err := http.NewRequest(&#34;PATCH&#34;, apiURL, strings.NewReader(jsonMergePatchBody))&#xA;&#x9;req.Header.Set(&#34;Content-Type&#34;, &#34;application/json&#34;)&#xA;&#xA;&#x9;client := &amp;http.Client{}&#xA;&#x9;resp, err := client.Do(req)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;&#x9;var user User&#xA;&#xA;&#x9;resBody, err := io.ReadAll(resp.Body)&#xA;&#x9;fmt.Println(string(resBody))&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;err = json.Unmarshal(resBody, &amp;user)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;&#x9;fmt.Println(&#34;Updated/Patched User&#34;, user)&#xA;&#x9;fmt.Println(&#34;Id:&#34;, user.ID)&#xA;&#x9;fmt.Println(&#34;Name:&#34;, user.Name)&#xA;&#x9;fmt.Println(&#34;Email:&#34;, user.Email)&#xA;    fmt.Println(&#34;Bio:&#34;, user.Bio)&#xA;&#x9;fmt.Println(&#34;Roles:&#34;, user.Roles)&#xA;}&#xA;```&#xA;&#xA;Original User with id 2&#xA;&#xA;```plaintext&#xA;{&#34;id&#34;:2,&#34;name&#34;:&#34;dummy&#34;,&#34;email&#34;:&#34;dummyyummy@user.com&#34;,&#34;bio&#34;:&#34;empty bio&#34;,&#34;roles&#34;:&#34;read&#34;}&#xA;&#xA;Id: 2&#xA;Name: dummy&#xA;Email: dummyyummy@user.com&#xA;Bio: empty bio&#xA;Roles: read&#xA;```&#xA;&#xA;Output of the program&#xA;&#xA;```plaintext&#xA;Request Body: {&#34;name&#34;:&#34;dummy name&#34;,&#34;roles&#34;:&#34;dummy role&#34;}&#xA;&#xA;{&#34;id&#34;:2,&#34;name&#34;:&#34;dummy name&#34;,&#34;email&#34;:&#34;dummyyummy@user.com&#34;,&#34;bio&#34;:&#34;empty bio&#34;,&#34;roles&#34;:&#34;dummy role&#34;}&#xA;&#xA;Updated/Patched User {2 dummy name dummyyummy@user.com empty bio dummy role}&#xA;&#xA;Id: 2&#xA;Name: dummy name&#xA;Email: dummyyummy@user.com&#xA;Bio: empty bio&#xA;Roles: dummy role &#xA;```&#xA;&#xA;In the above example, the only fields that will be updated are `name` and `roles` , since the API is implemented to only update the fields provided in the json merge patch document (request body).&#xA;&#xA;As you can see that, only the `name` and `roles` are changed. The name was `dummy` that changed to `dummy name` and role changed from `read` to `dummy role` .&#xA;&#xA;Now, let’s see the same request but with PUT method on it.&#xA;&#xA;Before we hit this API however, let’s note what the user with id 2 is&#xA;&#xA;```json&#xA;{&#xA;  &#34;id&#34;: 2,&#xA;  &#34;name&#34;: &#34;dummy name&#34;,&#xA;  &#34;email&#34;: &#34;dummyyummy@user.com&#34;,&#xA;  &#34;bio&#34;: &#34;empty bio&#34;,&#xA;  &#34;roles&#34;: &#34;dummy role&#34;&#xA;}&#xA;```&#xA;&#xA;This is the result of our recent patch request. Now, we will send a PUT request to the same user with a different body.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;type User struct {&#xA;&#x9;ID    int    `json:&#34;id,omitempty&#34;`&#xA;&#x9;Name  string `json:&#34;name,omitempty&#34;`&#xA;&#x9;Email string `json:&#34;email,omitempty&#34;`&#xA;&#x9;Bio   string `json:&#34;bio,omitempty&#34;`&#xA;&#x9;Roles string `json:&#34;roles,omitempt&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;    baseURL := &#34;https://dummy-json-patch.netlify.app/.netlify/functions&#34;&#xA;    userID := 2&#xA;&#x9;apiURL := fmt.Sprintf(&#34;%s/users/?id=%d&#34;, baseURL, userID)&#xA;    &#xA;&#x9;userObj := User{&#xA;&#x9;&#x9;Name:  &#34;not a dummy name&#34;,&#xA;&#x9;&#x9;Roles: &#34;not a dummy role&#34;,&#xA;&#x9;}&#xA;&#xA;&#x9;var jsonPatchBody []byte&#xA;&#x9;jsonPatchBody, err := json.Marshal(userObj)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(&#34;Request Body:&#34;, string(jsonPatchBody))&#xA;&#xA;&#x9;//jsonPatchBody := `{&#xA;&#x9;//    &#34;name&#34;: &#34;dummy&#34;,&#xA;&#x9;//    &#34;roles&#34;: &#34;new dummy role&#34;&#xA;&#x9;//}`&#xA;&#xA;&#x9;req, err := http.NewRequest(&#34;PUT&#34;, apiURL, strings.NewReader(string(jsonPatchBody)))&#xA;&#x9;req.Header.Set(&#34;Content-Type&#34;, &#34;application/merge-patch+json&#34;)&#xA;&#xA;&#x9;client := &amp;http.Client{}&#xA;&#x9;resp, err := client.Do(req)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;&#x9;var user User&#xA;&#xA;&#x9;resBody, err := io.ReadAll(resp.Body)&#xA;&#x9;fmt.Println(string(resBody))&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;err = json.Unmarshal(resBody, &amp;user)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;&#x9;fmt.Println(&#34;Updated/Patched User&#34;, user)&#xA;&#x9;fmt.Println(&#34;Id:&#34;, user.ID)&#xA;&#x9;fmt.Println(&#34;Name:&#34;, user.Name)&#xA;&#x9;fmt.Println(&#34;Bio:&#34;, user.Bio)&#xA;&#x9;fmt.Println(&#34;Email:&#34;, user.Email)&#xA;&#x9;fmt.Println(&#34;Roles:&#34;, user.Roles)&#xA;}&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```plaintext&#xA;Request Body: {&#34;name&#34;:&#34;not a dummy name&#34;,&#34;roles&#34;:&#34;not a dummy role&#34;}&#xA;&#xA;{&#34;id&#34;:2,&#34;name&#34;:&#34;not a dummy name&#34;,&#34;email&#34;:&#34;&#34;,&#34;bio&#34;:&#34;&#34;,&#34;roles&#34;:&#34;not a dummy role&#34;}&#xA;&#xA;Updated/Patched User {2 not a dummy name   not a dummy role}&#xA;&#xA;Id: 2&#xA;Name: not a dummy name&#xA;Bio:&#xA;Email:&#xA;Roles: not a dummy role&#xA;```&#xA;&#xA;As you can see the `name` and `roles` are updated, however the `bio` and `email` fields are empty. Since we only said to update the `name` and `roles` fields, but it was a `PUT` request, it expects all the fields, and if any of the fields are missing, it will consider them as empty and update those as well.&#xA;&#xA;So, the difference might be crystal clear now. When to use `PATCH` and when to avoid `PUT`.&#xA;&#xA;* When you have a large set of updates, preference could be given to PUT&#xA;    &#xA;* If you have very specific fields to update and a very limited fields PATCH is recommended&#xA;    &#xA;&#xA;There is other type of PATCH specifically designed for JSON APIs, or I should say JSON Documents APIs.&#xA;&#xA;## JSON PATCH&#xA;&#xA;The [JSON PATCH](https://datatracker.ietf.org/doc/html/rfc6902/) is a specification in which we can define what operations to perform on which fields, or path of the fields to replace, move or copy to.&#xA;&#xA;&gt; A JSON Patch document is a JSON document that represents an array of objects. Each object represents a single operation to be applied to the target JSON document.&#xA;&#xA;As it takes this operations, it applies them sequentially and hence it won’t replace all the fields for the entity, as that is the expected behavior of the PATCH method. In other words, it would only apply changes to the fields and the related fields provided in the json patch document (request body).&#xA;&#xA;There are a few operations that you can perform with this json patch method, and provide the instructions accordingly for individual operations in the JSON PATCH document.&#xA;&#xA;Operations&#xA;&#xA;* add&#xA;    &#xA;* remove&#xA;    &#xA;* replace&#xA;    &#xA;* move&#xA;    &#xA;* copy&#xA;    &#xA;* test&#xA;    &#xA;&#xA;So, for each of the operations, a high level definition can be considered as:&#xA;&#xA;* To add a field you can specify the operation as `add` , the path as the field to be added, and the value as the actual value to be added&#xA;    &#xA;* To remove a field, you can specify the operation as `remove` , and the path as the field to remove&#xA;    &#xA;* To replace a field, you can specify the operation as `replace`, the path as the field to be updated/replaced, and the value of the actual value to be added&#xA;    &#xA;* To move a field, you can specify the operation as `move`, the **from** as the field to be updated/moved from and the path to the field the from value should be moved to.&#xA;    &#xA;* To copy a field, you can specify the operation as `copy`, the from as the field to updated/copied from and the path to the field to which the value should be copied to.&#xA;    &#xA;* The test operation is a bit different as it is used for comparison of a `path` value to the actual value specified in the object. It might return true or false, but not actually return it might be used as a checkpoint for continuing with the operation in the document.&#xA;    &#xA;&#xA;In this example, we are creating a similar patch request, but using this json patch document kind of structure.&#xA;&#xA;### Construct the json-patch document&#xA;&#xA;### Send the request&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;type User struct {&#xA;&#x9;ID    int    `json:&#34;id&#34;`&#xA;&#x9;Name  string `json:&#34;name&#34;`&#xA;&#x9;Email string `json:&#34;email&#34;`&#xA;    Bio   string `json:&#34;bio&#34;`&#xA;&#x9;Roles string `json:&#34;roles&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;baseURL := &#34;https://dummy-json-patch.netlify.app/.netlify/functions&#34;&#xA;    userID := 2&#xA;&#x9;apiURL := fmt.Sprintf(&#34;%s/users/?id=%d&#34;, baseURL, userID)&#xA;&#xA;&#x9;jsonPatchBody := `[&#xA;        {&#xA;            &#34;op&#34;: &#34;replace&#34;,&#xA;            &#34;path&#34;: &#34;/name&#34;,&#xA;            &#34;value&#34;: &#34;new dummy name&#34;&#xA;        },&#xA;        {&#xA;            &#34;op&#34;: &#34;replace&#34;,&#xA;            &#34;path&#34;: &#34;/roles&#34;,&#xA;            &#34;value&#34;: &#34;new dummy role&#34;&#xA;        },&#xA;    ]`&#xA;&#xA;&#x9;req, err := http.NewRequest(&#34;PATCH&#34;, apiURL, strings.NewReader(jsonPatchBody))&#xA;&#x9;req.Header.Set(&#34;Content-Type&#34;, &#34;application/json-patch+json&#34;)&#xA;&#xA;&#x9;client := &amp;http.Client{}&#xA;&#x9;resp, err := client.Do(req)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;&#x9;var user User&#xA;&#xA;&#x9;resBody, err := io.ReadAll(resp.Body)&#xA;&#x9;fmt.Println(string(resBody))&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;err = json.Unmarshal(resBody, &amp;user)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;&#x9;fmt.Println(&#34;Updated/Patched User&#34;, user)&#xA;&#x9;fmt.Println(&#34;Id:&#34;, user.ID)&#xA;&#x9;fmt.Println(&#34;Name:&#34;, user.Name)&#xA;&#x9;fmt.Println(&#34;Bio:&#34;, user.Bio)&#xA;&#x9;fmt.Println(&#34;Email:&#34;, user.Email)&#xA;&#x9;fmt.Println(&#34;Roles:&#34;, user.Roles)&#xA;}&#xA;```&#xA;&#xA;Original User (id=2) before the request&#xA;&#xA;```json&#xA;{&#xA;  &#34;id&#34;: 2,&#xA;  &#34;name&#34;: &#34;dummy name&#34;,&#xA;  &#34;email&#34;: &#34;dummyyummy@user.com&#34;,&#xA;  &#34;bio&#34;: &#34;empty bio&#34;,&#xA;  &#34;roles&#34;: &#34;dummy role&#34;&#xA;}&#xA;```&#xA;&#xA;Output of the Program (JSON PATCH Request)&#xA;&#xA;```plaintext&#xA;{&#34;id&#34;:2,&#34;name&#34;:&#34;new dummy name&#34;,&#34;email&#34;:&#34;dummyyummy@user.com&#34;,&#34;bio&#34;: &#34;empty bio&#34;, &#34;roles&#34;:&#34;new dummy role&#34;}     &#xA;&#xA;Updated/Patched User {2 new dummy name dummyyummy@user.com empty bio new dummy role} &#xA;&#xA;Id: 2&#xA;Name: new dummy name&#xA;Email: dummyyummy@user.com&#xA;Bio: empty bio&#xA;Roles: read&#xA;```&#xA;&#xA;### References:&#xA;&#xA;* [Wikipedia: HTTP Request Methods](https://en.wikipedia.org/wiki/HTTP#Request\_methods)&#xA;    &#xA;* [Ruby on Rails: Patch is the new primary HTTP method for updates](https://rubyonrails.org/2012/2/26/edge-rails-patch-is-the-new-primary-http-method-for-updates)&#xA;    &#xA;* [RFC 5789](https://datatracker.ietf.org/doc/html/rfc5789)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Advent of Code Day 5 in Golang: Ordering Pages</title>
      <link>meetgor.com/aoc-2024-day-5</link>
      <description>Solving day 5 of Advent of Code 2024 in Golang. Diving into one of the possible approaches to the puzzle.</description>
      <pubDate>Wed, 11 Dec 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;It is day 5 of the advent of code, and today we have an interesting problem of ordering pages. Let’s dive into the problem and how I approached it. It was a pretty simple problem if thought it peacefully, otherwise, it would get into a map, list, and indices mess.&#xA;&#xA;## Input&#xA;&#xA;In the input for day 5, we have two sections, The first defines the rules for ordering the pages, specifically which page should come before which and the second contains the actual order of pages.&#xA;&#xA;```plaintext&#xA;47|53&#xA;97|13&#xA;97|61&#xA;97|47&#xA;75|29&#xA;61|13&#xA;75|53&#xA;29|13&#xA;97|29&#xA;53|29&#xA;61|53&#xA;97|53&#xA;61|29&#xA;47|13&#xA;75|47&#xA;97|75&#xA;47|61&#xA;75|61&#xA;47|29&#xA;75|13&#xA;53|13&#xA;&#xA;75,47,61,53,29&#xA;97,61,53,29,13&#xA;75,29,13&#xA;75,97,47,61,53&#xA;61,13,29&#xA;97,13,75,29,47&#xA;```&#xA;&#xA;So, the first section has the rules mapped out, the other has the ordering of pages, and each line is a query or a list of pages as our actual data to process. We need to use it in the processing of parts 1 and 2.&#xA;&#xA;### Reading Sections&#xA;&#xA;So, we need to parse these sections and read them in a data structure that could be easier to access.&#xA;&#xA;One way to do that would be&#xA;&#xA;* A list with two sections&#xA;    &#xA;* The first section will be a list&#xA;    &#xA;    * The list will be a list of integers to hold the two integers i.e. for rules&#xA;        &#xA;* The second section will be a list&#xA;    &#xA;    * The list will be a list of integers to hold the page list&#xA;        &#xA;&#xA;So, the data structure would look like a list of list of list of integers.&#xA;&#xA;```go&#xA;&#xA;func ReadFileSections(path string) [][][]int {&#xA;&#xA;&#x9;fileBytes := ReadFileBytes(path)&#xA;&#x9;lines := []string{}&#xA;&#x9;separator := []byte(&#34;&#xA;&#xA;&#34;)&#xA;&#x9;for _, line := range bytes.Split(fileBytes, separator) {&#xA;&#x9;&#x9;if string(line) != &#34;&#34; {&#xA;&#x9;&#x9;&#x9;lines = append(lines, string(line))&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;sections := [][][]int{}&#xA;&#x9;for i, section := range lines {&#xA;&#x9;&#x9;nums := [][]int{}&#xA;&#x9;&#x9;lineStrs := strings.Split(section, &#34;&#xA;&#34;)&#xA;&#x9;&#x9;separator := &#34;,&#34;&#xA;&#x9;&#x9;if i == 0 {&#xA;&#x9;&#x9;&#x9;separator = &#34;|&#34;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;for _, lineStr := range lineStrs {&#xA;&#x9;&#x9;&#x9;if lineStr == &#34;&#34; {&#xA;&#x9;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;numL := []int{}&#xA;&#x9;&#x9;&#x9;for _, numStr := range strings.Split(lineStr, separator) {&#xA;&#x9;&#x9;&#x9;&#x9;num, _ := strconv.Atoi(numStr)&#xA;&#x9;&#x9;&#x9;&#x9;numL = append(numL, num)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;nums = append(nums, numL)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;sections = append(sections, nums)&#xA;&#x9;}&#xA;&#x9;return sections&#xA;}&#xA;```&#xA;&#xA;The above function called `ReadFileSections` takes in a path to the input file and returns a slice/array) of the list of list of integers as discussed. We first read the file and split the bytes into two newline characters that will be the separator for the sections, we will store the lines as a list of strings, the first will contain the rule lines and the second will contain the page list lines.&#xA;&#xA;Then we iterate over the section and split the individual lines for sections separately with the respective separator i.e. `|` for the first section and (whitespace) for the second section. We are parsing each line to get a list of integers and append them to the respective sections.&#xA;&#xA;So, we now have data that we can use to construct the rules and pages to help process the problem.&#xA;&#xA;### Constructing Rules&#xA;&#xA;Now, we need to process the rules list for convenient access, we need to get the page number that should appear after a given page, so we will use a map of integer with a list of integers, where the key will be the first number and the one of the value will be the second number ( the number that should appear after in order of the pages).&#xA;&#xA;```go&#xA;func ConstructRules(rulesList [][]int) map[int][]int {&#xA;&#x9;rules := make(map[int][]int)&#xA;&#x9;for _, rule := range rulesList {&#xA;&#x9;&#x9;rules[rule[0]] = append(rules[rule[0]], rule[1])&#xA;&#x9;}&#xA;&#x9;return rules&#xA;}&#xA;```&#xA;&#xA;We simply iterate over the list of integers and map the first element as the key and the value as the second element in the list, so to visualize:&#xA;&#xA;```go&#xA;FROM&#xA;&#xA;[][]int&#xA;&#xA;[&#xA;    [47,53]&#xA;    [97,13]&#xA;    [97,61]&#xA;]&#xA;&#xA;TO&#xA;&#xA;map[int][]int&#xA;{&#xA;    47: [53]&#xA;    97: [13,61]&#xA;}&#xA;```&#xA;&#xA;So, now have the rules as a map of integers with integers.&#xA;&#xA;### Constructing indices&#xA;&#xA;Now, to make the first and second parts easier, we need to make a map for each number in the rules section with the indices that appear in the pages list.&#xA;&#xA;So, we will iterate over the rules, which is a map of integers and integers, we will create a map of integers that will help us create a unique list of integers from the rules.&#xA;&#xA;Now, once we have the list of integers from the rules, we will iterate over all the numbers and on each page line, check on which index it appears, for creating a list of integers(indices).&#xA;&#xA;So, we iterate over all the numbers in the line of pages, if we find that number in the list of pages, we append the index, however, if we don’t we append -1, so for each line we need to have an index appended for that number like so:&#xA;&#xA;```plaintext&#xA;# 75&#xA;&#xA;75,47,61,53,29  -&gt;  0&#xA;97,61,53,29,13  -&gt; -1&#xA;75,29,13        -&gt;  0&#xA;75,97,47,61,53  -&gt;  0&#xA;61,13,29        -&gt; -1&#xA;97,13,75,29,47  -&gt;  2&#xA;&#xA;75[0,-1,0,0,-1,2]&#xA;&#xA;# map[int][]int&#xA;# 75 -&gt; int&#xA;# [0,-1,0,0,-1,2] -&gt; []int&#xA;```&#xA;&#xA;So, in the above example, we have taken 75 for reference, we will get the index for each list of page numbers, and we get the list of indexes where 75 appears.&#xA;&#xA;Now, this can be done with the following function:&#xA;&#xA;```go&#xA;&#xA;func GetPageIndices(rules map[int][]int, pages [][]int) map[int][]int {&#xA;&#x9;nums := make(map[int]bool)&#xA;&#x9;for num, list := range rules {&#xA;&#x9;&#x9;nums[num] = true&#xA;&#x9;&#x9;for _, elem := range list {&#xA;&#x9;&#x9;&#x9;if !nums[elem] {&#xA;&#x9;&#x9;&#x9;&#x9;nums[elem] = true&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;numIndices := make(map[int][]int)&#xA;&#x9;for num, _ := range nums {&#xA;&#x9;&#x9;for _, numLine := range pages {&#xA;&#x9;&#x9;&#x9;index := -1&#xA;&#x9;&#x9;&#x9;for i, n := range numLine {&#xA;&#x9;&#x9;&#x9;&#x9;if n == num {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;index = i&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;numIndices[num] = append(numIndices[num], index)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return numIndices&#xA;}&#xA;```&#xA;&#xA;So, we now have the index mapped at each page numbers list from the rules.&#xA;&#xA;## Part 1&#xA;&#xA;Now, for part one we need to iterate over each page update (line), then we need to check if the page numbers are following the rules, each number should follow the rules. This means that if a number is after a certain number but the rule says it should be before, then it has violated the page numbering rule in that update, so we cannot consider it as the correct ordered page, we need to add the middle page number of each update which is correctly ordered as the answer for the part one.&#xA;&#xA;To do that, we iterate over each page update, then we need to iterate over each of the numbers in that page update, we obtain all the rules associated with that number (let’s call it the current number) since we have a map of integers with a list of integers. Now, we have to check if the number that we currently are in is before the numbers in its rules. So, we check with the index of the current number using the number indices that we created which is a map of the number with a list of integers as indices. So, we obtain the list of indices of the map with the current number as the key for the map and the index in the list as the number of line/page updates we are currently in.&#xA;&#xA;Then once we have got the index for the current number, we obtain the same for the second number which is all the numbers in its rule, and if that number in its rule is present in that page line/update i.e. it is not -1 and if that is the case, we get the index of it similarly and check if it appears after the current number following the rule, And so if any number violates the rule, we need to mark the page update as not in correct order.&#xA;&#xA;As we see that the index rule for that page update is violated, we mark the order as false. If we see the ordered flag is still true, we update the score with the middle element of that page update.&#xA;&#xA;```go&#xA;&#xA;func GetOrderedPages(rules, numIndices map[int][]int, pages [][]int) int {&#xA;&#x9;score := 0&#xA;&#xA;&#x9;for index, pageLine := range pages {&#xA;&#x9;&#x9;ordered := true&#xA;&#x9;&#x9;for _, num1 := range pageLine {&#xA;&#x9;&#x9;&#x9;rule := rules[num1]&#xA;&#x9;&#x9;&#x9;index1 := numIndices[num1][index]&#xA;&#x9;&#x9;&#x9;for _, num2 := range rule {&#xA;&#x9;&#x9;&#x9;&#x9;index2 := numIndices[num2][index]&#xA;&#x9;&#x9;&#x9;&#x9;if index1 == -1 || index2 == -1 {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if index1 &gt; index2 {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ordered = false&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if ordered {&#xA;&#x9;&#x9;&#x9;score += pageLine[int(len(pageLine)/2)]&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return score&#xA;}&#xA;```&#xA;&#xA;So, to reiterate, we create a function called `GetOrderedPage` with rule and number indices as a map of integers with a list of integers and the pages which is a list of integers as the page update. We return the score as the output of this function.&#xA;&#xA;We iterate through each of the page updates, then through each page number in the update, we check for the rule of that number and if the index of that is lower than the current number we mark it as not ordered, and hence at the end of each page update we update the score with the middle element of the page update, if the order is correct.&#xA;&#xA;So, that will be part one summed up, we just have to get the score of the correct ordered page updates.&#xA;&#xA;## Part 2&#xA;&#xA;In part 2 however, we need to check if the page update is in order, if it is not then we need to make it in order.&#xA;&#xA;We do a similar thing for part 2, we need to iterate over each of the page updates, and for each number in that page update, we need to check if the rule is violated or not, if we encounter any case where the rule is violated for any number, we mark the flag ordered as false, this we will use to correct the order of the page updates. After updating the pages in that page line/update, we need to add the score with middle element of the corrected order of page update.&#xA;&#xA;```go&#xA;&#xA;&#xA;func GetCorrectOrderedPages(rules, numIndices map[int][]int, pages [][]int) int {&#xA;&#xA;&#x9;score := 0&#xA;&#x9;for index, pageLine := range pages {&#xA;&#x9;&#x9;ordered := true&#xA;&#x9;&#x9;for _, num1 := range pageLine {&#xA;&#x9;&#x9;&#x9;rule := rules[num1]&#xA;&#x9;&#x9;&#x9;index1 := numIndices[num1][index]&#xA;&#x9;&#x9;&#x9;for _, num2 := range rule {&#xA;&#x9;&#x9;&#x9;&#x9;index2 := numIndices[num2][index]&#xA;&#x9;&#x9;&#x9;&#x9;if index1 == -1 || index2 == -1 {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if index1 &gt; index2 {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ordered = false&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if !ordered {&#xA;&#x9;&#x9;&#x9;newLine := CorrectPageOrder(pageLine, rules)&#xA;&#x9;&#x9;&#x9;score += newLine[len(newLine)/2]&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return score&#xA;}&#xA;```&#xA;&#xA;We need to implement the CorrectPageOrder function that takes in the page line or page update and the rules, we need to create a new page update, that will populate the page that follows all the rules.&#xA;&#xA;So, we first keep track of the initialized elements index and update the index if we need to move the element before it.&#xA;&#xA;So, we iterate over all the numbers in the page update and set the index before any number in the rule, if we encounter any such number in the rule map, we need to update the index with the index of that number.&#xA;&#xA;And once we have got the index where we want to swap the element to, we create a slice before that index and append that number into it, and append everything after that index.&#xA;&#xA;```go&#xA;func CorrectPageOrder(line []int, rules map[int][]int) []int {&#xA;&#x9;newLine := []int{}&#xA;&#x9;for _, num := range line {&#xA;&#x9;&#x9;index := make(map[int]int)&#xA;&#x9;&#x9;for i, n := range newLine {&#xA;&#x9;&#x9;&#x9;index[n] = i&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;newInsertIndex := len(newLine)&#xA;&#x9;&#x9;for _, rule := range rules[num] {&#xA;&#x9;&#x9;&#x9;if idx, ok := index[rule]; ok {&#xA;&#x9;&#x9;&#x9;&#x9;if newInsertIndex &gt; idx {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;newInsertIndex = idx&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;afterNum := slices.Clone(newLine[newInsertIndex:])&#xA;&#x9;&#x9;newLine = append(newLine[:newInsertIndex], num)&#xA;&#x9;&#x9;newLine = append(newLine, afterNum...)&#xA;&#x9;}&#xA;&#x9;return newLine&#xA;}&#xA;```&#xA;&#xA;So, this function will find the index of a number to place it at the most extreme left (beginning of the list) so that we are not violating any rules for that number, then we create a slice to append that number before that index and append everything after that index.&#xA;&#xA;That’s it from part two, we have updated the page order if there were any discrepancies in the page order.&#xA;&#xA;## Conclusion&#xA;&#xA;So, that is it from day 5 of Advent of Code in Golang, let me know if you have any suggestions, and how you approached it. any better solutions?&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Advent of Code Day 4 in Golang: Finding XMAS and X-MAS</title>
      <link>meetgor.com/aoc-2024-day-4</link>
      <description>Solving day 4 of Advent of Code 2024 in Golang. Diving into one of the possible approaches to the puzzle.</description>
      <pubDate>Mon, 09 Dec 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Moving on to day 4, we have a grid problem in front of us, we are given some numbers in the form of a grid, i.e. some rows and columns with some upper case letters. What we need to do is to find is the word `XMAS` in any direction (up, left, down, right, diagonals), and in the second part we need to find the word `MAS` forming an X.&#xA;&#xA;So, let’s see how we can approach this and solve it in golang.&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day04/main.go)[.](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day04/main.go)&#xA;&#xA;### [Constructin](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day02/main.go)g the grid&#xA;&#xA;The most fundamental part of the problem lies in actually converting the text into a grid or a matrix form. We can split the lines, into individual lines and append each character as an element in a list, and that way we can have a list of list of strings which is a matrix or grid-like (2-dimensional) structure.&#xA;&#xA;So, below is the input for the puzzle.&#xA;&#xA;```plaintext&#xA;MMMSXXMASM&#xA;MSAMXMSMSA&#xA;AMXSXMAAMM&#xA;MSAMASMSMX&#xA;XMASAMXAMM&#xA;XXAMMXXAMA&#xA;SMSMSASXSS&#xA;SAXAMASAAA&#xA;MAMMMXMMMM&#xA;MXMXAXMASX&#xA;```&#xA;&#xA;We need to convert it into something like this&#xA;&#xA;```plaintext&#xA;[&#xA;    [M M M S X X M A S M]&#xA;    [M S A M X M S M S A]&#xA;    [A M X S X M A A M M]&#xA;    [M S A M A S M S M X]&#xA;    [X M A S A M X A M M]&#xA;    [X X A M M X X A M A]&#xA;    [S M S M S A S X S S]&#xA;    [S A X A M A S A A A]&#xA;    [M A M M M X M M M M]&#xA;    [M X M X A X M A S X]&#xA;]&#xA;```&#xA;&#xA;So, this is a list of strings, we can say in golang it is a `[][]string` . We can do that by creating a function like this:&#xA;&#xA;```go&#xA;func ConstructGrid(lines []string) [][]string {&#xA;&#x9;grid := [][]string{}&#xA;&#x9;for _, line := range lines {&#xA;&#x9;&#x9;row := []string{}&#xA;&#x9;&#x9;for _, char := range strings.Split(line, &#34;&#34;) {&#xA;&#x9;&#x9;&#x9;row = append(row, char)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;grid = append(grid, row)&#xA;&#x9;}&#xA;&#x9;return grid&#xA;}&#xA;```&#xA;&#xA;The above function takes in a list of strings and returns a list of list of strings that are individual letters in the grid.  &#xA;We can read the file bytes and split the bytes on newline characters and then this will be used as the input for this function.&#xA;&#xA;So, once the input is parsed into a grid, we can start thinking about the actual logic of finding the word `XMAS` in it.&#xA;&#xA;## Part 1&#xA;&#xA;So, in the first part, we need to find the word `XMAS` in the matrix which could be appearing:&#xA;&#xA;* forwards (as `XMAS`)&#xA;    &#xA;* backward (as `SAMX`)&#xA;    &#xA;* upwards&#xA;    &#xA;     ```plaintext&#xA;            S&#xA;            A&#xA;            M&#xA;            X&#xA;        ```&#xA;        &#xA;* downwards&#xA;    &#xA;     ```plaintext&#xA;            X&#xA;            M&#xA;            A&#xA;            S&#xA;        ```&#xA;        &#xA;* Diagonal upwards (right or up left)&#xA;    &#xA;     ```plaintext&#xA;            S&#xA;              A&#xA;                M&#xA;                  X&#xA;            &#xA;            OR&#xA;                  S&#xA;                A&#xA;              M &#xA;            X&#xA;        ```&#xA;        &#xA;* Diagonals downwards (right or left)&#xA;    &#xA;     ```plaintext&#xA;                     X&#xA;                   M&#xA;                 A&#xA;               S&#xA;            &#xA;            OR&#xA;            X&#xA;              M&#xA;                A&#xA;                  S&#xA;        ```&#xA;        &#xA;&#xA;So, there are 8 directions where `XMAS` could appear in the grid, there could n number of these `XMAS` . We need to find the count of these in the grid.&#xA;&#xA;![](https://cdn.hashnode.com/res/hashnode/image/upload/v1733761379973/8a0a0263-b286-47f1-a338-410dec2c6b7b.png)&#xA;&#xA;To approach this, we can either find the first character in the word `XMAS` and then search in all directions one by one and check if we find `M` and if we have found `M` in any of the direction, we keep moving ahead in that direction and check if there is `A` and `S` in that direction.&#xA;&#xA;The approach looks like this:&#xA;&#xA;* Initialize the counter to 0&#xA;    &#xA;* Iterate over each line&#xA;    &#xA;    * Iterate over each character in the line&#xA;        &#xA;        * Check if the character is equal to `X`&#xA;            &#xA;        * If the character is `X`→&#xA;            &#xA;            * Iterate over all the directions (up, down, right, left, up-left, up-right, down-left, down-right)&#xA;                &#xA;                * For that direction if we find the character to be `M`&#xA;                    &#xA;                * Keep moving ahead in the same direction to find `A` and `S` similarly, if we found all the characters `XMAS` then, increment the counter&#xA;                    &#xA;                * Else choose another direction in the loop&#xA;                    &#xA;&#xA;This looks complex and large but is simple, focus one thing at a time and you can solve this easily.&#xA;&#xA;So, for the implementation of this, we need to define a few things first:&#xA;&#xA;```go&#xA; var directions [][]int = [][]int{&#xA;&#x9;[]int{0, -1},   // up&#xA;&#x9;[]int{0, 1},  // down&#xA;&#x9;[]int{1, 0},   // right&#xA;&#x9;[]int{-1, 0},  // left&#xA;&#x9;[]int{1, -1},   // up right&#xA;&#x9;[]int{-1, -1},  // up left&#xA;&#x9;[]int{1, 1},  // down right&#xA;&#x9;[]int{-1, 1}, // down left&#xA;}&#xA;&#xA;var wordList []string = []string{&#34;X&#34;, &#34;M&#34;, &#34;A&#34;, &#34;S&#34;}&#xA;```&#xA;&#xA;So, we have defined the list of integers in the directions which are the x and y coordinates that we need to add or subtract to get to the desired location. It is basically like a unit vector, it has a distance of 1 and a direction indicated by `+` or `-` indicating to move the left or right for x coordinates and up and down for y c-ordinates.&#xA;&#xA;So, let me explain that more clearly, let’s say I am at `(1,2)` in the grid which is of 4x4 dimension.&#xA;&#xA;```plaintext&#xA;A B C D&#xA;E F G H&#xA;I J K L&#xA;M N O P&#xA;```&#xA;&#xA;So, at 2,1 we have `G` , so we check some directions for this&#xA;&#xA;up → `0,-1` → 2+0, 1-1 → 2,0, we have moved to `C`&#xA;&#xA;right → `1,0` → 2+1, 1+0 → 3,1 , we have moved to `H`&#xA;&#xA;down, left → `-1,1` → 2-1, 1+1 → 1, 2, we have moved to `J`&#xA;&#xA;So, you get the idea, that we are moving in some directions using these coordinates.&#xA;&#xA;We can use these to get the next direction jump we want to make to find if that element has the next character in the word that we are searching.&#xA;&#xA;We will write a function that does this first and abstract the function that checks if we have found the word in the grid.&#xA;&#xA;```go&#xA;func TraverseGrid(grid [][]string) int {&#xA;&#x9;score := 0&#xA;&#x9;for x, row := range grid {&#xA;&#x9;&#x9;for y, char := range row {&#xA;&#x9;&#x9;&#x9;if char == wordList[0] {&#xA;&#x9;&#x9;&#x9;&#x9;for _, direction := range directions {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if FindXMAS(x, y, 1, direction, grid) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;score += 1&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return score&#xA;}&#xA;```&#xA;&#xA;The above function takes in a grid and returns an integer which will be the score i.e. the count of words `XMAS` found in the grid/matrix.&#xA;&#xA;First, we need to iterate through each of the rows in the grid, for each row, we iterate over the character, so we will have x and y coordinates as the index of the grid. We need to then check if the current character is `X` or `wordList[0]` , if that is the case, we iterate over all the directions and check if we can find `XMAS` i.e. `MAS` in that direction, if so we increment the counter. What is the `FindXMAS` function, let’s abstract that away, and pass in the `x`, `y`, which are the coordinates of the current word, `1` which will be the word position of the `XMAS` and in this case, we already have found `X` we need to find `MAS` in that direction. We pass the grid and the direction, so this function will return true or false if that direction has `MAS` in it.&#xA;&#xA;So to iterate:&#xA;&#xA;* We iterate over the grid and get `row` and `x` as the list of strings and index of the current row.&#xA;    &#xA;* For each row i.e. list of strings, we iterate over the list of strings to get `char` and `y` as the character (string) and the index of that character in the list of the string.&#xA;    &#xA;* If we find the current character to be equal to `X` which is the 0th index of the `wordList` then&#xA;    &#xA;    * We iterate over all the directions and call the function `FindXMAS` to check if the remaining word `MAS` in that direction&#xA;        &#xA;    * If we find all the words, we increment the counter.&#xA;        &#xA;* So, we return the counter as we count the number of words `XMAS` in the grid/matrix.&#xA;    &#xA;&#xA;Now, we can implement the `FindXMAS` function, that takes in a `x`, `y` coordinates, the `wordPosition`, the direction and the grid, and return if the word is found.&#xA;&#xA;* First, we take the current x coordinates and add the direction’s x component (0th index or first element)&#xA;    &#xA;* add current y coordinates to the direction’s y component (1st index or second element)&#xA;    &#xA;* if the word position i.e.. the word index or the word itself in the current function is equal to the wordList, it means that it has found the required word completely&#xA;    &#xA;* We need to check by adding the direction to the x and y coordinates, we are not overshooting the width and height of the grid, so if we do, we return a false&#xA;    &#xA;* The final if is for checking if the current character is equal to the word that we are looking for, it could be `M`, `A` , or `S` . If so, we return the recursively call the `FindXMAS` function by passing the updated x and y coordinates and the next word in the wordList, we keep the direction the same and pass the entire grid.&#xA;    &#xA;&#xA;```go&#xA;func FindXMAS(x, y, wordPosition int, direction []int, grid [][]string) bool {&#xA;&#x9;xNext := x + direction[0]&#xA;&#x9;yNext := y + direction[1]&#xA;&#x9;if wordPosition &gt; len(wordList)-1 {&#xA;&#x9;&#x9;return true&#xA;&#x9;}&#xA;&#xA;&#x9;if xNext &lt; 0 || xNext &gt;= len(grid) || yNext &lt; 0 || yNext &gt;= len(grid[x]) {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;if grid[xNext][yNext] == wordList[wordPosition] {&#xA;&#x9;&#x9;return FindXMAS(xNext, yNext, wordPosition+1, direction, grid)&#xA;&#x9;}&#xA;&#x9;return false&#xA;&#xA;}&#xA;```&#xA;&#xA;So, we have implemented the `FindXMAS` function, this will just return if we have found the `MAS` word by going in a particular direction by updating the coordinates and checking if the word at that position in the gird is the next word in `MAS` list.&#xA;&#xA;So, this is what the entire first part looks like:&#xA;&#xA;```go&#xA;func main() {&#xA;&#x9;lines := ReadFileLines(&#34;sample.txt&#34;)&#xA;&#x9;grid := ConstructGrid(lines)&#xA;&#x9;score := TraverseGrid(grid)&#xA;&#x9;fmt.Println(score)&#xA;}&#xA;```&#xA;&#xA;We take in the lines as a list of strings and pass that to `ConstructGrid` and get the grid, finally, we call `TraverseGrid` , by passing the grid and getting the score as the count of the words `XMAS` in the grid.&#xA;&#xA;That’s it from the part 1.&#xA;&#xA;## Part 2&#xA;&#xA;For part two, we need to find `MAS` in the cross shape, like below:&#xA;&#xA;```plaintext&#xA;M.S&#xA;.A.&#xA;M.S&#xA;```&#xA;&#xA;So, to solve this, we can do a similar approach but much simpler, we just need to find `A` as there will always be the word `MAS` in the center, so we just check if we have `A` and the top-left, top-right, or bottom-right, bottom-left has `M` or `S` .&#xA;&#xA;We get the coordinates of the top-right, top-left positions, down-right, and down-left positions by adding and subtracting 1 from it. We make a basic check if we are not overshooting the boundary of the grid. If we overshoot the boundaries, we won’t find the `MAS`&#xA;&#xA;But if we are within the grid, we now get the character at those 4 positions, we check if the top-left and bottom-right have `M` and `S` or `S` or `M`, similarly for top-right and bottom-left has `M` and `S` or `S` or `M` respectively. This is the diagonal search for `M` and `S` above and below the character `A`.&#xA;&#xA;So, if we have both the diagonal matched we return true.&#xA;&#xA;```go&#xA;&#xA;&#xA;func FindMAS(x, y int, grid [][]string, wordList []string) bool {&#xA;&#x9;xL, yT := x-1, y+1 // Top-left neighbor&#xA;&#x9;xR, yD := x+1, y-1 // Bottom-right neighbor&#xA;&#xA;&#x9;// Check if the indices are within bounds&#xA;&#x9;if xL &lt; 0 || xR &gt;= len(grid) || yT &lt; 0 || yD &lt; 0 ||&#xA;&#x9;&#x9;yT &gt;= len(grid[xL]) || yD &gt;= len(grid[xR]) {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;topLeft := grid[xL][yT]&#xA;&#x9;bottomRight := grid[xR][yD]&#xA;&#x9;topRight := grid[xR][yT]&#xA;&#x9;bottomLeft := grid[xL][yD]&#xA;&#xA;&#x9;word1, word3 := wordList[1], wordList[3]&#xA;&#xA;&#x9;isDiagonalMatch := (topLeft == word1 &amp;&amp; bottomRight == word3) || (topLeft == word3 &amp;&amp; bottomRight == word1)&#xA;&#x9;isAntiDiagonalMatch := (topRight == word1 &amp;&amp; bottomLeft == word3) || (topRight == word3 &amp;&amp; bottomLeft == word1)&#xA;&#xA;&#x9;return isDiagonalMatch &amp;&amp; isAntiDiagonalMatch&#xA;}&#xA;```&#xA;&#xA;So, that is the simple implementation for finding the `MAS` the diagonal.&#xA;&#xA;Now, we need to change the `TraverseGrid` a bit, as we just iterate over the grid, and check if we have `A` in the character in the row, i.e. `wordList[2]`. Now, if we have `A`, we need to call the `FindMAS` function with the current coordinates and the grid, if that function returns true, we increment the counter,.&#xA;&#xA;```go&#xA;&#xA;func TraverseGrid2(grid [][]string) int {&#xA;&#x9;score := 0&#xA;&#x9;for x, row := range grid {&#xA;&#x9;&#x9;for y, char := range row {&#xA;&#x9;&#x9;&#x9;if char == wordList[2] {&#xA;&#x9;&#x9;&#x9;&#x9;if FindMAS(x, y, grid) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;score += 1&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return score&#xA;}&#xA;```&#xA;&#xA;So, that is the final implementation of part 2, we get the count of `MAS` in the cross direction.&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day04/main.go)[.](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day04/main.go)&#xA;&#xA;## Conclusion&#xA;&#xA;So, that is it from day 4 of Advent of Code in Golang, let me know if you have any suggestions, and how you approached it. any better solutions?&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Advent of Code Day 3 in Golang: Do Or Don’t Regex</title>
      <link>meetgor.com/aoc-2024-day-3</link>
      <description>Solving day 3 of Advent of Code 2024 in Golang. Diving into one of the possible approaches to the puzzle.</description>
      <pubDate>Sat, 07 Dec 2024 00:00:00 UTC</pubDate>
      <content>&#xA;&#xA;## Introduction&#xA;&#xA;Well, it is day 3 of the advent of code 2024, and I have been doing it on live streams. I am behind two days but working through them one by one. So far, I have learned a lot of things in Go. Let’s dive in for the day 3.&#xA;&#xA;## Part 1&#xA;&#xA;Part one to any AOC problem seems straightforward, but as soon as part two is revealed, the real implementation starts to break the sweat (if you weren’t optimistic or thoughtful)&#xA;&#xA;For part 1 for this day, was to parse a string that contained `mul(X,Y`) an expression, where X could be any 3-digit number. So, there could be multiple such expressions within the string and the purpose was to multiply the X and Y in the individual expression and add them up.&#xA;&#xA;![AOC Day 3 Part 1](https://meetgor-cdn.pages.dev/aoc-2024-d3-solution-part1.jpg)&#xA;&#xA;```plaintext&#xA;&#xA;xmul(2,4)&amp;mul[3,7]!^don&#39;t()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))&#xA;```&#xA;&#xA;In this example above there are 4 such expressions, and if we add the multiplications of those, we get the answer as 161.&#xA;&#xA;### Approach&#xA;&#xA;It looks like a Regex pattern, finding an expression-like pattern in a string. So, the approach would be to find such expressions with a regex pattern and parse the numbers to integers, and multiply them, simply.&#xA;&#xA;You could go ahead and write the parser for iterating over each character in the string and parsing the tokens, then evaluating the expression. That is a valid approach, but I choose to do this because I don’t know how to write a parser honestly, I want to try that solution at the end as well.&#xA;&#xA;But for the first part, a quick regular expression seems a good idea.&#xA;&#xA;### Constructing the Regular Expression&#xA;&#xA;The first thing is to write the regular expression for the `mul(X,Y)` part which is the only challenging section in part one. The rest is just simple math.&#xA;&#xA;So, we need to find `mul`, then a `(` then any number which is 1 to 3 digits long, then `,` and again a number that is 1 to 3 digits long, and finally ends with a `)`&#xA;&#xA;That translates to:&#xA;&#xA;```plaintext&#xA;mul\((\d{1,3}),(\d{1,3})\) &#xA;```&#xA;&#xA;Let’s breakdown:&#xA;&#xA;* `mul` for capturing the literal word `mul`&#xA;    &#xA;* `\(` this is for the first parenthesis in the expression `mul()` , we need to escape the bracket in a regular expression if we want to match it, so we use `\` before it.&#xA;    &#xA;* Then we have a match group `(\d{1,3})` , this will be the `X` in `mul(X,Y)`:&#xA;    &#xA;    * A match group is like a group of a match in a regex, basically, if you want to capture specific parts in the entire match, then we use `()` to group them individually, this is not necessary but helps in getting the right things without overhead&#xA;        &#xA;    * In this case, we are using a match group for capturing a number which can have 1 to 3 digits.&#xA;        &#xA;    * The other way to write this is `([0-9]{1,3})` , which also would do the same thing, (NOTE: there are some differences in `[0-9]` and `\d`, but that is very subtle and won’t affect this puzzle, if you are still curious, I prefer reading this [StackOverflow question](https://unix.stackexchange.com/questions/414226/difference-between-0-9-digit-and-d))&#xA;        &#xA;* We then use `,` for the separator of `X` and `Y` operands in the `mul(X,Y)` expression&#xA;    &#xA;* We then similarly do the match for `Y` in `mul(X,Y)` with the `(\d{1,3})` match group&#xA;    &#xA;* Finally, we end the regular expression with the `)` to end the expression&#xA;    &#xA;&#xA;### Code it&#xA;&#xA;This is quite straightforward, we grab the line as a string and use [regexp.MustCompile](https://pkg.go.dev/regexp#MustCompile) function which gives us a [Regexp](https://pkg.go.dev/regexp#Regexp) object, that in turn has a few methods associated with it to find, match, replace, and other things that can be done with a regular expression on a string.&#xA;&#xA;Once we have the `mulRegex` , we can use the [FindAllStringSubmatch](https://pkg.go.dev/regexp#Regexp.FindAllStringSubmatch) method associated with the `Regexp` struct in the `regexp` package. The function takes in a string to perform the regex on, and the maximum number of matches to return. We want all the results, so we pass them in `-1` to get all the matches.&#xA;&#xA;Now, this method returns a slice of a slice of strings, each slice is a match, and within each slice, there is a slice of string, with the matched string and the subsequent match groups in the string if any.&#xA;&#xA;```go&#xA;func FindMulExpression(line string) [][]string {&#xA;  mulRegex := regexp.MustCompile(`mul\((\d{1,3}),(\d{1,3})\)`)&#xA;  return mulRegex.FindAllStringSubmatch(line, len(line))&#xA;}&#xA;```&#xA;&#xA;So, the above function will return something like this&#xA;&#xA;```go&#xA;[&#xA;    [mul(2,4) 2 4]&#xA;    [mul(5,5) 5 5]&#xA;    [mul(11,8) 11 8]&#xA;    [mul(8,5) 8 5]&#xA;]&#xA;```&#xA;&#xA;This is a list of list of strings, these look like numbers but those are string types in Golang.&#xA;&#xA;Now we have this, we can create the actual logic part of obtaining the result, which is to parse these expressions, multiply `X` and `Y` and add the results for each of the expressions.&#xA;&#xA;```go&#xA;func Multiply(matches [][]string) int {&#xA;&#x9;score := 0&#xA;&#x9;for _, match := range matches {&#xA;&#x9;&#x9;x, err := strconv.Atoi(string(match[1]))&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;panic(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;y, err := strconv.Atoi(string(match[2]))&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;panic(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;score += x * y&#xA;&#x9;}&#xA;&#x9;return score&#xA;}&#xA;```&#xA;&#xA;This is pretty straightforward, we iterate over each of the matches, that is one `mul(X,Y)` expression and parse the `X` and `Y` each into integers and multiply them, the result obtained is then added to the score. We do this for each `mul(X,Y)` expression that is found in the string(line) and return the final score.&#xA;&#xA;### Input&#xA;&#xA;Now, the example gave us a single string, but I realized there were six lines in the input (individual input), so we needed to parse each line and add up the score.&#xA;&#xA;Remember this as it will be critical in part 2, it took me some time and questioning my existence to realize we need to combine all the lines to get the result (not necessary in part 1 but for sure in part 2).&#xA;&#xA;## Part 2&#xA;&#xA;This is where things go wrong usually. At least for me, it did.&#xA;&#xA;I started with a very naive approach, with a forever loop and finding the index of do or don’t and stripping off those sections, and then looping until we have no do and don’ts left. That was working for the test case but failed on the actual input.&#xA;&#xA;The approach I finally came up and was working by tweaking the same approach slightly.&#xA;&#xA;### Approach&#xA;&#xA;What I came up with is to find the first match location of `don’()` and `do()` strings in the entire string, we take that and remove the parts after `don’t()` or before `do()` . That way we can trim down the string to only valid/enabled `mul()`expressions.&#xA;&#xA;![AOC Day 3 Part 2](https://meetgor-cdn.pages.dev/aoc-2024-d3-solution-part2.jpg)&#xA;&#xA;So, the approach more clearly defined will be:&#xA;&#xA;* Find the location (index) of the `don’t()` and `do()` expressions&#xA;    &#xA;* We need to keep track of whether the previous string was enabled or disabled so will keep a flag to append the enabled expressions (part of the string) to the final result&#xA;    &#xA;* If none of them are found, return the string(line) as it is&#xA;    &#xA;* If we found either of them then:&#xA;    &#xA;    * If we find don’t first (`don’t()` appears before `do()`)&#xA;        &#xA;        * If the enabled flag is true → append the string before the `don’t()` expression&#xA;            &#xA;        * Then toggle the enabled as false and trim off the `don’t()` part  &#xA;            (This way we have completed checking everything before the don’t expression, so we remove that part from the line string)&#xA;            &#xA;    * If we find do first (`do()` appears before `don’t()`)&#xA;        &#xA;        * If the enabled flag is true → append the string before the `do()` expression&#xA;            &#xA;        * Then toggle the enabled as true and trim off the `do()` part  &#xA;            (This way we have completed checking everything before the do expression, so we remove the part from the line string)&#xA;            &#xA;* We do this until there is no line string left to be checked&#xA;    &#xA;&#xA;### Code&#xA;&#xA;I used simple Strings.Index to get the first match index for the substring, In this case, I want the first matching index for `don’t()` and `do()` . Once we have the indices of both the matches, we can iterate over till we are not left with any do or don’ts in the string.&#xA;&#xA;If we have either do or don’t we append to the string the part before don’t if enabled or part before do if enabled and toggle on and off the enabled flag accordingly. By the end of the loop, the result string will have only the enabled parts of the line/string.&#xA;&#xA;```go&#xA;func StripDoDont(line string) string {&#xA;    result := &#34;&#34;&#xA;    enabled := true&#xA;    dontOffset := len(&#34;don&#39;t()&#34;)&#xA;    doOffset := len(&#34;do()&#34;)&#xA;&#xA;    for len(line) &gt; 0 {&#xA;        dontIndex := strings.Index(line, &#34;don&#39;t()&#34;)&#xA;        doIndex := strings.Index(line, &#34;do()&#34;)&#xA;&#xA;        if dontIndex == -1 &amp;&amp; doIndex == -1 {&#xA;            if enabled {&#xA;                result += line&#xA;            }&#xA;            break&#xA;        }&#xA;        &#xA;        if dontIndex != -1 &amp;&amp; (doIndex == -1 || dontIndex &lt; doIndex) {&#xA;            if enabled {&#xA;                result += line[:dontIndex]&#xA;            }&#xA;            enabled = false&#xA;            line = line[dontIndex+dontOffset:]&#xA;        } else {&#xA;            if enabled {&#xA;                result += line[:doIndex]&#xA;            }&#xA;            enabled = true&#xA;            line = line[doIndex+doOffset:]&#xA;        }&#xA;    }&#xA;&#xA;    return result&#xA;}&#xA;```&#xA;&#xA;I take this function and pass it to the multiply function where I get the matching patterns for the `mul` expression and do the math.&#xA;&#xA;The [strings.Index](https://pkg.go.dev/strings#Index) method takes in a string and a substring to find within that string and returns the index of the first occurring instance of that substring. With that we can identify if the line string contains the `do()` or `don’t()` expressions, if they don’t we simply return the line and if there are instances of them, we loop and trim the string before and after the expressions depending on whether the flag is enabled or disabled.&#xA;&#xA;Let’s take an example and walk through the logic:&#xA;&#xA;```plaintext&#xA;abcxmul(1,3)don&#39;t()mul(9, 7)do()mul(1,2)don&#39;t()mul(8,7)&#xA;&#xA;enabled = True&#xA;result = &#34;&#34;&#xA;line = &#34;abcxmul(1,3)don&#39;t()mul(9, 7)do()mul(1,2)don&#39;t()mul(8,7)&#34;&#xA;---&#xA;After Iteration 1:&#xA;    result -&gt; abcxmul(1,3)&#xA;    line -&gt; mul(9, 7)do()mul(1,2)don&#39;t()mul(8,7)&#xA;    enabled = False&#xA;---&#xA;After Iteration 2:&#xA;    result -&gt; abcxmul(1,3)&#xA;    line -&gt; mul(1,2)don&#39;t()mul(8,7)&#xA;    enabled = True&#xA;---&#xA;After Iteration 3:&#xA;    result -&gt; abcxmul(1,3)mul(1,2)&#xA;    line -&gt; mul(8,7)&#xA;    enabled -&gt; False&#xA;---&#xA;After Iteration 4:&#xA;    No do and don&#39;t found&#xA;    result -&gt; abcxmul(1,3)mul(1,2)&#xA;    break out of loop&#xA;---&#xA;&#xA;Result -&gt; abcxmul(1,3)mul(1,2)&#xA;```&#xA;&#xA;We process the result with the same `Multiply` function that we used in the first part after passing it through the `FindMulExpression` function that will return all the mul expressions in the result line string.&#xA;&#xA;### Heads up with the input&#xA;&#xA;The actual input of the puzzle is I think multiple lines, so we need to preserve this state of the line in all the remaining lines. OR, we could be smarter and create a single large string and process that. Both are valid and would give the same results. I just didn’t like to add an overhead of keeping track of all the states and line, so I just concatenated all the lines and processed that single string.&#xA;&#xA;## Conclusion&#xA;&#xA;This was a simple problem in essence but if you are not aware of regex you could go down a rabbit hole of writing your own parser or wired string manipulation (just like I did).&#xA;&#xA;That’s it form day 3, I will be doing more live stream solving over the weekend and may be the next week as well. Find the code for my AoC solutions here on GitHub.&#xA;&#xA;Till then,&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Advent of Code Day 2 in Golang: Slicing and Dicing Reports</title>
      <link>meetgor.com/aoc-2024-day-2</link>
      <description>Solving day 2 of Advent of Code 2024 in Golang. Diving into one of the possible approaches to the puzzle.</description>
      <pubDate>Mon, 02 Dec 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;So, this is day 2 of the Advent of Code 2024 in Golang, and we will be exploring my approach and solution for the same. The problem was not as easy but was pretty simple after implemented and found correct.&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day02/main.go).&#xA;&#xA;## Part 1&#xA;&#xA;We have been given some lines called reports, and each report has a bunch of levels. and the requirement of the report is that it needs to be either strictly increasing or decreasing by a factor of at least 1 or at most 3.&#xA;&#xA;This means if the first two elements are increasing even by one, the other subsequent elements in that report should be increasing (by 1, 2, or 3) levels, and there cannot be any change (i.e. 0 change in two adjacent numbers, or two adjacent numbers cannot be same)&#xA;&#xA;```plaintext&#xA;7 6 4 2 1&#xA;1 2 7 8 9&#xA;9 7 6 2 1&#xA;1 3 2 4 5&#xA;8 6 4 4 1&#xA;1 3 6 7 9&#xA;```&#xA;&#xA;* We first do the input parsing, it is pretty straightforward, we need to split it by `&#xA;` to get individual reports, this will be a string so `”7 6 4 2 1&#34;` , we want to get a slice of integers.&#xA;    &#xA;* So we go ahead and split by spaces/whitespace `” “` to get the individual levels (numbers) and we need to convert them into integers.&#xA;    &#xA;* Once we have individual strings of the report i.e. levels as `[“7”, “6”, “4”, “2”, “1”]` , we need to cast them to integers.&#xA;    &#xA;* We iterate over each of them and cast them to integers and append to the list.&#xA;    &#xA;* Once we have constructed the list, we append to the reports list which will be the array of arrays, i.e. each line is a report, and each report has many levels so slice of slice of integers.&#xA;    &#xA;&#xA;```go&#xA;func SplitLevels(lines []string) [][]int {&#xA;&#x9;reportLevels := [][]int{}&#xA;&#x9;for i, reportLine := range lines {&#xA;&#x9;&#x9;reportLevels = append(reportLevels, []int{})&#xA;&#x9;&#x9;for _, levelStr := range strings.Split(reportLine, &#34; &#34;) {&#xA;&#x9;&#x9;&#x9;level, err := strconv.Atoi(levelStr)&#xA;&#x9;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;reportLevels[i] = append(reportLevels[i], level)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return reportLevels&#xA;}&#xA;```&#xA;&#xA;Once we have constructed the reports and levels, we move ahead in actually analyzing the patterns within the levels in the individual reports.&#xA;&#xA;For that:&#xA;&#xA;* We first take individual reports, calculate the difference between the first two elements, and remember to use absolute difference carefully here.&#xA;    &#xA;* We need to maintain a flag which indicates whether the levels in the report are increasing or decreasing, which can be determined with the first two elements.&#xA;    &#xA;    That is if the first two elements are increasing, the subsequent levels should also be increasing and if they are decreasing then all the levels should be decreasing as well&#xA;    &#xA;* We first have a guard check, if the difference between them is 0 or greater than 3 or less than -3 which is the condition of the levels to be safe. If that is the case then we return false that is the report is not safe.&#xA;    &#xA;* We now iterate on the report after the first two elements, we then compute the difference between the next two levels, if the flag is increasing is true and the current difference is less than or equal to 0 or it exceeding 3 we also mark it as false&#xA;    &#xA;* The other condition is that if the flag is is decreasing, which means the first two elements were having a negative difference, so we check if the current difference is greater than or equal to 0 or it is less than -3, if that is the case we mark that as false&#xA;    &#xA;* After computing the difference for all the levels, if we come out of the loop, we return true as we didn’t see any discrepancy in the levels.&#xA;    &#xA;&#xA;```go&#xA;&#xA;&#xA;func IsSafe(report []int) (bool) {&#xA;&#x9;prevDiff := report[1] - report[0]&#xA;&#x9;isIcreasing := prevDiff &gt; 0&#xA;&#x9;if prevDiff == 0 || prevDiff &gt; 3 || prevDiff &lt; -3 {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#xA;&#x9;for i := 2; i &lt; len(report); i++ {&#xA;&#x9;&#x9;currDiff := report[i] - report[i-1]&#xA;&#x9;&#x9;if isIcreasing {&#xA;&#x9;&#x9;&#x9;if currDiff &lt;= 0 || currDiff &gt; 3 {&#xA;&#x9;&#x9;&#x9;&#x9;return false&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;if currDiff &gt;= 0 || currDiff &lt; -3 {&#xA;&#x9;&#x9;&#x9;&#x9;return false&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return true&#xA;}&#xA;```&#xA;&#xA;## Part 2&#xA;&#xA;For part two, we need to do a few things, we need to compute if the report is safe or not, and if that is unsafe, we can almost remove one element from the report to make it safe.&#xA;&#xA;For that the approach is:&#xA;&#xA;* Get the index where we first saw the discrepancy in the levels&#xA;    &#xA;* Check by removing that element from the report, if that makes the report safe, then return true i.e. we found the safe report&#xA;    &#xA;* If we still find the report unsafe, remove the element before the index where the discrepancy was found, if now we find it safe after removing that element, then mark it safe&#xA;    &#xA;* If still we find the report unsafe, then remove the element after the index where we originally found the discrepancy, if the report becomes safe, we mark that report safe&#xA;    &#xA;* Else we mark the report unsafe, as we cannot find only the element removable that makes the report safe.&#xA;    &#xA;&#xA;```go&#xA;func RemoveAndCheck(report []int, index int) bool {&#xA;&#x9;if index &gt; len(report)-1 || index &lt; 0 {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;&#x9;reportNew := append([]int{}, report[:index]...)&#xA;&#x9;reportNew = append(reportNew, report[index+1:]...)&#xA;&#x9;safe, _ := IsSafe(reportNew)&#xA;&#x9;fmt.Println(safe, report)&#xA;&#x9;return safe&#xA;}&#xA;&#xA;func RemoveLevels(report []int) bool {&#xA;&#x9;safe, unsafeIndex := IsSafe(report)&#xA;&#x9;if safe {&#xA;&#x9;&#x9;return true&#xA;&#x9;} else {&#xA;&#x9;&#x9;if RemoveAndCheck(report, unsafeIndex) {&#xA;&#x9;&#x9;&#x9;return true&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if RemoveAndCheck(report, unsafeIndex-1) {&#xA;&#x9;&#x9;&#x9;return true&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if RemoveAndCheck(report, unsafeIndex+1) {&#xA;&#x9;&#x9;&#x9;return true&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day02/main.go).&#xA;&#xA;## Conclusion&#xA;&#xA;So that was it, a pretty simple problem for day 2 of the advent of code 2024 in Golang. Hope you enjoyed this walkthrough of the day one puzzle in the Advent of Code 2024 in Golang.&#xA;&#xA;Let me know if you have any other interesting solutions, or if you have anything to share about this, any feedback, questions, or suggestions are welcome.&#xA;&#xA;Thank you for reading, and I will see you tomorrow for day 3&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Advent of Code, 2024, Day 1 in Golang: Historian Hysteria</title>
      <link>meetgor.com/aoc-2024-day-1</link>
      <description>Solving day 1 of Advent of Code 2024 in Golang. Diving into one of the possible approaches to the puzzle.</description>
      <pubDate>Sun, 01 Dec 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Hello everyone, it’s that time of the year, Advent of Code, I will be solving this year as well with Golang. In previous years I have been doing Advent of Code but was not able to keep up with the pace and left it midway (not even halfway). This year however I am determined and want to solve all the problems as much as I can.&#xA;&#xA;Let’s dive into the first day which should be and is pretty simple and straightforward. A simple list and map creation and traversal and basic math operations.&#xA;&#xA;I also live-streamed the solution, you can check it out the [stream on YouTube](https://www.youtube.com/live/3K02tEEBgto?si=ojS5rsh5nGpk3U-B)&#xA;&#xA;And also a [shorter video](https://youtu.be/4U97gLyz0Ss?si=SvINHaGz-mow_q3O) on the approach and solution in Golang.&#xA;&#xA;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/4U97gLyz0Ss&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&#xA;Or you stick here and continue reading. Thank you&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day01/main.go).&#xA;&#xA;## Part 1&#xA;&#xA;[Advent of code, 2024, day 1](https://adventofcode.com/2024/day/1)&#xA;&#xA;We are given two lists here, the first part aims to find the absolute difference (distance) between each element sorted from smallest to largest.&#xA;&#xA;So, in essence, we take the two lists, sort them and one by one, for each corresponding element paired up, we take the absolute difference and sum that difference up for all the numbers in the list.&#xA;&#xA;```plaintext&#xA;3   4&#xA;4   3&#xA;2   5&#xA;1   3&#xA;3   9&#xA;3   3&#xA;```&#xA;&#xA;So, first, we need to split the input into different lists:&#xA;&#xA;1. We first range over all the lines, initialize two empty lists of integers&#xA;    &#xA;2. Then we split the line with the space as the separator, so this gives us the slice of strings as `[“3”, “4”]`&#xA;    &#xA;3. But we need to elements as integers, so take the first number and convert it to integer, similarly we do it for the second number.&#xA;    &#xA;4. Then once we have both numbers, we append them to the corresponding lists, the first number goes to the first list, and the second is appended to the second list.&#xA;    &#xA;5. Then we return the two lists&#xA;    &#xA;&#xA;NOTE: You cannot take the difference of those two numbers here itself, since we need to find the smallest number and sort the numbers in each list, so we need to get the lists populated first.&#xA;&#xA;```go&#xA;func SplitLists(lines []string) ([]int, []int) {&#xA;&#x9;listOne := []int{}&#xA;&#x9;listTwo := []int{}&#xA;&#xA;&#x9;for _, line := range lines {&#xA;&#x9;&#x9;// |3   4&#xA;&#x9;&#x9;// [&#34;3&#34;,&#34;4&#34;] slice of string ([]string)&#xA;&#x9;&#x9;// 3 &#xA;        // 4&#xA;        // [3,4] slice of int ([]int)&#xA;&#x9;&#x9;numbers := strings.Split(line, &#34;   &#34;)&#xA;&#x9;&#x9;numOne, err := strconv.Atoi(numbers[0])&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;numTwo, err := strconv.Atoi(numbers[1])&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;listOne = append(listOne, numOne)&#xA;&#x9;&#x9;listTwo = append(listTwo, numTwo)&#xA;&#x9;}&#xA;&#x9;return listOne, listTwo&#xA;}&#xA;```&#xA;&#xA;In the above code, we have initialized two empty slices of strings, we take the parameter lines which is a slice of string, indicating a line-by-line string representation of the input. I have parsed the input with these helper functions.&#xA;&#xA;The ReadFileBytes and ReadFileLines, one the bytes, the other gives the line-by-line string which gives a slice of strings.&#xA;&#xA;So once we have the lines, we iterate over each line and split the lines on space to get the two numbers. So, the line “`3 4`“ will be split into `[“3”, “4”]` . Now we get the first element and convert it into an integer as we need to sort and take the difference later.&#xA;&#xA;So, by accessing the first and second elements in the split line as `numbers[0]` and `numbers[1]` and converting the type to integer, [strconv.Atoi](https://pkg.go.dev/strconv#Atoi) function, which takes in a string and gives back an integer or an error.&#xA;&#xA;Now, we have two numbers as integers, we append the first element to the first element as `listOne = append(listOne, numOne)` and `listTwo = append(listTwo, numTwo)`&#xA;&#xA;So, we append one by one as we iterate over the input through all the lines, so at the end of this function, we will have two lists of integers.&#xA;&#xA;```&#xA;[3 4 2 1 3 3]&#xA;[4 3 5 3 9 3]&#xA;```&#xA;&#xA;Then, once we have the slices of integers, we sort those lists. Then we range over the lists one by one element, since both the lists are of the same size, we can reference one by the index of the other.&#xA;&#xA;Then for each difference of the two integers (one from the first list and the other from the second list), we cast it to a `float64` and pass it to the [math.Abs](https://pkg.go.dev/math#Abs) function, which is annoying as Golang doesn’t have an absolute function for intgers. We cast the integer to float for parsing it to the Abs method and cast the returned float64 value back to int. Kind of wired but fine.&#xA;&#xA;We keep adding the absolute differences for each paired difference of the elements in the two lists. At the end, we will have a final score which is the score for part one.&#xA;&#xA;```go&#xA;func PartOne(lines []string) int {&#xA;&#x9;listOne, listTwo := SplitLists(lines)&#xA;&#x9;sort.Ints(listOne)&#xA;&#x9;sort.Ints(listTwo)&#xA;&#x9;totalScore := 0&#xA;&#x9;for i := range listOne {&#xA;&#x9;&#x9;totalScore += int(math.Abs(float64(listOne[i] - listTwo[i]))&#xA;&#x9;}&#xA;&#x9;return totalScore&#xA;}&#xA;```&#xA;&#xA;## Part 2&#xA;&#xA;For part two, we need to take all the numbers in the first list count the number of times that number has occurred in the second list, and take a product of them and add it up for all the numbers.&#xA;&#xA;So in the example:&#xA;&#xA;```plaintext&#xA;3   4&#xA;4   3&#xA;2   5&#xA;1   3&#xA;3   9&#xA;3   3&#xA;```&#xA;&#xA;The numbers in the first list are \[3,4,2,1,3,3\]&#xA;&#xA;We have to count the occurrences of each of them in the second list&#xA;&#xA;So, in the second list \[4,3,5,3,9,3\], the number `3` occurs `3` times, so we do `3×3` which is `9` and then, do the same for `4` which occurs only once in the second list so, we get `4`, then `2` occurs `0` times, so we get `0`&#xA;&#xA;We get → `(3×3) + (4×1) + (2×0) + (1×0) + (3×3) + (3×3)`&#xA;&#xA;The first number is the element in the first list and the second number is the occurrence of that number in the second list.&#xA;&#xA;which comes out to be `9+4+0+0+9+9` , so the answer is `31` for the example.&#xA;&#xA;Once it is clear, what we have to do, we simply have to iterate over the second list and create a map of the frequency/occurances/number of times it appears in that list.&#xA;&#xA;### Solution&#xA;&#xA;So, we will have to modify the `SplitLists` functions a bit, we need to split and also map the second list with the key as the number itself and the value as its count in the second list.&#xA;&#xA;Just that change, we create an additional return value with an empty map of integers with integers. The mapTwo variable will be a map that will have a key as the number in the second list and its value as the number of times it is present in that list.&#xA;&#xA;```go&#xA;func SplitListsAndMap(lines []string) ([]int, map[int]int) {&#xA;&#x9;listOne := []int{}&#xA;&#x9;listTwoCounts := make(map[int]int)&#xA;&#xA;&#x9;for _, line := range lines {&#xA;&#x9;&#x9;numbers := strings.Split(line, &#34;   &#34;)&#xA;&#x9;&#x9;numOne, err := strconv.Atoi(numbers[0])&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;numTwo, err := strconv.Atoi(numbers[1])&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;listOne = append(listOne, numOne)&#xA;        listTwoCounts[numTwo] += 1&#xA;&#x9;}&#xA;&#x9;return listOne, listTwoCounts&#xA;}&#xA;```&#xA;&#xA;So, as we iterate over each line, we parse the string number into an integer and increment its count in the map.&#xA;&#xA;```&#xA;[3 4 2 1 3 3]&#xA;map[3:3 4:1 5:1 9:1]&#xA;```&#xA;&#xA;In the actual calculation of the score, we need to iterate over the elements of the first list and multiply the number with its count in the second list as we now have the map of it. We multiply those and add them up for each line, which becomes the final score.&#xA;&#xA;```go&#xA;func PartTwo(lines []string) int {&#xA;    similarityScore := 0&#xA;&#xA;&#x9;listOne, mapTwo := SplitListsAndMap(lines)&#xA;&#xA;&#x9;for _, numOne := range listOne {&#xA;&#x9;&#x9;score := numOne * mapTwo[numOne]&#xA;&#x9;&#x9;similarityScore += score&#xA;&#x9;}&#xA;&#xA;&#x9;return similarityScore&#xA;}&#xA;```&#xA;&#xA;So, that is how we got the final score for part two.&#xA;&#xA;You can check out my solutions [here on GitHub](https://github.com/Mr-Destructive/advent_of_code/blob/main/2024/src/day01/main.go).&#xA;&#xA;## Conclusion&#xA;&#xA;So that was it, a pretty simple problem for day 1 of the advent of code 2024 in Golang. Hope you enjoyed this walkthrough of the day one puzzle in the Advent of Code 2024 in Golang.&#xA;&#xA;Thank you for reading, and I will see you tomorrow for day 2&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Building Golang from Source v1.23 and Above</title>
      <link>meetgor.com/golang-build-from-source-1-24-above</link>
      <description>Exploring one of the way to install and build golang from source for version 1.23 and above.</description>
      <pubDate>Tue, 19 Nov 2024 00:00:00 UTC</pubDate>
      <content>## Introduction&#xA;&#xA;Are you excited to try out the latest golang version, or test out your changes (cooking some serious stuff?), or install some random golang version? Then let’s explore one of the easiest ways to install golang on your system (Linux).&#xA;&#xA;## Building Go from source 1.23+&#xA;&#xA;The process for installing and building golang from source is quite simple.&#xA;&#xA;* Clone the repo&#xA;    &#xA;* Build the binary&#xA;    &#xA;* Set Environment Variables&#xA;    &#xA;* Export the binary to the system path&#xA;    &#xA;&#xA;For detailed other steps, you can follow [this guide](https://go.dev/doc/install/source).&#xA;&#xA;### Clone the repo&#xA;&#xA;Just clone the repo from GitHub or Google Git repo.&#xA;&#xA;```bash&#xA;git clone https://github.com/golang/go&#xA;&#xA;OR&#xA;&#xA;git clone https://go.googlesource.com/go&#xA;```&#xA;&#xA;This will install the golang source code required to build the golang binary and the ecosystem (gofmt + standard library + test suite).&#xA;&#xA;Then let’s navigate to the cloned repo and we can build the golang from the source.&#xA;&#xA;### Build it&#xA;&#xA;We need to run the bash script in the folder to build the binary. They `all.bash` can be run to build the binary which will be stored in the `go/bin` folder `go/bin/go` and `go/bin/gofmt` files. These two binaries will be generated and are required in the Golang ecosystem.&#xA;&#xA;```bash&#xA;cd src&#xA;&#xA;./all.bash&#xA;```&#xA;&#xA;Once we have the binaries in the specified folder, we can move ahead to make the environment understand where the actual binary is located.&#xA;&#xA;### Environment Variables&#xA;&#xA;The `GOROOT` and `GOPATH` variables are required for the golang ecosystem to work as expected. The `GOROOT` is set as the path to the actual golang source repository, the cloned repository from which we built the binary. This `GOPATH` is the path where Golang stores the external repositories or modules for use anywhere in the system.&#xA;&#xA;```bash&#xA;export GOROOT=path_to_clone_repo&#xA;&#xA;export GOPATH=$(HOME)/go&#xA;&#xA;export PATH=$PATH:$GOROOT/bin:$GOPATH/bin&#xA;```&#xA;&#xA;The `PATH` environment needs to be updated with the `GOROOT` and `GOPATH` to make the binaries in those paths visible and accessible to the system.&#xA;&#xA;&gt; NOTE: If you are installing the golang from source when you have already a version of golang installed on your system, then you need to make sure you do not mess up the `GOROOT` and `GOPATH`.&#xA;&gt; &#xA;&gt; Those could be juse set with the current shell session, as you do not want this golang version permantely on the system, if you do requrie the newly installed golang version as your default, then you can set this environment variables in your shell config.&#xA;&#xA;Finally, we can now set the binary as something different because we do not want it to clash with the default golang version.&#xA;&#xA;### Run the binary&#xA;&#xA;The binary can be stored in the `/usr/local/bin/` to make any binary available in the system from anywhere. This is not necessary but handy if you are going to use it commonly but don’t need it as the default golang version.&#xA;&#xA;```bash&#xA;# The binary is stored in the &#xA;# path_to_cloned_repo/bin&#xA;# Whatever you want to name the binary&#xA;&#xA;cp bin/go /usr/local/bin/go-dev&#xA;&#xA;OR&#xA;&#xA;cp bin/go /usr/local/bin/go1.24&#xA;```&#xA;&#xA;Once this is done. we can check the installed golang version&#xA;&#xA;```bash&#xA;go1.24 version&#xA;```&#xA;&#xA;With this, you can use it as go1.24 or go-dev as the binary name.&#xA;&#xA;So, that is how we install and build from source any golang version above 1.23.&#xA;&#xA;## Conclusion&#xA;&#xA;For context, I wanted to check out the latest changes in 1.24, so I cloned the repo and after some trial and error of some commands to build the golang version, I was able to do it correctly. So just decided to share it here, hope you found it helpful.&#xA;&#xA;Thank you for reading.&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>til</type>
    </item>
    <item>
      <title>Use Embedded Replicas of LibSQL Database hosted on Turso with a Golang Application</title>
      <link>meetgor.com/turso-libsql-embedded-replicas-golang</link>
      <description>Understanding and exploring how to create, connect, and query local embedded replicas of LibSQL database hosted on Turso with a Golang application.</description>
      <pubDate>Thu, 31 Oct 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Welcome to the Let&#39;s Go with Turso series. In this series, we will learn how to interact with LibSQL databases with Golang. In the past article of the series, we explored how to connect remote/local LibSQL database in golang.&#xA;&#xA;With this section, we will specifally dive into understanding how to create, connect, and query local embedded replicas of LibSQL database hosted on Turso with a Golang application.&#xA;&#xA;If you want to check out the YouTube video, check this out:&#xA;&#xA;[LibSQL Embedded Replicas on Turso in Golang](https://www.youtube.com/watch?v=BitxB40rdVw)&#xA;&#xA;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/vBrvX0X0phw&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&#xA;## LibSQL Embedded Replicas on Turso in Golang&#xA;&#xA;### Embedded Replicas&#xA;The embedded replica is a native feature of the libSQL database. With embedded replicas, we can have faster writes as with the local database and global read access from the remote database.&#xA;&#xA;Embedded replica is like creating a copy of a primary remote database and using it for performing any operations from the applications as a local database and then it has a mechanism or standard to sync up with the primary remote database. The primary remote database serves as a single source of truth, however we can use the database locally as well. This however should be done carefully to avoid data corruption or stale data. To cope up with this stale or corruption of data, the periodic syncing can be used.&#xA;&#xA;Embedded replicas have a 3 fold process&#xA;- Create a copy of the primary remote database&#xA;- Perform any operations on the local database&#xA;- Sync up with the primary remote database&#xA;&#xA;![Embedded Replicas for LibSQL](https://meetgor-cdn.pages.dev/embedded-replicas-flow.png)&#xA;&#xA;There are a few things to remember here:&#xA;- The local database can read it&#39;s newly written data, however other local replica databases can only view those changes once the sync has happened and the primary database has been updated from the local copy.&#xA;- These would require to sync the local with the primary database first and then the other local database also needs to sync with the primary database.&#xA;&#xA;You can read more about it [here](https://docs.turso.tech/features/embedded-replicas/introduction) on the Turso documentation.&#xA;&#xA;Let&#39;s get started,&#xA;&#xA;What we are going to do is create a step by step procedure to understand how to work with embedded replicas of LibSQL database.&#xA;&#xA;1. Perform the operations on the local LibSQL database&#xA;2. Create a Embedded Replica and sync up with the primary remote database&#xA;3. Fetch data from the primary remote database&#xA;&#xA;![Embedded Replicas of LibSQL with Golang](https://meetgor-cdn.pages.dev/LibSQL_Embedded_Replicas_on_Turso_in_Golang.gif)&#xA;&#xA;In this way, we can understand how to operate the Embedded Replicas as a whole from locally as well as remotely&#xA;&#xA;## Initializing a Golang project&#xA;&#xA;Let&#39;s start with initializing a Golang project.&#xA;&#xA;```bash&#xA;# go mod init &lt;git-provider-domain&gt;/&lt;username&gt;/&lt;project-name&gt;&#xA;# Example&#xA;&#xA;go mod init github.com/mr-destructive/lets-go-with-turso&#xA;&#xA;```&#xA;&#xA;This will initialize the project in the current directory, creating a `go.mod` file with the specification of the Golang version and the packages that we will install and use in this module.&#xA;&#xA;## Installing go-libsql package&#xA;&#xA;We will need to install the [go-libsql](https://github.com/tursodatabase/go-libsql) package, this is the driver for LibSQL for Golang. To install simply use the `go get` command to be installed as the dependency for the project&#xA;&#xA;```bash&#xA;go get github.com/tursodatabase/go-libsql&#xA;```&#xA;&#xA;Once this is done, we can create a local LibSQL database.&#xA;&#xA;## Creating a local LibSQL database&#xA;&#xA;Let&#39;s create a local LibSQL database. With the `go-libsql` package, we can connect to the local database. This will be done using the `libsql` driver. There is really no much difference than the normal SQLite database driver, this works just like SQLite, the only difference being the ability to connect to the remote database.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;database/sql&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#xA;&#x9;_ &#34;github.com/tursodatabase/go-libsql&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;dbName := &#34;file:./local.db&#34;&#xA;&#xA;&#x9;db, err := sql.Open(&#34;libsql&#34;, dbName)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer db.Close()&#xA;}&#xA;```&#xA;&#xA;The above code will simply connect to the local LibSQL database which resides as the `local.db` file. Now, to demonstrate that it is an actual sqlite-like database, we can execute queries on the connected database.&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;database/sql&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#xA;&#x9;_ &#34;github.com/tursodatabase/go-libsql&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;dbName := &#34;file:./local.db&#34;&#xA;&#xA;&#x9;db, err := sql.Open(&#34;libsql&#34;, dbName)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer db.Close()&#xA;&#x9;rows, err := db.Query(&#34;SELECT ABS(RANDOM()%5) FROM generate_series(1,10)&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to query %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer rows.Close()&#xA;&#x9;for rows.Next() {&#xA;&#x9;&#x9;var i int&#xA;&#x9;&#x9;if err := rows.Scan(&amp;i); err != nil {&#xA;&#x9;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to scan %s&#34;, err)&#xA;&#x9;&#x9;&#x9;os.Exit(1)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Println(i)&#xA;&#x9;}&#xA;&#xA;}&#xA;```&#xA;Output:&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;3&#xA;0&#xA;4&#xA;4&#xA;2&#xA;1&#xA;2&#xA;3&#xA;4&#xA;1&#xA;&#xA;$ go run main.go&#xA;&#xA;0&#xA;2&#xA;1&#xA;2&#xA;3&#xA;2&#xA;2&#xA;1&#xA;0&#xA;2&#xA;```&#xA;&#xA;Just a simple `SELECT ABS(RANDOM()%5) FROM generate_series(1,10)` query will be executed on the connected database. This query will basically genrate a random number between `-4` and `4` and take the absolute value i.e. now between 0 and 4, this will genrate 10 such numbers.&#xA;&#xA;Now, we can move into the actual embedded replica creation of the primary remote database and use it as a local database to perform operations.&#xA;&#xA;## Creating an Embedded Replica of Turso&#39;s LibSQL database&#xA;&#xA;We need a few things to specify before we create the embedded replica, first being the primary remote database, that typically is a libsql database hosted on turso or self hosted. We also need to provide the local database path, where the local-replica will be stored or we can say the copy of the primary libsql database will be created.&#xA;&#xA;We will be using the [LibSQL.NewEmbeddedReplicaConnector](https://pkg.go.dev/github.com/levydsa/libsql-go#NewEmbeddedReplicaConnector) to create a local replica of a libsql database. The function takes in two paramters, the first paramter being the local database filename path to create the copy into, and the second paramter being the primary database URL. The function returns a connector object or an error if any. The connector object is then further used with [OpenDB](https://pkg.go.dev/database/sql#OpenDB) function to create a database connection. The `OpenDB` function returns a reference of database connections which we&#39;ll use to connect and perform operations on the database.&#xA;The same `connector` object could be used to sync with the primary database after performing operations on the local database with the [Sync](https://pkg.go.dev/github.com/levydsa/libsql-go#Connector.Sync) method. This will pull or push the changes from the local database to the primary database.&#xA;&#xA;We can configure the syncing mechanism while creating the embedded replica with the additional parameters to the `NewEmbeddedReplicaConnector` function. There are [Options](https://pkg.go.dev/github.com/levydsa/libsql-go#Option) to include for the paramters that could be passed like:&#xA;&#xA;- `WithAuthToken(string)`: This will be used to authenticate with the primary database.&#xA;- `WithSyncInterval(time.Duration)`: This will be used to specify the interval of syncing between the local and primary database.&#xA;- `WithEncrytion(string)`: This will be used to encrypt the local database.&#xA;- `WithReadYourWrites(bool)`: This will be used to specify if the local database can read the newly written changes or not.&#xA;&#xA;So, let&#39;s create a exmaple to create a embedded replica, make some changes by creating tables and then syncing the local with primary, finally appending some data to the local and reading those.&#xA;&#xA;#### Create the Embedded Replica&#xA;&#xA;We first need to create a copy of the primary database, as said, we will configure the 2 paramters that we need to create the embedded replica with `NewEmbeddedReplicaConnector`. Then once we have the connector object, we open up a database connection, at that point we can further run queries on the local replica that was just created from the primary remote LibSQL database.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;database/sql&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#x9;&#34;path/filepath&#34;&#xA;&#xA;&#x9;&#34;github.com/tursodatabase/go-libsql&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;dbName := &#34;local.db&#34;&#xA;    // this is not required, but can be used to create a temporary directory and then delete it later&#xA;&#x9;dir, err := os.MkdirTemp(&#34;&#34;, &#34;libsql-*&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&#34;Error creating temporary directory:&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer os.RemoveAll(dir)&#xA;&#xA;    // first paramter required for creating NewEmbeddedReplicaConnector&#xA;&#x9;dbPath := filepath.Join(dir, dbName)&#xA;&#x9;fmt.Println(dbPath)&#xA;&#xA;    // second paramter required for creating NewEmbeddedReplicaConnector&#xA;&#x9;dbURL := os.Getenv(&#34;TURSO_DATABASE_URL&#34;)&#xA;&#x9;dbAuthToken := os.Getenv(&#34;TURSO_AUTH_TOKEN&#34;)&#xA;&#xA;&#x9;connector, err := libsql.NewEmbeddedReplicaConnector(dbPath, dbURL, libsql.WithAuthToken(dbAuthToken))&#xA;&#x9;fmt.Println(connector)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer connector.Close()&#xA;&#xA;    // open a database connection from the connector object&#xA;&#x9;db := sql.OpenDB(connector)&#xA;&#x9;fmt.Println(&#34;Connected to database&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer db.Close()&#xA;}&#xA;```&#xA;&#xA;In the above code, we first create a temporary directory with the help of [MkdirTemp](https://pkg.go.dev/os#MkdirTemp), this is not required, but would be easier for cleanup later. We then the path for the local database to be created. The combined path string `dbPath` will serve as the first paramter to the `NewEmbeddedReplicaConnector`. Then we have taken the `dbURL` and the `dbAuthToken` from the environment variables `TURSO_DATABASE_URL` and `TURSO_AUTH_TOKEN` respectively. The `dbURL` will serve as the second paramter for the `NewEmbeddedReplicaConnector` that is the URL of the primary remote LibSQL database. The function `NewEmbeddedReplicaConnector` will return the `Connector` object if successfull in creation of the replica, else return `err` if it fails. The connector object needs to be closed at the end of the program, so we use the `defer connector.Close()` that will close the connection to the primary database at the end of the program. The `sql.OpenDB` is used to create the connection with the local database that will be created from the `connector` object. Finally we also need to close the local database connection at the end of the program.&#xA;&#xA;Further, we will try to query the local replica and create tables and append data to it.&#xA;&#xA;### Adding data to teh local replica&#xA;&#xA;Once we have the `db` connection to the local database, we can noramlly query the database as we did in the previous example, of querying the local LibSQL database. Let&#39;s start by creating a table `posts` to the local replica, this will basically create the schema in the local database.&#xA;&#xA;```go&#xA;    ....&#xA;&#xA;&#x9;createPostTableQuery := `CREATE TABLE IF NOT EXISTS posts(&#xA;        id INTEGER PRIMARY KEY,&#xA;        title VARCHAR(100),&#xA;        description VARCHAR(255),&#xA;        content TEXT&#xA;    );`&#xA;&#xA;&#x9;_, err = db.Exec(createPostTableQuery)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to create table %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;```&#xA;&#xA;The `createPostTableQuery` will be the `SQL` to create the table `posts` if it doesn&#39;t already exist in the database (local replica). Then with the help of [db.Exec](https://pkg.go.dev/database/sql#DB.Exec) function, we can execute the query and return back the rows if it had created any. In this case it won&#39;t as we have just added a table.&#xA;&#xA;Then, we can either sync the database to the primary, but let&#39;s populate the table `posts` with some data before syncing with the primary db.&#xA;&#xA;```go&#xA;&#xA;&#x9;createPostQuery := `INSERT INTO posts(title, description, content) &#xA;        VALUES(?, ?, ?)`&#xA;&#xA;&#x9;_, err = db.Exec(createPostQuery, &#34;test title&#34;, &#34;test description&#34;, &#34;test content&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to insert %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#xA;```&#xA;&#xA;We have created the `createPostQuery` similarly to insert into the `posts` table in the local replica. The values are added with the placeholders in the `Exec` function as positional parameters. Once we have executed the query, this will populate the `posts` table in the lcoal replica.&#xA;&#xA;We can now finally sync with the primary remote LibSQL database to make sure that the primary database also has these migrations applied.&#xA;&#xA;### Syncing the local replica&#xA;&#xA;Remember, `connector` is for primary database and `db` is for the local replica. So, we will sync the remote database from the replica that was created with the `connector.Sync`&#xA;&#xA;```go&#xA;&#xA;&#x9;_, err = connector.Sync()&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to sync %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#xA;&#x9;fmt.Printf(&#34;Successfully synced %s db&#xA;&#34;, dbPath)&#xA;&#x9;rows, err := db.Query(&#34;SELECT * FROM posts&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to query %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer rows.Close()&#xA;&#x9;for rows.Next() {&#xA;&#x9;&#x9;var id int&#xA;&#x9;&#x9;var title string&#xA;&#x9;&#x9;var description string&#xA;&#x9;&#x9;var content string&#xA;&#x9;&#x9;if err := rows.Scan(&amp;id, &amp;title, &amp;description, &amp;content); err != nil {&#xA;&#x9;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to scan %s&#34;, err)&#xA;&#x9;&#x9;&#x9;os.Exit(1)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Println(id, title, description, content)&#xA;&#x9;}&#xA;&#xA;```&#xA;&#xA;Output:&#xA;&#xA;```bash&#xA;&#xA;$ go run main.go                                                            &#xA;&#xA;/tmp/libsql-349052144/local.db&#xA;&amp;{0x2eec9d0 &lt;nil&gt; &lt;nil&gt;}&#xA;Connected to database&#xA;Successfully synced /tmp/libsql-349052144/local.db db&#xA;1 test title test description test content&#xA;```&#xA;&#xA;Once we have synced the local replica, we can now query the database i.e. the local replica, with the changes, also note that this could also be done without syncing the database, but the primary database won&#39;t have the applied changes.&#xA;&#xA;We finally Query the local replica with the query `SELECT * FROM posts` and print out the results. This has the 1 record in the `posts` table that we inserted.&#xA;&#xA;So, that&#39;s how we basically create a local replica from a remote LibSQL database hosted on Turso. We first create the path for the local database to be copied, then provide the primary database URL and credentials, then request a copy of the primary database, then we perform any mutation or operations on the local copy and finally sync up with the remote primary database to persist the data from that replica (acting like a session of database operation).&#xA;&#xA;That wraps the article for now.&#xA;&#xA;For all the code related to this article, you can check out the [Let&#39;s Go with Turso](https://github.com/mr-destructive/lets-go-with-turso) GitHub repo for all the examples and additional examples for using LibSQL with Golang.&#xA;&#xA;&#xA;## Conclusion&#xA;&#xA;So, that is a wrap for this part of the series, we have explored how to create a local embedded replica from a remote LibSQL database hosted on Turso with Golang. In the next part of the series, we will explore how to setup a local LibSQL database server and then connect it with Golang.&#xA;&#xA;Thank you for reading this post, If you have any questions, feedback, and suggestions, feel free to drop them in the comments.&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Connect LibSQL Database hosted on Turso in a Golang Application</title>
      <link>meetgor.com/turso-libsql-db-golang</link>
      <description>Exploring how to connect and query a LibSQL database hosted on Turso/Cloud in a Golang Application using libsql-client.</description>
      <pubDate>Mon, 30 Sep 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Welcome to the new series in Golang, Let&#39;s Go with Turso. In this series, we will learn how to interact with LibSQL databases with Golang. We will connect with a remote/local LibSQL database, create Embedded replicas, set up a local LibSQL database, and so much more as we explore and find out more features of LibSQL.&#xA;&#xA;## Connect a LibSQL database in a Golang application&#xA;&#xA;In this post, we will learn how to connect and query a LibSQL database hosted on Turso/Cloud in a Golang Application using libsql-client package. We will go from setting up golang project, installing turso-cli, creating a database on turso with the cli, connecting to the database with shell, and golang and finally, we can query the database using Golang.&#xA;&#xA;If you want to check out the YouTube video, check this out:&#xA;&#xA;[Conenct LibSQL Database hosted on Turso with Golang](https://www.youtube.com/watch?v=vBrvX0X0phw)&#xA;&#xA;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/vBrvX0X0phw&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&#xA;### Initializing a Golang project&#xA;&#xA;Let&#39;s start with initializing a Golang project.&#xA;&#xA;```bash&#xA;# go mod init &lt;git-provider-domain&gt;/&lt;username&gt;/&lt;project-name&gt;&#xA;# Example&#xA;&#xA;go mod init github.com/mr-destructive/lets-go-with-turso&#xA;&#xA;```&#xA;&#xA;This will initialize the project in the current directory, creating a `go.mod` file with the specification of the Golang version and the packages that we will install and use in this module.&#xA;&#xA;### Installing Turso CLI&#xA;&#xA;```bash&#xA;# Linux/Windows&#xA;curl -sSfL https://get.tur.so/install.sh | bash&#xA;curl -sSfL https://get.tur.so/install.sh | bash&#xA;&#xA;# macOS&#xA;brew install tursodatabase/tap/turso&#xA;&#xA;```&#xA;&#xA;This will install the Turso CLI. To verify that Turso CLI is installed properly, you can run the version command to check the setup.&#xA;&#xA;```&#xA;turso --version&#xA;```&#xA;&#xA;Once it is installed, we can now log in into Turso platform, simply by running the `auth signup` or `auth login` to Register or Log-in.&#xA;&#xA;```&#xA;turso auth signup&#xA;&#xA;# OR&#xA;&#xA;turso auth login&#xA;```&#xA;&#xA;This will redirect to the browser for the OAuth flow, once signed up and logged in, this will allow to interact with the Turso platform with the CLI that we downloaded.&#xA;&#xA;To make sure we are logged in as the correct user, we can run the `auth whoami` command to get the currently logged-in user.&#xA;&#xA;```&#xA;turso auth whoami&#xA;```&#xA;&#xA;This will print the username if you are logged-in. If everything seems correct, we can move ahead with the database creation step.&#xA;&#xA;### Creating a Remote LibSQL Database on Turso&#xA;&#xA;To create a LibSQL database hosted on Turso, we will use the `turso db create` command.&#xA;&#xA;```&#xA;turso db create&#xA;&#xA;# OR&#xA;&#xA;turso db create &lt;name&gt;&#xA;```&#xA;&#xA;This will create a database with the specified name, even if you don&#39;t provide the name, it will give out a random friendly two-word name to your database. It will create a database on the nearest location available from your location.&#xA;&#xA;This command will output the following:&#xA;&#xA;```&#xA;Created database &lt;db-name&gt; at group default in 1.99s.&#xA;&#xA;Start an interactive SQL shell with the following:&#xA;    turso db shell &lt;db-name&gt;&#xA;&#xA;To see information about the database, including a connection URL, run:&#xA;    turso db show &lt;db-name&gt;&#xA;&#xA;To get an authentication token for the database, run:&#xA;    turso db tokens create &lt;db-name&gt;&#xA;```&#xA;&#xA;The next step, it shows to start an interactive shell, to see information about the database, and to generate an authentication token for the database.&#xA;&#xA;We will move to the next part, which would be to create an authentication token for accessing the database from an external application.&#xA;&#xA;### Generating and Storing Authentication Token for LibSQL Database&#xA;&#xA;After we executed the `db create` command, and it created the database on the Turso cloud, there was a command hint for creating a `token` with the command `db tokens create`&#xA;&#xA;So, this command will create a JWT authentication token, that will be used to connect and read/write to the database.&#xA;&#xA;```bash&#xA;turso db tokens create &lt;db-name&gt;&#xA;&#xA;# OR&#xA;&#xA;turso db tokens create &lt;db-name&gt; --read-only&#xA;&#xA;# OR&#xA;&#xA;turso db tokens create &lt;db-name&gt; --expiration 30d&#xA;```&#xA;&#xA;We can use the simple `db tokens create &lt;db-name&gt;` to create an authentication token for the database with (read + write access). You can copy that returned token into a environment variable, or wherever your application can read that token.&#xA;&#xA;This could be stored in the environment variable as follows:&#xA;&#xA;```bash&#xA;export TURSO_AUTH_TOKEN=&#34;&lt;token&gt;&#34;&#xA;```&#xA;&#xA;To make a `read-only` token, we can use the flag `--read-only`. This will be handy, if you only have a database as a local replica, and the only purpose of the database is for querying data.&#xA;This will prevent any write operation on the database.&#xA;&#xA;We can also use the `--expiration` flag that will be used to set the duration of the token. By default the value for expiry is `never`, but that could be a little too risky if you are making a serious application. You can either set it to `7d` which will make the token expire after seven days.&#xA;&#xA;&#xA;Now, we can get the remote database URL and connect to the database. The URL could be obtained by running the command `db show &lt;db-name&gt;`&#xA;&#xA;```&#xA;turso db show &lt;db-name&gt;&#xA;```&#xA;&#xA;This will output the following:&#xA;&#xA;```bash&#xA;Name:           &lt;db-name&gt;&#xA;URL:            libsql://&lt;db-name&gt;-&lt;username&gt;.turso.io&#xA;ID:             &lt;db-id&gt;   &#xA;Group:          default&#xA;Version:        0.24.22&#xA;Locations:      bom&#xA;Size:           4.1 kB&#xA;Archived:       No&#xA;Bytes Synced:   0 B&#xA;Is Schema:      No&#xA;&#xA;Database Instances:&#xA;NAME        TYPE        LOCATION&#xA;bom         primary     bom&#xA;```&#xA;&#xA;The above output shows the meta-information of the database. This also has the URL hosted on Turso. We can construct the URL using the name of the database and your username as `libsql://&lt;db-name&gt;-&lt;username&gt;.turso.io`, you can set this in an environment variable or in the configuration wherever you can access it from the application.&#xA;&#xA;To set the URL of the database in your application, you can use the `TURSO_DB_URL` environment variable.&#xA;&#xA;```bash&#xA;export TURSO_DATABASE_URL=&#34;libsql://&lt;db-name&gt;-&lt;username&gt;.turso.io&#34;&#xA;```&#xA;&#xA;So, we have a remote database URL, and the access token configured, these are the two pieces that we will need to connect, read and write to the libsql database.&#xA;&#xA;&#xA;### Installing LibSQL Client for Golang&#xA;&#xA;So, we can install the [libsql-client-go](https://pkg.go.dev/github.com/tursodatabase/libsql-client-go/libsql) package for Golang which will be used as an SDK in Golang to interact with a remote LibSQL database.&#xA;&#xA;```bash&#xA;go get github.com/tursodatabase/libsql-client-go/libsql&#xA;```&#xA;&#xA;This will install the package `libsql` into the golang module. Now, we can use this in our golang application.&#xA;&#xA;### Populating the LibSQL Database&#xA;&#xA;Moving ahead, we have a database, but it doesn&#39;t have data! So let&#39;s create some tables and insert some rows. We can use the `db shell` command to open an interactive SQL shell on a remote LibSQL database.&#xA;&#xA;```bash&#xA;turso db shell libsql://&lt;db-name&gt;-&lt;username&gt;.turso.io&#xA;```&#xA;&#xA;This will be a default `sqlite3` like a shell, where we can execute SQL commands, like `.schema`, `.mode`, `.tables`, etc.&#xA;&#xA;```bash&#xA;  .dump       Render database content as SQL&#xA;  .help       List of all available commands.&#xA;  .indexes    List indexes in a table or database&#xA;  .mode       Set output mode&#xA;  .quit       Exit this program&#xA;  .read       Execute commands from a file&#xA;  .schema     Show table schemas.&#xA;  .tables     List all existing tables in the database.&#xA;```&#xA;&#xA;And definitely, we can use the normal SQL queries, to read, write and delete data from the database.&#xA;&#xA;#### Creating a Table&#xA;&#xA;First, let&#39;s create a simple table, called `posts` with columns like `id`, `title` as a `VARCHAR(100)`, `description` as a `VARCHAR(255)`, and `content` as `TEXT` which won&#39;t be `NULL`.&#xA;&#xA;```sql&#xA;CREATE TABLE posts&#xA;  (&#xA;     id          INTEGER PRIMARY KEY,&#xA;     title       VARCHAR(100),&#xA;     description VARCHAR(255),&#xA;     content     TEXT NOT NULL&#xA;  ); &#xA;```&#xA;&#xA;This will create a table `posts` on the LibSQL database, yes this will mutate the primary LibSQL database which is hosted on Turso.&#xA;&#xA;#### Inserting Rows&#xA;&#xA;Now, since we have the `posts` table, we will insert some rows into the table.&#xA;&#xA;```bash&#xA;INSERT INTO posts (title, description, content)&#xA;VALUES &#xA;    (&#39;test title&#39;, &#39;test description&#39;, &#39;test content&#39;);&#xA;```&#xA;&#xA;Now, we have some rows populated in the `posts` table. We can add more tables, and rows into the database, as usual, but this is just an example, so I&#39;ll keep it short.&#xA;&#xA;### Connecting to the LibSQL Database&#xA;&#xA;Now, we have something to query from a database, after we connect to the database via the Golang application program.&#xA;&#xA;First, we will grab two pieces to connect to the database.&#xA;&#xA;```bash&#xA;export TURSO_DATABASE_URL=&#34;libsql://&lt;db-name&gt;-&lt;username&gt;.turso.io&#34;&#xA;export TURSO_AUTH_TOKEN=&#34;&lt;token&gt;&#34;&#xA;```&#xA;&#xA;Now, let&#39;s start with the Golang program code.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    dbURL := os.Getenv(&#34;TURSO_DATABASE_URL&#34;)&#xA;    dbToken := os.Getenv(&#34;TURSO_AUTH_TOKEN&#34;)&#xA;    dbUrl := fmt.Sprintf(&#34;%s?authToken=%s&#34;, dbURL, dbToken)&#xA;}&#xA;```&#xA;&#xA;This will be the basic config to grab the database URL and the authentication token, then we can construct the `dbURL` along with `dbToken` to construct the complete dbURL which will allow to access the database.&#xA;&#xA;Moving ahead, we will import `database/sql` package that will be used to open the database connection and `github.com/tursodatabase/libsql-client-go/libsql` to connect to the remote LibSQL database.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;database/sql&#34;&#xA;    &#34;fmt&#34;&#xA;    &#34;os&#34;&#xA;&#xA;&#x9;_ &#34;github.com/tursodatabase/libsql-client-go/libsql&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;dbURL := os.Getenv(&#34;TURSO_DATABASE_URL&#34;)&#xA;&#x9;dbToken := os.Getenv(&#34;TURSO_AUTH_TOKEN&#34;)&#xA;&#x9;dbUrl := fmt.Sprintf(&#34;%s?authToken=%s&#34;, dbURL, dbToken)&#xA;&#xA;&#x9;db, err := sql.Open(&#34;libsql&#34;, dbUrl)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s: %s&#34;, dbUrl, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer db.Close()&#xA;&#xA;}&#xA;```&#xA;&#xA;The `sql.Open` function will open the connection to the database, this will return a `sql.DB` object. The driver selected is `libsql` and the `dbURL` is the entire URL along with the authentication token.&#xA;&#xA;&#xA;```go&#xA;type Post struct {&#xA;&#x9;Id          int&#xA;&#x9;Title       string&#xA;&#x9;Description string&#xA;&#x9;Content     string&#xA;}&#xA;&#xA;rows, err := db.Query(&#34;SELECT * FROM posts&#34;)&#xA;if err != nil {&#xA;    fmt.Fprintf(os.Stderr, &#34;failed to query: %s&#34;, err)&#xA;    os.Exit(1)&#xA;}&#xA;&#xA;for rows.Next() {&#xA;    var post Post&#xA;    if err := rows.Scan(&amp;post.Id, &amp;post.Title, &amp;post.Description, &amp;post.Content); err != nil {&#xA;        fmt.Fprintf(os.Stderr, &#34;failed to scan: %s&#34;, err)&#xA;        os.Exit(1)&#xA;    }&#xA;    fmt.Println(post)&#xA;}&#xA;defer rows.Close()&#xA;```&#xA;&#xA;Now, let&#39;s query some data from the database. We can construct the `Post` struct that will be used to grab the required fields like `Id`, `Title`, `Description`, and `Content` from the `posts` table in the database.&#xA;&#xA;Then, we will use the `db.Query` function to query the database. This function takes in a query and returns a `sql.Rows` object. We will iterate over all the `rows` returned from the database, with the `rows.Next()` that will fetch each row. Then we can `row.Scan` the row object with the appropriate and respective fields returned in the row. In this case, the `Id`, `Title`, `Description`, and the `Content` is fetched and stored into the `post` fields.&#xA;&#xA;We have fetched the rows and we can do operations on them as required, this was just a basic example. So the entire code can be found below.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;database/sql&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#xA;&#x9;_ &#34;github.com/tursodatabase/libsql-client-go/libsql&#34;&#xA;)&#xA;&#xA;type Post struct {&#xA;&#x9;Id          int&#xA;&#x9;Title       string&#xA;&#x9;Description string&#xA;&#x9;Content     string&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;dbURL := os.Getenv(&#34;TURSO_DATABASE_URL&#34;)&#xA;&#x9;dbToken := os.Getenv(&#34;TURSO_AUTH_TOKEN&#34;)&#xA;&#x9;dbUrl := fmt.Sprintf(&#34;%s?authToken=%s&#34;, dbURL, dbToken)&#xA;&#xA;&#x9;db, err := sql.Open(&#34;libsql&#34;, dbUrl)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to open db %s: %s&#34;, dbUrl, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#x9;defer db.Close()&#xA;&#xA;&#x9;rows, err := db.Query(&#34;SELECT * FROM posts&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to query: %s&#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;&#xA;&#x9;for rows.Next() {&#xA;&#x9;&#x9;var post Post&#xA;&#x9;&#x9;if err := rows.Scan(&amp;post.Id, &amp;post.Title, &amp;post.Description, &amp;post.Content); err != nil {&#xA;&#x9;&#x9;&#x9;fmt.Fprintf(os.Stderr, &#34;failed to scan: %s&#34;, err)&#xA;&#x9;&#x9;&#x9;os.Exit(1)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;fmt.Println(post)&#xA;&#x9;}&#xA;&#x9;defer rows.Close()&#xA;&#xA;}&#xA;```&#xA;The output of the above code will result in all the rows present in the post table of the LibSQL database.&#xA;&#xA;```bash&#xA;$ go run remote.go&#xA;&#xA;{1 test title test description test content}&#xA;{2 test title test description test content}&#xA;{3 sample post libsql tutorial create db, connect, create tables, insert rows, sync}&#xA;{4 test title test description test content}&#xA;```&#xA;&#xA;I have added a few more rows to the post table, as you can see we have successfully connected, inserted, and read from the post table in the LibSQL database hosted on Turso.&#xA;&#xA;For all the code related to this article, you can check out the [Let&#39;s Go with Turso](https://github.com/mr-destructive/lets-go-with-turso) GitHub repo for all the examples and additional examples for using LibSQL with Golang.&#xA;&#xA;## Conclusion&#xA;&#xA;So, that is a wrap for this part of the series, we have explored how to connect a remote LibSQL database hosted on Turso with Golang. In the next part of the series, we will explore how to create embedded replicas on Turso&#39;s LibSQL database in Golang.&#xA;&#xA;Thank you for reading this post, If you have any questions, feedback, and suggestions, feel free to drop them in the comments.&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Safely using Maps in Golang: Differences in declaration and initialization</title>
      <link>meetgor.com/golang-safely-using-maps</link>
      <description>Walkthrough the differences and pitfalls in declaring and initializing maps in Golang</description>
      <pubDate>Sat, 31 Aug 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;This week, I was working on one of the API wrapper packages for golang, and that dealt with sending post requests with URL encoded values, setting cookies, and all the fun stuff. However, while I was constructing the body, I was using [url.Value](https://pkg.go.dev/net/url#Values) type to construct the body, and use that to add and set key-value pairs. However, I was getting a wired `nil` pointer reference error in some of the parts, I thought it was because of some of the variables I set manually. However, by debugging closer, I found out a common pitfall or bad practice of just declaring a type but initializing it and that causing `nil` reference errors.&#xA;&#xA;In this post, I will cover, what are maps, how to create maps, and especially how to properly declare and initialize them. Create a proper distinction between the declaration and initialization of maps or any similar data type in golang.&#xA;&#xA;## What is a map in Golang?&#xA;&#xA;A [map](https://go.dev/src/runtime/map.go) or a hashmap in golang is a basic data type that allows us to store key-value pairs. Under the hood, it is a header map-like data structure that holds buckets, which are basically pointers to bucket arrays (contiguous memory). It has hash codes that store the actual key-value pairs, and pointers to new buckets if the current overflows with the number of keys. This is a really smart data structure that provides almost constant time access.&#xA;&#xA;## How to create maps in Golang&#xA;&#xA;To create a simple map in golang, you can take an example of a letter frequency counter using a map of string and integer. The map will store the letters as keys and their frequency as values.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;    words := &#34;hello how are you&#34;&#xA;    letters := map[string]int{}&#xA;&#xA;    for _, word := range words {&#xA;        wordCount[word]++&#xA;    }&#xA;&#xA;    fmt.Println(&#34;Word counts:&#34;)&#xA;    for word, count := range wordCount {&#xA;        fmt.Printf(&#34;%s: %d&#xA;&#34;, word, count)&#xA;    }&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;Word counts:&#xA;e: 2&#xA; : 3&#xA;w: 1&#xA;r: 1&#xA;y: 1&#xA;u: 1&#xA;h: 2&#xA;l: 2&#xA;o: 3&#xA;a: 1&#xA;```&#xA;&#xA;So, by initializing the map as `map[string]int{}` you will get an empty map. This can be then used to populate the keys and values, we iterate over the string, and for each character (rune) we cast that byte of character into the string and increment the value, the zero value for int is `0`, so by default if the key is not present, it will be zero, it is a bit of double-edged swords though, we never know the key is present in the map with the value `0` or the key is not present but the default value is `0`. For that, you need to check if the `key` exists in the map or not.&#xA;&#xA;For further details, you can check out my [Golang Maps](https://www.meetgor.com/golang-maps/) post in detail.&#xA;&#xA;## Difference between declaration and initialization&#xA;&#xA;There is a difference in declaring and initializing any variable in a programming language and has to do a lot more with the implementation of the underlying type. In the case of primary data types like `int`, `string`, `float`, etc. there are default/zero values, so that is the same as the declaration and initialization of the variables. However, in the case of maps and slices, the declaration is just making sure the variable is available to the scope of the program, however for initialization is setting it to its default/zero value or the actual value that should be assigned.&#xA;&#xA;So, declaration simply makes the variable available within the scope of the program. For maps and slices, declaring a variable without initialization sets it to `nil`, meaning it points to no allocated memory and cannot be used directly.&#xA;&#xA;Whereas the `initialization` allocates memory and sets the variable to a usable state. For maps and slices, you need to explicitly initialize them using syntax like `myMap = make(map[keyType]valueType)` or `slice = []type{}`. Without this initialization, attempting to use the map or slice will lead to runtime errors, such as panics for accessing or modifying a nil map or slice.&#xA;&#xA;Let&#39;s looks at the values of a map when it is declared/initialized/not initialized.&#xA;&#xA;Imagine you&#39;re building a configuration manager that reads settings from a map. The map will be declared globally but initialized only when the configuration is loaded.&#xA;&#xA;1. Declared but not initialized&#xA;    &#xA;&#xA;The below code demonstrates a map access that is not initialized.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;)&#xA;&#xA;// Global map to store configuration settings&#xA;var configSettings map[string]string // Declared but not initialized&#xA;&#xA;func main() {&#xA;&#x9;// Attempt to get a configuration setting before initializing the map&#xA;&#x9;serverPort := getConfigSetting(&#34;server_port&#34;)&#xA;&#x9;fmt.Printf(&#34;Server port: %s&#xA;&#34;, serverPort)&#xA;}&#xA;&#xA;func getConfigSetting(key string) string {&#xA;&#x9;if configSettings == nil {&#xA;&#x9;&#x9;log.Fatal(&#34;Configuration settings map is not initialized&#34;)&#xA;&#x9;}&#xA;&#x9;value, exists := configSettings[key]&#xA;&#x9;if !exists {&#xA;&#x9;&#x9;return &#34;Setting not found&#34;&#xA;&#x9;}&#xA;&#x9;return value&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;Server port: Setting not found&#xA;```&#xA;&#xA;2. Declared and Initialized at the same time&#xA;    &#xA;&#xA;The below code demonstrates a map access that is initialized at the same time.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;)&#xA;&#xA;// Global map to store configuration settings&#xA;var configSettings = map[string]string{&#xA;&#x9;&#34;server_port&#34;:  &#34;8080&#34;,&#xA;&#x9;&#34;database_url&#34;: &#34;localhost:5432&#34;,&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;serverPort := getConfigSetting(&#34;server_port&#34;)&#xA;&#x9;fmt.Printf(&#34;Server port: %s&#xA;&#34;, serverPort)&#xA;}&#xA;&#xA;func getConfigSetting(key string) string {&#xA;&#x9;value, exists := configSettings[key]&#xA;&#x9;if !exists {&#xA;&#x9;&#x9;return &#34;Setting not found&#34;&#xA;&#x9;}&#xA;&#x9;return value&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;Server port: 8080&#xA;```&#xA;&#xA;3. Declared and later initialized&#xA;    &#xA;&#xA;The below code demonstrates a map access that is initialized later.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;)&#xA;&#xA;// Global map to store configuration settings&#xA;var configSettings map[string]string // declared but not initialized&#xA;&#xA;func main() {&#xA;&#x9;// Initialize configuration settings&#xA;&#x9;initializeConfigSettings()&#xA;    // if the function is not called, the map will be nil&#xA;&#xA;&#x9;// Get a configuration setting safely&#xA;&#x9;serverPort := getConfigSetting(&#34;server_port&#34;)&#xA;&#x9;fmt.Printf(&#34;Server port: %s&#xA;&#34;, serverPort)&#xA;}&#xA;&#xA;func initializeConfigSettings() {&#xA;&#x9;if configSettings == nil {&#xA;&#x9;&#x9;configSettings = make(map[string]string) // Properly initialize the map&#xA;&#x9;&#x9;configSettings[&#34;server_port&#34;] = &#34;8080&#34;&#xA;&#x9;&#x9;configSettings[&#34;database_url&#34;] = &#34;localhost:5432&#34;&#xA;&#x9;&#x9;fmt.Println(&#34;Configuration settings initialized&#34;)&#xA;&#x9;}&#xA;}&#xA;&#xA;func getConfigSetting(key string) string {&#xA;&#x9;if configSettings == nil {&#xA;&#x9;&#x9;log.Fatal(&#34;Configuration settings map is not initialized&#34;)&#xA;&#x9;}&#xA;&#x9;value, exists := configSettings[key]&#xA;&#x9;if !exists {&#xA;&#x9;&#x9;return &#34;Setting not found&#34;&#xA;&#x9;}&#xA;&#x9;return value&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;Configuration settings initialized&#xA;Server port: 8080&#xA;```&#xA;&#xA;&#xA;In the above code, we declared the global map `configSettings` but didn&#39;t initialize it at that point, until we wanted to access the map. We initialize the map in the main function, this main function could be other specific parts of the code, and the global variable `configSettings` a map from another part of the code, by initializing it in the required scope, we prevent it from causing nil pointer access errors. We only initialize the map if it is `nil` i.e. it has not been initialized elsewhere in the code. This prevents overriding the map/flushing out the config set from other parts of the scope.&#xA;&#xA;## Pitfalls in access of un-initialized maps&#xA;&#xA;But since it deals with pointers, it comes with its own pitfalls like nil pointers access when the map is not initialized.&#xA;&#xA;Let&#39;s take a look at an example, a real case where this might happen.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/url&#34;&#xA;)&#xA;&#xA;func main() {&#xA;        var vals url.Values&#xA;        vals.Add(&#34;foo&#34;, &#34;bar&#34;)&#xA;        fmt.Println(vals)&#xA;}&#xA;```&#xA;&#xA;This will result in a runtime panic.&#xA;&#xA;```nginx&#xA;$ go run main.go&#xA;panic: assignment to entry in nil map&#xA;&#xA;goroutine 1 [running]:&#xA;net/url.Values.Add(...)&#xA;        /usr/local/go/src/net/url/url.go:902&#xA;main.main()&#xA;        /home/meet/code/playground/go/main.go:10 +0x2d&#xA;exit status 2&#xA;```&#xA;&#xA;This is because the [url.Values](https://pkg.go.dev/net/url#Values) is a map of string and a list of string values. Since the underlying type is a map for `Values`, and in the example, we only have declared the variable `vals` with the type `url.Values`, it will point to a `nil` reference, hence the message on adding the value to the type. So, it is a good practice to use `make` while declaring or initializing a map data type. If you are not sure the underlying type is `map` then you could use `Type{}` to initialize an empty value of that type.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/url&#34;&#xA;)&#xA;&#xA;func main() {&#xA;        vals := make(url.Values)&#xA;        // OR&#xA;        // vals := url.Values{}&#xA;        vals.Add(&#34;foo&#34;, &#34;bar&#34;)&#xA;        fmt.Println(vals)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run urlvals.go&#xA;map[foo:[bar]]&#xA;foo=bar&#xA;```&#xA;&#xA;It is also recommended by the [golang team](https://go.dev/blog/maps) to use the make function while initializing a map. So, either use `make` for maps, slices, and channels, or initialize the empty value variable with `Type{}`. Both of them work similarly, but the latter is more generally applicable to structs as well.&#xA;&#xA;## Conclusion&#xA;&#xA;Understanding the difference between declaring and initializing maps in Golang is essential for any developer, not just in golang, but in general. As we&#39;ve explored, simply declaring a map variable without initializing it can lead to runtime errors, such as panics when attempting to access or modify a nil map. Initializing a map ensures that it is properly allocated in memory and ready for use, thereby avoiding these pitfalls.&#xA;&#xA;By following best practices—such as using the make function or initializing with Type{}—you can prevent common issues related to uninitialized maps. Always ensure that maps and slices are explicitly initialized before use to safeguard against unexpected nil pointer dereferences&#xA;&#xA;Thank you for reading this post, If you have any questions, feedback, and suggestions, feel free to drop them in the comments.&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang Web: PUT Method</title>
      <link>meetgor.com/golang-web-put-method</link>
      <description>Exploring the fundamentals of a PUT method in golang. How to request a resource, parse body, headers, etc. in a HTTP PUT request.</description>
      <pubDate>Sat, 15 Jun 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In this section of the series, we will be exploring how to send a `PUT` HTTP request in golang. We will understand how to send a basic PUT request, create an HTTP request, update a resource on a server, parsing the content from struct to json, headers, etc in the following section of this post.&#xA;&#xA;## What is a PUT Method&#xA;&#xA;A PUT method is a type of request that is used to update or modify an entire resource on a server/database.&#xA;&#xA;Imagine you have ordered a pizza at a restaurant and realized you want to change the toppings after you&#39;ve already placed the order. With a PUT request, it&#39;s like informing the waiter about the changes you want to make to your existing order. You specify the updated toppings or any modifications (the data you send). The waiter then takes this updated information (PUT request) back to the kitchen (the server) to apply the changes to your order.&#xA;&#xA;Let&#39;s say you created a order.&#xA;&#xA;```nginx&#xA;PUT /api/order/456 HTTP/1.1&#xA;Host: example.com&#xA;Content-Type: application/json&#xA;Content-Length: 123&#xA;&#xA;{&#xA;    &#34;userID&#34;: 123,&#xA;    &#34;orderID&#34;: 456,&#xA;    &#34;items&#34;: [&#xA;        {&#xA;            &#34;itemID&#34;: 789,&#xA;            &#34;name&#34;: &#34;Pizza&#34;,&#xA;            &#34;quantity&#34;: 2,&#xA;            &#34;toppings&#34;: [&#34;Mushrooms&#34;]&#xA;        }&#xA;    ]&#xA;}&#xA;```&#xA;&#xA;In the context of web development, PUT requests are often used for actions such as:&#xA;&#xA;* Updating existing records or resources&#xA;    &#xA;* Modifying specific parts of an existing resource&#xA;    &#xA;* Replacing an entire resource with updated data&#xA;    &#xA;&#xA;Here&#39;s an example of what the PUT request might look like in this scenario:&#xA;&#xA;```nginx&#xA;PUT /api/order/456 HTTP/1.1&#xA;Host: example.com&#xA;Content-Type: application/json&#xA;Content-Length: 155&#xA;&#xA;{&#xA;    &#34;userID&#34;: 123,&#xA;    &#34;orderID&#34;: 456,&#xA;    &#34;items&#34;: [&#xA;        {&#xA;            &#34;itemID&#34;: 789,&#xA;            &#34;name&#34;: &#34;Pizza&#34;,&#xA;            &#34;quantity&#34;: 2,&#xA;            &#34;toppings&#34;: [&#34;Mushrooms&#34;, &#34;Olives&#34;]&#xA;        }&#xA;    ]&#xA;}&#xA;```&#xA;&#xA;In this example:&#xA;&#xA;* The PUT method is used to update the resource identified by `/api/order/456`.&#xA;    &#xA;* The application/json is the content type of the request.&#xA;    &#xA;* The 155 is the content length of the request.&#xA;    &#xA;* The body contains the updated details of the order, including the addition of toppings to the pizza.&#xA;    &#xA;&#xA;PUT requests are crucial for maintaining and updating data in applications where accuracy and consistency are paramount, ensuring that resources are kept current and reflect the latest changes made by users or systems&#xA;&#xA;## Why the need of PUT Method&#xA;&#xA;In the world of HTTP requests, we use the PUT method to update or modify an entire resource on a server or database. This method is crucial because the POST method, while convenient for creating new data, is not intended for updating existing resources according to standard conventions. While it&#39;s possible to misuse the POST method for updates internally, doing so can lead to confusion and inconsistencies in how requests are understood and processed.&#xA;&#xA;## How PUT Method request works&#xA;&#xA;A [PUT](https://www.rfc-editor.org/rfc/rfc9110#PUT) request is utilized to send data to a server for the purpose of updating a resource. When a client (such as a browser or other APIs) sends a PUT request to the server&#39;s API endpoint, it includes data in the request body, typically formatted as JSON, XML, or form data.&#xA;&#xA;The server processes the PUT request by first identifying the resource to be updated, either through the URL or data provided in the request body. It then validates, parses, and applies the data from the request body to make modifications to the resource. Following this, the server returns a response that includes a status code indicating the success or failure of the operation. Optionally, the response may also include the updated resource in the response body.&#xA;&#xA;Unlike the POST method, which is primarily used for creating new resources, PUT is specifically designed for updating existing resources on the server. The request body of a PUT contains the data necessary for the update, while the URL identifies the specific resource to be updated.&#xA;&#xA;In summary, PUT requests facilitate the transfer of data to the server specifically for updating resources, ensuring that changes to existing data are accurately processed and reflected.&#xA;&#xA;## Basic PUT Method&#xA;&#xA;To send a `PUT` request to an API in golang, we need to create a `http.Request` object. For `POST` method, the `http` package had the `Post` function defined, however for `PUT` method, there is no separate function. The Go philosophy is right now against adding all the method functions. There have been a couple of discussions on this on [GitHub](https://github.com/golang/go/issues/22841), but it is not been adopted as of 2024.&#xA;&#xA;So, we need to create a `http.Request` object for `PUT` method.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;apiURL := &#34;https://reqres.in/api/users/5&#34;&#xA;&#xA;&#x9;req, err := http.NewRequest(http.MethodPut, apiURL, nil)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;resp, err := http.DefaultClient.Do(req)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(resp.StatusCode)&#xA;&#xA;&#x9;defer resp.Body.Close()&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;200&#xA;```&#xA;&#xA;The above code sends a `PUT` request to the [`https://reqres.in/api/users/5`](https://reqres.in/api/users/5) endpoint. The resource we are trying to update is fetched with the identifier `5` which could probably be `id` for the user in the database of the server.&#xA;&#xA;## PUT Method with JSON&#xA;&#xA;Marshaling and encoding are essential in Go for preparing structured data, such as from a struct, into JSON format suitable for HTTP requests like PUT. This conversion ensures data integrity and compatibility between Go types and JSON representations. It&#39;s crucial when updating resources on servers, as APIs often require specific data formats for processing updates correctly. Marshaling transforms Go structs into JSON bytes, while encoding further prepares them as request bodies, facilitating seamless communication with web services. This process ensures data consistency and adherence to API specifications, maintaining robust communication in distributed systems.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bytes&#34;&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type User struct {&#xA;&#x9;Name   string `json:&#34;name&#34;`&#xA;&#x9;Salary int    `json:&#34;salary&#34;`&#xA;&#x9;Age    string `json:&#34;age&#34;`&#xA;&#x9;ID     int    `json:&#34;id,omitempty&#34;`&#xA;}&#xA;&#xA;type UserResponse struct {&#xA;&#x9;Status  string `json:&#34;status&#34;`&#xA;&#x9;Message string `json:&#34;message&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;user := User{&#xA;&#x9;&#x9;Name:   &#34;Alice&#34;,&#xA;&#x9;&#x9;Salary: 50000,&#xA;&#x9;&#x9;Age:    &#34;25&#34;,&#xA;&#x9;}&#xA;&#x9;apiURL := &#34;https://dummy.restapiexample.com/api/v1/update/11&#34;&#xA;&#xA;&#x9;// marshalling process&#xA;&#x9;// converting Go specific data structure/types to JSON&#xA;&#x9;bodyBytes, err := json.Marshal(user)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(string(bodyBytes))&#xA;&#xA;&#x9;// reading json into a buffer/in-memory&#xA;&#x9;body := bytes.NewBuffer(bodyBytes)&#xA;&#xA;&#x9;// post request&#xA;&#x9;req, err := http.NewRequest(http.MethodPut, apiURL, body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;resp, err := http.DefaultClient.Do(req)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(resp.StatusCode)&#xA;&#x9;if resp.StatusCode == 429 {&#xA;&#x9;&#x9;fmt.Println(&#34;too many requests&#34;)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#x9;respBody, err := io.ReadAll(resp.Body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(string(respBody))&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;&#x9;// unmarshalling process&#xA;&#x9;// converting JSON to Go specific data structure/types&#xA;&#x9;var userResponse UserResponse&#xA;&#x9;if err := json.Unmarshal(respBody, &amp;userResponse); err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(userResponse)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run json.go                                                                 &#xA;{&#34;name&#34;:&#34;Alice&#34;,&#34;salary&#34;:50000,&#34;age&#34;:&#34;25&#34;}&#xA;200                                                                              &#xA;{&#34;status&#34;:&#34;success&#34;,&#34;data&#34;:[],&#34;message&#34;:&#34;Successfully! Record has been updated.&#34;}&#xA;{success Successfully! Record has been updated.}&#xA;```&#xA;&#xA;In the provided Go code example, the `json.Marshal` function is used to convert a Go struct (`User`) into a JSON formatted byte slice (`[]byte`). Here&#39;s a breakdown of the steps involved:&#xA;&#xA;* Struct Definition: Define a Go struct with json tags.&#xA;    &#xA;* Marshalling: Use json.Marshal to convert the struct into JSON byte slice.&#xA;    &#xA;* Buffer Creation: Wrap the JSON byte slice into an in-memory buffer (bytes.Buffer).&#xA;    &#xA;* Request Sending: Send a PUT request with the buffer as the request body and set appropriate headers.&#xA;    &#xA;&#xA;Let&#39;s explore it step by step in detail:&#xA;&#xA;When using the PUT method in Go to update a resource on a server, you often need to send data in JSON format as the request body. Here&#39;s how you can achieve this using marshaling and encoding:&#xA;&#xA;1. Define the Struct&#xA;    &#xA;&#xA;```go&#xA;type User struct {&#xA;    Name   string `json:&#34;name&#34;`&#xA;    Salary int    `json:&#34;salary&#34;`&#xA;    Age    string `json:&#34;age&#34;`&#xA;    ID     int    `json:&#34;id,omitempty&#34;`&#xA;}&#xA;```&#xA;&#xA;Define a Go struct (`User`) that represents the data structure you want to send in JSON format. The json tags specify how each field should be serialized into JSON.&#xA;&#xA;2. Create an Object&#xA;    &#xA;&#xA;```go&#xA;user := User{&#xA;    Name:   &#34;Alice&#34;,&#xA;    Salary: 50000,&#xA;    Age:    &#34;25&#34;,&#xA;}&#xA;```&#xA;&#xA;Create an instance of the User struct (user) with sample data. This data will be marshaled into JSON format to send in the `PUT` request body.&#xA;&#xA;3. Marshal the Struct&#xA;    &#xA;&#xA;```go&#xA;bodyBytes, err := json.Marshal(user)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;```&#xA;&#xA;Use json.Marshal(user) to convert the user struct into a JSON byte slice (bodyBytes). This byte slice contains the serialized JSON representation of the User struct.&#xA;&#xA;4. Create a Buffer&#xA;    &#xA;&#xA;```go&#xA;body := bytes.NewBuffer(bodyBytes)&#xA;```&#xA;&#xA;Use `bytes.NewBuffer(bodyBytes)` to create an in-memory buffer (`body`) containing the JSON byte slice (`bodyBytes`). The buffer implements the `io.Reader` interface needed for the PUT request body.&#xA;&#xA;5. Create a PUT Request&#xA;    &#xA;&#xA;```go&#xA;req, err := http.NewRequest(http.MethodPut, apiURL, body)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;```&#xA;&#xA;Use http.NewRequest to create a new PUT request to the specified URL with the JSON buffer (`body`) as the request body. Set appropriate headers if needed (e.g., Content-Type as application/json).&#xA;&#xA;6. Send the Request&#xA;    &#xA;&#xA;```go&#xA;resp, err := http.DefaultClient.Do(req)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;```&#xA;&#xA;Use [`http.DefaultClient.Do`](http://http.DefaultClient.Do)`(req)` to execute the PUT request and obtain the response. Handle any errors that may occur during the request execution.&#xA;&#xA;7. Process the Response&#xA;    &#xA;&#xA;```go&#xA;respBody, err := io.ReadAll(resp.Body)&#xA;if err != nil {&#xA;    panic(err)&#xA;}&#xA;```&#xA;&#xA;Use `io.ReadAll(resp.Body)` to read and store the response body from the server. Handle any errors encountered during the reading process.&#xA;&#xA;8. Unmarshal the Response&#xA;    &#xA;&#xA;```go&#xA;var userResponse UserResponse&#xA;if err := json.Unmarshal(respBody, &amp;userResponse); err != nil {&#xA;    panic(err)&#xA;}&#xA;```&#xA;&#xA;Use `json.Unmarshal(respBody, &amp;userResponse)` to deserialize the JSON response body into a Go struct. This allows you to work with the response data in a structured manner.&#xA;&#xA;The parsing of files and form data is also possible with `PUT` requests, however, that has been covered in the [POST Method](https://meetgor.com/golang-web-post-method). Those snippets would be handy in these request method as well.&#xA;&#xA;I have also included some more examples of PUT requests [here](https://github.com/Mr-Destructive/100-days-of-golang/blob/main/web/methods/put/).&#xA;&#xA;That&#39;s it from the 35th part of the series, all the source code for the examples are linked in the GitHub on the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/web/methods/put/) repository.&#xA;&#xA;[100-days-of-golang](https://github.com/Mr-Destructive/100-days-of-golang)&#xA;&#xA;## Conclusion&#xA;&#xA;That&#39;s it from this post of the series, a post on the PUT method in golang :)&#xA;&#xA;We have covered topics like creating basic PUT requests and marshaling golang types into JSON format. Hope you found this article helpful. If you have any queries, questions, or feedback, please let me know in the comments or on my social handles. Thank you for reading.&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang Web: POST Method</title>
      <link>meetgor.com/golang-web-post-method</link>
      <description>Exploring the fundamentals of a POST method in golang. How to send a basic POST request, parse json, structs, files, form-data into the request body.</description>
      <pubDate>Sun, 10 Mar 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In this section of the series, we will be exploring how to send a `POST` HTTP request in golang. We will understand how to send a basic POST request, create an HTTP request, and parse json, structs into the request body, add headers, etc in the following sections of this post. We will understand how to marshal the golang struct/types into JSON format, send files in the request, and handle form data with examples of each in this article. Let&#39;s answer a few questions first.&#xA;&#xA;## What is a POST request?&#xA;&#xA;POST method is a type of request that is used to send data to a server(a machine on the internet).&#xA;&#xA;Imagine you are placing an order at a restaurant. With a GET request, it would be like asking the waiter, &#34;What kind of pizza do you have?&#34; The waiter would respond by telling you the menu options (the information retrieved from the server).&#xA;&#xA;However, a POST request is more like giving your completed order to the waiter. You tell them the specific pizza you want, its size, and any additional toppings (the data you send). The waiter then takes this information (POST request) back to the kitchen (the server) to process it (fulfill your order).&#xA;&#xA;In the world of web development, POST requests are often used for things like:&#xA;&#xA;Submitting forms (e.g., contact forms, login forms) Uploading files (e.g., photos, videos) Creating new accounts Sending data to be processed (e.g., online purchases)&#xA;&#xA;Here&#39;s an example of what the POST request might look like in this scenario:&#xA;&#xA;```nginx&#xA;POST /api/order HTTP/1.1&#xA;Host: example.com&#xA;Content-Type: application/json&#xA;Content-Length: 123&#xA;&#xA;{&#xA;    &#34;userID&#34;: 123,&#xA;    &#34;orderID&#34;: 456,&#xA;    &#34;items&#34;: [&#xA;        {&#xA;            &#34;itemID&#34;: 789,&#xA;            &#34;name&#34;: &#34;Pizza&#34;,&#xA;            &#34;quantity&#34;: 2&#xA;        },&#xA;        {&#xA;            &#34;itemID&#34;: 999,&#xA;            &#34;name&#34;: &#34;Burger&#34;,&#xA;            &#34;quantity&#34;: 1&#xA;        }&#xA;    ]&#xA;}&#xA;```&#xA;&#xA;In this example:&#xA;&#xA;* The `POST` method is used to send data to the server.&#xA;* The `/api/order` is the endpoint of the server.&#xA;* The `application/json` is the content type of the request.&#xA;* The `123` is the content length of the request.&#xA;* The `{&#34;userID&#34;: 123, &#34;orderID&#34;: 456, &#34;items&#34;: [{&#34;itemID&#34;: 789, &#34;name&#34;: &#34;Pizza&#34;, &#34;quantity&#34;: 2}, {&#34;itemID&#34;: 999, &#34;name&#34;: &#34;Burger&#34;, &#34;quantity&#34;: 1}]}` is the body of the request.&#xA;&#xA;&#xA;## Why the need for a POST request?&#xA;&#xA;In the world of HTTP requests, we use the POST method to securely send data from a client (like a user&#39;s browser) to a server. This is crucial because the GET method, while convenient for retrieving data, has limitations:&#xA;&#xA;Imagine you are in registering for an event via Google form, you type in your details on the webpage like name, email, address, phone number, and other personal details. If the website/app was using the `GET` method to send the request to register or do any other authentication/privacy-related requests, it could expose the data in the URL itself. It would be something along the lines [`https://form.google.com/register/&lt;form-name&gt;-&lt;id&gt;/?name=John&amp;phone_number=1234567890`](https://form.google.com/register/%3Cform-name%3E-%3Cid%3E/?name=John&amp;phone_number=1234567890), if a user maliciously sniffs into your network and inspects the URL, your data will be exposed. That is the reason we need `POST` a method.&#xA;&#xA;## How a POST method works?&#xA;&#xA;A [POST](https://www.rfc-editor.org/rfc/rfc9110#POST) request is used to send data to a server to create or update(there is a separate method for updating) a resource. The client(browser/other APIs) sends a POST request to the server&#39;s API endpoint with the data in the request body. This data can be in formats like JSON, XML, or form data. The server processes the POST request, validates and parses the data in the request body, makes any changes or creates resources based on that data, and returns a response. The response would contain a status code indicating the success or failure of the operation and may contain the newly created or updated resource in the response body. The client must check the response status code to verify the outcome and process the response accordingly. Unlike GET, POST can create new resources on the server. The body of a POST contains the data for creation while the URL identifies the resource to be created. Overall, POST transfers data to the server for processing, creation or updating of resources.&#xA;&#xA;The status code is usually `201` indicating the resource is successfully created or `200` for just indicating success.&#xA;&#xA;Some common steps for creating and sending a POST request as a developer include:&#xA;&#xA;* Defining the API endpoint&#xA;&#xA;* Clarifying the data format (json, language native objects, xml , text, form-data, etc)&#xA;&#xA;* Converting / Marshalling the data&#xA;&#xA;* Attaching header for `Content-Type` as key and value as the format of the data type (e.g. `application/json` for json)&#xA;&#xA;* Sending the request&#xA;&#xA;&#xA;The above steps are general for creating and sending a POST request, they are not specific to Golang. For golang specific steps, we need to dive a bit deeper, let&#39;s get started.&#xA;&#xA;## Basic POST method in Golang&#xA;&#xA;To send a POST request in golang, we need to use the `http` package. The `http` package has the `Post` method, which takes in 3 parameters, namely the URL, the Content-Type, and the Body. The body can be `nil` if the URL endpoint doesn&#39;t necessarily require a body. The `Content-Type` is the string, since we are just touching on how the Post request is constructed, we will see what the `Content-Type` string value should be in the later sections.&#xA;&#xA;&gt; [http.Post](http://http.Post)(URL, Content-Type, Body)&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;apiURL := &#34;https://reqres.in/api/users&#34;&#xA;&#xA;&#x9;// POST request&#xA;&#x9;resp, err := http.Post(apiURL, &#34;&#34;, nil)&#xA;    // ideally the Content-Type header should be set to the relevant format&#xA;&#x9;// resp, err := http.Post(apiURL, &#34;application/json&#34;, nil)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(resp.StatusCode)&#xA;    fmt.Println(resp)&#xA;&#x9;defer resp.Body.Close()&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;&#xA;$ go run main.go&#xA;&#xA;201&#xA;&amp;{&#xA;    201 Created&#xA;    201&#xA;    HTTP/2.0&#xA;    2&#xA;    0&#xA;    map[&#xA;        Access-Control-Allow-Origin:[*]&#xA;        Cf-Cache-Status:[DYNAMIC]&#xA;        Cf-Ray:[861cd9aec8223e4b-BOM]&#xA;        Content-Length:[50]&#xA;        Content-Type:[application/json; charset=utf-8]&#xA;        Date:[Sat, 09 Mar 2024 17:40:28 GMT]&#xA;        Server:[cloudflare]&#xA;        ...&#xA;        ...&#xA;        ...&#xA;        X-Powered-By:[Express]&#xA;    ]&#xA;    {0xc00017c180}&#xA;    50&#xA;    []&#xA;    false&#xA;    false&#xA;    map[]&#xA;    0xc000156000&#xA;    0xc00012a420&#xA;}&#xA;```&#xA;&#xA;The above code is sending the `POST` request to the [`https://reqres.in/api/users`](https://reqres.in/api/users) endpoint with an empty body and no specific format for `Content-Type` header. The response is according to the [Response](https://pkg.go.dev/net/http#Response) structure. We can see we got `201` status, which indicates the server received the POST request successfully, the API is a dummy api, so we don&#39;t care about the data we are processing, we are just using the API as a placeholder for sending the POST request.&#xA;&#xA;We can use `map[string]interface{}` it to pass the data in the request body. The `json.Marshal` method is used to convert the map into JSON format. We will look into the details shortly in the next few examples.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bytes&#34;&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    apiURL := &#34;https://reqres.in/api/users&#34;&#xA;    bodyMap := map[string]interface{}{&#xA;        &#34;name&#34;: &#34;morpheus&#34;,&#xA;        &#34;job&#34;: &#34;leader&#34;,&#xA;    }&#xA;&#xA;    requestBody, err := json.Marshal(bodyMap)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;    body := bytes.NewBuffer(requestBody)&#xA;&#xA;    resp, err := http.Post(apiURL, &#34;application/json&#34;, body)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;    fmt.Println(resp.StatusCode)&#xA;    defer resp.Body.Close()&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;201&#xA;```&#xA;&#xA;The above code sends the `POST` request to the [`https://reqres.in/api/users`](https://reqres.in/api/users) endpoint with the data in the request body in JSON format.&#xA;&#xA;## Creating a POST request in Golang&#xA;&#xA;We can construct the POST request with the [NewRequest](https://pkg.go.dev/net/http#NewRequest) method. The method takes in 3 parameters, namely the `method` (e.g. `POST`, `GET`), the `URL` and the `body` (if there is any). We can then add extra information to the headers or the Request object after constructing the basic HTTP [Request](https://pkg.go.dev/net/http#Request) object.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;apiURL := &#34;https://reqres.in/api/users&#34;&#xA;&#xA;&#x9;req, err := http.NewRequest(http.MethodPost, apiURL, nil)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;resp, err := http.DefaultClient.Do(req)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(resp.StatusCode)&#xA;&#x9;//fmt.Println(resp)&#xA;&#x9;defer resp.Body.Close()&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;201&#xA;```&#xA;&#xA;In the above example, we have created an HTTP Request as the `POST` method, with [`https://reqres.in/api/users`](https://reqres.in/api/users) as the URL, and no body. This constructs an HTTP Request object, which can be sent as the parameter to the [http.DefaultClient.Do](http://http.DefaultClient.Do) method, which is the default client for the request we sent in the earlier examples as `http.Get` or [`http.Post`](http://http.Post) methods. We can implement a custom client as well, and then apply `Do` the method with the request parameters. The `Do` method returns the `Request` object or the `error` if any.&#xA;&#xA;More on the customizing Client will be explained in a separate post in the series.&#xA;&#xA;The response is also in the same format as the [Response](https://pkg.go.dev/net/http#Response) structure that we have seen earlier. This section of the series aims to construct a post request, and not to parse the response, we have already understood the parsing of the response in the [Get method](https://www.meetgor.com/golang-web-get-method/#?:~:text=Parsing%20the%20JSON%20body%20with%20structs) section of the series.&#xA;&#xA;### Parsing objects to JSON for POST method request&#xA;&#xA;We might have a golang object that we want to send as a body to an API in the POST request, for that we need to convert the golang struct object to JSON. We can do this by using the [Marshal](https://pkg.go.dev/encoding/json#Marshal) or the [Encode](https://pkg.go.dev/encoding/json#Encoder.Encode) method for serialization of the golang struct object to JSON.&#xA;&#xA;#### Using Marshal method&#xA;&#xA;Marshaling is the process of converting data from a data structure into a format suitable for transmission over a network or for storage. It&#39;s commonly used to convert native objects in a programming language into a serialized format, typically a byte stream, that can be transmitted or stored efficiently. You might get a question here, what is the difference between `Marshalling` and `Serialization`? Well, Serialization, is a broader term that encompasses marshalling. It refers to the process of converting an object or data structure into a format that can be stored or transmitted and later reconstructed into the original object. Serialization may involve converting data into byte streams, XML, JSON, or other formats. So, in summary, marshaling specifically deals with converting native objects into a format suitable for transmission, while serialization encompasses the broader process of preparing data for storage or transmission.&#xA;&#xA;The `json` package has the [Marshal](https://pkg.go.dev/encoding/json#Marshal) method that converts the golang object into JSON. The `Marshal` method takes in a parameter as the struct object with type `any` and returns a byte slice `[]byte` and error (if any).&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bytes&#34;&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type User struct {&#xA;&#x9;Name   string `json:&#34;name&#34;`&#xA;&#x9;Salary int    `json:&#34;salary&#34;`&#xA;&#x9;Age    int    `json:&#34;age&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;user := User{&#xA;&#x9;&#x9;Name:   &#34;Alice&#34;,&#xA;&#x9;&#x9;Salary: 50000,&#xA;&#x9;&#x9;Age:    25,&#xA;&#x9;}&#xA;&#x9;apiURL := &#34;https://dummy.restapiexample.com/api/v1/create&#34;&#xA;&#xA;&#x9;// marshalling process&#xA;&#x9;// converting Go specific data structure/types to JSON&#xA;&#x9;bodyBytes, err := json.Marshal(user)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(string(bodyBytes))&#xA;&#xA;&#x9;// reading json into a buffer/in-memory&#xA;&#x9;body := bytes.NewBuffer(bodyBytes)&#xA;&#xA;&#x9;// post request&#xA;&#x9;resp, err := http.Post(apiURL, &#34;application/json&#34;, body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(resp.StatusCode)&#xA;&#x9;defer resp.Body.Close()&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;{&#34;name&#34;:&#34;Alice&#34;,&#34;salary&#34;:50000,&#34;age&#34;:25}&#xA;200&#xA;```&#xA;&#xA;In the above example, we have created a struct `User` with fields `Name`, `Salary`, and `Age`, the json tags will help label each key in JSON with the tag for the respective fields in the struct. We create an object `user` of a type `User` with the values as `Alice`, `50000`, and `25` respectively.&#xA;&#xA;We call the `json.Marshal` method with the parameter `user` that represents the struct object `User`, the method returns a slice of bytes, or an error either or both could be nil. If we try to see the stringified representation of the byte slice, we can see something like `{&#34;name&#34;:&#34;Alice&#34;,&#34;salary&#34;:50000,&#34;age&#34;:25}` which is a JSON string for the user struct. We can&#39;t parse the byte slice as the body in the POST request, we need the `io.Reader` object, so we can load the byte slice `bodyBytes` into a buffer and parse that as a body for the POST request.&#xA;&#xA;We then send a `POST` request to the endpoint [`https://dummy.restapiexample.com/api/v1/create`](https://dummy.restapiexample.com/api/v1/create) with the content type as `application/json` and with the body as `body` which was a `io.Reader` object as an in-memory buffer.&#xA;&#xA;In brief, we can summarize the marshaling of the golang object into JSON with `Marshal` function as the following steps:&#xA;&#xA;* Defining the structure as per the request body&#xA;&#xA;* Creating the struct object for parsing the data as body to the request&#xA;&#xA;* Calling the `json.Marshal` function to convert the object to JSON (parameter as the struct object `any` type)&#xA;&#xA;* Loading the byte slice into a buffer with `bytes.NewBuffer()`&#xA;&#xA;* Sending the POST request to the endpoint with the body as the `io.Reader` object and content type as `application/json`&#xA;&#xA;&#xA;#### Using Encode method&#xA;&#xA;We can even use the [Encoder.Encode](https://pkg.go.dev/encoding/json#Encoder.Encode) method to parse the golang struct object to JSON. Firstly, we should have the struct defined as per the request body that the particular API takes, we can make use of the json tags, omitempty, omit(-) options to make the marshaling process work accordingly. We can then create the object of that particular struct with the data we require to be created as a resource with the POST request on that API service.&#xA;&#xA;Thereafter we can create an empty buffer object with [bytes.Buffer](https://pkg.go.dev/bytes#Buffer), this buffer object would be used to initialize the [Encoder](https://pkg.go.dev/encoding/json#Encoder) object with the [NewEncoder](https://pkg.go.dev/encoding/json#NewEncoder) method. This would give access to the [Encode](https://pkg.go.dev/encoding/json#Encoder.Encode) method, which is used to take in the struct object (`any` type) and this will populate the buffer we initialized with the `NewEncoder` method.&#xA;&#xA;Later we can access that buffer to parse it to the Post request as the body. Let&#39;s understand it better with an example.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bytes&#34;&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type User struct {&#xA;&#x9;Name   string&#xA;&#x9;Salary int&#xA;&#x9;Age    int&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;user := User{&#xA;&#x9;&#x9;Name:   &#34;Alice&#34;,&#xA;&#x9;&#x9;Salary: 50000,&#xA;&#x9;&#x9;Age:    25,&#xA;&#x9;}&#xA;&#x9;apiURL := &#34;https://dummy.restapiexample.com/api/v1/create&#34;&#xA;&#xA;&#x9;var bodyBuffer bytes.Buffer&#xA;&#x9;var encoder = json.NewEncoder(&amp;bodyBuffer)&#xA;&#x9;err := encoder.Encode(user)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;&#x9;resp, err := http.Post(apiURL, &#34;application/json&#34;, &amp;bodyBuffer)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(resp.StatusCode)&#xA;&#x9;fmt.Println(resp)&#xA;&#x9;defer resp.Body.Close()&#xA;}&#xA;```&#xA;&#xA;Over here, we have created a struct `User` with fields `Name`, `Salary`, and `Age`, we initialize the `user` as the object of the `User` struct. Then we create a buffer `bodyBuffer` of type `bytes.Buffer` this is the actual buffer that we will send as the body. Further, we initialize the `Encoder` object as `encoder` with the `json.NewEncoder` method by parsing the reference of `bodyBuffer` as the parameter. Since `bytes.Buffer` implements the `io.Writer` interface, we can pass the `bodyBuffer` to the `NewEncoder` method. This will create the `Encoder` object which in turn will give us access to the `Encode` method, where we will parse the struct instance and it will populate the buffer with which we initialized the `Encoder` object earlier.&#xA;&#xA;Now, we have the `encode` object, this gives us the access to `Encode` method, we call the `Encode` method with the parameter of `user` which is a User struct instance/object. The Encode method will populate the `bodyBuffer` object or it will result in an error if anything goes wrong (the data is incorrectly parsed or is not in the required format).&#xA;&#xA;We can call the `Post` method with the initialized URL, the `Content-Type` as `application/json` since we have converted the struct instance to JSON object, and the body as the reference to the buffer as `&amp;bodyBuffer`&#xA;&#xA;So, the steps for parsing struct instances into JSON objects with the `Encoder.Encode` method is as follows:&#xA;&#xA;* Defining the structure as per the request body&#xA;&#xA;* Creating the struct object for parsing the data as body to the request&#xA;&#xA;* Creating an empty `bytes.Buffer` object as an in-memory buffer&#xA;&#xA;* Initializing the `Encoder` object with `NewEncoder` method by parsing the reference of `bodyBuffer` as the parameter&#xA;&#xA;* Calling the `Encode` method with the parameter of struct instance/object&#xA;&#xA;* Sending the POST request to the endpoint with the content type as `application/json` and body as the reference to the buffer&#xA;&#xA;The results are the same as the above example just the way we have parsed the struct instance to JSON object is different.&#xA;&#xA;### Parsing JSON to POST request&#xA;&#xA;We have seen how we can parse golang struct instances to JSON and then send the post request, but what if we had the JSON string already with us, and we want to send the request? Well, that&#39;s much easier, right? We already have parsed the JSON string to the Post request by loading the slice of bytes into a buffer, so we just need to convert the string to a slice of bytes which is quite an easy task, and then load that byte slice to the buffer.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bytes&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// dummy api&#xA;&#x9;apiURL := &#34;https://dummy.restapiexample.com/api/v1/create&#34;&#xA;&#xA;&#x9;// json data&#xA;&#x9;data := `{&#xA;        &#34;name&#34;: &#34;Alice&#34;,&#xA;        &#34;job&#34;: &#34;Teacher&#34;&#xA;    }`&#xA;&#x9;body := bytes.NewBuffer([]byte(data))&#xA;&#xA;&#x9;// POST request&#xA;&#x9;resp, err := http.Post(apiURL, &#34;application/json&#34;, body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(resp.StatusCode)&#xA;&#x9;fmt.Println(resp)&#xA;&#x9;defer resp.Body.Close()&#xA;}&#xA;```&#xA;&#xA;In the example above, we already have a JSON string `data` with keys as `name` and `job` but it is not JSON, it is a stringified JSON. We can convert the stringified JSON to a slice of bytes using the `[]byte` function. Further, we have used the `bytes.NewBuffer` method to load the byte slice into an `io.Reader` object. This object returned by the `bytes.NewBuffer` will serve as the body for the POST request.&#xA;&#xA;### Parsing JSON to objects in Golang from POST method response&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bytes&#34;&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type User struct {&#xA;&#x9;Name   string `json:&#34;name&#34;`&#xA;&#x9;Salary int    `json:&#34;salary&#34;`&#xA;&#x9;Age    string `json:&#34;age&#34;`&#xA;&#x9;ID     int    `json:&#34;id,omitempty&#34;`&#xA;}&#xA;&#xA;type UserResponse struct {&#xA;&#x9;Status string `json:&#34;status&#34;`&#xA;&#x9;Data   User   `json:&#34;data&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;user := User{&#xA;&#x9;&#x9;Name:   &#34;Alice&#34;,&#xA;&#x9;&#x9;Salary: 50000,&#xA;&#x9;&#x9;Age:    &#34;25&#34;,&#xA;&#x9;}&#xA;&#x9;apiURL := &#34;https://dummy.restapiexample.com/api/v1/create&#34;&#xA;&#xA;&#x9;// marshalling process&#xA;&#x9;// converting Go specific data structure/types to JSON&#xA;&#x9;bodyBytes, err := json.Marshal(user)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(string(bodyBytes))&#xA;&#xA;&#x9;// reading json into a buffer/in-memory&#xA;&#x9;body := bytes.NewBuffer(bodyBytes)&#xA;&#xA;&#x9;// post request&#xA;&#x9;resp, err := http.Post(apiURL, &#34;application/json&#34;, body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(resp.StatusCode)&#xA;&#x9;fmt.Println(resp)&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;&#x9;// Read response body&#xA;&#x9;respBody, err := io.ReadAll(resp.Body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;&#x9;// unmarshalling process&#xA;&#x9;// converting JSON to Go specific data structure/types&#xA;&#x9;var userResponse UserResponse&#xA;&#x9;if err := json.Unmarshal(respBody, &amp;userResponse); err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(userResponse)&#xA;&#x9;fmt.Println(userResponse.Data)&#xA;}&#xA;```&#xA;&#xA;```nginx&#xA;&#xA;{success {Alice 50000 25 3239}}&#xA;{Alice 50000 25 577}&#xA;```&#xA;&#xA;The above example is a POST request with a struct instance being loaded as a JSON string and then sent as a buffer to the API endpoint, it also reads the response body with a specific structure `UserResponse` and unmarshalled the `resp.Body` from the `io.Reader` as `respBody` and then loads into `userResponse` object. This example gives an entire process of what we have understood in the JSON data parsing for a POST request.&#xA;&#xA;### Sending Form data in a POST request&#xA;&#xA;We can also send data to a POST request in the form of a form, the form which we use in the HTML. Golang has a `net/url` package to parse the form data. The form data is sent in the `application/x-www-form-urlencoded` format.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;net/url&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;type ResponseLogin struct {&#xA;&#x9;Token string `json:&#34;token&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;// dummy api&#xA;&#x9;apiURL := &#34;https://reqres.in/api/login&#34;&#xA;&#xA;&#x9;// Define form data&#xA;&#x9;formData := url.Values{}&#xA;&#x9;formData.Set(&#34;email&#34;, &#34;eve.holt@reqres.in&#34;)&#xA;&#x9;formData.Set(&#34;password&#34;, &#34;cityslicka&#34;)&#xA;&#xA;&#x9;// Encode the form data&#xA;&#x9;fmt.Println(formData.Encode())&#xA;&#x9;reqBody := strings.NewReader(formData.Encode())&#xA;&#x9;fmt.Println(reqBody)&#xA;&#xA;&#x9;// Make a POST request with form data&#xA;&#x9;resp, err := http.Post(apiURL, &#34;application/x-www-form-urlencoded&#34;, reqBody)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;&#x9;// Print response status code&#xA;&#x9;fmt.Println(&#34;Status Code:&#34;, resp.StatusCode)&#xA;&#xA;&#x9;// Read response body&#xA;&#x9;respBody, err := io.ReadAll(resp.Body)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#x9;token := ResponseLogin{}&#xA;&#xA;&#x9;json.Unmarshal(respBody, &amp;token)&#xA;&#x9;fmt.Println(token)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;email=eve.holt%40reqres.in&amp;password=cityslicka&#xA;&amp;{email=eve.holt%40reqres.in&amp;password=cityslicka 0 -1}&#xA;Status Code: 200&#xA;{QpwL5tke4Pnpja7X4}&#xA;```&#xA;&#xA;In the above example, we set a `formData` with the values of `email` and `password` which are `url.Values` object. The `url.Values` the object is used to store the key-value pairs of the form data. The `formData` is encoded with the `url.Encode` method, We load the encoded string to a `buffer` with `strings.NewReader` which implements the `io.Reader` interface, so that way we can pass that object as the body to the post request.&#xA;&#xA;We send the `POST` request to the endpoint [`https://reqres.in/api/login`](https://reqres.in/api/login) with the content type as `application/x-www-form-urlencoded` and with the body as `reqBody` which implements the `io.Reader` interface as an in-memory buffer. The response from the request is read into the buffer with `io.ReadAll` method and we can `Unmarshal` the stream of bytes as a buffer into the `ResponseLogin` struct object.&#xA;&#xA;The output shows the `formData` as encoded string `email=eve.holt%`[`40reqres.in`](http://40reqres.in)`&amp;password=cityslicka` as `@` is encoded to `%40`, then we wrap the `formData` in a `strings.NewReader` object which is a buffer that implements `io.Reader` interface, hence we can see the result as the object. The status code for the request is `200` indicating the server received the `form-data` in the body and upon unmarshalling, we get the token as a response to the POST request which was a dummy login API.&#xA;&#xA;This way we have parsed the form-data to the body of a POST request.&#xA;&#xA;### Sending File in a POST request&#xA;&#xA;We have covered, parsing text, JSON, and form data, and now we need to move into sending files in a POST request. We can use the `multipart` package to parse files into the request body and set appropriate headers for reading the file from the API services.&#xA;&#xA;We first read the file contents [`os.Open`](http://os.Open) which returns a reference to the `file` object or an error. We create an empty `bytes.Buffer` object as `body` which will be populated later. The [multipart.NewWriter](https://pkg.go.dev/mime/multipart#NewWriter) method takes in the `io.Writer` object which will be the `body` as it is an `bytes.Buffer` object that implements the `io.Writer` interface. This will initialize the [Writer](https://pkg.go.dev/mime/multipart#Writer) object in the `multipart` package.&#xA;&#xA;We create a `form-field` in the `Writer` object with the [CreateFormFile](https://pkg.go.dev/mime/multipart#Writer.CreateFormFile) method, which takes in the `fieldName` as the name of the field, and the `fileName` as the name of the file which will be read later in the multipart form. The method returns either the part or the error. The `part` is an object that implements the `io.Writer` interface.&#xA;&#xA;Since we have stored the file contents in the `file` object, we copy the contents into the `form-field` with the [Copy](https://pkg.go.dev/io#Copy) method. Since the `part` return from the `CreateFormFile` was implementing the `io.Writer` interface, we can use it to Copy the contents from source to destination. The source is the `io.Reader` object and the destination is the `io.Writer` object, the destination for the `Copy` method is the first parameter, the source is the second parameter.&#xA;&#xA;This Copy method will populate the buffer initialized earlier in the `NewWriter` method. This will give us a buffer that has the file contents in it. We can pass this buffer to the POST request with the `body` parameter. We also need to make sure we close the `Writer` object after copying the contents of the file. We can extract the type of file which will serve as the `Content-Type` of the request.&#xA;&#xA;Let&#39;s clear the explanation with an example.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bytes&#34;&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;mime/multipart&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;type ResponseFile struct {&#xA;&#x9;Files map[string]string `json:&#34;files&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;apiURL := &#34;http://postman-echo.com/post&#34;&#xA;&#x9;fileName := &#34;sample.csv&#34;&#xA;&#xA;&#x9;file, err := os.Open(fileName)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer file.Close()&#xA;&#xA;&#x9;body := &amp;bytes.Buffer{}&#xA;&#x9;writer := multipart.NewWriter(body)&#xA;&#xA;&#x9;part, err := writer.CreateFormFile(&#34;csvFile&#34;, fileName)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;_, err = io.Copy(part, file)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;    contentType := writer.FormDataContentType()&#xA;    fmt.Println(contentType)&#xA;&#xA;&#x9;writer.Close()&#xA;&#xA;&#x9;resp, err := http.Post(apiURL, contentType, body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;&#x9;fmt.Println(&#34;Status Code:&#34;, resp.StatusCode)&#xA;&#xA;&#x9;respBody, err := io.ReadAll(resp.Body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;token := ResponseFile{}&#xA;&#x9;json.Unmarshal(respBody, &amp;token)&#xA;&#x9;fmt.Println(token)&#xA;&#x9;fmt.Println(token.Files[fileName])&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;multipart/form-data; boundary=7e0eacfff890be395eba19c70415c908124b503a56f23ebeec0ab3c665ca&#xA;&#xA;&#xA;--619671ea2c0aa47ca6664a7cda422169d73f3b8a089c659203f5413d03de&#xA;Content-Disposition: form-data; name=&#34;csvFile&#34;; filename=&#34;sample.csv&#34;&#xA;Content-Type: application/octet-stream&#xA;&#xA;User,City,Age,Country&#xA;Alex Smith,Los Angeles,20,USA&#xA;John Doe,New York,30,USA&#xA;Jane Smith,Paris,25,France&#xA;Bob Johnson,London,40,UK&#xA;&#xA;--619671ea2c0aa47ca6664a7cda422169d73f3b8a089c659203f5413d03de--&#xA;&#xA;&#xA;&#xA;Status Code: 200&#xA;&#xA;{map[sample.csv:data:application/octet-stream;base64,VXNlcixDaXR5LEFnZSxDb3VudHJ5CkFsZXggU21pdGgsTG9zIEFuZ2VsZXMsMjAsVVNBCkpvaG4gRG9lLE5ldyBZb3JrLDMwLFVTQQpKYW5lIFNtaXRoLFBhmlzLDI1LEZyYW5jZQpCb2IgSm9obnNvbixMb25kb24sNDAsVUsK]}&#xA;&#xA;data:application/octet-stream;base64,VXNlcixDaXR5LEFnZSxDb3VudHJ5CkFsZXggU21pdGgsTG9zIEFuZ2VsZXMsMjAsVVNBCkpvaG4gRG9lLE5ldyBZb3JrLDMwLFVTQQpKYW5lIFNtaXRoLFBhmlzLDI1LEZyYW5jZQpCb2IgSm9obnNvbixMb25kb24sNDAsVUsK&#xA;```&#xA;&#xA;In the above example, we first read the file `sample.csv` into the `file` object with [`os.Open`](http://os.Open) method, this will return a reference to the file object or return an error if any arises while opening the file.&#xA;&#xA;Then we create an empty buffer `bytes.Buffer` object which will serve as the body of the post request later as it will get populated with the file contents in the form of `multipart/form-data`.&#xA;&#xA;We initialize the `Writer` object with `multipart.NewWriter` method which takes in the empty buffer as the parameter, we parse the `body` as the parameter. The method will return a reference to the `multipart.Writer` object.&#xA;&#xA;With the `Writer` object we access the `CreateFormFile` method which takes in the `fieldName` as the name of the field, and the `fileName` as the name of the file. The method will return either the part or an error. The `part` in this case, is the reference to the `io.Writer` object that will be used to write the contents from the uploaded file.&#xA;&#xA;Then, we can use the `io.Copy` method to copy the contents from the `io.Reader` object to the `io.Writer` object. The source is the `io.Reader` object and the destination is the `io.Writer` object. The first parameter is however the destination and the second parameter is the source. In the example, we call `io.Copy(part, file)` which will copy the contents of `file` to the `part` buffer.&#xA;&#xA;We get the `Content-Type` by calling the [Writer.FormDataContentType](https://pkg.go.dev/mime/multipart#Writer.FormDataContentType) method. This returns us `multipart/form-data; boundary=7e0eacfff890be395eba19c70415c908124b503a56f23ebeec0ab3c665ca` which will serve the `Content-Type` for the Post request.&#xA;&#xA;We need to make sure we close the `Writer` object with the `Close` method.&#xA;&#xA;We just print the `body.String()` to get a look at what the actual body looks like, we can see there is a form for the file as a `form-data` with keys like `Content-Type`, `Content-Disposition`, etc. The file has the `Content-Type` as `application/octet-stream` and the actual content is rendered in the output.&#xA;&#xA;The dummy API responds with a 200 status code and also sends the JSON data with the name of the file as the key and the value as the `base64` encoded value of the file contents. This indicates that we were able to upload the file to the server API using a POST request. Well done!&#xA;&#xA;I have also included some more examples of POST requests with files [here](https://github.com/Mr-Destructive/100-days-of-golang/blob/main/web/methods/post/file_2.go) which extends the above example by taking the encoded values and decoding to get the actual contents of the file back.&#xA;&#xA;## Best Practices for POST method&#xA;&#xA;Here are some of the best practices for the POST method which are followed to make sure you consume or create the POST request in the most secure, efficient, and graceful way.&#xA;&#xA;### Always Close the Response Body&#xA;&#xA;Ensure that you close the response body after reading from it. Use `defer response.Body.Close()` to automatically close the body when the surrounding function returns. This is crucial for releasing associated resources like network connections or file descriptors. Failure to close the response body can lead to memory leaks, particularly with a large volume of requests. Properly closing the body prevents resource exhaustion and maintains efficient memory usage.&#xA;&#xA;### Client Customization&#xA;&#xA;Utilize the [Client](https://pkg.go.dev/net/http#Client) struct to customize the HTTP client behavior. By using a custom client, you can set timeouts, headers, user agents, and other configurations without modifying the `DefaultClient` provided by the `http` package. This approach allows for flexibility and avoids repetitive adjustments to the client configuration for each request.&#xA;&#xA;### Set Content-Type Appropriately&#xA;&#xA;Ensure that you set the `Content-Type` header according to the request payload. Correctly specifying the Content-Type is crucial for the server to interpret the request payload correctly. Failing to set the Content-Type header accurately may result in the server rejecting the request. Always verify and match the Content-Type header with the content being sent in the POST request to ensure smooth communication with the server.&#xA;&#xA;## Reference&#xA;&#xA;* [Postman POST API](https://www.postman.com/postman/workspace/postman-answers/documentation/13455110-00378d5c-5b08-4813-98da-bc47a2e6021d) (For POST request with file upload)&#xA;&#xA;* [Golang net/http Package](https://pkg.go.dev/net/http)&#xA;&#xA;&#xA;## Conclusion&#xA;&#xA;That&#39;s it from this post of the series, a post on the POST method in golang :)&#xA;&#xA;We have covered topics like creating basic post requests, Marshalling golang types into JSON format, parsing form data, sending a POST request with files, and best practices for the POST method. Hope you found this article helpful. If you have any queries, questions, or feedback, please let me know in the comments or on my social handles.&#xA;&#xA;Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Sort Package Introduction</title>
      <link>meetgor.com/golang-sort-package-basic</link>
      <description>Understanding the fundamentals of the sort package in Golang. Sorting integers, slices, struct values, maps</description>
      <pubDate>Mon, 15 Jan 2024 00:00:00 UTC</pubDate>
      <content>I have been learning Golang for around 2 years now, and I have never paid attention to the sort package, can you believe that! Where was this package hiding?&#xA;&#xA;The `sort` package provides convenient methods for sorting slices and user-defined collections in Go. Here&#39;s a quick overview of what it can do:&#xA;&#xA;## Sorting Slices&#xA;&#xA;To sort a slice of builtin types like ints, strings, etc, you can simply call `sort.Slice()`:&#xA;&#xA;```go&#xA;nums := []int{5, 2, 6, 3, 1}&#xA;&#xA;sort.Slice(nums, func(i, j int) bool {&#xA;    return nums[i] &lt; nums[j]&#xA;})&#xA;&#xA;// or &#xA;// sorts.Ints(nums)&#xA;&#xA;fmt.Println(nums)&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;[1, 2, 3, 5, 6]&#xA;```&#xA;The sort is in-place, mutating the original slice. You can customize the sort order by providing a less(i, j int) bool function.&#xA;&#xA;## Sorting Struct Slices&#xA;&#xA;To sort a slice of custom structs, add a Len(), Less(i, j int) bool, and Swap(i, j int) method:&#xA;&#xA;```go&#xA;type Person struct {&#xA;  Name string&#xA;  Age  int&#xA;}&#xA;&#xA;people := []Person{&#xA;  {&#34;Bob&#34;, 30},&#xA;  {&#34;John&#34;, 20},&#xA;  {&#34;Alice&#34;, 25},&#xA;}&#xA;&#xA;sort.Slice(people, func(i, j int) bool {&#xA;  return people[i].Age &lt; people[j].Age&#xA;}) &#xA;&#xA;fmt.Println(person)&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;[{&#34;Name&#34;:&#34;Alice&#34;,&#34;Age&#34;:25},{&#34;Name&#34;:&#34;Bob&#34;,&#34;Age&#34;:30},{&#34;Name&#34;:&#34;John&#34;,&#34;Age&#34;:20}]&#xA;```&#xA;&#xA;This will sort people by age.&#xA;&#xA;## Sorting Maps&#xA;&#xA;Maps are inherently unordered in Go. We can&#39;t sort them, but we can iterate them in a sorted way. We need a separate slice of keys or values(whicher required), we will sort those keys/values and iterate over them in that order.:&#xA;&#xA;### Sort by Keys&#xA;&#xA;To sort a map by keys, we can use the `sort.Strings()` function or any other sort function as per the data structure, there are functions like [sort.Ints](https://pkg.go.dev/sort#Ints), [sort.Float64](https://pkg.go.dev/sort#Float64s), or [sort.Slice](https://pkg.go.dev/sort#Slice). We can create a new slice of keys from the map and then apply the sort on that newly created slice. After the slice of keys is created, we can iterate over it and access the map values in a order of sorted keys.&#xA;&#xA;```go&#xA;counts := map[string]int{&#xA;  &#34;hello&#34;: 5,&#xA;  &#34;world&#34;: 2,&#xA;  &#34;foo&#34;: 3,&#xA;}&#xA;&#xA;keys := make([]string, 0, len(counts))&#xA;// extract keys &#xA;for k := range counts {&#xA;  keys = append(keys, k)&#xA;} &#xA;&#xA;// sort keys&#xA;sort.Strings(keys) &#xA;&#xA;// iterate with the sorted keys slice&#xA;for _, k := range keys {&#xA;  fmt.Println(k, counts[k]) &#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;foo 3&#xA;hello 5&#xA;world 2&#xA;```&#xA;&#xA;This prints the map ordered by key. You can sort by value too.&#xA;&#xA;### Sort by Value&#xA;&#xA;To iterate the map with sorting order of values, we can approach it in a similar way. We create a slice of keys. This time, we don&#39;t sort the keys, instead, we change the position of the slice of keys depending on the values. This changes the key order based on the sorted values in the map. By similarly iterating over the key slice, we iterate over the map in a sorted order of the values.&#xA;&#xA;```go&#xA;counts := map[string]int{&#xA;  &#34;hello&#34;: 5,&#xA;  &#34;world&#34;: 2,&#xA;  &#34;foo&#34;: 3,&#xA;}&#xA;&#xA;keys := make([]string, 0, len(counts))&#xA;// extract keys&#xA;for k := range counts {&#xA;  keys = append(keys, k)&#xA;}&#xA;&#xA;// sort by value&#xA;// i.e. change the order of key based on values sort order&#xA;sort.SliceStable(keys, func(i, j int) bool {&#xA;    return counts[keys[i]] &lt; counts[keys[j]]&#xA;})&#xA;&#xA;// iterate sorted&#xA;for _, k := range keys {&#xA;  fmt.Println(k, counts[k])&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;world 2&#xA;foo 3&#xA;hello 5&#xA;```&#xA;&#xA;The `sort.SliceStable` function is used to sort the slice in place. It takes in a slice and the less function which is the actual logic for comparison in the values. This function sorts the key elements based on the values in the map, and thereby the key slice is shuffled by the sorted order of the values in the map.&#xA;&#xA;The sort package is super useful for quickly organizing Go data structures.&#xA;There are [Find](https://pkg.go.dev/sort#Find) which tries to return a index of the first element that satisfies a comparison condition with a flag or found or not with a boolean. There is also a [Search](https://pkg.go.dev/sort#Search) which is used specifically for searching elements in a sorted array, it also gives a first index of the occuring element. But that is a topic for another day!&#xA;&#xA;Thank you, Happy Coding :)&#xA;</content>
      <type>til</type>
    </item>
    <item>
      <title>Golang: Test Output JSON</title>
      <link>meetgor.com/golang-test-output-json</link>
      <description>Obtain JSON output of test results in Golang</description>
      <pubDate>Mon, 01 Jan 2024 00:00:00 UTC</pubDate>
      <content>I just discovered that we can generate a JSON output of test results in Golang. I found this [here](https://youtu.be/cf72gMBrsI0?t=80).&#xA;&#xA;Let&#39;s take a fresh simple example.&#xA;&#xA;```go&#xA;package jsontest&#xA;&#xA;func hello() string {&#xA;    return &#34;Hello, World!&#34;&#xA;}&#xA;```&#xA;```go&#xA;package jsontest&#xA;&#xA;import (&#xA;    &#34;testing&#34;&#xA;)&#xA;&#xA;func TestHello(t *testing.T) {&#xA;    want := &#34;Hello, World!&#34;&#xA;    got := hello()&#xA;    t.Logf(&#34;got: %q&#34;, got)&#xA;    if got != want {&#xA;        t.Errorf(&#34;got: %q, want: %q&#34;, got, want)&#xA;    }&#xA;}&#xA;```&#xA;&#xA;Here, we have a function `hello` that simply returns a string, the `TestHello` function in the `jsontest` package will check if the returned string is correctly returned or not.&#xA;&#xA;So, we can test this with `go test ./...` command, this will give out the output in a standard output/error in text format. However, if we add the `-json` flag, we can get the output in JSON format.&#xA;&#xA;&#xA;```bash&#xA;go test ./... -json&#xA;```&#xA;&#xA;```json&#xA;{&#34;Time&#34;:&#34;2024-01-01T20:52:45.861974085+05:30&#34;,&#34;Action&#34;:&#34;start&#34;,&#34;Package&#34;:&#34;json-test&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T20:52:45.863133332+05:30&#34;,&#34;Action&#34;:&#34;run&#34;,&#34;Package&#34;:&#34;json-test&#34;,&#34;Test&#34;:&#34;TestHello&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T20:52:45.863142397+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;json-test&#34;,&#34;Test&#34;:&#34;TestHello&#34;,&#34;Output&#34;:&#34;=== RUN   TestHello\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T20:52:45.863148346+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;json-test&#34;,&#34;Test&#34;:&#34;TestHello&#34;,&#34;Output&#34;:&#34;    main_test.go:10: got: \&#34;Hello, World\&#34;\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T20:52:45.863151351+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;json-test&#34;,&#34;Test&#34;:&#34;TestHello&#34;,&#34;Output&#34;:&#34;    main_test.go:12: got: \&#34;Hello, World\&#34;, want: \&#34;Hello, World!\&#34;\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T20:52:45.863157014+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;json-test&#34;,&#34;Test&#34;:&#34;TestHello&#34;,&#34;Output&#34;:&#34;--- FAIL: TestHello (0.00s)\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T20:52:45.863160418+05:30&#34;,&#34;Action&#34;:&#34;fail&#34;,&#34;Package&#34;:&#34;json-test&#34;,&#34;Test&#34;:&#34;TestHello&#34;,&#34;Elapsed&#34;:0}&#xA;{&#34;Time&#34;:&#34;2024-01-01T20:52:45.863411555+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;json-test&#34;,&#34;Output&#34;:&#34;FAIL\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T20:52:45.863438344+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;json-test&#34;,&#34;Output&#34;:&#34;FAIL\tjson-test\t0.001s\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T20:52:45.863443461+05:30&#34;,&#34;Action&#34;:&#34;fail&#34;,&#34;Package&#34;:&#34;json-test&#34;,&#34;Elapsed&#34;:0.001}&#xA;```&#xA;&#xA;Pretty cool right?&#xA;&#xA;This is really useful for programmatically taking the output and parsing it to get the metrics.&#xA;&#xA;&#xA;We can even combine with the coverage flag to get the coverage metrics as well.&#xA;&#xA;```bash&#xA;go test ./... -json -cover&#xA;```&#xA;&#xA;```json&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:13:30.771976961+05:30&#34;,&#34;Action&#34;:&#34;start&#34;,&#34;Package&#34;:&#34;jsontest&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:13:30.775118482+05:30&#34;,&#34;Action&#34;:&#34;run&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Test&#34;:&#34;TestHello&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:13:30.775172535+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Test&#34;:&#34;TestHello&#34;,&#34;Output&#34;:&#34;=== RUN   TestHello\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:13:30.775201647+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Test&#34;:&#34;TestHello&#34;,&#34;Output&#34;:&#34;    main_test.go:10: got: \&#34;Hello, World!\&#34;\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:13:30.775231759+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Test&#34;:&#34;TestHello&#34;,&#34;Output&#34;:&#34;--- PASS: TestHello (0.00s)\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:13:30.775253928+05:30&#34;,&#34;Action&#34;:&#34;pass&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Test&#34;:&#34;TestHello&#34;,&#34;Elapsed&#34;:0}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:13:30.775269402+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Output&#34;:&#34;PASS\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:13:30.776153185+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Output&#34;:&#34;coverage: 100.0% of statements\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:13:30.776808599+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Output&#34;:&#34;ok  \tjsontest\t0.004s\tcoverage: 100.0% of statements\n&#34;&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:13:30.777814589+05:30&#34;,&#34;Action&#34;:&#34;pass&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Elapsed&#34;:0.006}&#xA;```&#xA;&#xA;I am planning to use this in my workflow for integrating the output of the tests suite with specific tests.&#xA;&#xA;For running the specific tests, you can use `go test -run TestName` command, this will only run the provided test function.&#xA;&#xA;```go&#xA;// main.go&#xA;&#xA;package jsontest&#xA;&#xA;func hello() string {&#xA;    return &#34;Hello, World!&#34;&#xA;}&#xA;&#xA;func add(x, y int) int {&#xA;    return x + y&#xA;}&#xA;```&#xA;&#xA;```go&#xA;// main_test.go&#xA;package jsontest&#xA;&#xA;import (&#xA;&#x9;&#34;testing&#34;&#xA;)&#xA;&#xA;func TestHello(t *testing.T) {&#xA;    want := &#34;Hello, World!&#34;&#xA;    got := hello()&#xA;    t.Logf(&#34;got: %q&#34;, got)&#xA;    if got != want {&#xA;        t.Errorf(&#34;got: %q, want: %q&#34;, got, want)&#xA;    }&#xA;}&#xA;&#xA;func TestAdd(t *testing.T) {&#xA;    want := 2&#xA;    got := add(1, 1)&#xA;    t.Logf(&#34;got: %d&#34;, got)&#xA;    if got != want {&#xA;        t.Errorf(&#34;got: %d, want: %d&#34;, got, want)&#xA;    }&#xA;}&#xA;```&#xA;&#xA;So, we have two test in this go module, we can run a specific test using `go test -run TestName` command as so:&#xA;&#xA;```bash&#xA;go test -run TestAdd -json&#xA;```&#xA;&#xA;```json&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:33:44.19397581+05:30&#34;,&#34;Action&#34;:&#34;start&#34;,&#34;Package&#34;:&#34;jsontest&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:33:44.198067398+05:30&#34;,&#34;Action&#34;:&#34;run&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Test&#34;:&#34;TestAdd&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:33:44.198150156+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Test&#34;:&#34;TestAdd&#34;,&#34;Output&#34;:&#34;=== RUN   TestAdd\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:33:44.198197444+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Test&#34;:&#34;TestAdd&#34;,&#34;Output&#34;:&#34;    main_test.go:19: got: 2\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:33:44.198217057+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Test&#34;:&#34;TestAdd&#34;,&#34;Output&#34;:&#34;--- PASS: TestAdd (0.00s)\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:33:44.198230965+05:30&#34;,&#34;Action&#34;:&#34;pass&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Test&#34;:&#34;TestAdd&#34;,&#34;Elapsed&#34;:0}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:33:44.198241628+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Output&#34;:&#34;PASS\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:33:44.19869148+05:30&#34;,&#34;Action&#34;:&#34;output&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Output&#34;:&#34;ok  \tjsontest\t0.004s\n&#34;}&#xA;{&#34;Time&#34;:&#34;2024-01-01T21:33:44.198822637+05:30&#34;,&#34;Action&#34;:&#34;pass&#34;,&#34;Package&#34;:&#34;jsontest&#34;,&#34;Elapsed&#34;:0.005}&#xA;```&#xA;&#xA;As we can see, there is only one test being executed and the output of the test is in JSON format.&#xA;&#xA;These are really good flags and options to have as they make the output more portable. I will be planning to use this to improve my workflow in testing and developing open source projects and personal projects as well. I am really inspired by the Teej&#39;s video of executing anything in NeoVim.&#xA;&#xA;</content>
      <type>til</type>
    </item>
    <item>
      <title>Golang Web: GET Method</title>
      <link>meetgor.com/golang-web-get-method</link>
      <description>Exploring the fundamentals of a GET method in golang. How to request a resource, parse body, headers, etc. in a HTTP GET request.</description>
      <pubDate>Sat, 28 Oct 2023 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In this section of the series, we will be exploring how to send a `GET` HTTP request in golang. We will be understanding how to send a basic GET request, create an HTTP request and customize the client, add headers, read the response body, etc in the following sections of this post.&#xA;&#xA;## What is a GET method?&#xA;&#xA;A [GET](https://en.wikipedia.org/wiki/HTTP#Request_methods) method in the context of an HTTP request is an action that is used to obtain data/resources. The `GET` method is used in a web application to get a resource like an HTML page, image, video, media, etc.&#xA;&#xA;Some common usecases of the `GET` method are:&#xA;&#xA;- Loading a webpage&#xA;- Getting an image, file or other resource&#xA;- API requests to retrieve data&#xA;- Search queries sending filters and parameters&#xA;&#xA;## Basic GET Request&#xA;&#xA;To use the HTTP method `GET` in golang, the [net/http](https://pkg.go.dev/net/http) package has a [Get](https://pkg.go.dev/net/http#Get) method. This method simply takes in a URL as a string and returns the [response](https://pkg.go.dev/net/http#Response) or an error. Let&#39;s look at how to send a basic HTTP GET request in golang.&#xA;&#xA;```go&#xA;// web/methods/get/main.go&#xA;&#xA;&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;reqURL := &#34;https://www.google.com&#34;&#xA;&#x9;resp, err := http.Get(reqURL)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(resp)&#xA;    fmt.Println(resp.Status)&#xA;    fmt.Println(&#34;Status Code:&#34;, resp.StatusCode)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;&amp;{200 OK 200 HTTP/2.0 2 0 map[Alt-Svc:[h3=&#34;:443&#34;; ma=2592000,h3-29=&#34;:443&#34;; ma=2592000] Cache-Control:[private, max-age=0] Content-Security-Policy-Report-Only:[object-src &#39;none&#39;;base-uri &#39;self&#39;;script-src &#39;nonce-pdz_s8Gr0owwMbX8I9qNEQ&#39; &#39;strict-dynamic&#39; &#39;report-sample&#39; &#39;unsafe-eval&#39; &#39;unsafe-inline&#39; https: http:;report-uri https://csp.withgoogle.com/csp/gws/other-hp] Content-Type:[text/html; charset=ISO-8859-1] Date:[Fri, 27 Oct 2023 09:37:04 GMT] Expires:[-1] P3p:[CP=&#34;This is not a P3P policy! See g.co/p3phelp for more info.&#34;] Server:[gws] Set-Cookie:[1P_JAR=2023-10-27-09; expires=Sun, 26-Nov-2023 09:37:04 GMT; path=/; domain=.google.com; Secure AEC=Ackid1Q5FARA_9d7f7znggUdw6DoJA1DBpI17Z0SWxN519Dc64EqmYVHlFg; expires=Wed, 24-Apr-2024 09:37:04 GMT; path=/; domain=.google.com; Secure; HttpOnly; SameSite=lax NID=511=EToBPqckCVRE7Paehug1PgNBKqe7lFLI9d12xJrGbvP9r8tkFIRWciry3gsy8FZ8OUIK4gE4PD-irgNzg4Y1fVePLdyu0AJdY_HcqL6zQYok-Adn-y5TDPmMCNuDnrouBfoxtqVjYY_4RFOe8jalkYto5fQAwzWnNJyw8K0avsw; expires=Sat, 27-Apr-2024 09:37:04 GMT; path=/; domain=.google.com; HttpOnly] X-Frame-Options:[SAMEORIGIN] X-Xss-Protection:[0]] 0xc000197920 -1 [] false true map[] 0xc0000ee000 0xc0000d8420}&#xA;&#xA;200 OK&#xA;&#xA;Status Code: 200&#xA;```&#xA;&#xA;In the above code, we have defined a URL string as `reqURL` and used the [Get](https://pkg.go.dev/net/http#Get) method to send a GET request. The `Get` is parsed with the `reqURL` string and the return values are stored as `resp` and `err`. We have added an error check after calling the `Get` method in order to avoid errors later in the code.&#xA;&#xA;The `Get` method as seen from the output has returned a `*http.Response` object, we can use the `Status` and `StatusCode` properties to get the status code of the response. In this case, the status code of the response was `200`. The response `resp` is an object of type `http.Response` i.e. it has fields like `Body`, `StatusCode`, `Headers`, `Proto`, etc. We can get each individual field from the `resp` object. We will later look into how to read the `Body` field from the response, it is not directly read as a string nor it is stored in other forms, rather it is streamed from the requested URL.&#xA;&#xA;## Creating a GET request&#xA;&#xA;We can even construct a GET request using the [NewRequest](https://pkg.go.dev/net/http#NewRequest) method. This is a low-level way of creating a `GET` request. We mention the `method`, `URL`, and the `body`, in the case of `GET` request, there is nobody. So, the `NewRequest` is a general way of creating a `http` request.&#xA;&#xA;```go&#xA;// web/methods/get/newreq.go&#xA;&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;reqURL := &#34;https://www.google.com&#34;&#xA;&#x9;req, err := http.NewRequest(http.MethodGet, reqURL, nil)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;resp, err := http.DefaultClient.Do(req)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(resp)&#xA;}&#xA;```&#xA;&#xA;As we can see, we construct a `GET` request using the `NewRequest` method and then use the [Do](https://pkg.go.dev/net/http#Client.Do) method to send the request to the server. The [http.DefaultClient](https://pkg.go.dev/net/http#DefaultClient) is used as a client to send the request, if we want to customize this we can create a new instance object of [http.Client](https://pkg.go.dev/net/http#Client) and use it to send requests. We will be taking a look at clients in another part of this series when we want to persist a connection or avoid connecting multiple times to the same application/URL.&#xA;&#xA;For now, we will go ahead with the DefaultClient. This will trigger the request, in this case, a `GET` request to the specified URL in the `reqURL` string. The `Do` method returns either a `http.Response` or an `error` just like the `Get` method did.&#xA;&#xA;## Reading the Response Body&#xA;&#xA;We saw some different ways to send a `GET` request, now the below example will demonstrate how to read the body of the response. The response body is read from a buffer rather than loading the entire response into memory. It makes it flexible to parse the data efficiently and as per the needs. We will see how we use the [io](https://pkg.go.dev/io) package&#39;s [ReadAll](https://pkg.go.dev/io#ReadAll) method can be used to read from the response buffer.&#xA;&#xA;```go&#xA;// web/methods/get/body.go&#xA;&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;reqURL := &#34;https://httpbin.org/html&#34;&#xA;&#x9;resp, err := http.Get(reqURL)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;// close the body object before returning the function&#xA;&#x9;// this is to avoid the memory leak&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;&#x9;// stream the data from the response body only once&#xA;&#x9;// it is not buffered in the memory&#xA;&#x9;body, err := io.ReadAll(resp.Body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(string(body))&#xA;}&#xA;```&#xA;&#xA;In the above example, we are trying to get the body from the response to the request sent at [`https://httpbin.org/html`](https://httpbin.org/html). We have used the simple `Get` method instead of `NewRequest` and `Do` for simplicity. The response is stored in `resp`, we also have added `defer resp.Body.Close()` which is to say that we will close the body reader object when the function is returned/closed. So, this means that the `Body` is not readily available data, we need to obtain/stream the data from the server. We have to receive the body in bytes as a tcp request, the body is streamed in a buffer.&#xA;&#xA;The response body is streamed from the server, which means that it&#39;s not immediately available as a complete data set. We read the body in bytes as it arrives over the network, and it&#39;s stored in a buffer, which allows us to process the data efficiently.&#xA;&#xA;### Reading Body in bytes&#xA;&#xA;We can even read the body in bytes i.e. by reading a chunk of the buffer at a time. We can use the [bytes.Buffer](https://pkg.go.dev/bytes#Buffer) container object to store the body. Then we can create a slice of bytes as `[]bytes` of a certain size and read the body into the chunk. By writing the chunk into the buffer, we get the entire body from the response.&#xA;&#xA;```go&#xA;// web/methods/get/body.go&#xA;&#xA;&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bytes&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;reqURL := &#34;https://httpbin.org/html&#34;&#xA;&#x9;resp, err := http.Get(reqURL)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;    // create a empty buffer&#xA;&#x9;buf := new(bytes.Buffer)&#xA;&#xA;    // create a chunk buffer of a fixed size&#xA;&#x9;chunk := make([]byte, 1024)&#xA;&#xA;&#x9;for {&#xA;&#x9;&#x9;// Read into buffer&#xA;&#x9;&#x9;n, err := resp.Body.Read(chunk)&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;break&#xA;&#x9;&#x9;}&#xA;        // append the chunk to the buffer&#xA;&#x9;&#x9;buf.Write(chunk[:n])&#xA;&#x9;&#x9;fmt.Printf(&#34;%s&#xA;&#34;, chunk[:n])&#xA;&#x9;}&#xA;&#xA;    // entire body stored in bytes&#xA;&#x9;fmt.Println(buf.String())&#xA;}&#xA;```&#xA;&#xA;In the above example, the body is read chunkwise buffers and obtained as a slice of bytes. We define the request as a `GET` request to the [`httpbin.org/html`](http://httpbin.org/html). We create a new Buffer as a slice of bytes with [bytes.Buffer](https://pkg.go.dev/bytes#Buffer), then we define chunk as a container to stream the response body with a particular size. We have taken `1024` bytes as the size of the chunk. Then inside an infinite for loop, we read the body as `n, err :=` [`resp.Body.Read`](http://resp.Body.Read)`(chunk)`. The code will read the body into the chunk(slice of byte) and the return value will be the size of the bytes read or an error. Then we check if there is no error, and if there is an error, we break the loop indicating we have completed reading the entire body or something went wrong. Then we write the chunk into the buffer that we allocated earlier as `buf`. This is a slice of bytes, we are basically populating the buffer with more slices of bytes.&#xA;&#xA;The entire body is then stored in the buffer as a slice of bytes. So, we have to cast it into a string to see the contents. So, this is how we can read the contents of a body in a response in chunks.&#xA;&#xA;### Parsing the JSON body with structs&#xA;&#xA;If we have the structure of the response body already decided, then we can define a struct for the response body and then we can [Unmarshal](https://doc.akka.io/docs/akka-http/current/common/unmarshalling.html#unmarshalling:~:text=Unmarshalling,type%20T.) / deserialize/unpickle. This means we can convert the bytes representation of the data into a Golang-specific structure which is called a high-level representation of the data. We can parse the JSON body into a defined struct using [Unmarshal](https://pkg.go.dev/encoding/json#Unmarshal) or [Decode](https://pkg.go.dev/encoding/json#Decoder.Decode) methods in the [json](https://pkg.go.dev/encoding/json) package.&#xA;&#xA;Let&#39;s look at both the methods.&#xA;&#xA;#### Using Unmarshal&#xA;&#xA;The `Unmarshal` method takes in two parameters i.e. the body in bytes and the reference of the object that we want to unmarshal into. The method returns an error if there is a discrepancy in the returned JSON or the structure defined it is unable to deserialize the JSON object into the defined structure.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type Product struct {&#xA;&#x9;ID                 int      `json:&#34;id&#34;`&#xA;&#x9;Title              string   `json:&#34;title&#34;`&#xA;&#x9;Description        string   `json:&#34;description&#34;`&#xA;&#x9;Price              float64  `json:&#34;price&#34;`&#xA;&#x9;DiscountPercentage float64  `json:&#34;discountPercentage&#34;`&#xA;&#x9;Rating             float64  `json:&#34;rating&#34;`&#xA;&#x9;Stock              int      `json:&#34;stock&#34;`&#xA;&#x9;Brand              string   `json:&#34;brand&#34;`&#xA;&#x9;Category           string   `json:&#34;category&#34;`&#xA;    Thumbnail          string   `json:&#34;thumbnail,omitempty&#34;`&#xA;    Images             []string `json:&#34;-&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;reqURL := &#34;https://dummyjson.com/products/1&#34;&#xA;&#x9;resp, err := http.Get(reqURL)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;&#x9;body, err := io.ReadAll(resp.Body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;&#x9;var data Product&#xA;&#x9;if err := json.Unmarshal(body, &amp;data); err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;&#x9;fmt.Println(data)&#xA;&#x9;fmt.Println(data.Title)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;{1 iPhone 9 An apple mobile which is nothing like apple 549 12.96 4.69 94 Apple smartphones https://cdn.dummyjson.com/product-images/1/thumbnail.jpg []}&#xA;iPhone 9&#xA;```&#xA;&#xA;In the above example, we have defined a structure called Product with fields such as `ID`, `Title`, `Description`, etc. We use the JSON tag to specify how each field should be encoded to or decoded from JSON. These tags guide the Golang JSON encoders and decoders to correctly map JSON data to struct fields and vice versa. The `omitempty` option in a struct tag instructs the encoder to omit the field from the JSON output if the field&#39;s value is the zero value for its type (e.g., 0 for integers, &#34;&#34; for strings, nil for pointers, slices, and maps). This is useful for reducing the size of the JSON output by excluding empty or default-valued fields.&#xA;&#xA;Conversely, the `-` option in a struct tag tells the encoder and decoder to completely ignore the field. It will not be included in encoded JSON, nor will it be populated when decoding JSON into a struct. This is particularly useful for excluding fields that are meant for internal use only and should not be exposed through JSON.&#xA;&#xA;Therefore, `omitempty` is used to control the inclusion of fields in the JSON output based on their values, while `-` is used to exclude fields from both encoding and decoding from JSON.&#xA;&#xA;We send the `GET` request to the api `https://dummyjson.com/products/1`. The response from the request is read into a slice of bytes with [io.ReadAll](https://pkg.go.dev/io#ReadAll) that takes in a [io.Reader](https://pkg.go.dev/io#Reader) object in this case it is the `resp.Body` and it returns a slice of byte and error if any issue arises while reading in the body. Further, we can use the [Unmarshal](https://pkg.go.dev/encoding/json#Unmarshal) method to parse the slice of body `body` into the struct `Product` with the variable `data`, the reference to `&amp;data` indicates that the method will directly mutate/change this variable and populate the object with the fields from the body.&#xA;&#xA;&#xA;So in a gist, to convert the JSON body into a golang native structure with `Unmarshal` with the following steps:&#xA;&#xA;- Read the body into a slice of bytes using `io.ReadAll`&#xA;- Create an object of the struct&#xA;- Pass the body as a slice of bytes and the reference of that object (struct instance) into the Unmarshal method&#xA;- Access the object with the fields in the struct&#xA;&#xA;In the output response, we can see the object is populated with the fields from the body. The `Title` field is accessed using the `data.Title` as we do with a normal golang struct. The `Images` field is not populated because we have always ignored/omitted from the json tag with `-`.&#xA;&#xA;#### Using Decoder&#xA;&#xA;Similar to the `Unmarshal` we can use the [Decoder](https://pkg.go.dev/encoding/json#Decoder) to parse the body into a struct. However, the parameters it takes are a bit different and it is a two-step process. We first create a [Decoder](https://pkg.go.dev/encoding/json#Decoder) object using the [NewDecoder](https://pkg.go.dev/encoding/json#NewDecoder) method, which takes in a `io.Reader` object, luckily the body from the response is already in that structure, so we can directly pass that `resp.Body` into the `NewDecoder` method. The second step is to decode the data into the object, here as well, we need to create the object of the struct and parse the reference to the object to the [Decode](https://pkg.go.dev/encoding/json#Decoder.Decode) method. The `Decode` method converts the bytes parsed in the `resp.Body` from the `Decoder` object and populates the fields of the object provided in the reference struct.&#xA;&#xA;So the steps for deserializing the json object into the struct with the decode method are:&#xA;&#xA;- Create a decoder with `NewDecoder` method and pass the `resp.Body` as the parameter which is an `io.Reader` object&#xA;- Create an object of the struct&#xA;- Decode the body into that object using the `decoder.Decode` method&#xA;- Access the object with the fields in the struct&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type Product struct {&#xA;&#x9;ID                 int     `json:&#34;id&#34;`&#xA;&#x9;Title              string  `json:&#34;title&#34;`&#xA;&#x9;Description        string  `json:&#34;description&#34;`&#xA;&#x9;Price              float64 `json:&#34;price&#34;`&#xA;&#x9;DiscountPercentage float64 `json:&#34;discountPercentage&#34;`&#xA;&#x9;Rating             float64 `json:&#34;rating&#34;`&#xA;&#x9;Stock              int     `json:&#34;stock&#34;`&#xA;&#x9;Brand              string  `json:&#34;brand&#34;`&#xA;&#x9;Category           string  `json:&#34;category&#34;`&#xA;    Thumbnail          string   `json:&#34;thumbnail,omitempty&#34;`&#xA;    Images             []string `json:&#34;-&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;reqURL := &#34;https://dummyjson.com/products/1&#34;&#xA;&#x9;resp, err := http.Get(reqURL)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer resp.Body.Close()&#xA;&#xA;&#x9;var data Product&#xA;&#x9;decoder := json.NewDecoder(resp.Body)&#xA;    err = decoder.Decode(&amp;data)&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;&#xA;&#x9;fmt.Println(data)&#xA;&#x9;fmt.Println(data.Title)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;{1 iPhone 9 An apple mobile which is nothing like apple 549 12.96 4.69 94 Apple smartphones https://cdn.dummyjson.com/product-images/1/thumbnail.jpg []}&#xA;iPhone 9&#xA;```&#xA;&#xA;&#xA;We have first defined the struct `Product` with the `json:&#34;id&#34;` tag. As explained earlier, we have used the json tags to identify the fields from the json data to the structures while encoding and decoding.&#xA;In the above example, we have sent a `GET` request to the api endpoint `https://dummyjson.com/products/1`, and we have created a new decoder with the `NewDecoder` method with the `resp.Body` as the parameter. The `data` is created as a `Product` instance. The reference to `data` is parsed to the `Decode` method from the `decoder` instance as `&amp;data`. This method will either return `nil` or an `error`. Thereafter, we can check for errors and then only access the data object with its populated fields from the response body.&#xA;&#xA;There is a certain difference between the `Unmarshal` and `Decode` methods. The difference is just a slight performance improvement in the `NewDecoder` and `Decode` methods. Though it is not significant, having a little info about it might be handy in your use case. Read here for more info : [To Unmarshal or Decode](https://dev.to/jpoly1219/to-unmarshal-or-to-decode-json-processing-in-go-explained-5870)&#xA;&#xA;## Adding Headers to a GET Request&#xA;&#xA;We can even add headers before sending a `GET` request to a URL. By creating a `Request` object with the `NewRequest` method and adding a [Header](https://pkg.go.dev/net/http#Header) with the [Add](https://pkg.go.dev/net/http#Header.Add) method. The `Add` method will take in two parameters i.e. the key of the header, and the value of the header both as strings.&#xA;&#xA;```go&#xA;// web/methods/get/header.go&#xA;&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;req, err := http.NewRequest(http.MethodGet, &#34;https://api.github.com/users/mr-destructive&#34;, nil)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;req.Header.Add(&#34;Authorization&#34;, &#34;token YOUR_TOKEN&#34;)&#xA;&#x9;resp, err := http.DefaultClient.Do(req)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;defer resp.Body.Close()&#xA;&#x9;body, err := io.ReadAll(resp.Body)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(string(body))&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run web/methods/get/header.go&#xA;&#xA;{&#34;message&#34;:&#34;Bad credentials&#34;,&#34;documentation_url&#34;:&#34;https://docs.github.com/rest&#34;}&#xA;```&#xA;&#xA;In the above example, we have created a `GET` request to the [`https://api.github.com/users/mr-destructive`](https://api.github.com/users/mr-destructive) the last portion is the username, it could be any valid username. The request is to the GitHub API, so it might require API Key/Tokens in the headers, however, if there are certain endpoints that do not require Authorization headers might work just fine.&#xA;&#xA;So, the above code will give `401` error indicating the request has wrong or invalid credentials, if we remove the header, the request will work fine. This is just an example, but headers are useful in working with APIs.&#xA;&#xA;Without adding the header:&#xA;&#xA;```&#xA;$ go run web/methods/get/header.go&#xA;&#xA;{&#34;login&#34;:&#34;Mr-Destructive&#34;,&#34;id&#34;:40317114,&#34;node_id&#34;:&#34;MDQ6VXNlcjQwMzE3MTE0&#34;,&#34;avatar_url&#34;:&#34;https://avatars.githubusercontent.com/u/40317114?v=4&#34;,&#34;gravatar_id&#34;:&#34;&#34;,&#34;url&#34;:&#34;https://api.github.com/users/Mr-Destructive&#34;,&#xA;... &#xA;&#34;updated_at&#34;:&#34;2023-10-10T17:57:22Z&#34;}&#xA;```&#xA;&#xA;That&#39;s it from the 33rd part of the series, all the source code for the examples are linked in the GitHub on the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/web/methods/get/) repository.&#xA;&#xA;[100-days-of-golang](https://github.com/Mr-Destructive/100-days-of-golang)&#xA;&#xA;## References&#xA;&#xA;- [To Unmarshal or Decode](https://dev.to/jpoly1219/to-unmarshal-or-to-decode-json-processing-in-go-explained-5870)&#xA;- [Golang JSON tutorial](https://drstearns.github.io/tutorials/gojson/)&#xA;- [Golang OmitEmpty](https://www.sohamkamani.com/golang/omitempty/)&#xA;&#xA;## Conclusion&#xA;&#xA;From this article, we explored the `GET` HTTP method in golang. By using a few examples for creating a get request, adding headers, reading response body, the basic use cases were demonstrated.&#xA;&#xA;Hopefully, you found this section helpful, if you have any comments or feedback, please let me know in the comments section or on my social handles. Thank you for reading. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang Web: URL Parsing</title>
      <link>meetgor.com/golang-web-url-parsing</link>
      <description>Understanding the fundamentals of web development with URL parsing in Golang. Intro to the net package in golang.</description>
      <pubDate>Tue, 05 Sep 2023 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;We have done around 32 posts on the fundamental concepts in golang, With that basic foundation, I&#39;d like to start with the new section of this series which will be a major one as `web-development`. This section will have nearly 40-50 posts, this will cover the fundamental concepts for web development like APIs, Database integrations, Authentication and Authorizations, Web applications, static sites, etc.&#xA;&#xA;## What is a URL?&#xA;&#xA;A URL is a Uniform Resource Locator. It is a string of characters that identifies a resource on the Internet. URLs are the building blocks of the web, allowing us to access websites, documents, and data with just a click. URLs are all over the place, if we want to build a strong foundation in web development, it&#39;s quite important to understand what URLs actually mean and what can they store.&#xA;&#xA;A URL looks something like this:&#xA;&#xA;```&#xA;[scheme:][//[userinfo@]host][/]path[?query][#fragment]&#xA;```&#xA;&#xA;Not all the URLs are like this, majority of the URLs that the common user sees are simply the ones with the `scheme`, `host`, and `paths`. However other components are equally important and are vital in the exchanging of information over the network. &#xA;&#xA;- The `scheme` is the protocol used for accessing the resource like `http`, `https`, `ftp`, etc.&#xA;- The `userinfo` is the username and password used to access the resource.&#xA;- The `host` is the domain name of the resource.&#xA;- The `path` is the path or folder to the resource.&#xA;- The `query` is the query string of the resource. It is usually a key-value pair as a paramter to access resources.&#xA;- The `fragment` is used as a reference within the resource.&#xA;&#xA;We will see the use cases of most of them throughout this series for example, the `userinfo` is commonly used in accessing databases over the internet/cloud. The query parameters will be used in making dynamic API calls, etc.&#xA;&#xA;## Basic URL Parsing&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/url&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// simple url&#xA;&#x9;urlString := &#34;http://www.google.com&#34;&#xA;&#x9;parsedUrl, err := url.Parse(urlString)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(parsedUrl)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;http://www.google.com&#xA;```&#xA;&#xA;&#xA;So, what is getting parsed here, we gave the URL as a string we get the URL back, the only difference is that instead of the URL being a string, it is now a structure of components. For instance, we want the protocol the host name, the port, etc. from the URL.&#xA;&#xA;&#xA;```&#xA;fmt.Printf(&#34;%T&#xA;&#34;, parsedUrl)&#xA;// *url.URL&#xA;```&#xA;&#xA;The `parsedUrl` is a pointer to a [url.URL](https://pkg.go.dev/net/url#URL) structure. The structure `url.URL` has a lot of components to it like `Scheme`, `Host`, `User`, `Path`, `RawQuery`, etc. We will dive into each of these soon.&#xA;&#xA;We could get those specific components ourselves, but that would be a bit tedious and might be even prone to bugs.&#xA;&#xA;Let&#39;s try to get those components from the URL without any functions, just string manipulation.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    urlString := &#34;http://www.google.com&#34;&#xA;    protocol := urlString.split(&#34;:&#34;)[0]&#xA;    hostName := urlString.split(&#34;//&#34;)[1]&#xA;    fmt.Println(protocol)&#xA;    fmt.Println(hostName)&#xA;}&#xA;```&#xA;&#xA;This might work for a simple URL, but what if we have more complex URLs which have paths, query parameters, fragments, username, port, etc? This could mess up quickly if we tried to get the parts of the URL ourselves. So, golang has a package called [net/url](https://pkg.go.dev/net/url) explicitly for parsing URLs.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;urlString := []string{&#34;http://www.google.com&#34;,&#xA;&#x9;&#x9;&#34;http://www.google.com/about/&#34;,&#xA;&#x9;&#x9;&#34;http://www.google.com/about?q=hello&#34;,&#xA;&#x9;&#x9;&#34;http://www.google.com:8080/about?q=hello&#34;,&#xA;&#x9;&#x9;&#34;http://user:password@example.com:8080/path/to/resource?query=value#fragment&#34;,&#xA;&#x9;}&#xA;&#x9;for _, url := range urlString {&#xA;&#x9;&#x9;hostStr := strings.Split(url, &#34;//&#34;)[1]&#xA;        hostName := strings.Split(hostStr, &#34;/&#34;)[0]&#xA;&#x9;&#x9;fmt.Println(hostName)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;www.google.com&#xA;www.google.com&#xA;www.google.com&#xA;www.google.com:8080&#xA;user:password@example.com:8080&#xA;```&#xA;&#xA;The above code might work for most of the URLs, but what if we have a more complex URL like the one with `port` or `user`, it doesn&#39;t give the thing we want exactly. In the above example, we have created a list of URLs as strings and simply iterated over each of the `url` in the `urlString`. Thereafter, we split the `url` on `//` so we get `https:` and `www.google.com`, if we want the host/domain name, we could simply get the `1` index in the slice since the [strings.Split](https://pkg.go.dev/strings#Split) method returns a slice after splitting the string with the provided separator. The `hostName` could be fetched from the `1` index. However, this time for the 2nd element in the list, we have `https://www.google.com/about`, which would return `www.google.com/about` as the hostname which is not ideal, so we will again have to split this string with `/` and grab the first part i.e. 0th index.&#xA;&#xA;The above code would work for `paths` and `query` parameters but if we had ports, and username, and password, it would not work as expected as evident from the last 2 examples in the list.&#xA;&#xA;So, now we know the downsides of manually parsing the URLs, we can use the [net/url](https://pkg.go.dev/net/url) package to do it for us.&#xA;&#xA;## Parsing DB URLs&#xA;&#xA;Databases have a connection URL or connection string which provides a standard way to connect to a database/database server. The format of the URL is just the `URL` with all the components from the `scheme` to the `path`. The common examples of some database connection URLs might include:&#xA;&#xA;&#xA;```&#xA;# PostgreSQL DB Connection URL/string&#xA;postgresql://username:password@hostname:port/database_name&#xA;&#xA;# MongoDB Connection URL/string&#xA;mongodb://username:password@hostname:port/database_name&#xA;```&#xA;&#xA;The above are examples of the Postgres and MongoDB connection URLs, they have a `protocol` which usually for databases is their short name, the user credentials i.e. `username` and `password`, the `hostname` i.e. the server IP address, the `port` on which the database is running, and finally the path as the `database name`.&#xA;&#xA;We can construct a simple snippet in golang to grab all the details from the simple connection URL string with the `net/url` package.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/url&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;//postgres db url&#xA;&#x9;dbUrl, err := url.Parse(&#34;postgres://admin:pass1234@localhost:5432/mydb&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(dbUrl)&#xA;&#x9;fmt.Println(&#34;Scheme/Protocol = &#34;, dbUrl.Scheme)&#xA;&#x9;fmt.Println(&#34;User = &#34;, dbUrl.User)&#xA;&#x9;//fmt.Println(&#34;User = &#34;, dbUrl.User.String())&#xA;&#x9;fmt.Println(&#34;Username = &#34;, dbUrl.User.Username())&#xA;&#x9;password, _ := dbUrl.User.Password()&#xA;&#x9;fmt.Println(&#34;Password = &#34;, password)&#xA;&#x9;fmt.Println(&#34;Host = &#34;, dbUrl.Host)&#xA;&#x9;fmt.Println(&#34;HostName = &#34;, dbUrl.Hostname())&#xA;&#x9;fmt.Println(&#34;Port = &#34;, dbUrl.Port())&#xA;&#x9;fmt.Println(&#34;DB Name = &#34;, dbUrl.Path)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;postgres://postgres:pass1234@localhost:5432/mydb&#xA;Scheme/Protocol =  postgres&#xA;User = admin:pass1234&#xA;Username =  admin&#xA;Password =  pass1234&#xA;Host =  localhost:5432&#xA;HostName =  localhost&#xA;Port =  5432&#xA;DB Name =  mydb&#xA;```&#xA;&#xA;In the above code, we have given the string `postgres://admin:pass1234@localhost:5432/mydb`, and we have parsed the URL using the `net/url` package. The result is we have a `parsedUrl` object which has all the components that can be accessed as either fields or methods. Let&#39;s break down each field/method we used in the above example:&#xA;&#xA;- The `Scheme` is simply a string representing the protocol of the resource(URL).&#xA;- The `User` is the [UserInfo](https://pkg.go.dev/net/url#Userinfo) object having immutable username and password fields.&#xA;- The `Username` is the method on [UserInfo](https://pkg.go.dev/net/url#Userinfo.Username) that returns the string representing the username of the URL.&#xA;- The `Password` is the method on [UserInfo](https://pkg.go.dev/net/url#Userinfo.Password) that returns the string representing the password of the URL.&#xA;- The `Host` is the field on `URL` as a string representing the host:port of the URL.&#xA;- The `Hostname` is the method on [URL](https://pkg.go.dev/net/url#URL.Hostname) that returns the string representing the hostname of the URL.&#xA;- The `Port` is the method on [URL](https://pkg.go.dev/net/url#URL.Port) that returns the string representing the port of the URL.&#xA;- The `Path` is the field as the string representing the path of the URL.&#xA;&#xA;So, this is how we can get almost every detail like `db protocol`, `username`, `password`, `hostname`, `port`, and the `database name` from the database connection string URL.&#xA;&#xA;&#xA;## Parsing Query Parameters&#xA;&#xA;We can even get the query parameters of a URL using the [Query](https://pkg.go.dev/net/url#URL.Query) method on the `URL` object. The `Query` method returns a `map[string][]string` which is to say a map with the key as `string` and the value as a `[]string` slice of string. For example, if the URL is something like `https://google.com/?q=hello`, the `Query` method will return `map[q:[hello]]` which means the key is `q` and the value is a list of strings of which the only element is `hello`.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/url&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// a complex url with query params&#xA;&#x9;urlStr := &#34;http://www.google.com/?q=hello&amp;q=world&amp;lang=en&#34;&#xA;&#x9;parsedUrl, err := url.Parse(urlStr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(parsedUrl)&#xA;&#x9;fmt.Println(parsedUrl.Query())&#xA;&#x9;for k, v := range parsedUrl.Query() {&#xA;&#x9;&#x9;fmt.Println(&#34;KEY:&#34;, k)&#xA;&#x9;&#x9;for _, vv := range v {&#xA;&#x9;&#x9;&#x9;fmt.Println(vv)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;http://www.google.com/?q=hello+world&amp;lang=en&amp;q=gopher&#xA;map[lang:[en] q:[hello world gopher]]&#xA;KEY: q&#xA;hello world&#xA;gopher&#xA;KEY: lang&#xA;en&#xA;```&#xA;&#xA;We have taken a bit of a complex example that might cover many use cases of the `Query` method. We have a URL as `http://www.google.com/?q=hello&amp;q=world&amp;lang=en`, and the `Query` method returns `map[lang:[en] q:[hello world]]` which means the `q` key has a slice of a string with elements `hello world` and `gopher` and the `lang` key has a value of `en`. Here, the first paramter, `q=hello+world` is basically `hello world` or `hello%20world`, which is to say escaping the space in the URL. We can have multiple values for the same key, which is evident as we have added `q=gopher` at the end of the `URL`, the key `q` has two elements in the slice as `hello world` and `gopher`. The `lang=en` is simply a key as `lang` with the only element as `en` in the slice. We use `&amp;` to separate different query parameters in the URL.&#xA;&#xA;### Checking Values in Query Parameters&#xA;&#xA;We can even check the values in the query parameters without requiring the construction of for loops to find a particular value in a key. The [Values](https://pkg.go.dev/net/url#Values) is a type that stores the map as a return value from the `Query` method. It has a few handy methods like:&#xA;- [Has](https://pkg.go.dev/net/url#Values.Has) to check if the key exists in the map (paramter as key `string` and returns a `bool`).&#xA;- [Get](https://pkg.go.dev/net/url#Values.Get) to fetch the first value of the given key as a string or if not present then returns an empty string (paramter as key `string` and returns `string`).&#xA;- [Add](https://pkg.go.dev/net/url#Values.Add) method is used to append the value for a given key (paramter as key `string` and value to be added as `string`).&#xA;- [Set](https://pkg.go.dev/net/url#Values.Set) method is used to replace the value for a given key if already exists (paramter as key `string` and value as `string`).&#xA;- [Del](https://pkg.go.dev/net/url#Values.Del) method is used to delete the value for a given key (paramter as key `string`).&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/url&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// a complex url with query params&#xA;&#x9;urlStr := &#34;http://www.google.com/?q=hello+world&amp;lang=en&amp;q=gopher&#34;&#xA;&#x9;parsedUrl, err := url.Parse(urlStr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(parsedUrl)&#xA;&#x9;fmt.Println(parsedUrl.Query())&#xA;&#xA;&#x9;queryParams := parsedUrl.Query()&#xA;&#xA;&#x9;fmt.Println(queryParams.Get(&#34;q&#34;))&#xA;&#xA;&#x9;fmt.Println(queryParams.Has(&#34;q&#34;))&#xA;&#xA;&#x9;if queryParams.Has(&#34;lang&#34;) {&#xA;&#x9;&#x9;fmt.Println(queryParams.Get(&#34;lang&#34;))&#xA;&#x9;}&#xA;&#xA;&#x9;queryParams.Add(&#34;q&#34;, &#34;ferris&#34;)&#xA;&#x9;fmt.Println(queryParams)&#xA;&#xA;&#x9;queryParams.Set(&#34;q&#34;, &#34;books&#34;)&#xA;&#x9;fmt.Println(queryParams)&#xA;&#xA;&#x9;queryParams.Del(&#34;q&#34;)&#xA;&#x9;fmt.Println(queryParams)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;http://www.google.com/?q=hello+world&amp;lang=en&amp;q=gopher&#xA;hello world&#xA;true&#xA;en&#xA;map[lang:[en] q:[hello world gopher ferris]]&#xA;map[lang:[en] q:[books]]&#xA;map[lang:[en]]&#xA;```&#xA;&#xA;The above code example demonstrates almost all the methods available on the `Values` type. The `Get` method is used to fetch the first value for a given key, so we parse the key as a `string` to the method and it would return a `string`. We checked for the `q` as the key and it returned the first element in the `queryParams` for key `q` as `hello world` from the list `[hello world, gopher]`. The `Has` method takes in the paramter as key as `string` and returns if the key exists in the `queryParams` or not as a bool. The `Add` method, we have used to `Add` a key with a particular value, we added the value `ferris` to the key `q` hence it appended to the list and the list of `queryParams[q]` became `[hello world, gopher, ferris]`. The `Set` method is used to override the existing key with a particular value, here we have set the value `books` to the key `q` and hence the list of `queryParams[q]` becomes `[books]`. We can use the `Del` method to remove the key from the `queryParams`, so we delete `q` from `queryParams`, then the `queryParams` simply has no key as `q` in it.&#xA;&#xA;### Parsing Query Parameters to String&#xA;&#xA;Now, that you have manipulated the query parameters, let&#39;s say you want to construct back that string representation of the query particular or the URL for it. The [Encode]() method is used to grab the `queryParams` i.e. `Values` object and convert it into the `string` representation of the encoded URL.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/url&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// a complex url with query params&#xA;&#x9;urlStr := &#34;http://www.google.com/?q=hello+world&amp;lang=en&amp;q=gopher&#34;&#xA;&#x9;parsedUrl, err := url.Parse(urlStr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;    queryParams := parsedUrl.Query()&#xA;    queryParams.Add(&#34;name&#34;, &#34;ferris&#34;)&#xA;&#xA;    q := queryParams.Encode()&#xA;    fmt.Println(q)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;lang=en&amp;name=ferris&amp;q=hello+world&amp;q=gopher&#xA;```&#xA;&#xA;So, we can see the `Encode` method has given a query parameter in the form of a URL encoded string. We first grab the query parameters from the `parsedUrl` which is a `URL` object via the `Query` method, we then `Add` the key `name` with a value of `ferris` to the `queryParams`. This is then used to `Encode` the object back to a string representation. This could be useful to construct a query paramter for requesting other websites/APIs.&#xA;&#xA;## Parsing URL object back to String&#xA;&#xA;We can even get the `URL` object back to a string representation using the [String](https://pkg.go.dev/net/url#URL.String) method on the `URL` object. The `String` method returns a `string` representation of the URL object.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/url&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;urlStr := &#34;http://www.google.com/?q=hello+world&amp;lang=en&amp;q=gopher&#34;&#xA;&#x9;fmt.Println(&#34;URL:&#34;, urlStr)&#xA;&#x9;parsedUrl, err := url.Parse(urlStr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;queryParams := parsedUrl.Query()&#xA;&#x9;queryParams.Add(&#34;name&#34;, &#34;ferris&#34;)&#xA;&#xA;&#x9;q := queryParams.Encode()&#xA;&#x9;fmt.Println(q)&#xA;&#x9;parsedUrl.RawQuery = q&#xA;&#x9;newUrl := parsedUrl.String()&#xA;&#x9;fmt.Println(&#34;New URL:&#34;, newUrl)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;URL: http://www.google.com/?q=hello+world&amp;lang=en&amp;q=gopher&#xA;lang=en&amp;name=ferris&amp;q=hello+world&amp;q=gopher&#xA;New URL: http://www.google.com/?lang=en&amp;name=ferris&amp;q=hello+world&amp;q=gopher&#xA;```&#xA;&#xA;In the example above, we parse a URL string into a `URL` object as `parsedUrl`, then we `Add` the key `name` with a value of `ferris` to the `queryParams`. We then `Encode` the `URL` object back to a string representation. But this won&#39;t change the `parsedUrl` object we want to change the entire `URL` object. For that, we have overwritten the `RawQuery` field of the `URL` object with the query parameter encoded string as `q`. The `String` method returns a `string` representation of the `URL` object.&#xA;&#xA;## Parsing Fragments&#xA;&#xA;The fragment in a URL is usually present in a static website like `#about`, `#contact`, `#blog`, etc. The `Fragment` is a string that is usually a reference to a specific section or anchor point within a web page or resource. When a URL with a fragment is accessed, the web browser or user agent will scroll the page to display the section identified by the fragment.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/url&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// url with fragments&#xA;&#x9;urlStr := &#34;https://pkg.go.dev/math/rand#Norm Float64&#34;&#xA;&#x9;parsedUrl, err := url.Parse(urlStr)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;fmt.Println(parsedUrl)&#xA;&#x9;fmt.Println(parsedUrl.Fragment)&#xA;&#x9;fmt.Println(parsedUrl.RawFragment)&#xA;&#x9;fmt.Println(parsedUrl.EscapedFragment())&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;https://pkg.go.dev/math/rand#Norm Float64&#xA;&#xA;Norm Float64&#xA;Norm Float64&#xA;Norm%20Float64&#xA;```&#xA;&#xA;The above code is used to fetch the `#Norm Float64` fragment from the URL `https://pkg.go.dev/math/rand#NormFloat64`. We can use the [Fragment](https://pkg.go.dev/net/url#URL) field in the `URL` object to get the fragment text. There is [RawFragment](https://pkg.go.dev/net/url#URL) field that is used to parse the fragment text as it is, without trying to escape any special characters in the URL. The [EscapedFragment](https://pkg.go.dev/net/url#URL.EscapedFragment) is used to parse the fragment text by escaping the characters in the URL.&#xA;&#xA;That&#39;s it from the 32nd part of the series, all the source code for the examples are linked in the GitHub on the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/web/url-parsing) repository.&#xA;&#xA;[100-days-of-golang](https://github.com/Mr-Destructive/100-days-of-golang)&#xA;&#xA;## Conclusion&#xA;&#xA;From the first post of the web development section, we covered the fundamentals of URL parsing and got a bit introduced to the `net` package, which will be heavily used for most of the core language&#39;s features for working with the web. We covered the concepts for parsing URLs, getting components of URLs from the parsed object, Database connection URL resolving, parsing query parameters, and some other URL-related concepts.&#xA;&#xA;Hopefully, you found this section helpful, if you have any comments or feedback, please let me know in the comments section or on my social handles. Thank you for reading. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Channels</title>
      <link>meetgor.com/golang-channels</link>
      <description>Understanding the core of concurrency in Go with channels and go routines. Exploring various patterns used in concurrent operations.</description>
      <pubDate>Mon, 28 Aug 2023 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In this part of the series, we will be continuing with the concurrency features of golang with channels. In the last post, we covered the fundamentals of go routines and wait groups. By leveraging those understood concepts, we will explore channels to communicate the data between various go routines.&#xA;&#xA;## What are Channels&#xA;&#xA;A golang Channel is like a pipe that lets goroutines communicate. It lets you pass values from one goroutine to another. Channels are typed i.e. you declare them with `chan` keyword followed by the type to be sent and received (e.g. `chan int`). The `chan` type specifies the type of values that will be passed through the channel. We will explore the detailed technicalities soon. Right now, we need to just focus on what problem is channels solving.&#xA;&#xA;In the previous article, we worked with go routines and wait groups which allowed us to process tasks asynchronously. However, if we wanted to access the data in between the processes, we would have to tweak the core functionality or might require global variables, however, in real-world applications, the environment is quite constrained. We would require a way to communicate data between those go routines. Channels are made just for that(more than that), but in essence, it solves that exact problem.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;ch := make(chan string)&#xA;&#x9;defer close(ch)&#xA;&#xA;&#x9;go func() {&#xA;&#x9;&#x9;message := &#34;Hello, Gophers!&#34;&#xA;&#x9;&#x9;ch &lt;- message&#xA;&#x9;}()&#xA;&#xA;&#x9;msg := &lt;-ch&#xA;&#x9;fmt.Println(msg)&#xA;}&#xA;```&#xA;&#xA;In the above code example, the channel `ch` is created of type `string` and a message is sent to the channel inside a go routine as `ch &lt;- message`, and the message is retrieved from the channel as `&lt;-ch`.&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;Hello, Gophers!&#xA;```&#xA;&#xA;Channels have two key properties:&#xA;&#xA;- Send and receive operations block until both sides are ready(i.e. there is a sender and a receiver for a channel). This allows goroutines to synchronize without explicit locks or condition variables.&#xA;- Channels are typed, so only values of the specified type can be sent and received. This provides type safety.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    ch := make(chan string)&#xA;    go func() {&#xA;        message := &#34;Hello, Gophers!&#34;&#xA;        ch &lt;- message&#xA;    }()&#xA;    fmt.Println(&lt;-ch)&#xA;    fmt.Println(&lt;-ch)&#xA;}&#xA;```&#xA;&#xA;In the same example, if we tried to add the second receiver i.e. `&lt;-ch`, it would result in a deadlock/block forever since there is no second message sent into the channel. Only one value i.e. &#34;Hello Gophers!&#34; was sent as a `message` into the channel, and that was received by the first receiver as `&lt;-ch`, however in the next receiver, there is no sender.&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;Hello, Gophers!&#xA;fatal error: all goroutines are asleep - deadlock!&#xA;&#xA;goroutine 1 [chan receive]:&#xA;main.main()&#xA;        /home/meet/code/100-days-of-golang/scripts/channels/main.go:16 +0x125&#xA;exit status 2&#xA;```&#xA;&#xA;To sum up the deadlock concept in unbuffered channels:&#xA;&#xA;- The main goroutine is waiting at the second receive operation for a second message that will never arrive (was never sent).&#xA;- The anonymous goroutine is waiting for someone to read from the channel so it can proceed with sending the second message.&#xA;&#xA;## Buffered Channels&#xA;&#xA;In Go, you can create both buffered and unbuffered channels. An unbuffered channel has no capacity to hold data, it relies on immediate communication between the sender and receiver. However, you can create a buffered channel by specifying a capacity when using the make function, like `ch := make(chan int, 5)` will create a channel with a capacity of `5` i.e. it can store a certain number of values without an immediate receiver. A buffered channel allows you to send multiple values to the channel without an immediate receiver, up to its capacity. After that, it will block until the receiver retrieves values.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;buffchan := make(chan int, 2)&#xA;&#xA;&#x9;wg := sync.WaitGroup{}&#xA;&#x9;wg.Add(2)&#xA;&#xA;&#x9;for i := 1; i &lt;= 2; i++ {&#xA;&#x9;&#x9;go func(n int) {&#xA;&#x9;&#x9;&#x9;buffchan &lt;- n&#xA;&#x9;&#x9;&#x9;wg.Done()&#xA;&#x9;&#x9;}(i)&#xA;&#x9;}&#xA;&#xA;&#x9;wg.Wait()&#xA;&#x9;close(buffchan)&#xA;&#xA;&#x9;for c := range buffchan {&#xA;&#x9;&#x9;fmt.Println(c)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run channels.go&#xA;1&#xA;2&#xA;&#xA;$ go run channels.go&#xA;2&#xA;1&#xA;```&#xA;&#xA;In this code snippet, we create a buffered channel ch with a capacity of 2. We send two values to the channel, and even though there&#39;s no immediate receiver, the code doesn&#39;t block. If we were to send a third value, it would lead to a deadlock because there is no receiver to free up space in the buffer.&#xA;&#xA;## Closing Channels&#xA;&#xA;Closing a channel is important to signal to the receiver that no more data will be sent. It&#39;s achieved using the built-in close function. After closing a channel, any further attempts to send data will result in a panic. On the receiving side, if a channel is closed and there&#39;s no more data to receive, the receive operation will yield the zero value for the channel&#39;s type.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;ch := make(chan int)&#xA;&#xA;&#x9;go func() {&#xA;&#x9;&#x9;for i := 1; i &lt;= 5; i++ {&#xA;&#x9;&#x9;&#x9;ch &lt;- i&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;close(ch)&#xA;&#x9;}()&#xA;&#xA;&#x9;for num := range ch {&#xA;&#x9;&#x9;fmt.Println(&#34;Received:&#34;, num)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;In this example, a goroutine sends numbers to the channel and then closes it. The main routine receives these numbers using a for-range loop. When the channel is closed and all values are received, the loop will terminate automatically. Keep in mind that only a sender can close the channel, to indicate the receiver to not wait for further values from the channel.&#xA;&#xA;## Select Statement for Channels&#xA;&#xA;The select statement is used for handling multiple channels. There are a few operations that can be checked with a case statement in the select block.&#xA;&#xA;|Case     |Channel Operation|&#xA;|---------|-----------------|&#xA;|         |                 |&#xA;|Sending  | chan &lt;- value   |&#xA;|         |                 |&#xA;|Receiving|    &lt;- chan      |&#xA;|         |                 |&#xA;&#xA;So, we can either check if there is a sender or a receiver available for a channel with a case statement just like a switch statement.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func sendMessage(ch chan string, message string, wg *sync.WaitGroup) {&#xA;&#x9;defer wg.Done()&#xA;&#x9;ch &lt;- message&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;var wg sync.WaitGroup&#xA;&#xA;&#x9;ch1 := make(chan string, 2)&#xA;&#x9;ch2 := make(chan string, 2)&#xA;&#x9;wg.Add(2)&#xA;&#xA;&#x9;go sendMessage(ch1, &#34;Hello, Gophers!&#34;, &amp;wg)&#xA;&#x9;go sendMessage(ch2, &#34;Hello, Hamsters!&#34;, &amp;wg)&#xA;&#xA;&#x9;go func() {&#xA;&#x9;&#x9;defer wg.Done()&#xA;&#x9;&#x9;wg.Wait()&#xA;&#x9;&#x9;close(ch1)&#xA;&#x9;&#x9;close(ch2)&#xA;&#x9;}()&#xA;&#x9;ch1 &lt;- &#34;new message to c1&#34;&#xA;&#x9;ch2 &lt;- &#34;new message to c2&#34;&#xA;&#xA;&#x9;select {&#xA;&#x9;case &lt;-ch1:&#xA;&#x9;&#x9;fmt.Println(&#34;Received from ch1&#34;)&#xA;&#x9;case ch1 &lt;- &#34;new message to c1&#34;:&#xA;&#x9;&#x9;fmt.Println(&#34;Sent to ch1&#34;)&#xA;&#x9;case &lt;-ch2:&#xA;&#x9;&#x9;fmt.Println(&#34;Received from ch2&#34;)&#xA;&#x9;case ch2 &lt;- &#34;new message to c2&#34;:&#xA;&#x9;&#x9;fmt.Println(&#34;Sent to ch2&#34;)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run channels.go&#xA;Sent to ch1&#xA;&#xA;$ go run simple.go&#xA;Received from ch1&#xA;&#xA;$ go run simple.go&#xA;Received from ch2&#xA;&#xA;$ go run simple.go&#xA;Sent to ch2&#xA;&#xA;$ go run simple.go&#xA;Received from ch1&#xA;```&#xA;The order of the messages is not guaranteed, the operation which is performed first based on the go routine will be only logged.&#xA;&#xA;In the simple example above, we have created two channels `ch1` and `ch2`, and sent two messages to them using two go routines. The main routine then waits for the messages to be received from the channels. We close the channels when the sending is done and simply check for the 4 cases i.e. the send on channel 1, receive on channel 1, and similarly for channel 2. So, that is how we can use the select statement to check which operation is being performed on the different channels, and this forms the basis for the communication between channels. We get more ease in the flow while working with channels.&#xA;&#xA;Below is an example to test which `url` or a web server is responding first to the request.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func pingGoogle(c chan string, wg *sync.WaitGroup) {&#xA;&#x9;defer wg.Done()&#xA;&#x9;res, _ := http.Get(&#34;http://google.com&#34;)&#xA;&#x9;c &lt;- res.Status&#xA;}&#xA;&#xA;func pingDuckDuckGo(c chan string, wg *sync.WaitGroup) {&#xA;&#x9;defer wg.Done()&#xA;&#x9;res, _ := http.Get(&#34;https://duckduckgo.com&#34;)&#xA;&#x9;c &lt;- res.Status&#xA;}&#xA;&#xA;func pingBraveSearch(c chan string, wg *sync.WaitGroup) {&#xA;&#x9;defer wg.Done()&#xA;&#x9;res, _ := http.Get(&#34;https://search.brave.com&#34;)&#xA;&#x9;c &lt;- res.Status&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;gogChan := make(chan string)&#xA;&#x9;ddgChan := make(chan string)&#xA;&#x9;braveChan := make(chan string)&#xA;&#xA;&#x9;var wg sync.WaitGroup&#xA;&#x9;wg.Add(3)&#xA;&#xA;&#x9;go pingDuckDuckGo(ddgChan, &amp;wg)&#xA;&#x9;go pingGoogle(gogChan, &amp;wg)&#xA;&#x9;go pingBraveSearch(braveChan, &amp;wg)&#xA;&#xA;&#x9;openChannels := 3&#xA;&#xA;&#x9;go func() {&#xA;&#x9;&#x9;wg.Wait()&#xA;&#x9;&#x9;close(gogChan)&#xA;&#x9;&#x9;close(ddgChan)&#xA;&#x9;&#x9;close(braveChan)&#xA;&#x9;}()&#xA;&#xA;&#x9;for openChannels &gt; 0 {&#xA;&#x9;&#x9;select {&#xA;&#x9;&#x9;case msg1, ok := &lt;-gogChan:&#xA;&#x9;&#x9;&#x9;if !ok {&#xA;&#x9;&#x9;&#x9;&#x9;openChannels--&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;fmt.Println(&#34;Google responded:&#34;, msg1)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;case msg2, ok := &lt;-ddgChan:&#xA;&#x9;&#x9;&#x9;if !ok {&#xA;&#x9;&#x9;&#x9;&#x9;openChannels--&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;fmt.Println(&#34;DuckDuckGo responded:&#34;, msg2)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;case msg3, ok := &lt;-braveChan:&#xA;&#x9;&#x9;&#x9;if !ok {&#xA;&#x9;&#x9;&#x9;&#x9;openChannels--&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;fmt.Println(&#34;BraveSearch responded:&#34;, msg3)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;The above example shows how to use a select statement to wait for multiple channels to be ready before proceeding with the next operation. With this example, we can get the channel that sent the response first i.e. which search engine in this case responded to the ping first. Just a bit exaggerated example but it helps in understanding the concept of the `select` statement.&#xA;&#xA;```bash&#xA;$ go run select-chan.go&#xA;&#xA;DuckDuckGo responded: 200 OK&#xA;Google responded: 200 OK&#xA;BraveSearch responded: 200 OK&#xA;&#xA;&#xA;$ go run select-chan.go&#xA;&#xA;DuckDuckGo responded: 200 OK&#xA;BraveSearch responded: 200 OK&#xA;Google responded: 200 OK&#xA;```&#xA;&#xA;Let&#39;s break each of the steps down:&#xA;&#xA;- `pingDuckDuckGo(ddgChan, &amp;wg)` is a method which sends data to the channel `ddgChan`.&#xA;- `pingGoogle(gogChan, &amp;wg)` is a method that sends data to the channel `gogChan`.&#xA;- `pingBraveSearch(braveChan, &amp;wg)` is a method that sends data to the channel `braveChan`.&#xA;- We wait for each go routine to finish using `wg.Wait()` and close the channels.&#xA;- Finally, we close the channels `gogChan`, `ddgChan`, and `braveChan` to pick up the data from the channel as `&lt;-chan` with the select case block.&#xA;- The select case will pick the first channel that is ready to receive data. Hence we get the output based on the order of which the channel responded first.&#xA;- We use the `!ok` condition to check if the channel is closed or not, we have a `openChannels` variable to keep track of the number of open channels, if there are no channels open, we simply break out of the infinite loop.&#xA;&#xA;## Directional Channels&#xA;&#xA;Channels can also be designated as &#34;send-only&#34; or &#34;receive-only&#34; to enforce certain communication patterns and enhance safety. This is done by specifying the direction when defining the channel type.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func receiver(ch &lt;-chan int, wg *sync.WaitGroup) {&#xA;&#x9;for i := range ch {&#xA;&#x9;&#x9;fmt.Println(&#34;Received:&#34;, i)&#xA;&#x9;}&#xA;&#x9;wg.Done()&#xA;}&#xA;&#xA;func sender(ch chan&lt;- int, wg *sync.WaitGroup) {&#xA;&#x9;for i := 0; i &lt; 10; i++ {&#xA;&#x9;&#x9;fmt.Println(&#34;Sent:&#34;, i)&#xA;&#x9;&#x9;ch &lt;- i&#xA;&#x9;}&#xA;&#x9;close(ch)&#xA;&#x9;wg.Done()&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;ch := make(chan int)&#xA;&#x9;wg := sync.WaitGroup{}&#xA;&#x9;wg.Add(2)&#xA;&#x9;go receiver(ch, &amp;wg)&#xA;&#x9;go sender(ch, &amp;wg)&#xA;&#x9;wg.Wait()&#xA;}&#xA;```&#xA;&#xA;In the above example, we have created a channel `ch` and sent 10 values to it using two-go routines. The main routine is waiting for the goroutines to finish before closing the channel. The `sender` sends values `0` through `9`, and the `receiver` prints whenever a value is received. In the `sender` method, we only accept the channel to send data as `chan&lt;-`, and in the `receiver` method, the channel parameter is set to only read from the channel as `&lt;-chan`.&#xA;&#xA;```bash&#xA;$ go run send-recv.go&#xA;&#xA;Sent: 0&#xA;Received: 0&#xA;Sent: 1&#xA;Sent: 2&#xA;Received: 1&#xA;Received: 2&#xA;Sent: 3&#xA;Sent: 4&#xA;Received: 3&#xA;Received: 4&#xA;Sent: 5&#xA;Sent: 6&#xA;Received: 5&#xA;Received: 6&#xA;Sent: 7&#xA;Sent: 8&#xA;Received: 7&#xA;Received: 8&#xA;Sent: 9&#xA;Received: 9&#xA;```&#xA;&#xA;When we define a parameter as a write-only channel means that the function can only send data into that channel. It cannot read data from it or close it. This pattern is helpful when you want to make sure that the function is solely responsible for producing data and not consuming or interacting with the channel&#39;s current state.&#xA;&#xA;When we define a parameter as a read-only channel, it means that the function can only receive data from that channel. It cannot close the channel or send data into it. This pattern is useful when we want to ensure that the function only consumes data from the channel without modifying it or interfering with the sender&#39;s logic.&#xA;&#xA;Additionally, the compiler will catch code trying to send on a read-only channel or receive from a write-only one.&#xA;&#xA;## Common Channel Usage Pattern&#xA;&#xA;There are a variety of ways in which channels can be used in Go. In this section, we&#39;ll explore some of the most common patterns for using channels in Go. Some of the most useful and idiomatic channel usage patterns include pipelines, fan-in and fan-out, etc.&#xA;&#xA;### Async Await pattern for Channels&#xA;&#xA;In Go, goroutines and channels enable an elegant async/await style. A goroutine can execute a task asynchronously, while the main thread awaits the result using a channel.&#xA;&#xA;The async-await pattern in Go involves initiating multiple tasks concurrently, each with its own goroutine, and then awaiting their completion before proceeding. Channels are used to communicate between these goroutines, allowing them to work independently and provide results to the main routine when ready.&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func fetchURL(url string, ch chan&lt;- http.Response) {&#xA;&#x9;go func() {&#xA;&#x9;&#x9;res, err := http.Get(url)&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;panic(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;defer res.Body.Close()&#xA;&#x9;&#x9;ch &lt;- *res&#xA;&#x9;}()&#xA;}&#xA;&#xA;func task(name string) {&#xA;&#x9;fmt.Println(&#34;Task&#34;, name)&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(&#34;Start&#34;)&#xA;&#xA;&#x9;url := &#34;http://google.com&#34;&#xA;&#xA;&#x9;respCh := make(chan http.Response)&#xA;&#xA;&#x9;fetchURL(url, respCh)&#xA;&#xA;&#x9;task(&#34;A&#34;)&#xA;&#x9;task(&#34;B&#34;)&#xA;&#xA;&#x9;response := &lt;-respCh&#xA;&#x9;fmt.Println(&#34;Response Status:&#34;, response.Status)&#xA;&#xA;&#x9;fmt.Println(&#34;Done&#34;)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run async.go&#xA;Start&#xA;Task A&#xA;Task B&#xA;Response Status: 200 OK&#xA;Done&#xA;```&#xA;&#xA;In the above example, we have created a function `fetchURL` which takes a URL and a channel as an argument. The channel `respCh` is used to communicate between the goroutines. The function fires up a goroutine that fetches the request, we send a `GET` request to the provided URL and send the response to the provided channel.  In the main function, we access the `response` by receiving the data from the channel as `&lt;-respCh`. Before doing this, we can do any other task simultaneously, like `task(&#34;A&#34;)` and `task(&#34;B&#34;)` which just prints some string(it could be anything). But this should be before we pull in from the channel, anything after the access will be blocked i.e. will be executed sequentially.&#xA;&#xA;### Pipeline pattern for Channels&#xA;&#xA;The pipeline pattern is used to chain together a sequence of processing stages, each stage consumes input, processes data, and passes the output to the next stage. This type of pattern can be achieved by chaining different channels from one go routine to another.&#xA;&#xA;![Pipeline pattern flow using channels in golang](https://meetgor-cdn.pages.dev/100-days-of-golang/channels-pipelines-pattern.png)&#xA;&#xA;So, the pipeline pattern using channels in Go, data flows sequentially through multiple stages: Stage 1 reads input and sends to Channel A, Stage 2 receives from Channel A and sends to Channel B, and Stage 3 receives from Channel B and produces the final output.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func generate(nums []int, out chan&lt;- int, wg *sync.WaitGroup) {&#xA;&#x9;fmt.Println(&#34;Stage 1&#34;)&#xA;&#x9;for _, n := range nums {&#xA;&#x9;&#x9;fmt.Println(&#34;Number:&#34;, n)&#xA;&#x9;&#x9;out &lt;- n&#xA;&#x9;}&#xA;&#x9;close(out)&#xA;&#x9;wg.Done()&#xA;}&#xA;&#xA;func square(in &lt;-chan int, out chan&lt;- int, wg *sync.WaitGroup) {&#xA;&#x9;fmt.Println(&#34;Stage 2&#34;)&#xA;&#x9;for n := range in {&#xA;&#x9;&#x9;sq := n * n&#xA;&#x9;&#x9;fmt.Println(&#34;Square:&#34;, sq)&#xA;&#x9;&#x9;out &lt;- sq&#xA;&#x9;}&#xA;&#x9;close(out)&#xA;&#x9;wg.Done()&#xA;}&#xA;&#xA;func print(in &lt;-chan int, wg *sync.WaitGroup) {&#xA;&#x9;for n := range in {&#xA;&#x9;&#x9;fmt.Println(n)&#xA;&#x9;}&#xA;&#x9;wg.Done()&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;input := []int{1, 2, 3, 4, 5}&#xA;&#xA;&#x9;var wg sync.WaitGroup&#xA;&#x9;wg.Add(3)&#xA;&#xA;&#x9;stage1 := make(chan int)&#xA;&#x9;stage2 := make(chan int)&#xA;&#xA;&#x9;go generate(input, stage1, &amp;wg)&#xA;&#xA;&#x9;go square(stage1, stage2, &amp;wg)&#xA;&#xA;&#x9;go print(stage2, &amp;wg)&#xA;&#xA;&#x9;wg.Wait()&#xA;}&#xA;```&#xA;&#xA;&#xA;In the above example, we have created a sequence of processing stages, each stage consumes input, processes data, and passes the output to the next stage. We can consider the functions `generate`, `square`, and `print` as stages `1`, `2`, and `3` respectively.&#xA;&#xA;- The generate function, takes in the input as a slice of integers, an unbuffered channel, and the waitgroup b reference, the function basically iterates over the numbers in the slice and sends it to the channel provided in the parameters.&#xA;- The square function takes in the stage1 channel that the channel from the stage1, as well as its own channel as `stage2` (remember the `stage1` channel has sent the numbers via the generating function).&#xA;- The square function then iterates over the number sent from the channel `stage1` as `in` and squares it and sends it to the channel provided as `stage2` as the `out` channel.&#xA;- The print function takes in the stage2 channel as an argument and iterates over the number sent from the channel `stage2` and prints it.&#xA;&#xA;```&#xA;$ go run pipeline.go&#xA;Stage 1&#xA;Number: 1&#xA;Stage 2&#xA;Square: 1&#xA;1&#xA;Number: 2&#xA;Number: 3&#xA;Square: 4&#xA;Square: 9&#xA;Number: 4&#xA;4&#xA;9&#xA;Square: 16&#xA;16&#xA;Number: 5&#xA;Square: 25&#xA;25&#xA;```&#xA;&#xA;So, we can see the order of the execution, both the pipelines started synchronously, However, they perform the operation only when the data is sent from the previous channel. We first print the `number` from the `generate` function, then print the squared value in the `square` function, and finally print it as `Square: value` in the print function.&#xA;&#xA;### Fan-In pattern for Channels&#xA;&#xA;The Fan-In pattern is used for combining data from multiple sources into a single stream for unified processing, often using a shared data structure to aggregate the data. We can create the fan-in pattern by merging multiple input channels into a single output channel.&#xA;&#xA;![Fan-in pattern flow using channels in golang](https://meetgor-cdn.pages.dev/100-days-of-golang/channels-fan-in-pattern.png)&#xA;&#xA;The fan-in pattern is when multiple input channels (A, B, C) are read concurrently, and their data is merged into a single output channel (M).&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;io/ioutil&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func readFile(file string, ch chan&lt;- string) {&#xA;&#x9;content, _ := ioutil.ReadFile(file)&#xA;&#x9;fmt.Println(&#34;Reading from&#34;, file, &#34;as :: &#34;, string(content))&#xA;&#x9;ch &lt;- string(content)&#xA;&#x9;close(ch)&#xA;}&#xA;&#xA;func merge(chs ...&lt;-chan string) string {&#xA;&#x9;var wg sync.WaitGroup&#xA;&#x9;out := &#34;&#34;&#xA;&#xA;&#x9;for _, ch := range chs {&#xA;&#x9;&#x9;wg.Add(1)&#xA;&#x9;&#x9;go func(c &lt;-chan string) {&#xA;&#x9;&#x9;&#x9;for s := range c {&#xA;&#x9;&#x9;&#x9;&#x9;out += s&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;wg.Done()&#xA;&#x9;&#x9;}(ch)&#xA;&#x9;}&#xA;&#xA;&#x9;wg.Wait()&#xA;&#x9;return out&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;ch1 := make(chan string)&#xA;&#x9;ch2 := make(chan string)&#xA;&#xA;&#x9;go readFile(&#34;data/f1.txt&#34;, ch1)&#xA;&#x9;go readFile(&#34;data/f2.txt&#34;, ch2)&#xA;&#xA;&#x9;merged := merge(ch1, ch2)&#xA;&#xA;&#x9;fmt.Println(merged)&#xA;}&#xA;```&#xA;&#xA;In the above example, the `readFile` function reads the contents of the file and sends it to the channels `ch1` and `ch2` from different go routines. The `readFile` takes in the channel as send only channel which reads the file and sends the content to the channel as `ch &lt;- string(content)`. The `merge` function takes in `2` it can also be `n` number of channels to parse from as indicated as `...&lt;-chan`, it iterates over each channel, and for each channel, it reads the contents, and appends as a single string.&#xA;&#xA;```bash&#xA;$ go run fan-in.go&#xA;&#xA;Reading from data/f1.txt as ::  This is from file 1&#xA;Reading from data/f2.txt as ::  This is from file 2&#xA;&#xA;This is from file 1&#xA;This is from file 2&#xA;&#xA;&#xA;$ go run fan-in.go&#xA;Reading from data/f2.txt as ::  This is from file 2&#xA;Reading from data/f1.txt as ::  This is from file 1&#xA;&#xA;This is from file 2&#xA;This is from file 1&#xA;```&#xA;&#xA;So, this is how the fan-in pattern works, We create multiple channels and combine the results into a single stream of data(in this example a single string).&#xA;&#xA;&#xA;### Fan-Out Pattern for Channels&#xA;&#xA;The Fan-Out pattern involves taking data from a single source and distributing it to multiple workers or processing units for parallel or concurrent handling. Fan-out design splits an input channel into multiple output channels, it is used to distribute branches of work or data across concurrent processes.&#xA;&#xA;![Fan-Out pattern flow using channels in golang](https://meetgor-cdn.pages.dev/100-days-of-golang/channels-fan-out-pattern.png)&#xA;&#xA;The fan-out pattern is when data from a single input channel (A) is distributed to multiple worker channels (X, Y, Z) for parallel processing.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func readFile(file string, ch chan&lt;- string, wg *sync.WaitGroup) {&#xA;&#x9;defer wg.Done()&#xA;&#xA;&#x9;content, err := os.ReadFile(file)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Printf(&#34;Error reading from %s: %v&#xA;&#34;, file, err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;ch &lt;- string(content)&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;files := []string{&#34;data/f1.txt&#34;, &#34;data/f2.txt&#34;}&#xA;&#xA;&#x9;var wg sync.WaitGroup&#xA;&#x9;ch := make(chan string)&#xA;&#xA;&#x9;for _, f := range files {&#xA;&#x9;&#x9;wg.Add(1)&#xA;&#x9;&#x9;go readFile(f, ch, &amp;wg)&#xA;&#x9;}&#xA;&#xA;&#x9;go func() {&#xA;&#x9;&#x9;wg.Wait()&#xA;&#x9;&#x9;close(ch)&#xA;&#x9;}()&#xA;&#xA;&#x9;var fileData []string&#xA;&#x9;for content := range ch {&#xA;&#x9;&#x9;fileData = append(fileData, content)&#xA;&#x9;}&#xA;&#xA;&#x9;fmt.Printf(&#34;Read %d files&#xA;&#34;, len(fileData))&#xA;&#x9;fmt.Printf(&#34;Contents:&#xA;%s&#34;, fileData)&#xA;}&#xA;```&#xA;&#xA;In the above example, we create a single channel `ch` as our single source, we loop over all the files, and create go routines calling the `readFile` function. The `readFile` function takes in the filename, channel, and the WaitGroup reference, the function reads the file and sends the content to the channel as `ch &lt;- content`. The `readFile` is called concurrently for all the files, Here we have done a fan-out of the task into multiple go routines, then in the main function, we iterate over the channel and receive the content.&#xA;&#xA;```bash&#xA;$ go run fan-out.go&#xA;&#xA;Read 2 files&#xA;Contents:&#xA;[This is from file 2&#xA; This is from file 1&#xA;]&#xA;&#xA;&#xA;$ go run fan-out.go&#xA;&#xA;Read 2 files&#xA;Contents:&#xA;[This is from file 1&#xA; This is from file 2&#xA;]&#xA;```&#xA;Here&#39;s a brief summary of the fan-out pattern from the example provided:&#xA;&#xA;- Multiple files are read concurrently using goroutines. This &#34;fans out&#34; the work.&#xA;- The `readFile` function runs in a goroutine to process each file separately.&#xA;- WaitGroup coordinates the goroutines.&#xA;- A shared channel ch collects the results from each goroutine.&#xA;- The main goroutine reads from the channel and aggregates the results.&#xA;- Channel is closed and ranged over to collect results cleanly.&#xA;&#xA;I have a few more patterns to demonstrate that have been provided in the GitHub on the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/scripts/channels/patterns/) repository.&#xA;&#xA;That&#39;s it from the 31st part of the series, all the source code for the examples are linked in the GitHub on the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/scripts/channels) repository.&#xA;&#xA;## References&#xA;&#xA;- [Channels](https://go.dev/ref/spec#Channel_types)&#xA;- [Effective Go: Channels](https://go.dev/doc/effective_go#channels)&#xA;- [Fan-In and Fan-Out](https://mariocarrion.com/2021/08/19/learning-golang-concurrency-patterns-fan-in-fan-out.html)&#xA;- [Go 101: Channels](https://go101.org/article/channel.html)&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this part of the series, we were able to understand the fundamentals of channels in golang. By using the core concepts from the previous posts like go routines and wait groups, we were able to work with channels in golang. We wrote a few examples for different patterns using concurrency concepts with channels. Patterns like pipelines, fan-in, fan-out, async, and some usage of select statements for channels were explored in this section.&#xA;&#xA;Hopefully, you found this section helpful, if you have any comments or feedback, please let me know in the comments section or on my social handles. Thank you for reading. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Go Routines and WaitGroups</title>
      <link>meetgor.com/golang-go-routines</link>
      <description>Exploring Goroutines and WaitGroups in Go, understanding the fundamentals of Go&#39;s concurrency model.</description>
      <pubDate>Sat, 29 Jul 2023 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;One of the key features that set Go apart from many other languages is its native support for Goroutines - lightweight concurrent functions that can run concurrently and efficiently manage concurrency tasks. Goroutines are an essential aspect of Go&#39;s concurrency model, enabling developers to build highly concurrent and performant applications effortlessly.&#xA;&#xA;In this blog post, we will dive into the world of Goroutines and explore how they work, why they are essential for concurrent programming in Go, and how they can greatly improve the responsiveness and efficiency of your applications. This post will cover go routines and a primer on wait groups, in the next article we will be looking deeply into channels where all these three things can be demonstrated and understood in a better and more useful way.&#xA;&#xA;## Concurrency and Parallelism&#xA;&#xA;This two concepts are quite crucial before diving into the fundamentals of concurreny.&#xA;&#xA;**Concurrency** is about dealing with multiple things at once. Concurrent programs can have several processes or threads running simultaneously on a single CPU core by rapidly switching between them (context switching). The threads are interleaved, not necessarily executing at literally the same time. The CPU can switch between these tasks to give the appearance of simultaneous progress.&#xA;&#xA;**Parallelism** is about doing multiple things at literally the same time. Parallel programs can execute multiple computations simultaneously on separate CPU cores. The threads actually execute in parallel.&#xA;&#xA;## What is a Go Routine&#xA;&#xA;A go routine is a simple lightweight thread managed by the Go runtime. In the simplest of terms, a go routine can be defined as:&#xA;&#xA;&gt; Go routine is a way to perform multiple tasks within a program, allowing different parts of the program to work simultaneously and make the most out of the resources.&#xA;&#xA;Also it can be stated as:&#xA;&#xA;A goroutine in Golang is a lightweight, independently executing function that runs concurrently with other goroutines within the same address space. In other words, it is a concurrent unit of execution.&#xA;&#xA;Focussing on the word **same address space** that will be really critical in the later sections of this article.&#xA;&#xA;## Features of Go Routines&#xA;&#xA;Go routines form a key part of Go&#39;s concurrency model. Here are some of the key features of go routines:&#xA;&#xA;- **Lightweight Thread**:&#xA;    A Go routine is often referred to as a lightweight thread.&#xA;&#xA;- **Independent Execution**:&#xA;    Go routines run independently of each other, enabling concurrent execution.&#xA;&#xA;- **Managed by Go**:&#xA;    Go routines are managed by the Go runtime, making them easy to use.&#xA;&#xA;- **Low Overhead**:&#xA;    Go routines have low memory overhead, allowing us to create thousands of them efficiently.&#xA;&#xA;- **Communication**:&#xA;    Go routines can communicate and synchronize data through channels.&#xA;&#xA;- **Asynchronous**:&#xA;    Go routines can execute asynchronously, allowing other parts of the program to continue running.&#xA;&#xA;- **Scalability**:&#xA;    Go routines are the foundation of scalable concurrent programming in Go.&#xA;&#xA;Unlike threads in other languages, goroutines are cheap and you can easily create thousands or even millions of them in a program.&#xA;&#xA;&#xA;## Example of Go Routines&#xA;&#xA;Creating a go routine is not hard, just add the keyword `go` before the function call and the go runtime will create a new go routine inside the main function or wherever is the context from. Remember, the main function is also a go routine.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func process() {&#xA;&#x9;fmt.Println(&#34;Hello World!&#34;)&#xA;&#x9;time.Sleep(time.Second)&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;start := time.Now()&#xA;&#x9;go process()&#xA;&#x9;go process()&#xA;&#x9;end := time.Now()&#xA;&#x9;duration := end.Sub(start)&#xA;&#x9;fmt.Println(duration)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;scripts/go-routines on  main via 🐹 v1.20 &#xA;$ go run main.go &#xA;&#xA;Hello World!&#xA;15.607µs&#xA;&#xA;&#xA;scripts/go-routines on  main via 🐹 v1.20 &#xA;$ go run main.go &#xA;&#xA;9.889µs&#xA;&#xA;&#xA;scripts/go-routines on  main via 🐹 v1.20 &#xA;$ go run main.go &#xA;&#xA;8.834µs&#xA;&#xA;&#xA;scripts/go-routines on  main via 🐹 v1.20 &#xA;$ go run main.go &#xA;&#xA;9.158µs&#xA;&#xA;scripts/go-routines on  main via 🐹 v1.20 &#xA;$ go run main.go &#xA;&#xA;12.54µs&#xA;&#xA;&#xA;scripts/go-routines on  main via 🐹 v1.20 &#xA;$ go run main.go &#xA;&#xA;Hello World!&#xA;Hello World!&#xA;10.19µs&#xA;&#xA;&#xA;scripts/go-routines on  main via 🐹 v1.20 &#xA;$ go run main.go &#xA;&#xA;14.1µs&#xA;&#xA;&#xA;scripts/go-routines on  main via 🐹 v1.20 &#xA;$ &#xA;```&#xA;&#xA;Quite unpredictable output right? This is a power of go-routines. It is **asynchronous** so it will not block the main function. The two function calls to `process`, are executed independently of the main function scope. The program just calls the process function and captures the output, and sequentially reaches the end of the program(main function), At this point the go routines(threads) inside the main function are stopped abruptly.&#xA;&#xA;Let&#39;s break it down if it is not clear yet.&#xA;&#xA;- The main function starts.&#xA;- `go process()` creates a Go routine and starts its execution.&#xA;- Meanwhile, another call to `go process()` creates a separate Go routine and starts its execution as well.&#xA;- Meanwhile, calculate the time difference between the main function start and end.&#xA;- Meanwhile main function ends.&#xA;&#xA;So, in summary, the main function is only able to capture the output of the `duration` as it is synchronous and if the process has been executed, it prints the `Hello World!` message. Hence we have different outputs because the uncontrolled concurrency, lack of coordination, and OS scheduling across the program runs are different. &#xA;&#xA;&#xA;&#xA;## Wait Groups&#xA;&#xA;In simple terms, WaitGroup is used to synchronize multiple goroutines and to wait for them to finish executing. This allows the go routines to be completed before the completion of the main function, hence it blocks the main function from leaving/exiting the scope.&#xA;&#xA;&gt; A WaitGroup is a synchronization primitive that allows a goroutine to wait for a collection of other goroutines to finish executing. &#xA;&#xA;- A WaitGroup is initialized with a counter representing the number of goroutines to wait for.&#xA;- The Add() method increments the counter by the given value. This is called by each goroutine to indicate it is running.&#xA;- The main goroutine calls Add() to set the initial count, then launches worker goroutines.&#xA;- A WaitGroup is typically passed by a pointer to goroutines that need to be waited on.&#xA;- The Done() method decrements the counter by 1. Goroutines call this when finished.&#xA;- Each worker calls Done() when finished, decrementing the counter.&#xA;- The Wait() method blocks until the counter reaches 0, indicating all goroutines have finished.&#xA;- Main calls Wait() to block until Done() brings counter to 0.&#xA;&#xA;This provides a simple way to synchronize multiple goroutines finishing their work with a main thread that needs to wait for them to complete. The counter ensures the main thread knows how many goroutines it is waiting for. Interacting and working with go routines with synchronization using a wait group is quite intuitive and simple to follow. Let&#39;s look at a simple example below:&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;sync&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func process(pid int, wg *sync.WaitGroup) {&#xA;&#x9;fmt.Printf(&#34;Started process %d&#xA;&#34;, pid)&#xA;&#x9;time.Sleep(1 * time.Second)&#xA;&#x9;fmt.Printf(&#34;Completed process %d&#xA;&#34;, pid)&#xA;&#x9;defer wg.Done()&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;now := time.Now()&#xA;&#x9;var wg sync.WaitGroup&#xA;&#xA;&#x9;for i := 0; i &lt; 10; i++ {&#xA;&#x9;&#x9;wg.Add(1)&#xA;&#x9;&#x9;go process(i, &amp;wg)&#xA;&#x9;}&#xA;&#x9;wg.Wait()&#xA;&#x9;fmt.Println(&#34;All processes completed&#34;)&#xA;&#x9;end := time.Now()&#xA;&#x9;fmt.Println(end.Sub(now))&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;scripts/go-routines on  main [?] via 🐹 v1.20 &#xA;$ go run wg.go &#xA;Started process 9&#xA;Started process 0&#xA;Started process 1&#xA;Started process 2&#xA;Started process 3&#xA;Started process 4&#xA;Started process 5&#xA;Started process 6&#xA;Started process 7&#xA;Started process 8&#xA;Completed process 8&#xA;Completed process 3&#xA;Completed process 9&#xA;Completed process 0&#xA;Completed process 1&#xA;Completed process 2&#xA;Completed process 5&#xA;Completed process 4&#xA;Completed process 6&#xA;Completed process 7&#xA;1.000563257s&#xA;All processes completed&#xA;&#xA;scripts/go-routines on  main [?] via 🐹 v1.20 &#xA;$ &#xA;&#xA;```&#xA;&#xA;In the above example, we have used the same function `process` but with a slight twist, we have added a process id, just an integer to represent the go routine. We print the start and completion of the function in between the sleep for 1 second. We also have a wait group. &#xA;- A [WaitGroup](https://pkg.go.dev/sync#WaitGroup) is basically a struct type defined in the [sync](https://pkg.go.dev/sync) package. &#xA;- The variable `wg` is a new wait group instance that will be used to synchronize and wait for the completion of groups of go routines. &#xA;&#xA;We create a for loop with `10` iterations, so as to spawn 10 `process` function calls. We first use the `wg.Add(1)` which says to the wait group to wait for 1 go routine. The immediate next line is a go routine `go process()` which takes in a `pid` just to track which go routine is being executed in the loop. &#xA;&#xA;Inside the `process` function, we simply say the process with the given `pid` has started as a print statement, sleeps for a second, and then print the end of the process with `pid`. The end of the function is marked with `defer wg.Done()`, this is to indicate that the go routine is completed. &#xA;&#xA;The wg(wait group) has a counter that keeps track of the number of go routines it has to synchronize or wait for them to complete. In the [Add](https://pkg.go.dev/sync#WaitGroup.Add) function, the internal counter in the `WaitGroup` is incremented by the `delta` the integer parsed as a parameter. And the [Done](https://pkg.go.dev/sync#WaitGroup.Done) function, decrements the internal counter in the `WaitGroup` which indicates that the go routine is completed.&#xA;&#xA;In the main function, we call the [wg.Wait](https://pkg.go.dev/sync#WaitGroup.Wait) which will block until the counter for the `WaitGroup` is 0 i.e. all go routines have completed their execution. So, we created 10 go routines which ran concurrently but were synchronized with the help of WaitGroups. The WaitGroup is allowed to block the main function till all the go routines are done executing.&#xA;&#xA;&#xA;## Go Routine with WaitGroup Use Cases&#xA;&#xA;Go routines can be used for creating asynchronous tasks, and also for creating concurrent tasks. By using wait groups, we can create a way to wait for multiple goroutines to complete. By using go routines and wait groups, we can complete n number of tasks in a time frame of 1 task&#39;s completion. However, to create concurrent communication between the other processes, we need `channels` (which we will explore in the next article). &#xA;&#xA;Here is a simple breakdown of what asynchronous and concurrent tasks might refer to:&#xA;&#xA;**Asynchronous** tasks run independently of the main program flow, allowing the main program to continue executing without waiting for the task&#39;s completion. For example, not blocking other tasks in the sequential flow of the main function.&#xA;&#xA;**Concurrent** tasks run simultaneously and can execute at the same time as other tasks. They make use of multiple threads (goroutines in Go&#39;s case) to achieve parallel execution. For example, running multiple tasks parallel will cut the time down for spinning each task after the completion of another task.&#xA;&#xA;Some of the asynchronous tasks that can be done with go routines might include the following:&#xA;&#xA;- Sending a mail while saving the user to the database.&#xA;- Fetch and process data from multiple websites(web scraping/crawling).&#xA;- High-performance message brokers and queuing systems for inter-process communication.&#xA;&#xA;&#xA;One practical way of using go routines with wait groups would be to send mail, we are not going to see the actual implementation of the mail-sending stuff. However, we can try to mimic how the setup might be for sending bulk mail. By creating a wait group and a list of mail addresses to send, a go routine can be created with a function that sends those emails.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func sendMail(address string, wg *sync.WaitGroup) {&#xA;&#x9;fmt.Println(&#34;Sending mail to&#34;, address)&#xA;&#x9;defer wg.Done()&#xA;    // Actual mail sending, smtp stuff&#xA;    // handle errors&#xA;&#xA;    // client, err := smtp.Dial(&#34;smtp.example.com:587&#34;)&#xA;    // errr = client.Mail(&#34;sender@example.com&#34;)&#xA;    // err = client.Rcpt(address)&#xA;    // wc, err := client.Data()&#xA;    //_, err = wc.Write([]byte(&#34;This is the email body.&#34;))&#xA;    // err = wc.Close()&#xA;    // client.Quit()&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;emails := []string{&#xA;&#x9;&#x9;&#34;recipient1@example.com&#34;,&#xA;&#x9;&#x9;&#34;recipient2@example.com&#34;,&#xA;&#x9;&#x9;&#34;xyz@example.com&#34;,&#xA;&#x9;}&#xA;&#x9;wg := sync.WaitGroup{}&#xA;    wg.Add(len(emails))&#xA;&#xA;&#x9;for _, email := range emails {&#xA;&#x9;&#x9;go sendMail(email, &amp;wg)&#xA;&#x9;}&#xA;&#x9;wg.Wait()&#xA;&#x9;fmt.Println(&#34;All emails queued for sending&#34;)&#xA;&#x9;// Do other stuff&#xA;}&#xA;```&#xA;In the above example, the `emails` is a list of email ids to send the mail. We have created a wait group that we can initialize with the total number of go routines probably to be executed. The `wg.Add` method is parsed with the number of emails to be sent hence that equals the go routines to spawn.&#xA;&#xA;So, we can then in the for loop, iterate over each mail and send the emails with the `sendMail` function as go routine. The `wg.Wait` function outside the loop, will make sure the main function is halted before all the go routines complete their execution.&#xA;&#xA;There is one more way to call a function as a go routine without changing its signature since we had to pass `wg` pointer as the WaitGroup reference to it to acknowledge the completion of the go routine. We could wrap these two operations wiz. calling the function and calling the `wg.Done` method with an anonymous function.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func sendMail(address string) {&#xA;&#x9;fmt.Println(&#34;Sending mail to&#34;, address)&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;emails := []string{&#xA;&#x9;&#x9;&#34;recipient1@example.com&#34;,&#xA;&#x9;&#x9;&#34;recipient2@example.com&#34;,&#xA;&#x9;&#x9;&#34;xyz@example.com&#34;,&#xA;&#x9;}&#xA;&#x9;wg := sync.WaitGroup{}&#xA;&#x9;wg.Add(len(emails))&#xA;&#xA;&#x9;for _, email := range emails {&#xA;&#x9;&#x9;mail := email&#xA;&#x9;&#x9;go func(m string) {&#xA;&#x9;&#x9;&#x9;sendMail(m)&#xA;&#x9;&#x9;&#x9;wg.Done()&#xA;&#x9;&#x9;}(mail)&#xA;&#x9;}&#xA;&#x9;wg.Wait()&#xA;&#x9;fmt.Println(&#34;All emails queued for sending&#34;)&#xA;&#x9;// Do other stuff&#xA;}&#xA;```&#xA;&#xA;This does the exact same thing, but we don&#39;t have to change the signature of the function, This keeps the functional logic of the function in its place and handles the concurrency on the go.&#xA;&#xA;```go&#xA;&#xA;for _, email := range emails {&#xA;    mail := email&#xA;    go func(m string) {&#xA;        sendMail(m)&#xA;        wg.Done()&#xA;    }(mail)&#xA;}&#xA;```&#xA;&#xA;If the above bit scares you, don&#39;t worry it&#39;s too simple. &#xA;&#xA;- We are iterating over the email slice using a for loop and creating a Go routine for each email address. The loop variable email represents the email address at the current iteration.&#xA;- However, to avoid the loop variable capture issue (where all Go routines would share the same email variable), we create a new variable mail and assign the value of email to it. This step ensures that each Go routine captures its own copy of the email address.&#xA;- We immediately create an anonymous function (a closure) using the go keyword. This anonymous function takes the `mail` variable as a parameter m and is executed concurrently as a Go routine. Inside the Go routine, we call the `sendMail` function with the email address `m`.&#xA;- After the `sendMail` call has been executed i.e. email has been sent, we call wg.Done() to notify the WaitGroup that the Go routine has completed its work. This allows the WaitGroup to properly synchronize and wait for all Go routines to finish before the program proceeds beyond wg.Wait() in the main function.&#xA;&#xA;This is one way to do it if you want to separate the mail-sending logic from the goroutines/concurrency task. However, this should be handled with care as the variables inside the closure might be shared among all the goroutines instead of having individual variable literals. &#xA;&#xA;To ensure that each goroutine operates on its own copy of the email address, we use the approach of creating a new variable mail and passing it as a parameter to the anonymous function. This way, each goroutine captures its unique email address, avoiding any interference or unintended sharing of data between goroutines.&#xA;&#xA;## Mutual Exclusion Locks&#xA;&#xA;In the previous examples, we saw how goroutines and wait groups allow us to run multiple tasks concurrently in Go. However, sometimes these concurrent goroutines need to access shared resources like memory, files, network sockets, etc.&#xA;&#xA;When more than one goroutine tries to access a resource at the same time, it can lead to **race conditions** and unpredictable behavior. To handle this, we need a way to ensure only one goroutine can access the resource at a time.&#xA;&#xA;This is where mutual exclusion locks come in. A **mutual exclusion lock**, or **mutex**, provides a mechanism to lock access to a shared resource. It ensures only one goroutine at a time can acquire the lock, blocking other goroutines until the lock is released.&#xA;&#xA;For example, say we have multiple goroutines trying to append data to the same memory buffer(could be file/database/etc.) concurrently:&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func WriteToFile(filename string, contents string, buffer *[]byte, wg *sync.WaitGroup) {&#xA;&#x9;defer wg.Done()&#xA;&#x9;*buffer = append(*buffer, []byte(contents)...)&#xA;&#x9;err := os.WriteFile(filename, *buffer, 0644)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;var wg sync.WaitGroup&#xA;&#x9;var sharedBuffer []byte&#xA;&#xA;&#x9;wg.Add(2)&#xA;&#x9;go WriteToFile(&#34;data/f1.txt&#34;, &#34;Hello &#34;, &amp;sharedBuffer, &amp;wg)&#xA;&#x9;go WriteToFile(&#34;data/f1.txt&#34;, &#34;World! &#34;, &amp;sharedBuffer, &amp;wg)&#xA;&#x9;wg.Wait()&#xA;&#xA;&#x9;fmt.Println(string(sharedBuffer))&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run --race no-mutex.go&#xA;==================&#xA;WARNING: DATA RACE&#xA;Read at 0x00c000012030 by goroutine 8:&#xA;  main.WriteToFile()&#xA;      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:11 +0xe7&#xA;  main.main.func2()&#xA;      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:24 +0x64&#xA;&#xA;Previous write at 0x00c000012030 by goroutine 7:&#xA;  main.WriteToFile()&#xA;      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:11 +0x16a&#xA;  main.main.func1()&#xA;      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:23 +0x64&#xA;&#xA;Goroutine 8 (running) created at:&#xA;  main.main()&#xA;      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:24 +0x1f6&#xA;&#xA;Goroutine 7 (finished) created at:&#xA;  main.main()&#xA;      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:23 +0x14e&#xA;==================&#xA;```&#xA;&#xA;This is because we are trying to access the same memory address at the same time. This is a race condition and can lead to unpredictable behavior. Try removing the `--race` flag while running, in this little stupid example, it might not be obvious, but in complex and constrained environments, this can get the application in serious trouble.&#xA;&#xA;**NOTE**: We are using `go run --race no-mutex.go` to check if there are any race conditions in the program. This is the [race detector](https://go.dev/doc/articles/race_detector) flag in the run command.&#xA;&#xA;To avoid this race condition, we need to add the mutex locks provided in the [sync.Mutex](https://pkg.go.dev/sync#Mutex) type. There are methods like [Lock](), [Unlock](), and [TryLock]() which help in locking access of the resource to a single entity at a given time.&#xA;&#xA;When a goroutine calls `Lock()` on a mutex, it acquires the lock. If the mutex is already locked by another goroutine, the calling goroutine will be blocked (put to sleep) until the lock becomes available. Once the lock is acquired successfully, the goroutine can proceed with its critical section, which is the part of the code that should not be executed concurrently by multiple goroutines.&#xA;&#xA;When a goroutine calls `Unlock()` on a mutex, it releases the lock. This allows other waiting goroutines to acquire the lock and execute their critical sections. It&#39;s essential to ensure that `Unlock()` is called after the critical section to release the mutex and avoid deadlocks. The critical section/shared resource should not be accessed after the release of this lock.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#x9;&#34;sync&#34;&#xA;)&#xA;&#xA;func WriteToFile(filename string, contents string, buffer *[]byte, wg *sync.WaitGroup, mutex *sync.Mutex) {&#xA;&#x9;defer wg.Done()&#xA;&#x9;contentBytes := []byte(contents)&#xA;&#xA;&#x9;mutex.Lock()&#xA;&#x9;*buffer = append(*buffer, contentBytes...)&#xA;&#xA;&#x9;f, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;}&#xA;&#x9;defer f.Close()&#xA;&#x9;_, err = f.Write(contentBytes)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;}&#xA;&#x9;mutex.Unlock()&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;var wg sync.WaitGroup&#xA;&#x9;var mut sync.Mutex&#xA;&#x9;var sharedBuffer []byte&#xA;&#xA;&#x9;wg.Add(2)&#xA;&#x9;go WriteToFile(&#34;data/f1.txt&#34;, &#34;Hello Gophers!&#xA;&#34;, &amp;sharedBuffer, &amp;wg, &amp;mut)&#xA;&#x9;go WriteToFile(&#34;data/f1.txt&#34;, &#34;Welcome to Goworld!&#xA;&#34;, &amp;sharedBuffer, &amp;wg, &amp;mut)&#xA;&#x9;wg.Wait()&#xA;&#xA;&#x9;fmt.Println(string(sharedBuffer))&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run --race mutex.go&#xA;Welcome to Goworld!&#xA;Hello Gophers!&#xA;&#xA;$ go run --race mutex.go&#xA;Hello Gophers!&#xA;Welcome to Goworld!&#xA;&#xA;$ go run --race mutex.go&#xA;Hello Gophers!&#xA;Welcome to Goworld!&#xA;&#xA;$ go run --race mutex.go&#xA;Welcome to Goworld!&#xA;Hello Gophers!&#xA;```&#xA;&#xA;The above example is a preventive measure for race conditions with a mutex Lock on the shared resource used in the go routines. &#xA;&#xA;Let&#39;s break down the code step by step. First, we initialize a few variables:&#xA;- `wg` as `sync.WaitGroup`:&#xA;    The `wg` is a waitgroup that will be used for the synchronization of the go-routines by blocking the main function to exit&#xA;&#xA;- `mut` as `sync.Mutex`:&#xA;    The `mut` is a structure that internally holds a few integer values indicating either a blocked or unblocked state. The `sync.Mutex` has two private fields wiz. `state` and `sema`, the state holds the mutex state either `0`(unlocked) or `1` as locked. The `sema` field is a `uint32` that is used for blocking and signaling, it acts as a semaphore to manage blocking and unblocking goroutines trying to acquire the mutex.&#xA;    This will be used to acquire `Lock` and `Unlock` on the shared resource while writing the data to the file or appending the data to the resource.&#xA;&#xA;- `sharedBuffer` as `[]byte`: &#xA;  The `sharedBuffer` is the actually shared resource that will be used to hold the strings for keeping track of the data written to the file. It will be the resource that would require to lock for mutating its value(appending to the slice) among the go routines.&#xA;&#xA;We add `2` to the `wg` to indicate to wait for the two go-routines to complete, in the next line we call two go routines as the function `WriteToFile`. The `WriteToFile` is a function that takes in quite a few parameters namely, the filename, the content to write, the reference to the sharedBuffer, waitgroup, and the mutex.&#xA;&#xA;Inside the function `WriteToFile`:&#xA;-  We first `defer` the `waitgroups` as `Done` i.e. to call the `wg.Done` method at the end of the function call. &#xA;- Typecast the `contents` from `string` as the `[]byte`. &#xA;- Acquire the `mutex.Lock()` i.e. to say &#34;The below operations should not be done concurrently, one at a time&#34;. We then append the `contents` to the `buffer` which is a pointer to the `sharedBuffer` in the main function, so essentially we are trying to mutate the `sharedBuffer` in this function.&#xA;- Open the file as `O_APPEND` and `O_WRONLY` to indicate that the file should be opened in append/writing mode. (We have observed this type of operation in the [Golang: File Write](https://www.meetgor.com/golang-file-write/) article)&#xA;- Use the `Write` method to write the slice of bytes(contents) into the file that we opened. We have a `defer` for the closing of the file. &#xA;&#xA;We obviously check for errors and print them, but it could be a `panic` or `log` depending on the type of operation the application is doing.&#xA;So that is the all operation we want to do, so we finally open the lock with `mutex.Unlock()` which will allow the other go routine if any to access the resource and proceed with the operations.&#xA;&#xA;### Read Write Mutual Exclusion Lock&#xA;&#xA;The mutual exclusion lock is good if you have a write operation-heavy application. However, if we have read write operations in more or the less in same proportion(read heavy) we don&#39;t want to have readers getting blocked when other readers are accessing the resource since it is not a mutation process. &#xA;&#xA;We could allow many readers to read simultaneously. But for the writing operation, we want to block the readers/writers. The writer should be given preference first in case of a lock by other writers. This would prevent a writer from waiting for readers to complete. This is usually referred to as **Read Write Mutual Exclusion**.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;sync&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func reader(id int, count *int, wg *sync.WaitGroup, mutex *sync.Mutex) {&#xA;&#x9;defer wg.Done()&#xA;&#x9;if !mutex.TryLock() {&#xA;&#x9;&#x9;fmt.Printf(&#34;Reader %d blocked!&#xA;&#34;, id)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#x9;defer mutex.Unlock()&#xA;&#x9;fmt.Printf(&#34;Reader %d: read count %d&#xA;&#34;, id, *count)&#xA;}&#xA;&#xA;func writer(id, increment int, count *int, wg *sync.WaitGroup, mutex *sync.Mutex) {&#xA;&#x9;defer wg.Done()&#xA;&#x9;defer mutex.Unlock()&#xA;&#x9;mutex.Lock()&#xA;&#x9;*count += increment&#xA;&#x9;time.Sleep(5 * time.Millisecond)&#xA;&#x9;fmt.Printf(&#34;Writer %d: wrote count %d&#xA;&#34;, id, *count)&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;count := 1&#xA;&#x9;var wg sync.WaitGroup&#xA;&#x9;var mutex sync.Mutex&#xA;    readers := 5&#xA;    writers := 3&#xA;&#x9;wg.Add(readers)&#xA;&#x9;for i := 0; i &lt; readers; i++ {&#xA;&#x9;&#x9;go reader(i, &amp;count, &amp;wg, &amp;mutex)&#xA;&#x9;}&#xA;&#xA;&#x9;wg.Add(writers)&#xA;&#x9;for i := 0; i &lt; writers; i++ {&#xA;&#x9;&#x9;go writer(i, 1, &amp;count, &amp;wg, &amp;mutex)&#xA;&#x9;}&#xA;&#x9;wg.Wait()&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run --race no-rwmutex.go &#xA;Reader 0: read count 1&#xA;Reader 3 blocked!&#xA;Reader 2 blocked!&#xA;Reader 1 blocked!&#xA;Reader 4 blocked!&#xA;Writer 0: wrote count 2&#xA;Writer 1: wrote count 3&#xA;Writer 2: wrote count 4&#xA;&#xA;$ go run --race no-rwmutex.go &#xA;Reader 2 blocked!&#xA;Reader 0: read count 1&#xA;Reader 1 blocked!&#xA;Reader 4 blocked!&#xA;Reader 3 blocked!&#xA;Writer 2: wrote count 2&#xA;Writer 0: wrote count 3&#xA;Writer 1: wrote count 4&#xA;```&#xA;&#xA;The above example has a `reader` and a `writer` method, the `reader` method simply has to read the shared resource `count`. It acquires a `Mutex` lock before reading and unlocks it thereafter. Similarly, the `writer` function is used for incrementing the `count` shared resource. &#xA;&#xA;The `reader` method has a [TryLock](https://pkg.go.dev/sync#Mutex.TryLock) method that tries to acquire a mutex lock on the resource, if the resource is already locked, the function will return `false` and hence we can say that the reading is blocked(just for demonstration). And if the function `TryLock` returns `true`, it will acquire the `Lock`. We further `defer` the `Unlock` and access the `count` variable which is passed as a reference. &#xA;&#xA;The `writer` method is simply acquiring the `Lock` and incrementing the `counter` and thereafter `Unlock` is called with `defer`.&#xA;&#xA;In the above code:&#xA;- The `reader` and the `writer` both might be waiting for the lock to be released, however, for readers to wait for reading doesn&#39;t make sense. &#xA;- Because if you would want to just read a particular memory address, there shouldn&#39;t be any locks for one reader to wait for other readers to finish.&#xA;- However, for writing, there has to be a lock. The mutex lock will lock the resource irrespective of the `reader` or `writer`. &#xA;&#xA;This might not be as visible here, but it might be the reason, that all the `readers` are blocked from reading due to another reader&#39;s or writer&#39;s lock.&#xA;&#xA;The `sync` package has the [RWMutex](https://pkg.go.dev/sync#RWMutex) that does this exact same thing. It is almost similar to the `Mutex` however, it would allow concurrent reading operation and prefer writing operation before readers to prevent writer starvation.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;sync&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func reader(id int, count *int, wg *sync.WaitGroup, mutex *sync.RWMutex) {&#xA;&#x9;defer wg.Done()&#xA;&#x9;defer mutex.RUnlock()&#xA;&#xA;&#x9;if !mutex.TryRLock() {&#xA;&#x9;&#x9;fmt.Printf(&#34;Reader %d blocked!&#xA;&#34;, id)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#x9;fmt.Printf(&#34;Reader %d: read count %d&#xA;&#34;, id, *count)&#xA;&#xA;}&#xA;&#xA;func writer(id, increment int, count *int, wg *sync.WaitGroup, mutex *sync.RWMutex) {&#xA;&#x9;defer wg.Done()&#xA;&#x9;defer mutex.Unlock()&#xA;&#x9;mutex.Lock()&#xA;&#xA;&#x9;*count += increment&#xA;&#x9;time.Sleep(5 * time.Millisecond)&#xA;&#x9;fmt.Printf(&#34;Writer %d: wrote count %d&#xA;&#34;, id, *count)&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;count := 1&#xA;&#x9;var wg sync.WaitGroup&#xA;&#x9;var mutex sync.RWMutex&#xA;    readers := 5&#xA;    writers := 3&#xA;&#x9;wg.Add(readers)&#xA;&#x9;for i := 0; i &lt; readers; i++ {&#xA;&#x9;&#x9;go reader(i, &amp;count, &amp;wg, &amp;mutex)&#xA;&#x9;}&#xA;&#xA;&#x9;wg.Add(writers)&#xA;&#x9;for i := 0; i &lt; writers; i++ {&#xA;&#x9;&#x9;go writer(i, 1, &amp;count, &amp;wg, &amp;mutex)&#xA;&#x9;}&#xA;&#x9;wg.Wait()&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run --race rwmutex.go &#xA;Reader 0: read count 1&#xA;Reader 3: read count 1&#xA;Reader 1: read count 1&#xA;Reader 2: read count 1&#xA;Reader 4: read count 1&#xA;Writer 1: wrote count 2&#xA;Writer 0: wrote count 3&#xA;Writer 2: wrote count 4&#xA;Writer 3: wrote count 5&#xA;Writer 4: wrote count 6&#xA;&#xA;$ go run --race rwmutex.go &#xA;Reader 1 blocked!&#xA;Reader 0: read count 1&#xA;Reader 2 blocked!&#xA;Reader 3 blocked!&#xA;Reader 4 blocked!&#xA;Writer 4: wrote count 2&#xA;Writer 0: wrote count 3&#xA;Writer 1: wrote count 4&#xA;Writer 3: wrote count 5&#xA;Writer 2: wrote count 6&#xA;&#xA;```&#xA;&#xA;In the modified example, all the logic remains the same, just the `sync.Mutex` is replaced with `sync.RWMutex`. Also for trying to acquire the lock in the `reader` method [TryRLock](https://pkg.go.dev/sync#RWMutex.RLock) is used instead of [TryLock](https://pkg.go.dev/sync#RWMutex.TryRLock) which will check if the existing lock acquired is of a reader or writer, if it is a reader, it will return `true`, else `false`. Also the `Unlock` is replaced with the `RUnlock` method for releasing the read lock. In the `writer` method, everything remains the same so the writer has to acquire the lock irrespective of whether the current lock is from the reader/writer, so it is a normal `Lock` and `Unlock`.&#xA;&#xA;In the above example, we can see all the read operations sometimes are executed instead of getting blocked. This is due to the `RWMutex` Lock and Unlock on the read operation/function. &#xA;- When one reader is reading, it can&#39;t block other readers. &#xA;- However with simple `Mutex`, the reader is even blocked when another reader is reading.&#xA;- For the write operation, it will be blocked as usual, so if a writer is performing a write operation and a reader/readers come in, they will be blocked, also if in the meantime, while the resource is locked, another writer comes in, the writer will be given preference instead of waiting for all readers to complete. This prevents writer starvation.&#xA;&#xA;You can see, that the readers are still blocked the majority of the time, however, they are blocked due to the writer locking the resource and not any other reader.&#xA;&#xA;There is a bit more suitable [example](https://github.com/Mr-Destructive/100-days-of-golang/blob/main/scripts/go-routines/file-rw.go) related to `file` reading and writing with `RWMutex`, make sure to check that out to get a more clear understanding of an actual case of using the `RWMutex`.&#xA;&#xA;### Channels&#xA;&#xA;This is a big part and I would like to delve into this topic in a separate post. There are some patterns like `fan-in`, `fan-out`, `worker-pool`, `pub-sub`, etc. which are really common in web applications and backend systems. These patterns we shall explore in the next article.&#xA;&#xA;Channels are a way to provide a safe and idiomatic way for Goroutines to exchange data and coordinate their execution without resorting to low-level mechanisms like shared memory or explicit locking.&#xA;&#xA;That&#39;s it from the 30th part of the series, all the source code for the examples are linked in the GitHub on the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/scripts/go-routines) repository.&#xA;&#xA;### References:&#xA;&#xA;- [How Goroutines Work](https://blog.nindalf.com/posts/how-goroutines-work/)&#xA;- [Concurrency patterns in Golang: WaitGroups and Goroutines](https://blog.logrocket.com/concurrency-patterns-golang-waitgroups-goroutines/)&#xA;- [A complete journey with Goroutines](https://riteeksrivastava.medium.com/a-complete-journey-with-goroutines-8472630c7f5c)&#xA;&#xA;## Conclusion&#xA;&#xA;From this part of the series, the fundamentals of golang&#39;s concurrency model were understood specifically spawning go-routines, synchronously executing go-routines with the help of a wait group, mutex locks, and how to secure concurrent access to a shared resource. In the next part of the series, these concepts will be used in asynchronous communication using channels. &#xA;&#xA;Hopefully, you have got the basics of concurrency in golang cleared from this post. If you have any queries, suggestions, or feedback, please feel free to comment below or contact me on the social handles. Thank you for reading. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Generics</title>
      <link>meetgor.com/golang-generics</link>
      <description>Understanding the power of generics in Golang, enabling concise and flexible code. Learn how to apply generics to functions, slices, maps, and structs for enhanced reusability and type safety.</description>
      <pubDate>Sun, 23 Jul 2023 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the 29th post of the series, we will be looking into generics in Golang. Generics were added in Golang version 1.18, so they are quite new in the world of Golang but the concept is quite old in other programming languages.&#xA;&#xA;Generics provide a powerful toolset for writing more expressive and concise code that can handle a wide range of data types. With generics, we can write reusable algorithms, data structures, and functions that work seamlessly with various types, without sacrificing type safety.&#xA;&#xA;We will learn how to create generic functions and work with generic types. Additionally, we will cover type constraints and interfaces, which allow us to specify requirements for the types used with our generics.&#xA;&#xA;## Generic Type in Functions&#xA;&#xA;We can define a generic type with the keyword `any` that is going to replace the type `T` i.e. any data type with the inferred type at compilation. This makes the code reusable to any relevant data type to be used for that operation/task.&#xA;&#xA;We can provide the type `any` after the name of the function/struct to make it generic like `func Name[T any](x T)`. Here, the Name is a function that takes in a generic type `T` it could be any type and the variable is named as `x` that could be used inside the function.&#xA;&#xA;We could also make the function take specific types instead of `any` but we will eventually move into that. However, for now, let&#39;s ease the process of learning and then move on to the optimizations and adding constraints.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func Print[T any](stuff T) {&#xA;&#x9;fmt.Println(stuff)&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;Print(&#34;hello&#34;)&#xA;&#x9;Print(123)&#xA;&#x9;Print(3.148)&#xA;}&#xA;```&#xA;&#xA;[GO Playground Link](https://go.dev/play/p/t-ODmkHu5BJ)&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;hello&#xA;123&#xA;3.148&#xA;```&#xA;&#xA;The above is the simplest example that could be used to demonstrate a generic function. The function `Print` takes a parameter `stuff` of a generic type denoted by a type parameter `T`. The type parameter `T` serves as a placeholder that represents a specific type determined at compile time when the function is invoked.&#xA;&#xA;This means, if in my code I do not call the function with the type `[]int` it won&#39;t have the function with the signature as `Print(stuff []int)` rather only the types which the function is called with are inferred and written with that specific types.&#xA;&#xA;## Creating a Generic Slice&#xA;&#xA;We can even create a slice with a generic type and allow any valid processing on the elements or the slice as a whole.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func ForEach[T any](arr []T, f func(T)) {&#xA;&#x9;for _, v := range arr {&#xA;&#x9;&#x9;f(v)&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;strSlice := []string{&#34;b&#34;, &#34;e&#34;, &#34;a&#34;}&#xA;&#x9;ForEach(strSlice, func(v string) {&#xA;&#x9;&#x9;fmt.Println(v)&#xA;&#x9;})&#xA;&#xA;&#x9;slice := []int{10, 25, 33, 42, 50}&#xA;&#x9;var evenSlice []int&#xA;&#x9;ForEach(slice, func(v int) {&#xA;&#x9;&#x9;isEven := v%2 == 0&#xA;&#x9;&#x9;if isEven {&#xA;&#x9;&#x9;&#x9;evenSlice = append(evenSlice, v)&#xA;&#x9;&#x9;}&#xA;&#x9;})&#xA;&#x9;fmt.Println(evenSlice)&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;b&#xA;e&#xA;a&#xA;[10 42 50]&#xA;```&#xA;&#xA;[Go Playground Link](https://go.dev/play/p/tUwgbxnLc-1)&#xA;&#xA;The `ForEach` is a generic function that iterates over a slice of any type and calls a function on each element. Let&#39;s break it down:&#xA;&#xA;* `ForEach[T any]` declares this as a generic function that works on a slice of any type `T`.&#xA;    &#xA;* `arr []T` is the slice of elements we want to iterate over. It can be a slice of any type, ints, strings, `T` in general, etc. So it is a generic slice parameter.&#xA;    &#xA;* `f func(T)` is the function that will be called on each element. It takes a single parameter of type `T` which will be each element. So, this is a function parameter with a generic type as its parameter.&#xA;    &#xA;&#xA;In the body, we range over the slice arr:&#xA;&#xA;```go&#xA;for _, v := range arr {&#xA;&#xA;}&#xA;```&#xA;&#xA;On each iteration, `v` will be the next element. The underscore ignores the index. We call the provided function `f`, passing the element `v`: `f(v)`&#xA;&#xA;So in summary:&#xA;&#xA;* It allows iterating over a slice of any type&#xA;    &#xA;* This avoids having to know the specific slice type in the loop&#xA;    &#xA;* The provided function `f` is called on each element&#xA;    &#xA;* So it provides a reusable abstraction for processing slices generically.&#xA;    &#xA;&#xA;Now, we will discuss the example used in the main function. First, we create a slice of strings as `strSlice := []string{&#34;b&#34;, &#34;e&#34;, &#34;a&#34;}`. Then we call the generic `ForEach` function, passing the string slice and a function to handle each element.&#xA;&#xA;```bash&#xA;ForEach(strSlice, func(v string) {&#xA;  fmt.Println(v) &#xA;})&#xA;```&#xA;&#xA;Here, the `func(v string)` is the invocation of the `ForEach` function with the typed string and the variable name as v. The `v` is the element of the slice, so inside the function body(this is an anonymous function), we call the `fmt.Println(v)`, which will print each string in the slice.&#xA;&#xA;```go&#xA;slice := []int{10, 25, 33, 42, 50}&#xA;var evenSlice []int&#xA;ForEach(slice, func(v int) {&#xA;    isEven := v%2 == 0&#xA;    if isEven {&#xA;        evenSlice = append(evenSlice, v)&#xA;    }&#xA;})&#xA;fmt.Println(evenSlice)&#xA;```&#xA;&#xA;In the next example, we create a new slice of int as `slice := []int{10, 25, 33, 42, 50}`. Then we call the generic `ForEach` function again, passing the slice and a function to handle each element just as before, however, we are processing some things and then appending to an external slice.&#xA;&#xA;First, the `slice := []int{10, 25, 33, 42, 50}` is created with some numbers, we also initialize another slice as `evenSlice := []int{}` which is empty. Then we call the generic `ForEach` function again, passing the slice and a function to handle each [element.Here](http://element.Here), the ForEach is called with the `slice` slice and not the `evenSlice` slice, so we are going to access each element in the `slice` array. We first create a `isEven` boolean that checks if the element is even or odd by `v%2 == 0`. This expression will result in `true` if `v` is even and `false` otherwise. So, only if the `isEven` is true, we append the element `v` into the `evenSlice` slice.&#xA;&#xA;So, that&#39;s how generic slices can be handy for doing type-specific processing without writing functions for those individual types. This avoids needing to write type-specific functions for each slice type.&#xA;&#xA;NOTE: Make sure to only use generic functions with generic slice types with the appropriate and valid conditions and use it only when it looks legible to do so.&#xA;&#xA;## Creating a Generic Map&#xA;&#xA;We can also create a generic map with the generic type of `map[K]T` where `K` is a generic type and `T` is the type of the key.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func GetValue[K comparable, V any](m map[K]V, key K, defaultVal V) V {&#xA;&#x9;if v, ok := m[key]; ok {&#xA;&#x9;&#x9;return v&#xA;&#x9;}&#xA;&#x9;return defaultVal&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;serverStats := map[string]int{&#xA;&#x9;&#x9;&#34;port&#34;:      8000,&#xA;&#x9;&#x9;&#34;pings&#34;:     47,&#xA;&#x9;&#x9;&#34;status&#34;:    1,&#xA;&#x9;&#x9;&#34;endpoints&#34;: 13,&#xA;&#x9;}&#xA;&#x9;v := GetValue(serverStats, &#34;status&#34;, -1)&#xA;&#x9;fmt.Println(v)&#xA;&#x9;v = GetValue(serverStats, &#34;cpu&#34;, 4)&#xA;&#x9;fmt.Println(v)&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;1&#xA;4&#xA;```&#xA;&#xA;[Go Playground Link](https://go.dev/play/p/ludlh6UwKaD)&#xA;&#xA;&#xA;GetValue is a generic function that takes three type parameters: The map itself, the key to find the value for, and a default value if the key doesn&#39;t exist.&#xA;&#xA;The `m` is a map with keys of type K and values of type V, the key is of type K, and defaultVal is of type V. So, we have two generics here, as the key and value need not be of the same type, hence we have distinct generics here. K has added a constraint of `comparable` and `V` as `any` type. The type constraint comparable restricts K to be a comparable type, and the type constraint `any` allows V to be any type.&#xA;&#xA;* Inside the function, we use the ok variable to check if the given `key` exists in the map `m`.&#xA;    &#xA;* If the key is present in the map (ok is true), we retrieve the corresponding value from the map and return it as `m[key]` which is stored in the variable `v`.&#xA;    &#xA;* If the key is not present in the map (ok is false), we return the provided `defaultVal`.&#xA;    &#xA;&#xA;So, this is how we can use any type of map to retrieve the value of a key, the data type of key and value could be anything. It allows us to retrieve a value from a map irrespective of the pair type in the map.&#xA;&#xA;NOTE: The type of `defaultVal` and the type of `v` should be the same since the map will need to have the value for the given key as the same type as defined in the map type(here `map[string]int` so `v` is `int` and so should be the `defaultVal`).&#xA;&#xA;Moving into the main function, we create a map of `[string]int` i.e. the key is of type `string` and the value of type `int`. The map `serverStats` has a few keys like `port`, `pings`, `endpoints`, and `status`. We call the `GetValue` method on the map `serverStats` with the key `status` and provide a default value of `-1`. The function will readily return `1` since the key is present in the provided map. However, if we try to access the key `cpu`, the key is not present and the value is returned as the `defaultVal` which we passed as `4`.&#xA;&#xA;So, this was a simple generic getter method on a map. We can get a value of a key in a map of any pair and even provide a default value if doesn&#39;t exist. However, it won&#39;t add it to the map, we will just return the value from the function that&#39;s it. We have to see that returned default value manually.&#xA;&#xA;We can make another function to get or set the value of a key in a map. The function will take in a reference to the map rather than a copy of the map, we can then use that reference to set the key with the provided default value.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;)&#xA;&#xA;func GetOrSetValue[K comparable, V any](m *map[K]V, key K, defaultVal V) V {&#xA;    // reference the original map&#xA;&#x9;ref := *m&#xA;&#x9;if v, ok := ref[key]; ok {&#xA;&#x9;&#x9;return v&#xA;&#x9;} else {&#xA;        //mutate the original map&#xA;        ref[key] = defaultVal&#xA;&#xA;        return defaultVal&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;    serverStats := map[string]int{&#xA;        &#34;port&#34;:      8000,&#xA;        &#34;pings&#34;:     47,&#xA;        &#34;status&#34;:    1,&#xA;        &#34;endpoints&#34;: 13,&#xA;    }&#xA;    fmt.Println(serverStats)&#xA;    v := GetOrSetValue(&amp;serverStats, &#34;cpu&#34;, 4)&#xA;    fmt.Println(v)&#xA;    fmt.Println(serverStats)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;map[endpoints:13 pings:47 port:8000 status:1]&#xA;4&#xA;map[cpu:4 endpoints:13 pings:47 port:8000 status:1]&#xA;```&#xA;&#xA;[Go Playground Link](https://go.dev/play/p/fYtjFQRaPCb)&#xA;&#xA;In the above code, we take a reference of the map as `*map[K]V`, this will give access to the actual place(memory address where the map is located so we could mutate/change it). The rest of the parameters are kept as is, the key will be taken as it was before, and so will the `defaultVal`. The only difference is that we will set the `key` doesn&#39;t exist, we set the `ref[key]` to the `defaultVal` and return the `defaultVal`.&#xA;&#xA;For example, the `cpu` key is not present in the initial map `serverStats` so, when we call the `GetOrSetValue` with the reference to the map `serverStats`, key as `cpu` and the default value as `4`, the function returns `4` and the map is mutated with the key `cpu` with value `4`.&#xA;&#xA;The takeaway is you can even use references to access the original data and mutate it based on your needs.&#xA;&#xA;## Generic Type in Struct&#xA;&#xA;We can define custom structs with generic type as the field values. The name of the struct is followed by the `[T any]` which is the type parameter to be used in the struct fields, again this type could have multiple types(since a struct can have many fields), not necessary want a single type parameter, you could have multiple type parameters bunched up just like we saw in the map example.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;type Stack[T any] struct {&#xA;&#x9;items []T&#xA;}&#xA;&#xA;func NewStack[T any]() *Stack[T] {&#xA;&#x9;return &amp;Stack[T]{}&#xA;}&#xA;&#xA;func (s *Stack[T]) Push(item T) {&#xA;&#x9;s.items = append(s.items, item)&#xA;}&#xA;&#xA;func (s *Stack[T]) Pop() T {&#xA;&#x9;if len(s.items) == 0 {&#xA;&#x9;&#x9;panic(&#34;Stack is empty&#34;)&#xA;&#x9;}&#xA;&#x9;index := len(s.items) - 1&#xA;&#x9;item := s.items[index]&#xA;&#x9;s.items = s.items[:index]&#xA;&#x9;return item&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;intStack := NewStack[int]()&#xA;&#x9;intStack.Push(10)&#xA;&#x9;intStack.Push(20)&#xA;&#x9;intStack.Push(30)&#xA;&#x9;fmt.Println(&#34;Integer Stack&#34;)&#xA;&#x9;fmt.Println(intStack)&#xA;&#x9;intStack.Pop()&#xA;&#x9;intStack.Pop()&#xA;&#x9;fmt.Println(intStack)&#xA;&#xA;&#x9;// without the NewStack method&#xA;&#x9;strStack := Stack[string]{}&#xA;&#x9;strStack.Push(&#34;c&#34;)&#xA;&#x9;strStack.Push(&#34;python&#34;)&#xA;&#x9;strStack.Push(&#34;mojo&#34;)&#xA;&#x9;fmt.Println(&#34;String Stack:&#34;)&#xA;&#x9;fmt.Println(strStack)&#xA;&#x9;strStack.Pop()&#xA;&#x9;fmt.Println(strStack)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;Integer Stack&#xA;&amp;{[10 20 30]}&#xA;&amp;{[10]}&#xA;&#xA;String Stack:&#xA;{[c python mojo]}&#xA;{[c python]}&#xA;```&#xA;&#xA;[Go Playground Link](https://go.dev/play/p/4t_P2mKtTZN)&#xA;&#xA;In this example, we have used the `Stack` example for doing a basic `Push` and `Pop` operation on the elements. Here the type of the underlying stack elements could be anything, hence the type parameter is defined for the `items` which is a list/slice of the type `T` as `[]T`. We have to specify the type before initializing the&#xA;&#xA;We have created the `NewStack` method, it is not needed, it could be just used as `Stack[int]{}` to initialize a empty stack with int type(here `int` could be any other type you wish). I have just created it so that it shows the abstraction that could be built upon in real applications. The `NewStack` simply replaces the `T` with the provided `type` in the initialization.&#xA;&#xA;The `Push` method is associated with the `Stack` struct, as we refer to the `*Stack[T]` indicating a reference to the Stack object with the type `T`. The method takes in the parameter `T` which would be the element to be added to the `Stack`. Since the function is tied to the Stack struct, we can simply mutate the underlying `items` by appending the provided value `item` in the parameter using `s.items = append(s.items, item)`. This appends the `item` to the underlying `items` list in the `Stack` object `s`&#xA;&#xA;Similarly, we can create `Pop` method as well, which will first check if the `Stack` is not empty(i.e. the s.items slice has a length greater than 0), then get the index of the last element using `len(s.items) - 1` and then slice the `items` at index `[:last_index]`. This will basically get you all the elements except the last. Before we remove the element from the slice, we also store the item in `item` variable and return it from the method.&#xA;&#xA;You could see the case of generics here, you could build complex data structures without creating a separate implementation for each type.&#xA;&#xA;## Adding Constraints to Generics&#xA;&#xA;We can add constraints to the generics to restrict the type of the generic parameter. For example, we can add a constraint for the generic type to be a slice of a specific type or we have seen in the map example the `comparable` constraint.&#xA;&#xA;The `comparable` constraint is an interface that allows two instances of the same type to be compared i.e. support comparison operators like ==, &amp;lt;, &amp;gt;, !=, &amp;gt;=, &amp;lt;=, etc. It could be any numeric type like `int`, `float`, `uint` and variants, booleans, time duration, and any other struct that implements the `comparable` interface.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func FindIndex[T comparable](arr []T, value T) int {&#xA;&#x9;for i, v := range arr {&#xA;&#x9;&#x9;if v == value {&#xA;&#x9;&#x9;&#x9;return i&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;return -1&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;strSlice := []string{&#34;m&#34;, &#34;e&#34;, &#34;e&#34;, &#34;t&#34;}&#xA;&#x9;fmt.Println(FindIndex(strSlice, &#34;e&#34;))&#xA;&#x9;fmt.Println(FindIndex(strSlice, &#34;t&#34;))&#xA;&#x9;fmt.Println(FindIndex(strSlice, &#34;a&#34;))&#xA;&#xA;&#x9;intSlice := []int{10, 25, 33, 42, 50}&#xA;&#x9;fmt.Println(FindIndex(intSlice, 33))&#xA;&#x9;fmt.Println(FindIndex(intSlice, 90))&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;1&#xA;3&#xA;-1&#xA;&#xA;2&#xA;-1&#xA;```&#xA;&#xA;[Go Playground Link](https://go.dev/play/p/fv9gzb8K4d7)&#xA;&#xA;In the above example, we have created the function `FindIndex` that takes in a generic slice, the type parameter `[T comparable]` indicates that the type used for calling this method needs to have a type that implements the comparable interface (for the elements of the slice). The method takes in two parameters, one the slice as `[]T` and the other the value to find the index for as type `T`. The method returns a type `int` since the index of the slice has to be an integer value.&#xA;&#xA;Inside the function body, we simply iterate over the slice `arr` and check if the element is equal to the provided value. If the element exists, we return that index, else we return `-1`&#xA;&#xA;As we can see we have run a couple of slices with the function `FindIndex` with types `int` and `string`. The method returns an index value if the element exists, else it returns `-1`. The `comparable` is a built-in type constraint. We could even define custom constraints as interfaces that implement the types of the particular type(s).&#xA;&#xA;Also, we could define custom constraints like numeric only, string only, etc.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;type numeric interface {&#xA;&#x9;uint | uint8 | uint16 | uint32 | uint64 |&#xA;&#x9;&#x9;int | int8 | int16 | int32 | int64 |&#xA;&#x9;&#x9;float32 | float64&#xA;}&#xA;&#xA;func Sum[T numeric](nums []T) T {&#xA;&#x9;var s T&#xA;&#x9;for _, n := range nums {&#xA;&#x9;&#x9;s += n&#xA;&#x9;}&#xA;&#x9;return s&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;intSlice := []int{10, 20, 30, 40, 50}&#xA;&#x9;fmt.Println(Sum(intSlice))&#xA;&#xA;&#x9;floatSlice := []float64{1.1, 2.2, 3.3, 4.4, 5.5}&#xA;&#x9;fmt.Println(Sum(floatSlice))&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;150&#xA;16.5&#xA;```&#xA;&#xA;[Go Playground Link](https://go.dev/play/p/_1eGl58qQ-2)&#xA;&#xA;In the above example, we have created the `numeric` constraints that allow the type `int`, `float` and their variants to be allowed in the numeric generic type. The function `Sum` is a generic function with the constraint of `numeric` type parameter. The method takes in the parameter as type `[]T` and returns the type as `T`. The method will simply iterate over the slice and return the sum of its elements.&#xA;&#xA;This will allow any numeric type which can be added and the sum can be obtained, so if we try to call the method with other types like `string` or `maps`, it won&#39;t work, and give an error:&#xA;&#xA;```bash&#xA;$ go run constraints.go&#xA;&#xA;# command-line-arguments                                                                                                               &#xA;scripts/generics/constraints.go:46:20: &#xA;string does not satisfy numeric (string missing in uint | uint8 | uint16 | uint32 | uint64 | int&#xA; | int8 | int16 | int32 | int64 | float32 | float64)&#xA;&#xA;shell returned 1&#xA;```&#xA;&#xA;So, we can use the constraint to restrict the type of the generic type parameter which will allow us to restrict the usage and avoid any unsafe type to be used in the generic function.&#xA;&#xA;Also, if we have a custom type with the base types, we need to use `~` before the type to accept it into the generic constraint. This will allow any approximate type to be allowed in the constraint. Let&#39;s say we are implementing a custom string type, for that to work with a constraint, it won&#39;t be satisfied in the constraint since its type is `CustomString` and not `string`. So to avoid this we use `~string` that would approximate the type and allow abstracted base types.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;type string2 string&#xA;&#xA;type strings interface {&#xA;&#x9;~string&#xA;}&#xA;&#xA;func PrintEach[T strings](arr T) {&#xA;&#x9;for _, v := range arr {&#xA;&#x9;&#x9;fmt.Printf(&#34;%c&#xA;&#34;, v)&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;var s string2&#xA;&#x9;s = &#34;hello&#34;&#xA;&#x9;PrintEach(s)&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;h&#xA;e&#xA;l&#xA;l&#xA;o&#xA;```&#xA;&#xA;[Go Playground Link](https://go.dev/play/p/N-66A9C94ps)&#xA;&#xA;In the above example, we have used the type approximations in the type constraint `strings`, it allows any string type, whether a base `string` type or an abstract `string` type. If you try to remove the `~` in `~string`, it will result in the error that `string2 does not satisfy strings` interface. So, by adding `~` to the `string` type the abstract type `string2` can be satisfied in the generic constraint.&#xA;&#xA;That&#39;s it from the 29th part of the series, all the source code for the examples are linked in the GitHub on the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/scripts/generics) repository.&#xA;&#xA;### References&#xA;&#xA;- [Generics in Go](https://bitfieldconsulting.com/golang/generics)&#xA;- [Understanding generics in Go](https://blog.logrocket.com/understanding-generics-go-1-18/)&#xA;&#xA;## Conclusion&#xA;&#xA;From this section of the series, we have covered the basics of generics in Golang. By using generics in functions, slices, maps, and structs, and adding constraints to them the fundamental usage of generics was covered.&#xA;&#xA;If you have any questions, feedback, or suggestions, please drop them in the comments/social handles or discuss them below. Thank you so much for reading. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Date and Time</title>
      <link>meetgor.com/golang-date-time</link>
      <description>Performing date and time parsing, time duration, time and date arithmetic, timezones, sleep and tickers. We delve into the time standard library package and learn how to create time and date objects, extract specific components, and perform operations</description>
      <pubDate>Mon, 19 Jun 2023 00:00:00 UTC</pubDate>
      <content>&#xA;&#xA;## Introduction&#xA;&#xA;In the 28th post of the series, I will be exploring date and time handling in Golang. We will be covering the following topics:&#xA;&#xA;* Date and Time parsing&#xA;    &#xA;* Time Duration&#xA;    &#xA;* Time and Date Arithmetic&#xA;    &#xA;* Timezones&#xA;    &#xA;* Sleep and Tickers&#xA;    &#xA;&#xA;This will cover most of the methods and properties used extensively in general use cases related to time and date operations.&#xA;&#xA;## Time package&#xA;&#xA;The Golang standard library provides the time package to handle date and time-related operations. It has a lot of methods and constants to work and handle data related to time and dates.&#xA;&#xA;One of the fundamental methods to get time in golang is the [time.Now](http://time.Now) function, returns a time object representing the current time. The return value is a [time](https://pkg.go.dev/time#Time) object, which is the base struct that we can use to perform operations on top of it.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main(){&#xA;    now := time.Now()&#xA;    fmt.Println(now)&#xA;    fmt.Printf(&#34;%T&#xA;&#34;, now)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2023-06-18 15:18:53.977607431 +0530 IST m=+0.000050291&#xA;time.Time&#xA;```&#xA;&#xA;### Create a time/date type&#xA;&#xA;You can create a specific date by providing details like year, month, day, hour, minute, second, nanosecond, and time zone.&#xA;&#xA;The [time.Date](http://time.Date) method is used to create a time object. We will talk about location i.e. the timezone in a while.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main(){&#xA;    sometime := time.Date(2020, 03, 25, 8, 5, 0, 0, time.UTC)&#xA;    fmt.Println(sometime)&#xA;    fmt.Printf(&#34;%T&#xA;&#34;, sometime)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2020-03-25 08:05:00 +0000 UTC&#xA;time.Time&#xA;```&#xA;&#xA;The above example generates a custom time object as we parsed the year, month, day, etc to the function. The time zone is set to UTC, the method might also take in a custom timezone, but that is what we will be exploring further.&#xA;&#xA;We can also get some specific type from the time object using the methods that are available in the provided struct. For example, we can get the year from the time object by using the [time.Year()](https://pkg.go.dev/time#Time.Year), or month using [time.Month()](https://pkg.go.dev/time#Time.Month) and so on&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main(){&#xA;&#xA;&#x9;somedate := time.Date(2020, 03, 25, 8, 5, 0, 0, time.FixedZone(&#34;UTC&#34;, 5))&#xA;&#x9;fmt.Println(somedate)&#xA;&#xA;&#x9;today := somedate.Day()&#xA;&#x9;fmt.Println(today)&#xA;&#xA;&#x9;year := somedate.Year()&#xA;&#x9;fmt.Println(year)&#xA;&#xA;&#x9;month := somedate.Month()&#xA;&#x9;fmt.Println(month)&#xA;&#xA;&#x9;date := somedate.Day()&#xA;&#x9;fmt.Println(date)&#xA;&#xA;&#x9;weekDay := somedate.Weekday()&#xA;&#x9;fmt.Println(weekDay)&#xA;&#xA;    yearDay := somedate.YearDay()&#xA;    fmt.Println(yearDay)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2020-03-25 08:05:00 +0000 UTC&#xA;25&#xA;2020&#xA;March&#xA;25&#xA;Wednesday&#xA;85&#xA;```&#xA;&#xA;In the above example, we have used the methods available in the time structure to get the specific components like a year, month, day, hour, etc. The data type for these methods is simple integer or strings as suitable to the format like int for date, year, and string for weekday, month, and timezone/location.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main(){&#xA;&#xA;    now := time.Now()&#xA;&#x9;fmt.Println(now.Format(&#34;Monday 01 January 2006 15:04:05&#34;))&#xA;&#xA;&#x9;// day month date hour:minutes:second timezone year&#xA;&#x9;fmt.Println(now.Format(time.UnixDate))&#xA;&#xA;&#x9;// day month date hour:minutes:second year&#xA;&#x9;fmt.Println(now.Format(time.ANSIC))&#xA;&#xA;&#x9;// day month date hour:minutes:second&#xA;&#x9;fmt.Println(now.Format(time.Stamp))&#xA;&#xA;&#x9;// day month date hour:minutes:second.milisecond&#xA;&#x9;fmt.Println(now.Format(time.StampMilli))&#xA;&#xA;&#x9;// day month date hour:minutes:second.microsecond&#xA;&#x9;fmt.Println(now.Format(time.StampMicro))&#xA;&#xA;&#x9;// day month date hour:minutes:second.nanosecond&#xA;&#x9;fmt.Println(now.Format(time.StampNano))&#xA;&#xA;&#x9;// day, date month year hour:minutes:second timezone&#xA;&#x9;fmt.Println(now.Format(time.RFC1123))&#xA;&#xA;&#x9;// day, date month year hour:minutes:second offset&#xA;&#x9;fmt.Println(now.Format(time.RFC1123Z))&#xA;&#xA;&#x9;// year-month-dayThour:minutes:second+-offset&#xA;&#x9;fmt.Println(now.Format(time.RFC3339))&#xA;&#xA;&#x9;// year-month-dayThour:minutes.nanosecond:second&#xA;&#x9;fmt.Println(now.Format(time.RFC3339Nano))&#xA;&#xA;&#x9;// date month year hour:minutes timezone&#xA;&#x9;fmt.Println(now.Format(time.RFC822))&#xA;&#xA;&#x9;// hour:minuteAM/PM&#xA;&#x9;fmt.Println(now.Format(time.Kitchen))&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;Sunday 06 June 2023 20:09:09&#xA;Sun Jun 18 20:09:09 IST 2023&#xA;Sun Jun 18 20:09:09 2023&#xA;Jun 18 20:09:09&#xA;Jun 18 20:09:09.086&#xA;Jun 18 20:09:09.086565&#xA;Jun 18 20:09:09.086565975&#xA;Sun, 18 Jun 2023 20:09:09 IST&#xA;Sun, 18 Jun 2023 20:09:09 +0530&#xA;2023-06-18T20:09:09+05:30&#xA;2023-06-18T20:09:09.086565975+05:30&#xA;18 Jun 23 20:09 IST&#xA;8:09PM&#xA;```&#xA;&#xA;These are some of the time formats that are provided by the time package in golang. They all return a string, so it cannot be parsed and resolved into components again. You can definitely take in a custom timestamp, convert it into a time object and then use the appropriate time format for your needs.&#xA;&#xA;## Parsing time object from a string&#xA;&#xA;We can use the [Parse](https://pkg.go.dev/time#Parse) function to parse a string into a time object. The method takes in two parameters, a date format, and the string to convert to both are parsed as a string. The method returns the parsed time or can give an error if the provided string is not in the mentioned format.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main(){&#xA;&#xA;&#x9;customDate := &#34;2023-04-26&#34;&#xA;&#x9;t, err := time.Parse(&#34;2006-01-02&#34;, customDate)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;}&#xA;    fmt.Println(customDate)&#xA;&#x9;fmt.Println(t)&#xA;&#xA;    customDate = &#34;2023-0426&#34;&#xA;    t, err = time.Parse(&#34;2006-01-02&#34;, customDate)&#xA;    if err != nil {&#xA;        fmt.Println(err)&#xA;    }&#xA;    fmt.Println(customDate)&#xA;    fmt.Println(t)&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2023-04-26&#xA;2023-04-26 00:00:00 +0000 UTC&#xA;&#xA;2023-0426&#xA;parsing time &#34;2023-0426&#34; as &#34;2006-01-02&#34;: cannot parse &#34;26&#34; as &#34;-&#34;                                                          &#xA;0001-01-01 00:00:00 +0000 UTC&#xA;```&#xA;&#xA;In the above examples, we have parsed a time object from a string that looks like a date. We used the Parse method that takes in a string as the format to parse from and the string that we want to convert to. The format remains some specific date value like the `2006-01-02` which is fixed as a time to parse time in the time package. The method returns a time object which is parsed in the format, also it can return an error if the string is not in the provided format. We have used the second example that parsed a string as an invalid date format.&#xA;&#xA;## Time Duration field&#xA;&#xA;The time duration field is used to represent the elapsed time between two Time objects as an integer 64-bit (in hours at the biggest unit and nanoseconds as the smallest unit to scale).&#xA;&#xA;### Parse duration from string&#xA;&#xA;We can use the [ParseDuration](https://pkg.go.dev/time#ParseDuration) method to parse a duration like string into a time.Duration object. The duration object can have serialized fields like Hours, Minutes, and so on for further usage into the time processing.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;screentime, err := time.ParseDuration(&#34;6h30m&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;    fmt.Printf(&#34;%T&#xA;&#34;, screentime)&#xA;&#x9;fmt.Println(screentime.Hours())&#xA;&#x9;fmt.Println(screentime.Minutes())&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;time.Duration&#xA;6.5&#xA;390&#xA;```&#xA;&#xA;In this example, the time duration is 6 hours 30 minutes as indicated by `6h30m`. This is parsed as a time duration, the duration can accept formats like &#34;ns&#34;, &#34;us&#34; (or &#34;µs&#34;), &#34;ms&#34;, &#34;s&#34;, &#34;m&#34;, &#34;h&#34;. We have used the `h` and `m` as short forms of hours and minutes respectively. Similarly, `s` can be used for seconds, `ms` for milliseconds, `us` or `µs` for microseconds, and `ns` for nanoseconds respectively. If you use another format it will result in errors, and yes! you will have to write err != nil { handle the error } syntax and debug the issue in the console (just saying)&#xA;&#xA;The [ParseDuration](https://pkg.go.dev/time#ParseDuration) method will return the [Duration](https://pkg.go.dev/time#Duration) object or will error out if the string is not in the required short duration formats. In this example, the duration is stored in the `screentime` variable, which has a few methods like `Hours`, `Minutes`, `Seconds`, and so on to extract the component time duration in that object. So, if we use `screentime.Hours()`, this will give us the total hours in that parsed duration, in this case, it is `6.5` hours.&#xA;&#xA;The return type is:&#xA;&#xA;* `float64` for [Hours](https://pkg.go.dev/time#Duration.Hours), [Minutes](https://pkg.go.dev/time#Duration.Minutes), and [Seconds](https://pkg.go.dev/time#Duration.Seconds)&#xA;    &#xA;* `int64` for [Milliseconds](https://pkg.go.dev/time#Duration.Milliseconds), [Microseconds](https://pkg.go.dev/time#Duration.Microseconds), and [Nanoseconds](https://pkg.go.dev/time#Duration.Nanoseconds)&#xA;    &#xA;&#xA;This can be useful in Linux command line applications, where we can get the duration of the application running or execution speed, etc. It can be used to get the approximate number of hours or other metrics specific to the needs.&#xA;&#xA;The duration field is more useful for calculating the difference between two Time objects. Some methods like [Since](https://pkg.go.dev/time#Since), [Sub](https://pkg.go.dev/time#Time.Sub), are used to get the duration between the current time and other time objects and two Time objects respectively.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;newYear := time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC)&#xA;    // current time is 2023-06-18 15:27:12 +0000 UTC&#xA;    fmt.Println(time.Now().UTC())&#xA;&#x9;fmt.Println(time.Since(newYear).Hours())&#xA;&#xA;&#x9;nextNewYear := time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC)&#xA;&#x9;fmt.Println(nextNewYear.Sub(newYear).Hours())&#xA;&#x9;fmt.Println(nextNewYear.Sub(newYear).String())&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2023-06-18 15:27:12 +0000 UTC&#xA;4047.4130468335657&#xA;8760              &#xA;8760h0m0s&#xA;```&#xA;&#xA;So as seen from the examples, the `Since` method calculates the difference between the current time and some other time object, and the `Sub` method calculates the difference between two Time objects. The current time is `18th June 2023` which is roughly near the middle of the year, so if we get the duration from the start of the year(1st January 2023), we get `4047.4` hours. Similarly, we can get a duration between a year, i.e. 1st January 2023 and 1st January 2024, which comes out to be `8760` hours. We can even use `Minutes`, `Seconds`, `Milliseconds`, etc. to get the duration in those units.&#xA;&#xA;```go&#xA;day := time.Hour * 24&#xA;fmt.Println(day)&#xA;week := time.Hour * 24 * 7&#xA;fmt.Println(week)&#xA;month := time.Hour * 30 * 24 * 7&#xA;fmt.Println(month)&#xA;&#xA;fifteenDays := day * 15&#xA;fmt.Println(fifteenDays)&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;24h0m0s&#xA;168h0m0s&#xA;5040h0m0s&#xA;360h0m0s&#xA;```&#xA;&#xA;Here, we have created some custom units for calculating duration like a day which is 24 hours, that is obtained by multiplying an hour i.e. `time.Hour` by 24, and a week is 7 \* day, hence we do the calculation with precision in the duration structure. This can also be applied to `Minutes`, `Seconds`, and so on.&#xA;&#xA;## Time Zones and Locations&#xA;&#xA;Time zones are associated with every time object in the time structure. They are represented as [Locations](https://pkg.go.dev/time#Location) structure.&#xA;&#xA;[List of time zones](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)&#xA;&#xA;If not specified, the [`time.Now`](http://time.Now)`()` set the timezone as the Local time zone which is picked up from the system. It stores a list of timezone if the location uses daylight savings time, it picks the first timezone if daylight savings is not present.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;t := time.Now()&#xA;&#x9;fmt.Println(t)&#xA;&#x9;fmt.Println(t.Location())&#xA;&#xA;&#x9;newYorkTimeZone, err := time.LoadLocation(&#34;America/New_York&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;}&#xA;&#x9;londonTimeZone, err := time.LoadLocation(&#34;Europe/London&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;}&#xA;&#x9;newYorkTime := t.In(newYorkTimeZone)&#xA;&#x9;londonTime := t.In(londonTimeZone)&#xA;&#xA;&#x9;//local time&#xA;&#x9;fmt.Println(t)&#xA;&#xA;&#x9;// london time&#xA;    fmt.Println(londonTimeZone)&#xA;&#x9;fmt.Println(londonTime)&#xA;&#xA;&#x9;// new york time&#xA;    fmt.Println(newYorkTimeZone)&#xA;&#x9;fmt.Println(newYorkTime)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2023-06-19 13:58:13.232181805 +0530 IST m=+0.000044899&#xA;Local&#xA;2023-06-19 13:58:13.232181805 +0530 IST m=+0.000044899&#xA;&#xA;Europe/London&#xA;2023-06-19 09:28:13.232181805 +0100 BST&#xA;&#xA;America/New_York&#xA;2023-06-19 04:28:13.232181805 -0400 EDT&#xA;```&#xA;&#xA;The [LoadLocation](https://pkg.go.dev/time#LoadLocation) method is used to parse the timezone name as a string and returns the timezone/location object. It can return a `Location` object or an error in case the provided timezone name is not valid.&#xA;&#xA;We can use the [time.In](http://time.In)[(timezone)](https://pkg.go.dev/time#Time.In) to get the time in the specified timezone. In the above example, we have created a timezone/location object with the location name of the timezone as `Europe/London`. The timezone/location object has no exported/public properties or methods except the `String()` method used to get the string representation of the time stamp. However, this timezone is used to get time stamps in another timezone, for instance in this example, we have used my local timezone, i.e. `IST` or `Aisa/Kolkata` to get the current time, and used `In()` method to get time in `Europe/London` timezone. The `In()` method takes in a location object as a parameter and returns the `time.Time` object as the time in that provided location.&#xA;&#xA;### Creating a custom time zone&#xA;&#xA;A location object in the time package is basically a name and an offset value, so we can construct our own custom time zone location object with those parameters with the [FixedZone](https://pkg.go.dev/time#FixedZone) method. The `FixedZone` method takes in two parameters, one as the name of the timezone as a string, and the other as the offset as int. The offset can be up to 290 years roughly, as it can hold 64 bits and this can only represent an integer value as time only this far.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    t := time.Now()&#xA;    fmt.Println(t)&#xA;&#xA;&#x9;offset := int((4*time.Hour + 30*time.Minute + 30*time.Second).Seconds())&#xA;&#x9;// (4*60 + 30*1 + 30*0.166) * 60&#xA;&#x9;// (270 + 0.5) * 60 = 16230&#xA;&#x9;fmt.Println(offset)&#xA;&#x9;fmt.Println(t.UTC())&#xA;&#x9;customTimeZone := time.FixedZone(&#34;SOMETZ&#34;, offset)&#xA;&#x9;fmt.Println(customTimeZone)&#xA;&#x9;fmt.Println(t.In(customTimeZone))&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2023-06-19 15:25:44.8624019 +0530 IST m=+0.000044899&#xA;16230&#xA;2023-06-19 09:55:44.8624019 +0000 UTC&#xA;SOMETZ&#xA;2023-06-19 14:26:14.8624019 +0430 SOMETZ&#xA;```&#xA;&#xA;So from the example, the offset is 16230 seconds, which is then constructed by adding hours, minutes, and seconds, this is just an example, it shows you can customize the hour, minute, and seconds components, but you can extend it with millisecond up to nanosecond but that is a very niche case and might not be broadly used. To get an offset of `4h3030s`, we have used arithmetic to get the number of hours, minutes, and seconds.&#xA;&#xA;## Arithmetic on Time&#xA;&#xA;We can perform addition(going ahead) and subtraction(going back) of time in the `time.Time` object. There are also some comparison operations that can be performed using the method provided in the time struct.&#xA;&#xA;### Add Time and Date&#xA;&#xA;We can add a date to the `time.Time` object using the [Add](https://pkg.go.dev/time#Time.Add) method, this method takes in an integer value of `Hours`, `Minute`, `Second`, and so on to add the value of those units to the existing time object as a copy. This method can be chained to add multiple units of different types for instance hours, minutes, or seconds in a precise way to add the time. There is also a [AddDate](https://pkg.go.dev/time#Time.AddDate) method which takes in 3 parameters as a number of years, months, and days. We can add `x` years to the existing date by passing `AddDate(x, 0, 0)` to the time object we want to add to. These two method can be chained together to go from a scale of year to all the way to nanoseconds precision in adding the time.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;t := time.Now()&#xA;&#x9;fmt.Println(t)&#xA;&#xA;&#x9;afterOneHour := t.Add(time.Hour * 1)&#xA;&#x9;fmt.Println(afterOneHour)&#xA;&#xA;&#x9;afterOneDayTwoHours30minutes := t.AddDate(0, 0, 1).Add(time.Hour * 2).Add(time.Minute * 30)&#xA;&#x9;fmt.Println(afterOneDayTwoHours30minutes)&#xA;&#xA;&#x9;afterThreeMonths15days := t.AddDate(0, 3, 15)&#xA;&#x9;fmt.Println(afterThreeMonths15days)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2023-06-19 15:58:32.893246798 +0530 IST m=+0.000042833&#xA;2023-06-19 16:58:32.893246798 +0530 IST m=+3600.000042833&#xA;2023-06-20 18:28:32.893246798 +0530 IST&#xA;2023-10-04 15:58:32.893246798 +0530 IST&#xA;```&#xA;&#xA;Here, we can see, we have taken a simple example, for adding an hour to the existing time by saying `t.Add(time.Hour)`, this can be multiplied by the number of hours to add to, in this case, it was just one so we simply multiply with one. In the next example, we have chained the `AddDate` and `Add` methods to get the time after 1 day, 2 hours, and 30 minutes. The `AddDate` method is passed with `(0, 0, 1)` indicating a single day, then we tune the hours with 2 and minutes with 30 to get the desired time.&#xA;&#xA;In the last example, we have added the time by 3 months and 15 days, bypassing the `AddDate` method with `(0, 3, 15)`.&#xA;&#xA;Time can even be subtracted or we can get behind the specified time object using the negative number in the `Add` method. Instead of saying `.Add(1 * time.Hour)` to go one hour ahead of the parsed time, we can say `.Add(-1 * time.Hour)` to go one hour behind the current time.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    t := time.Now()&#xA;    fmt.Println(t)&#xA;&#xA;    oneHourBack := t.Add(-1 * time.Hour)&#xA;    fmt.Println(oneHourBack)&#xA;&#xA;    beforeOneYearTwoMonths := t.AddDate(-1, -2, 0)&#xA;    fmt.Println(beforeOneYearTwoMonths)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2023-06-19 16:23:26.992724868 +0530 IST m=+0.000044899&#xA;2023-06-19 15:23:26.992724868 +0530 IST m=-3599.999957644&#xA;2022-04-19 16:23:26.992724868 +0530 IST&#xA;```&#xA;&#xA;In this example, we have used the `Add` and `AddDate` methods with negative numbers to go back in time. In the first example, we have subtracted 1 hour from the existing time object, in the second example, we have used -1 to go back a year and -2 for going back 2 months from the current time object, hence we pass `.AddDate(-1, -2, 0)` in the example.&#xA;&#xA;### Comparing Time&#xA;&#xA;We can use `After`, `Before`, `Equal`, or `Compare` methods to compare the `Time` object in Golang. The method returns true or false depending if the time comes after, before, or is equal, the compare method returns -1 if it is before, 0 if two times are equal, and 1 if the time is after the other.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    t := time.Now()&#xA;    fmt.Println(t)&#xA;    &#xA;    afterOneHour := t.Add(time.Hour * 1)&#xA;    fmt.Println(afterOneHour)&#xA;&#xA;&#x9;isNowAfter := t.After(afterOneHour)&#xA;&#x9;isOneAfter := afterOneHour.After(t)&#xA;&#x9;fmt.Println(isNowAfter)&#xA;&#x9;fmt.Println(isOneAfter)&#xA;&#xA;&#x9;isNowBefore := t.Before(afterOneHour)&#xA;&#x9;isOneBefore := afterOneHour.Before(t)&#xA;&#x9;fmt.Println(isNowBefore)&#xA;&#x9;fmt.Println(isOneBefore)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2023-06-19 16:38:25.785629649 +0530 IST m=+0.000051616&#xA;2023-06-19 17:38:25.785629649 +0530 IST m=+3600.000051616&#xA;&#xA;// is now after one hour?&#xA;false&#xA;&#xA;// is one hour after now?&#xA;true &#xA;&#xA;// is now before after one hour?&#xA;true &#xA;&#xA;// is after one hour before now?&#xA;false&#xA;```&#xA;&#xA;These are some ridiculous examples, but it could be any date comparison like billing periods, subscription due, etc. We can compare dates with [After](https://pkg.go.dev/time#Time.After), [Before](https://pkg.go.dev/time#Time.Before), and [Equal](https://pkg.go.dev/time#Time.Equal) methods provided in the time package.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    t := time.Now()&#xA;    fmt.Println(t)&#xA;&#xA;    afterOneHour := t.Add(time.Hour * 1)&#xA;    fmt.Println(afterOneHour)&#xA;&#xA;&#x9;isNowEqual := t.Equal(afterOneHour)&#xA;&#x9;isEqual := time.Now().Equal(t)&#xA;&#x9;fmt.Println(isNowEqual)&#xA;&#x9;fmt.Println(isEqual)&#xA;&#xA;&#x9;londonTimeZone, err := time.LoadLocation(&#34;Europe/London&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;}&#xA;&#x9;londonTime := t.In(londonTimeZone)&#xA;&#xA;&#x9;fmt.Println(t)&#xA;&#x9;fmt.Println(londonTime)&#xA;&#x9;fmt.Println(t.Equal(londonTime))&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;2023-06-19 16:38:25.785629649 +0530 IST m=+0.000051616&#xA;2023-06-19 17:38:25.785629649 +0530 IST m=+3600.000051616&#xA;&#xA;// is now equal to one hour after now?&#xA;false&#xA;&#xA;// is t equal to now?&#xA;false&#xA;&#xA;2023-06-19 16:49:25.509421027 +0530 IST m=+0.000040200&#xA;2023-06-19 12:19:25.509421027 +0100 BST&#xA;&#xA;// is london time equal to now in local?&#xA;true&#xA;```&#xA;&#xA;Here in the examples, we have checked if two Time objects are equal or not, we have checked if a current time is equal to one hour after time, and it returns false rightly so. In the next example, we have created a new time object as [`time.Now`](http://time.Now), and then compared with the previous now, there will be a difference in the seconds of the initialization and hence it gives false as the return value.&#xA;&#xA;In the next example, we take the current time and the current time in the London location as the `BST` timezone, this gets the result as `true` because the time is the same despite being in different time zones.&#xA;&#xA;## Sleep Time&#xA;&#xA;We can even sleep for a certain duration of time, with the [Sleep](https://pkg.go.dev/time#Sleep) method in the time package, this results in halting the execution of the program.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    t1 := time.Now()&#xA;    time.Sleep(time.Second * 3)&#xA;    t2 := time.Now()&#xA;    duration := t2.Sub(t1)&#xA;    fmt.Println(duration)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;3.000235856s&#xA;```&#xA;&#xA;In this example, we have used the `Sleep()` method with a duration of 3 seconds which will halt the execution of the program (or the goroutine) for that duration. We also printed the duration for which the flow was halted by taking a timestamp before and after the sleep method was called and then taking the difference between the two-time stamps. This rightly gives us a value of three seconds which is the duration for which we tried to call the `Sleep` method.&#xA;&#xA;## Tickers&#xA;&#xA;Tickers are basically like a clock that ticks at regular intervals. It&#39;s a mechanism provided by the package to execute code repeatedly at fixed time intervals. The [Ticker](https://pkg.go.dev/time#Ticker) is a type and it has a few methods associated with it for handling these ticks. The [NewTicker](https://pkg.go.dev/time#NewTicker) method is used to create a ticker with the parameter as the amount of time to repeat the tick i.e. the frequency of its ticking. It will only stop when the [.Stop](https://pkg.go.dev/time#Ticker.Stop) method is called with that ticker object.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;ticker := time.NewTicker(time.Second * 2)&#xA;&#x9;counter := 0&#xA;&#x9;for {&#xA;&#x9;&#x9;select {&#xA;&#x9;&#x9;case &lt;-ticker.C:&#xA;&#x9;&#x9;&#x9;// api calls, call to database after specific time intervals&#xA;&#x9;&#x9;&#x9;counter++&#xA;&#x9;&#x9;&#x9;fmt.Println(&#34;Tick&#34;, counter)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if counter == 5 {&#xA;&#x9;&#x9;&#x9;ticker.Stop()&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;Tick 1&#xA;Tick 2&#xA;Tick 3&#xA;Tick 4&#xA;Tick 5&#xA;```&#xA;&#xA;In the example above, we have created a ticker with a frequency of 2 seconds, we initialize a counter to 0, we run an infinite condition for loop, and the ticker receives a value when the time is for ticking via the channel `.C`, this is used to check if it has ticked, and we enter the flow for the execution of any logic/code. We internally increment the counter and when the counter is 5 we stop the ticker and break out of the loop with either a `break` or `return`.&#xA;&#xA;So, that is how tickers can be used, this can be used in sending requests to APIs that have rate limiting, so we make sure we don&#39;t flood the API and maintain the rate of hitting the API only after specific intervals with tickers.&#xA;&#xA;That&#39;s it from the 28th part of the series, all the source code for the examples are linked in the GitHub on the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/scripts/date-time) repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, in conclusion, we have seen how to use the time package in Go. We covered time and date parsing, timezone, date comparison, sleep, and tickers. This would have given a good overview of the time package in golang.&#xA;&#xA;If you have any questions, feedback, or suggestions feel free to drop them in the comments section, or on the social handles. Thank you for reading. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Random Numbers</title>
      <link>meetgor.com/golang-random-numbers</link>
      <description>Generating random numbers, strings, shuffling arrays with golang, using packages like math/rand, crypto/rand, math/big.</description>
      <pubDate>Sun, 14 May 2023 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the 27th post of the series, we will be looking into random number generation in golang. We will be exploring how to create a random number, generate random numbers within a range, shuffle slices/arrays, and generate random strings, float, and bytes.&#xA;&#xA;There are two types of random number generation processes in software pseudo-random numbers and cryptographically secure pseudo-random number generation.&#xA;&#xA;The [math/rand](https://pkg.go.dev/math/rand) package in Golang provides a number of functions for generating pseudorandom numbers. These functions are suitable for a variety of applications, such as games, simulations, and to some extent in cryptography.&#xA;&#xA;The [crypto/rand](https://pkg.go.dev/crypto/rand) package in Golang generates cryptographically secure pseudorandom numbers. This means that the numbers are generated in a way that is very difficult to predict or reproduce. However, they are not truly random, as they are generated by a computer algorithm.&#xA;&#xA;## Creating a Random Source&#xA;&#xA;We need to first create a source/seed to generate a random number. If we do not add a new source each time we run the program or generate a random number, it will pick up the same source leading to the generation of the same pattern of the random numbers.&#xA;&#xA;We use the [rand.NewSource](https://pkg.go.dev/math/rand#NewSource) method to generate a new source of the random number, by initializing it with the current time in nanoseconds. Further, we need to create a [Rand](https://pkg.go.dev/math/rand#Rand) object for accessing the methods and properties attached to the struct type in the rand package for generating random numbers.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/rand&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;source := rand.NewSource(time.Now().UnixNano())&#xA;&#x9;rand_source := rand.New(source)&#xA;&#x9;for i := 0; i &lt; 5; i++ {&#xA;&#x9;&#x9;rand_num := rand_source.Int()&#xA;&#x9;&#x9;fmt.Println(rand_num)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run rand_source.go &#xA;2651653079934875120&#xA;5510445616427469234&#xA;3817011159463415912&#xA;5708754224362255659&#xA;7511308401304127761&#xA;```&#xA;&#xA;In the above example, we use the `NewSource` and the `New` method to generate the `Source` and the `Rand` object respectively. Further, for demonstration, we use the [Int](https://pkg.go.dev/math/rand#Rand.Int)method to generate a 64-bit random integer 5 times with a for loop.&#xA;&#xA;As we can see it generates a 5 random number, we will see why we need the random source initialized to the current time in the upcoming section.&#xA;&#xA;## Generating Random Numbers&#xA;&#xA;Random number as the name suggest are used to get an unpredictable number, however, using software we can only mimic the actual randomness. The process is called pseudo-random number generation. There is a particular pattern in the numbers, however, it is sufficient for trivial tasks in games, and simulations to some extent. However, actual cryptographic random numbers should be used for security tasks, crypto arithmetic, and other sensitive tasks.&#xA;&#xA;Golang provides a built-in package for both generating pseudo-random numbers called math/rand and cryptographic numbers with crypto/rand packages. This package contains a number of functions for generating random integers, floats, and strings.&#xA;&#xA;### Random Numbers&#xA;&#xA;To simply generate a random number we can use the `rand.Int` method from the [match/rand](https://pkg.go.dev/math/rand#Int) package to get a single random integer.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/rand&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(rand.Int())&#xA;&#x9;num := rand.Int()&#xA;    fmt.Printf(&#34;%d&#34;, num)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;5577006791947779410&#xA;int 8674665223082153551&#xA;&#xA;$ go run main.go&#xA;5577006791947779410&#xA;int 8674665223082153551&#xA;```&#xA;&#xA;In the above code, we have generated a couple of random numbers with the `rand.Int` method. The method returns a random 64-bit integer. If you run the program a few times, you can see the numbers are the same, so how exactly are they random?&#xA;&#xA;They are not random yet, we need to create a new seed/source each time we run the program in order to generate a new pattern of digits each time to generate a pseudo-random number.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/rand&#34;&#xA;    &#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    r := rand.New(rand.NewSoure(time.Now().UnixNano()))&#xA;&#xA;&#x9;fmt.Println(r.Int())&#xA;&#x9;num := r.Int()&#xA;    fmt.Printf(&#34;%d&#34;, num)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;5577006791947779410&#xA;int 8674665223082153551&#xA;7524437893560534176&#xA;int 5023070266853767708&#xA;&#xA;$ go run main.go&#xA;5577006791947779410&#xA;int 8674665223082153551&#xA;8935404877937414882 &#xA;int 209789266380754935&#xA;```&#xA;&#xA;No, we can see that after the `rand.New(rand.NewSource(time.Now().UnixNano()))` function call, the number generated is random each time we run the program. This is because we initialize the source of the random number generator package to the current time in nanoseconds.&#xA;&#xA;### Random Numbers in a Range&#xA;&#xA;The above numbers are too big, what if we want the random numbers to be in a specific range? This is quite a common thing to do, and hence there is a function like [rand.Intn](https://pkg.go.dev/math/rand#Intn) where we can specify the bound to which the function should generate the random numbers.&#xA;&#xA;```go&#xA; package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/rand&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func main() {   &#xA;    r := rand.New(rand.NewSoure(time.Now().UnixNano()))&#xA;&#xA;&#x9;for i := 0; i &lt; 10; i++ {&#xA;&#x9;&#x9;// generate an integer between 0 and 5&#xA;&#x9;&#x9;dice_throw := r.Intn(6)&#xA;&#x9;&#x9;// Move the Offset of 0&#xA;&#x9;&#x9;fmt.Println(dice_throw + 1)&#xA;&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;1&#xA;2&#xA;5&#xA;6&#xA;6&#xA;3&#xA;6&#xA;1&#xA;4&#xA;2&#xA;```&#xA;&#xA;In the above code, we have used the `r.Intn(upper_range int)` method to generate a random number between 0 and the provided range, so if we give a parameter to the method `r.Intn(6)`, it would generate the numbers between 0 and 5. so the range is not inclusive 0, 6). Thereby the numbers generated will be either 0, 1, 2, 3, 4, or 5. So to remove the offset of 0, we add 1.&#xA;&#xA;Hence we get some pseudo-random numbers between 1 and 6. I have used a for loop that generates 10 such numbers.&#xA;&#xA;### Cryptographic Random Numbers&#xA;&#xA;The above method was a pseudo-random number generator, however, for more robust random number generations, we can use the [crypto/rand](https://pkg.go.dev/crypto/rand) package that is more secure and powerful for complex operations.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;crypto_rand &#34;crypto/rand&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/big&#34;&#xA;)&#xA;&#xA;func Handle_error(err error) {&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;// Cryptographic random numbers&#xA;&#x9;var max *big.Int = big.NewInt(6)&#xA;&#x9;// big is a package for high-precision arithmetic&#xA;&#x9;for i := 0; i &lt; 10; i++ {&#xA;&#x9;&#x9;crypt_rand_num, err := crypto_rand.Int(crypto_rand.Reader, max)&#xA;&#x9;&#x9;Handle_error(err)&#xA;&#x9;&#x9;// Move the Offset of 0 by adding 1&#xA;&#x9;&#x9;crypt_num := crypt_rand_num.Add(crypt_rand_num, big.NewInt(1))&#xA;&#x9;&#x9;fmt.Println(crypt_num)&#xA;&#x9;}&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;3&#xA;5&#xA;5&#xA;1&#xA;5&#xA;5&#xA;4&#xA;2&#xA;3&#xA;6&#xA;```&#xA;&#xA;In the above example, we have used the [math/big](https://pkg.go.dev/math/big) package to store the random number generated by the [Int](https://pkg.go.dev/crypto/rand#Int) method in the `crypto/rand` package. We create a new integer from the `big` package. The [NewInt](https://pkg.go.dev/math/big#NewInt) function returns a pointer to the integer. So, we parse the integer 6 which will create a memory location storing 6 as a [big.Int](https://pkg.go.dev/math/big#Int) type. We use the max variable name as it denotes the maximum number to be generated in the next step.&#xA;&#xA;Then we can use the [crypto/rand](https://pkg.go.dev/crypto/rand) package to generate cryptographic random numbers. The package has [Int](https://pkg.go.dev/crypto/rand#Int) method to generate a `big.Int` type of number in a given range. However, it also takes in a [Reader](https://pkg.go.dev/crypto/rand#pkg-variables) object that is global in the package used as a shared instance of a cryptographically secure random number generator. This means it can be used as the platform&#39;s default random number generator in the program.&#xA;&#xA;So, the `crypto_rand.Int` method takes in two parameters, the `Reader` object which will be the platform-specific random number generator/api, and the next parameter is the max range to generate the random number. So, this method returns a `big.Int` type. This is the cryptographic random number.&#xA;&#xA;However, we have the range from 0 to 5 again, so we just add 1 to the `big.Int` type by using the [Add](https://pkg.go.dev/math/big#Int.Add) method associated to the `big.Int` type as `crypto_rand_num` variable and then parse two parameters as x and y, i.e. the two numbers to add. So, we just pass the `crypto_rand_num` and a new integer `1`. This adds the numbers and we store it in the `crypto_num` variable. This is how we generate a cryptographic random number between 1 and 6.&#xA;&#xA;### Random Float&#xA;&#xA;We can even generate random types like float. There are a quite a few variations like [Float32](https://pkg.go.dev/math/rand#Float32), [Float64](https://pkg.go.dev/math/rand#Float64), [ExpFloat64](https://pkg.go.dev/math/rand#ExpFloat64), and [NormFloat64](https://pkg.go.dev/math/rand#NormFloat64).&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/rand&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    r := rand.New(rand.NewSoure(time.Now().UnixNano()))&#xA;&#xA;    rand_float32 := r.Float32()&#xA;&#x9;fmt.Println(rand_float32)&#xA;&#xA;&#x9;rand_float64 := r.Float64()&#xA;&#x9;fmt.Println(rand_float64)&#xA;&#xA;&#x9;rand_exp_float := r.ExpFloat64()&#xA;&#x9;fmt.Println(rand_exp_float)&#xA;&#xA;&#x9;rand_norm_float := r.NormFloat64()&#xA;&#x9;fmt.Println(rand_norm_float)&#xA;&#xA;&#x9;for i := 0; i &lt; 5; i++ {&#xA;&#x9;&#x9;rand_float := r.Float32()&#xA;&#x9;&#x9;fmt.Println(rand_float)&#xA;&#x9;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;0.08891088&#xA;0.9218221078616824&#xA;1.8237338579299396&#xA;-0.30238778160373464&#xA;&#xA;0.65474856&#xA;0.65964687&#xA;0.39930198&#xA;0.8043338&#xA;0.17894344&#xA;```&#xA;&#xA;We have used 4 types for generating a random float. We have two variations of the float depending on the size, 32 or 64-bit number. We get 32-bit and 64-bit random floats from the `r.Float32` and `r.Float64` respectively.&#xA;&#xA;The `r.ExpFloat64` function returns an exponentially distributed float64 with a range from 0 to +math.MaxFloat64 with rate parameter and mean as 1. If you want to change the distribution&#39;s rate parameter, it can be done by dividing the number by the desired rate parameter.&#xA;&#xA;The `r.NormFlaot64` function returns a normally distributed float64 with a range from -math.MaxFloat64 to +math.MaxFloat64 with mean as 0 and standard deviation as 1. This can also be changed by multiplying the generated number by the desired standard deviation and then adding the desired mean.&#xA;&#xA;## Generating Random Strings&#xA;&#xA;We can generate a random string of a specific length. We can generate a random number between 0 and 25 and then add 97 for lowercase ASCII characters and add 65 for uppercase characters. So, we generate a random number between 97 and 122 which can be cast to string/rune to get the string equivalent of the numbers.&#xA;&#xA;This get&#39;s us a single character which would be random and thereby we use for loop to generate a fixed length random string for upper case and lower case characters similarly.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/rand&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;r := rand.New(rand.NewSoure(time.Now().UnixNano()))&#xA;&#xA;    //Random string&#xA;&#x9;randomLowerCase := make([]rune, 6)&#xA;&#x9;randomUpperCase := make([]rune, 6)&#xA;&#x9;for i := range randomLowerCase {&#xA;&#x9;&#x9;randomLowerCase[i] = rune(r.Intn(26) + 97)&#xA;&#x9;&#x9;randomUpperCase[i] = rune(r.Intn(26) + 65)&#xA;&#x9;}&#xA;&#x9;randomLowerCaseStr := string(randomLowerCase)&#xA;&#x9;randomUpperCaseStr := string(randomUpperCase)&#xA;&#xA;&#x9;fmt.Println(randomLowerCase)&#xA;&#x9;fmt.Println(randomLowerCaseStr)&#xA;&#x9;fmt.Println(randomUpperCase)&#xA;&#x9;fmt.Println(randomUpperCaseStr)&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;[100 113 122 97 107 101]&#xA;dqzake&#xA;[86 81 88 76 66 74]&#xA;VQXLBJ&#xA;&#xA;$ go run main.go&#xA;[116 115 120 97 100 111]&#xA;tsxado&#xA;[80 74 66 83 77 66]&#xA;PJBSMB&#xA;```&#xA;&#xA;We first create an empty or 0 initialized rune slice with length 6, it can be any length as per your requirement. Then we create a for loop iterating over that slice and set each rune to the `r.Intn` method with range 26 and add 97 for lower case letters and add 65 for upper case letters. This generates an integer between 97 to 122 that is typecast to a rune to represent the slice. Similarly, it generates an integer between 65 and 90 which is typecast to rune.&#xA;&#xA;## Shuffling Arrays&#xA;&#xA;We can use the [rand.Shuffle](https://pkg.go.dev/math/rand#Shuffle) and the [rand.Perm](https://pkg.go.dev/math/rand#Perm) to shuffle and create a random permutation of a particular list/slice of elements.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/rand&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    r := rand.New(rand.NewSoure(time.Now().UnixNano()))&#xA;&#xA;    fmt.Println(r.Perm(10))&#xA;&#xA;&#x9;arr := []int{1, 2, 3, 4, 5, 6}&#xA;&#x9;fmt.Println(&#34;Before shuffle:&#34;, arr)&#xA;&#x9;r.Shuffle(len(arr), func(i, j int) {&#xA;&#x9;&#x9;arr[i], arr[j] = arr[j], arr[i]&#xA;&#x9;})&#xA;&#x9;fmt.Println(&#34;After shuffle:&#34;, arr)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;[8 1 9 3 7 2 0 6 5 4]&#xA;&#xA;Before shuffle: [1 2 3 4 5 6]&#xA;After shuffle: [4 6 5 3 2 1]&#xA;```&#xA;&#xA;In the above example, we have used the `rand.Perm` method to create a permutation of the n number passed as a parameter. So, it would generate a permutation of numbers from 0 to 9 if we pass 10 as the parameter to the method. It would return a slice of int.&#xA;&#xA;We also have used the `rand.Shuffle` method to shuffle an already existing slice of elements. This is not restricted to int, it can be any type of slice. The method takes in two parameters, the length of the slice/array and the swap function which is an anonymous function.&#xA;&#xA;In the example, I have created an arr slice with 6 elements, it could be any number, for demonstration, I have initialized the slice with 1 to 6 numbers. The `rand.Shuffle` method has been parsed with the length of the `arr` as `len(arr)` and an anonymous function that takes in two integers as the indices of the array and inside the function, we swap the elements of the array. This can be modified as per the requirement, but this is the base swap function for the shuffle method.&#xA;&#xA;So, in the output, we print the shuffled array, which now looks like a random array of numbers.&#xA;&#xA;We can use the `Perm` method to generate a random list of indices of an array, and then assign the index to the string, to generate a random shuffled string.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/rand&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    r := rand.New(rand.NewSoure(time.Now().UnixNano()))&#xA;&#xA;    letters := &#34;abcdefghijklmnopqrstuvwxyz&#34;&#xA;&#x9;shuffled := r.Perm(len(letters))&#xA;&#xA;&#x9;result := make([]byte, len(letters))&#xA;&#x9;for i, randIndex := range shuffled {&#xA;&#x9;&#x9;result[i] = letters[randIndex]&#xA;&#x9;}&#xA;    rand_str := string(result)&#xA;&#x9;fmt.Println(rand_str)&#xA;    // random string of length 10&#xA;    fmt.Println(rand_str[:10]&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;yeinvkdbfqomacrzhtswgxulpj&#xA;yeinvkdbfq&#xA;&#xA;$ go run main.go&#xA;tvakbgnjprwiofquxlzecdshym&#xA;tvakbgnjpr&#xA;```&#xA;&#xA;In the above example, we have first created the string with all the alphabets and then created a random permutation with the length of that array i.e. 26. This would create a random permutation of numbers from 0 to 25. This is now a list of numbers, which can be used to assign the index of the string, to make it feel like a shuffled string.&#xA;&#xA;We create a for loop for the string iteration and assign the index with the random operation array index. This will basically jumble the order of the elements/characters in the string. We can then truncate or slice the string to any length as per the requirement.&#xA;&#xA;## Random Read Bytes&#xA;&#xA;There is another way to generate a slice of bytes/string with the [Read](https://pkg.go.dev/math/rand#Rand.Read) method. We have used the `Read` method in the cryptographic random number generation part. The Read method generates a random byte for the given length of a slice of bytes.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;crypto_rand &#34;crypto/rand&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/big&#34;&#xA;&#x9;&#34;math/rand&#34;&#xA;&#x9;&#34;time&#34;&#xA;)&#xA;&#xA;func Handle_error(err error) {&#xA;    if err != nil {&#xA;        panic(err)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;    r := rand.New(rand.NewSoure(time.Now().UnixNano()))&#xA;    rand_byte := make([]byte, 5)&#xA;&#x9;fmt.Println(rand_byte)&#xA;&#x9;_, err = r.Read(rand_byte)&#xA;    Handle_error(err)&#xA;&#x9;fmt.Println(rand_byte)&#xA;    fmt.Printf(&#34;%c &#xA;&#34;, rand_byte)&#xA;&#xA;&#x9;crypt_rand_byte := make([]byte, 5)&#xA;&#x9;fmt.Println(crypt_rand_byte)&#xA;&#x9;_, err = crypto_rand.Read(crypt_rand_byte)&#xA;&#x9;Handle_error(err)&#xA;    fmt.Println(crypt_rand_byte)&#xA;    fmt.Printf(&#34;%c &#xA;&#34;, crypto_rand_byte)&#xA;&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;&#xA;[0 0 0 0 0]&#xA;[88 53 113 116 251]&#xA;[X 5 q t û]&#xA;&#xA;[0 0 0 0 0]&#xA;[37 90 42 93 96]&#xA;[% Z * ] `] &#xA;```&#xA;&#xA;We have demonstrated usage of both the packages i.e. math/rand and crypto/rand for the generation of random bytes. In the example above, we initialize a slice of byte `rand_byte` and use the `Read` method that will take in the slice of byte as the parameter and return two things, the number of bytes it read and the error object if there is any or nil. So, we do not care how many bytes it read right now, so we do the `_` for the read bytes. It mutates/modifies the byte slice and the slice elements are then random byte values.&#xA;&#xA;We can print the slice of byte as a string with `%s`, or each character in the bytes using the `%c` format specifier. So, the generated bytes are between 0 and 255, which include Unicode and ASCII characters.&#xA;&#xA;Similarly, for the crypto/rand package, we create a slice of bytes with size 5 and use the crypto/rand package provided [Read](https://pkg.go.dev/crypto/rand#Read) method directly to modify the slice of bytes to random bytes.&#xA;&#xA;That&#39;s it from the 27th part of the series, all the source code for the examples are linked in the GitHub on the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/scripts/random-num) repository.&#xA;&#xA;## Conclusion&#xA;&#xA;From this part of the series, we were able to explore the random number generation in golang, packages like math/rand, mah/big, and crypto/rand were used for the examples and generation of random numbers, cryptographic secure random numbers, random strings and shuffling of arrays.&#xA;&#xA;So, hopefully, the article might have found useful to you, if you have any queries, questions, feedback, or mistakes in the article, you can let me know in the discussion or on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Regex</title>
      <link>meetgor.com/golang-regex</link>
      <description>Understanding the fundamentals and usage of regular expressions in golang with the regexp package. Exploring the package with the matching, finding, replacing and submatches methods and utilities with regular expressions.</description>
      <pubDate>Wed, 22 Mar 2023 00:00:00 UTC</pubDate>
      <content>&#xA;&#xA;## Introduction&#xA;&#xA;In this 26th part of the series, we will be covering the basics of using regular expressions in golang. This article will cover the basic operations like matching, finding, replacing, and sub-matches in a regular expression pattern from string source or file content. This will have examples for each of the concepts and similar variants will follow the same ideology in self-exploring the syntax.&#xA;&#xA;## Regex in golang&#xA;&#xA;So, let&#39;s start with what are regular expressions.&#xA;&#xA;&gt; Regular expressions are basic building blocks for searching, pattern matching, and manipulation from a source of text using computational logic.&#xA;&#xA;This is not the formal definition, but have written it in words for my understanding of regular expressions till now. Might not be accurate, but makes sense to me after I had played and explored it (not fully).&#xA;&#xA;So regular expressions use some pattern-matching techniques using basic logic operators like concatenation, quantifiers, etc. These relate to the study of the theory of computation quite closely but you don&#39;t need to get into too much theory in order to understand the working of regular expressions. However, it won&#39;t harm you if you are curious about it and want to explore it further.&#xA;&#xA;Some resources to learn the fundamentals of regular expressions:&#xA;&#xA;* [Regular Expressions LMU notes](https://cs.lmu.edu/~ray/notes/regex/)&#xA;    &#xA;* [RegexOne](https://regexone.com/)&#xA;    &#xA;&#xA;## Regexp package&#xA;&#xA;We will be using the [regexp](https://pkg.go.dev/regexp) package in the golang standard library to get some quick and important methods for quick and neat pattern matching and searching. It provides a `Regexp` type and a lot of methods on top of it to perform matching, finding, replacing, and sub-matches in the source text.&#xA;&#xA;This package also supports two types of methods serving different purposes and use cases for string and slice of bytes, this can be useful for reading from a buffer, file, etc., and also flexible enough to search for a simple string.&#xA;&#xA;## Matching Patterns&#xA;&#xA;One of the fundamental aspects of the regular expression is to check if a particular pattern is present or not in a source string. The `regexp` package provides some methods like [Match](https://pkg.go.dev/regexp#Match), [MatchString](https://pkg.go.dev/regexp#MatchString) methods on a slice of bytes and string respectively from the pattern string.&#xA;&#xA;### Matching Strings&#xA;&#xA;The basic operations with regex or regular expression can be performed to compare and match if the pattern matches a given string.&#xA;&#xA;In golang, the [regexp](https://pkg.go.dev/regexp) package provides a few functions to simply match expressions with strings or text. One of the easy-to-understand ones include the [MtachString](https://pkg.go.dev/regexp#MatchString), and [Match](https://pkg.go.dev/regexp#Match) methods.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;regexp&#34;&#xA;)&#xA;&#xA;func log_error(err error) {&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;str := &#34;gophers of the goland&#34;&#xA;&#x9;is_matching, err := regexp.MatchString(&#34;go&#34;, str)&#xA;&#x9;log_error(err)&#xA;&#x9;log.Println(is_matching)&#xA;&#x9;is_matching, err := regexp.MatchString(&#34;no&#34;, str)&#xA;&#x9;log_error(err)&#xA;&#x9;log.Println(is_matching)&#xA;&#xA;}&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;true&#xA;false&#xA;```&#xA;&#xA;In the above code, we have used the `MatchString` method that takes in two parameters string/pattern to find, and the source string. The function returns a boolean as `true` or `false` if the pattern is present in the source string, also it might return an error if the pattern(first parameter) is parsed as an incorrect regular expression.&#xA;&#xA;So, we can clearly see, the string `go` is present in the string `gophers of the goland` and the string `no` is not a substring.&#xA;&#xA;We also have `Match` method which is a more general version of `MatchString` it excepts a slice of byte rather than a string as the source string. The first parameter is still a string, but the second parameter is a slice of bytes.&#xA;&#xA;```go&#xA;is_matching, err = regexp.Match(`.*land`, []byte(&#34;goland is a land of gophers&#34;))&#xA;log_error(err)&#xA;log.Println(is_matching)&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;true&#xA;```&#xA;&#xA;We can use the `Match` method to simply parse a slice of bytes to use as the source text to check the pattern.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;    &#34;os&#34;&#xA;&#x9;&#34;regexp&#34;&#xA;)&#xA;&#xA;func log_error(err error) {&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;file_content, err := os.ReadFile(&#34;temp.txt&#34;)&#xA;&#x9;log_error(err)&#xA;&#x9;is_matching, err = regexp.Match(`memory`, file_content)&#xA;&#x9;log_error(err)&#xA;&#x9;log.Println(is_matching)&#xA;&#x9;is_matching, err = regexp.Match(`text `, file_content)&#xA;&#x9;log_error(err)&#xA;&#x9;log.Println(is_matching)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;# temp.txt&#xA;&#xA;One of the gophers used a slice,&#xA;the other one used a arrays.&#xA;Some gophers were idle in the memory.&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;true&#xA;false&#xA;```&#xA;&#xA;We can now even parse the contents of a file as a slice of bytes. So, it would be really nice to compare and check for a string pattern in a file quickly. Here in the above example, we have checked if `memory` is present in the text which it is, and in the second call, we check if `text` string is present anywhere in the file content which it is not.&#xA;&#xA;## Find Patterns&#xA;&#xA;We can even use regular expressions for searching text or string with the struct/type [Regexp](https://pkg.go.dev/regexp#Regexp) provided by golang&#39;s regexp. We can create a regular expression and use other functions like `MatchString`, `Match`, and others that we will explore to match or find a pattern in the text.&#xA;&#xA;### Find String from RegEx&#xA;&#xA;We can get a slice of byte from the `FindAll` method which will take in a slice of byte, the second parameter as -1 for all matches. The function returns a slice of slice of byte with the byte representation of the matched string in the source text.&#xA;&#xA;```bash&#xA;exp, err := regexp.Compile(`�\d{5}(?:[-\s]\d{4})?�`)&#xA;log_error(err)&#xA;pincode_file, err := os.ReadFile(&#34;pincode.txt&#34;)&#xA;log_error(err)&#xA;match := exp.FindAll(pincode_file, -1)&#xA;log.Println(match)&#xA;```&#xA;&#xA;```bash&#xA;# pincode.txt&#xA;&#xA;Pincode: 12345-1234&#xA;City, 40084&#xA;State 123&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;[[49 50 51 52 53 45 49 50 51 52] [52 48 48 56 52]]&#xA;```&#xA;&#xA;In the above example, we have used the [Compile](https://pkg.go.dev/regexp#Compile) method to create a regular expression and [FindAll](https://pkg.go.dev/regexp#Regexp.FindAll) to get all the occurrences of the matching patterns in the text. We have again read the contents from the file. In this example, the `exp` is a regular expression for a postal code, which can either have 5 digit or 5digits-4digit combination. We read the file `pincode.txt` as a slice of bytes and use the `FindAll` method. The FindAll method takes in the parameter as a slice of byte and the integer as the number of occurrences to search. If we use a negative number it will include all the matches.&#xA;&#xA;We search for the pin code in the file and the funciton returns a list of bytes that match the regular expression in the provided object `exp`. Finally, we get the result as `12345-1234` and `40084` which are present in the file. It doesn&#39;t match the number `123` which is not a valid match for the given regular expression.&#xA;&#xA;There is also a version of `FindAll` as `FindAllString` which will take in a string as the text source and return a slice of strings.&#xA;&#xA;```go&#xA;matches := exp.FindAllString(string(pincode_file), -1)&#xA;log.Println(matches)&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;[&#34;12345-1234&#34; &#34;40084&#34;]&#xA;```&#xA;&#xA;So, the `FindAllString` would return a slice of strings of the matches in the text.&#xA;&#xA;### Find the Index of String from RegEx&#xA;&#xA;We can even get the start and end index of the matched string in the text using the [FindIndex](https://pkg.go.dev/regexp#Regexp.FindIndex) and [FindAllIndex](https://pkg.go.dev/regexp#Regexp.FindAllIndex) methods to get the indexes of the match, or all the matches of the file content.&#xA;&#xA;```go&#xA;exp, err := regexp.Compile(`�\d{5}(?:[-\s]\d{4})?�`)&#xA;log_error(err)&#xA;pincode_file, err := os.ReadFile(&#34;pincode.txt&#34;)&#xA;log_error(err)&#xA;&#xA;match_index := exp.FindIndex(pincode_file)&#xA;log.Printf(&#34;%T&#xA;&#34;, match_index)&#xA;log.Println(match_index)&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;[]int&#xA;[9 19]&#xA;```&#xA;&#xA;The above code is using the `FindIndex` method to get the indexes of the first match of the regular expression. The output of the code gives a single slice of an integer with length two as the start and last index of the matched string in the text file. So, here, the `9` represents the position(index) of the first character match in the string, and `19` is the last index of the matched string.&#xA;&#xA;```bash&#xA;Pincode: 12345-1234&#xA;01234567890123456789&#xA;&#xA;Assume 0 as 10 after 9, 11, and so on&#xA;It starts from the 9th character as `1` and ends at the `4` character&#xA;at position 18 but it returns the end position + 1 for the ease of slicing&#xA; &#xA;City, 40084&#xA;012345678901&#xA;&#xA;State 123&#xA;234567890&#xA;```&#xA;&#xA;The character at 9 and 18 are the first and the last character position/index of the source string, so it returns the end position + 1 as the index. This makes retrieval of slicing source string much easier, as we won&#39;t be offset by one.&#xA;&#xA;If we want to get the text in the source string, we can use the slicing as:&#xA;&#xA;```go&#xA;exp, err := regexp.Compile(`�\d{5}(?:[-\s]\d{4})?�`)&#xA;log_error(err)&#xA;pincode_file, err := os.ReadFile(&#34;pincode.txt&#34;)&#xA;log_error(err)&#xA;&#xA;match_index := exp.FindIndex(pincode_file)&#xA;if len(match_index) &gt; 0 {&#xA;    &#xA;    // Get the slice of the original string from start to end index&#xA;    sliced_string := pincode_file[match_index[0]:match_index[1]]&#xA;    log.Printf(&#34;%q&#xA;&#34;, sliced_string)&#xA;}&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;&#34;12345-1234&#34;&#xA;```&#xA;&#xA;So, we can access the string from the source text without calling other functions, simply slicing the original string will retrieve the expected results. This is the convention of the golang standard library to make the end index exclusive.&#xA;&#xA;Similarly, the `FindAllIndex` method can be used to get a list of list of such indexes of matched strings.&#xA;&#xA;```go&#xA;exp, err := regexp.Compile(`�\d{5}(?:[-\s]\d{4})?�`)&#xA;log_error(err)&#xA;pincode_file, err := os.ReadFile(&#34;pincode.txt&#34;)&#xA;log_error(err)&#xA;&#xA;match_indexes := exp.FindAllIndex(pincode_file)&#xA;log.Printf(&#34;%T&#xA;&#34;, match_indexes)&#xA;log.Println(match_indexes)&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;[][]int&#xA;[[9 19] [26 31]]&#xA;```&#xA;&#xA;The above example gets the list of slices as for all the search pattern indexes in the source string/text. We can iterate over the list and get each matched string index.&#xA;&#xA;## Find Submatch&#xA;&#xA;the `regexp` package also has a utility function for finding the sub-match of a given regular expression. The method returns a list of strings (or slices of bytes) containing the leftmost match and the sub-matches in that match. This also has the `All` version which instead of returning a single match i.e. the leftmost match it returns all the matches and the corresponding sub-matches.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;regexp&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;str := &#34;abc@def.com is the mail address of 8th user with id 12&#34;&#xA;&#x9;exp := regexp.MustCompile(&#xA;        `([a-zA-Z0-9]+@[a-zA-Z0-9]+\.[a-zA-Z]{2,})` + &#xA;            `|(email|mail)|` + &#xA;            `(\d{1,3})`)`,&#xA;    )&#xA;&#x9;match := exp.FindStringSubmatch(str)&#xA;&#x9;log.Println(match)&#xA;&#x9;matches := exp.FindAllStringSubmatch(str, -1)&#xA;&#x9;log.Println(matches)&#xA;}&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;[abc@def.com abc@def.com  ]&#xA;[[abc@def.com abc@def.com  ] [mail  mail ] [8   8] [12   12]]&#xA;```&#xA;&#xA;The above example uses a regex to compute a few things like email address, words like `mail` or `email`, also a number of up to 3 digits. The `|` between these expressions indicates any combination of these three things would be matched for the regular expression. The [FindStringSubmatch](https://pkg.go.dev/regexp#Regexp.FindStringSubmatch) method, takes in a string as the source and returns a slice of the matching pattern. The first element is the leftmost match in the string source for the given regular expression, and the subsequent elements are the sub-matches in the matched string.&#xA;&#xA;We can now move a little step ahead for actually understanding the sub-match in a regular expression.&#xA;&#xA;```go&#xA;str := &#34;abe21@def.com is the mail address of 8th user with id 124&#34;&#xA;exp := regexp.MustCompile(&#xA;    `([a-zA-Z]+(\d*)[a-zA-Z]*@[a-zA-Z]*(\d*)[a-zA-Z]+\.[a-z|A-Z]{2,})` +&#xA;        `|(mail|email)` +&#xA;        `|(\d{1,3})`,&#xA;)&#xA;&#xA;match := exp.FindStringSubmatch(str)&#xA;log.Println(match)&#xA;matches := exp.FindAllStringSubmatch(str, -1)&#xA;log.Println(matches)&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;[abe21@def.com abe21@def.com 21   ]&#xA;[[abe21@def.com abe21@def.com 21   ] [mail    mail ] [8     8] [124     124]]&#xA;```&#xA;&#xA;In the above example, there are a few things to take away, let us break it down into small pieces. We have a regex for matching either a mail address, the word `mail` or `email`, or a number up to 3 digits. The regex is a bit different from the previous example for understanding the sub-matches within an expression. We find the sub-matches in the string which will be handled by the `FindStringSubmatch`. This function takes in a string and returns a list of strings that are the leftmost matches in the source string.&#xA;&#xA;First, we need to understand the regex to get a clear idea of the code snippet. The first sub-match is for the email address. However, we use `[a-zA-Z]` in the picking of the username and the domain name, we don&#39;t want to directly match numbers yet. The goal of this regex is to pick up numbers inside an email address. So, we can have 1 or more characters `[a-zA-z]+`, followed by 0 or more digits `(\d*)`, and again we can have 0 or more characters `[a-zA-Z]*`. The `+` is for 1 or more, `*` is for 0 or more, `\d` is for digits. After this, we have the `@` as a compulsory character in the mail, followed by the same sequence in the username i.e. 1 or more characters, 0 or more digits, 0 or more characters. Finally, we have the `.com` and the domain name extensions, as a group of 2 or more characters `[a-z|A-Z]{2,}`.&#xA;&#xA;So, the regex accepts an email, with a sub-match of the number anywhere in the username or the domain name.&#xA;&#xA;The `FindStringSubmatch` function lists out the sub-matches for the leftmost(first) match of the regex in the source string. So it finds the string `abc21@def.com` which is the email id. This regex `([a-zA-Z]+(\d*)[a-zA-Z]*@[a-zA-Z]+(\d*)[a-zA-Z]*\.[a-z|A-Z]{2,})` has two sub-matches `\d*` in the username part and also in the domain part. So, the list returns the email address as the match and the match as itself, as well as the number in the sub-match inside the mail address. So the result, `[abc21@def.com abc21@def.com 21 ]`, there are a few empty string sub-matches because the second sub-match for the domain name number returns an empty string.&#xA;&#xA;Similarly, the `FindAllStringSubmatch` will return the list of all the matches in the source string. The other matches don&#39;t have any sub-matches in the regular expression so it just gets the match and the sub-match as itself in the case of string `mail`, digit `8`, and digit `124`.&#xA;&#xA;We can also use this example from a file as a slice of bytes. This will return a list of slice of slice of bytes instead of slice of slice of strings.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;regexp&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    exp := regexp.MustCompile(&#xA;        `([a-zA-Z]+(\d*)[a-zA-Z]*@[a-zA-Z]*(\d*)[a-zA-Z]+\.[a-z|A-Z]{2,})` +&#xA;            `|(mail|email)` +&#xA;            `|(\d{1,3})`,&#xA;    )&#xA;&#x9;email_file, err := os.ReadFile(&#34;subtext.txt&#34;)&#xA;&#x9;log_error(err)&#xA;&#x9;mail_match := exp.FindSubmatch(email_file)&#xA;&#x9;log.Printf(&#34;%s&#xA;&#34;, mail_match)&#xA;&#x9;mail_matches := exp.FindAllSubmatch(email_file, -1)&#xA;&#x9;//log.Println(mail_matches)&#xA;&#x9;log.Printf(&#34;%s&#xA;&#34;, mail_matches)&#xA;&#xA;}&#xA;```&#xA;&#xA;```txt&#xA;# submatch.txt&#xA;&#xA;abc21@def.com is the mail address of user id 1234&#xA;The email address abe2def.com is of user name abc&#xA;a2be.@def.com&#xA;Email address: abe@de2f.com, User id: 45&#xA;johndoe@example.com&#xA;jane.doe123@example.com&#xA;janedoe@example.co.uk&#xA;john123@example.org&#xA;janedoe456@example.net&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;[][]unit8&#xA;[abc21@def.com abc21@def.com 21   ]&#xA;&#xA;[][][]unit8&#xA;[&#xA;    [abc21@def.com abc21@def.com 21   ] [mail    mail ] [123 123] [4     4] &#xA;    [email    email ] [2     2] [2     2] [mail    mail ] &#xA;    [abe@de2f.com abe@de2f.com  2  ] [45     45] &#xA;    [johndoe@example.com johndoe@example.com    ] &#xA;    [doe123@example.com doe123@example.com 123   ] &#xA;    [janedoe@example.co janedoe@example.co    ] &#xA;    [john123@example.org john123@example.org 123   ] &#xA;    [janedoe456@example.net janedoe456@example.net 456   ]&#xA;]&#xA;```&#xA;&#xA;As we can see from the dummy email ids and some random text, we are able to match the email ids and the numbers in them as the sub-match of the string. This is a `[][]unit8` in case of the `FindSubmatch` and `[][][]unit8` in case of `FindAllSubmatch`. The working remains the same for the bytes as it was for the strings.&#xA;&#xA;### Find Submatch Index&#xA;&#xA;We also have the [FindSubmatchIndex](https://pkg.go.dev/regexp#Regexp.FindSubmatchIndex) and [FindAllSubmatchIndex](https://pkg.go.dev/regexp#Regexp.FindAllSubmatchIndex), and the string variants to get the index(es) of the sub-matches in the pattern picked from the regular expression.&#xA;&#xA;```go&#xA;str := &#34;abe21@def.com is the mail address of 8th user with id 124&#34;&#xA;exp := regexp.MustCompile(&#xA;    `([a-zA-Z]+(\d*)[a-zA-Z]*@[a-zA-Z]*(\d*)[a-zA-Z]+\.[a-z|A-Z]{2,})` +&#xA;        `|(mail|email)` +&#xA;        `|(\d{1,3})`,&#xA;)&#xA;&#xA;match := exp.FindStringSubmatch(str)&#xA;match_index := exp.FindStringSubmatchIndex(str)&#xA;log.Println(match)&#xA;log.Println(match_index)&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;[abe21@def.com abe21@def.com 21   ]&#xA;[0 13 0 13 3 5 9 9 -1 -1 -1 -1]&#xA;```&#xA;&#xA;So this returns a list of pairs, here consider the list as `[(0, 13) (0, 13), (3, 5), (9, 9), (-1, -1), (-1, -1)]`. Because the list represents the start and end indexes of the sub-matches in the source string. The match is the first pair, i.e. at the first character `0` -&amp;gt; `a`, and ends at space i.e. `13` character off by one. Then we have the sub-match itself with the same indexes. Then the `3` and `5` indicating the number sub-match `21` in the `abc21@def.com` it starts at 3 and ends at 5, so it occupies 3 and 4 characters in the source string. Similarly, the domain level number doesn&#39;t have any number in the source string so it has returned the domain name end index as an empty string.&#xA;&#xA;We had used `(\d*)` which can return 0 or more occurrences of the digit, so it returned no match in the case of the domain level name, hence we get the `9` as an empty string at the end of the sub-match for it. The rest are for the `email` or `mail`, and the lone digit sub-matches in the regular expression which we don&#39;t have in the first match in the source string.&#xA;&#xA;```go&#xA;str := &#34;abe21@def.com is the mail address of 8th user with id 124&#34;&#xA;exp := regexp.MustCompile(&#xA;    `([a-zA-Z]+(\d*)[a-zA-Z]*@[a-zA-Z]*(\d*)[a-zA-Z]+\.[a-z|A-Z]{2,})` +&#xA;        `|(mail|email)` +&#xA;        `|(\d{1,3})`,&#xA;)&#xA;&#xA;match := exp.FindAllStringSubmatch(str, -1)&#xA;match_indexes := exp.FindAllStringSubmatchIndex(str, -1)&#xA;log.Println(match_indexes)&#xA;```&#xA;&#xA;```console&#xA;$ go run main.go&#xA;&#xA;[[abe21@def.com abe21@def.com 21   ] [mail    mail ] [8     8] [124     124]]&#xA;[&#xA;    [0 13 0 13 3 5 9 9 -1 -1 -1 -1]&#xA;    [21 25 -1 -1 -1 -1 -1 -1 21 25 -1 -1]&#xA;    [37 38 -1 -1 -1 -1 -1 -1 -1 -1 37 38]&#xA;    [54 56 -1 -1 -1 -1 -1 -1 -1 -1 54 57]&#xA;]&#xA;```&#xA;&#xA;Similarly, we have used the [FindAllStringSubmatchIndex](https://pkg.go.dev/regexp#Regexp.FindAllStringSubmatchIndex) for getting the list of a slice of indexes(int) for the sub-match of the expression in the source string.&#xA;&#xA;The first element is the same as the previous example, the next match in the source string is `mail` which comes at index 21 and ends at the 24th index which golang does 24+1 as a convention. Similarly, the number `8` is matched at index `37` and the number `124` at index `54`, rest of the sub-matches for these matches are not present so it turns up to be -1 for the rest of the sub-matches.&#xA;&#xA;So this can also be used for the byte/uint8 type of variants with [FindSubmatchIndex](https://pkg.go.dev/regexp#Regexp.FindSubmatchIndex) and [FindAllSubmatchIndex](https://pkg.go.dev/regexp#Regexp.FindAllSubmatchIndex).&#xA;&#xA;## Replace Patterns&#xA;&#xA;The replace method is used for replacing the matched patterns.&#xA;&#xA;The [ReplaceAll](https://pkg.go.dev/regexp#Regexp.ReplaceAll) and [ReplaceAllLiteral](https://pkg.go.dev/regexp#Regexp.ReplaceAllLiteral) with some string and byte slice variations can help us in replacing the source text with a replacement string against a regular expression.&#xA;&#xA;Let&#39;s start with a simple example of strings.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;regexp&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;str := &#34;Gophy gophers go in the golang grounds&#34;&#xA;&#x9;exp := regexp.MustCompile(`(Go|go)`)&#xA;&#x9;replaced_str := exp.ReplaceAllString(str, &#34;to&#34;)&#xA;&#x9;log.Println(replaced_str)&#xA;&#xA;}&#xA;```&#xA;&#xA;The above code can replace the string with regex with the replacement string. The regex provided in the `exp` variable has a pattern matching for `Go` or `go`. So, the `ReplaceAllString` method takes in two arguments as strings and returns the string after replacing the character.&#xA;&#xA;```console&#xA;$ go run replace.go&#xA;&#xA;Original:  Gophy gophers go in the golang grounds&#xA;Replaced:  tophy tophers to in the tolang grounds&#xA;```&#xA;&#xA;So, this replaces all the characters with `Go` or `go` in the source string with `to`.&#xA;&#xA;There is a special value available in the replacement string which can expand the regular expression literals. Since the regular expression consists of multiple literals/quantifiers, we can use those to replace or keep the string in a particular expression&#39;s evaluation.&#xA;&#xA;```go&#xA;str = &#34;Gophy gophers go in the golang grounds&#34;&#xA;exp2 := regexp.MustCompile(`(Go|go)|(phers)|(rounds)`)&#xA;log.Println(exp2.ReplaceAllString(str, &#34;hop&#34;))&#xA;log.Println(exp2.ReplaceAllString(str, &#34;$1&#34;))&#xA;log.Println(exp2.ReplaceAllString(str, &#34;$2&#34;))&#xA;log.Println(exp2.ReplaceAllString(str, &#34;$3&#34;))&#xA;```&#xA;&#xA;```console&#xA;$ go run replace.go&#xA;&#xA;hopphy hophop hop in the hoplang ghop&#xA;Gophy go go in the golang g&#xA;phy phers  in the lang g&#xA;phy   in the lang grounds&#xA;```&#xA;&#xA;The above code uses the regular expression match string have been replaced with the literals. So, the regex `(Go|go)|(phers)|(rounds)` has three parts `Go|go`, `phers`, and `rounds`. Each of the literals is separated by an operator, indicating either the match or all matches should be considered.&#xA;&#xA;In the first statement, we replace the regex with `hop` as you can see all the matches are replaced with the replacement string. For instance, the word `gophers` is replaced by `hophop`, because `go` and `phers` is matched separately and replaced.&#xA;&#xA;In the second statement, we replace the source string with `$1` indicating the first literal in the regex i.e. `Go|go`. These statements will expand the `$1` and keep the match only where the literal matches and rest are removed. So, `Gophy` is matched with `Go|go` so it is kept as is in the replacement. However, for `grounds`, the literal match for `$1` i.e. `Go|go` does not match and hence is not kept and removed, so the resulting string becomes `g` rest is substituted with an empty string.&#xA;&#xA;In the third print statement, the source string is replaced with the second literal `$2` i.e. `phers`. So if any string matches the literal, only those are kept and the rest are substituted by an empty string. So, `Gophy` or `Go` doesn&#39;t match `phers` and hence is replaced, however, `gophers` match the `phers` part and is kept as it is, but the `go` part is substituted.&#xA;&#xA;Similarly, for the fourth print statement, the source string is replaced with the third literal i.e. `rounds`. So if only the third literal is kept as is, the rest matching strings from the regex are substituted with an empty string. So, `grounds` remain as it is because it matches the `rounds` in the replacement literal.&#xA;&#xA;In short, we replace the literal back after replacing the regex patterns in the source string. This can be used to fine-tune or access specific literals or expressions in the regular expressions.&#xA;&#xA;```go&#xA;str = &#34;Gophy gophers go in the golang grounds&#34;&#xA;exp2 := regexp.MustCompile(`(Go|go)|(phers)|(rounds)`)&#xA;log.Println(exp2.ReplaceAllString(str, &#34;$1$2&#34;))&#xA;&#xA;str = &#34;Gophy gophers go in the golang cophers grounds&#34;&#xA;log.Println(exp2.ReplaceAllString(str, &#34;$1$3&#34;))&#xA;```&#xA;&#xA;```console&#xA;$ go run replace.go&#xA;&#xA;Gophy gophers go in the golang g&#xA;Gophy go go in the golang co grounds&#xA;```&#xA;&#xA;We can even concatenate and make some minor string literal adjustments to the replacement string. As we have done in the example, where both the `$1$2` are used as the replacement string. The two literals combine to make a string with `Go|go` and `phers`. So, we can see the result, in the first statement, `Gophy gophers go in the golang g`, all the character that have `Go|go` or `phers` are kept as it is(substituted the same string), the `grounds` however does not match and hence are replaced with the empty string(because the capture group `$1$2` does not match `rounds`).&#xA;&#xA;Similarly, for the third example, the `$1$3` i.e. `Go|go` or `rounds` are matched with the source string. So, we the `phers` in `gophers` and `cophers` does not match the capture group `$1$3` and hence is replaced by an empty group(string). However, the `Gophy`, `golang`, and `grounds` match the capture group and are replaced by that match string (which is the same string).&#xA;&#xA;If we want to avoid expansion of the strings as we did in the previous example with `$1` and other parameters, we can use the [ReplaceAllLiteral](https://pkg.go.dev/regexp#Regexp.ReplaceAllLiteral) or [ReplaceAllLiteralString](https://pkg.go.dev/regexp#Regexp.ReplaceAllLiteralString) to parse the string as it is.&#xA;&#xA;```go&#xA;str := &#34;Gophy gophers go in the golang cophers grounds&#34;&#xA;exp2 := regexp.MustCompile(`(Go|go)|(phers)|(rounds)`)&#xA;log.Println(exp2.ReplaceAllLiteralString(str, &#34;$1&#34;))&#xA;```&#xA;&#xA;```&#xA;$ go run replace.go&#xA;&#xA;$1phy $1$1 $1 in the $1lang co$1 g$1&#xA;```&#xA;&#xA;As we can see the `$1` is not expanded and parsed as it is for replacing the pattern in the regular expression. The `Go` is replaced with `$1` to look like `$1phy`, and similarly for the rest of the patterns.&#xA;&#xA;That&#39;s it from the 26th part of the series, all the source code for the examples are linked in the GitHub on the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/scripts/regex) repository.&#xA;&#xA;## Conclusion&#xA;&#xA;This article covered the fundamentals of using the `regexp` package for working with regular expressions in golang. We explored the methods and `Regexp` type in the package with various methods available through the type interface. By exploring the examples and simple snippets, various ways for pattern matching, finding, and replacing were walked over and found.&#xA;&#xA;So, hopefully, the article might have found useful to you, if you have any queries, questions, feedback, or mistakes in the article, you can let me know in the discussion or on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Command Line Arguments</title>
      <link>meetgor.com/golang-command-line-args</link>
      <description>Parsing command line arguments / positional parameters in golang. Using os and flag packages to parse command line arguments from a golang program</description>
      <pubDate>Sat, 07 Jan 2023 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the 25th post of the series, we will be taking a look into parsing of command line arguments in golang. We will be exploring how to do the basics of parsing and using the positional parameters or arguments from the command line in the program. By using standard library packages like `os` and `flag`, we can make powerful yet easy-to-build CLI apps and programs.&#xA;&#xA;## Parsing Arguments from the command line (os package)&#xA;&#xA;We can use the os package to get the arguments from the command line in a go script. We have to use the Args variable in the os package. The `Args` variable is a slice of strings which thereby is the parsed arguments from the command line.&#xA;&#xA;* The first (0 index) Argument is the path to the program&#xA;    &#xA;* The 1st index onwards are the actual arguments passed.&#xA;    &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;args := os.Args&#xA;    fmt.Printf(&#34;Type of Args = %T&#xA;&#34;, args)&#xA;&#x9;fmt.Println(args[0], args[1])&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go hello&#xA;Type of Args = []string&#xA;/tmp/go-build1414795487/b001/exe/main hello&#xA;```&#xA;&#xA;In the above example, we can see that the `Args` is a slice of string and we can get the indices as per the arguments passed from the command line.&#xA;&#xA;If you don&#39;t parse any arguments and access the 1st argument as `os.Args[1]` it will result in an `index out of range` error. So, you need to first check if the argument is parsed and set a default value otherwise.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;    &#34;strconv&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;var port int&#xA;&#x9;var err error&#xA;&#x9;if len(os.Args) &gt; 1 {&#xA;&#x9;&#x9;port, err = strconv.Atoi(args[1])&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;panic(err)&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;port = 8000&#xA;&#x9;}&#xA;&#x9;fmt.Println(port)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go&#xA;8000&#xA;&#xA;$ go run main.go 7000&#xA;7090&#xA;&#xA;$ go run main.go h&#xA;panic: strconv.Atoi: parsing &#34;h&#34;: invalid syntax&#xA;```&#xA;&#xA;In the above example, we have declared the port variable as an integer and tried to see if we had an argument parsed from the command line using the len function and if there was a variable, we will simply cast it into an integer using the [strconv.Atoi](https://pkg.go.dev/strconv#Atoi) function. If there are any errors in the process, we log an error message and panic out of the program. So, this is how we can set default values or check for any arguments from the command line in golang.&#xA;&#xA;### Get the number of args&#xA;&#xA;We can use the len function with the `Args` slice to get the total number of arguments from the command line. To ignore the first argument which would be the path to the program, we simply can slice the first element as `os.Args[1:]`. This will slice the list of the arguments from the first index till the last element in the slice.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;total_args := len(os.Args[1:])&#xA;&#x9;fmt.Println(&#34;Total Args =&#34;, total_args)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go hello world 56&#xA;&#xA;Total Args = 3&#xA;```&#xA;&#xA;This will simply give us the number of arguments passed from the command line, excluding the first(0th) argument which is the default argument as the execution path of the current program.&#xA;&#xA;### Iterate over all arguments&#xA;&#xA;We can use the simple for loop with range over the `os.Args` or `os.Args[1:]` for iterating over each of the arguments passed from the command line.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;for n, args := range os.Args {&#xA;&#x9;&#x9;fmt.Println(&#34;Arg&#34;, n, &#34;-&gt;&#34;, args)&#xA;&#x9;}&#xA;&#xA;    /* &#xA;    // For excluding the 0th argument&#xA;&#x9;for n, args := range os.Args[1:] {&#xA;&#x9;&#x9;fmt.Println(&#34;Arg&#34;, n, &#34;-&gt;&#34;, args)&#xA;&#x9;}&#xA;    */&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run main.go hello world 56&#xA;Arg 0 -&gt; /tmp/go-build2248205073/b001/exe/main&#xA;Arg 1 -&gt; hello&#xA;Arg 2 -&gt; world&#xA;Arg 3 -&gt; 56&#xA;```&#xA;&#xA;We can now iterate over the arguments passed from the command line using a simple for loop. We can further process these arguments per the program&#39;s requirements and need.&#xA;&#xA;## Using flags package&#xA;&#xA;Golang has a package in its standard library called [flags](https://pkg.go.dev/flag) which allows us to parse flags and arguments from the command line with a lot of built-in features. For instance, a default value is easily parsed with a simple function parameter, help text in case of an error in parsing the arguments or flag, customization and freedom for choosing a data type for the type of argument, and so on. For a bare-bones and quick CLI program, the flag package is a great choice.&#xA;&#xA;### Parse Typed Flags&#xA;&#xA;We can use typed flag values using the functions provided in the `flags` package like [IntVar](https://pkg.go.dev/flag#IntVar) for an integer value, [StringVar](https://pkg.go.dev/flag#StringVar) for string, [BoolVar](https://pkg.go.dev/flag#BoolVar) for boolean values and so on. Each function takes in 4 parameters and they set the value of the parsed variable from the parsed argument/flag from the command line.&#xA;&#xA;* The first parameter is a reference to the variable to store the value.&#xA;    &#xA;* The second parameter is the name of the argument/flag to be read from the command line.&#xA;    &#xA;* The third parameter is the default value of the variable.&#xA;    &#xA;* The fourth parameter is the help text for that argument/flag.&#xA;    &#xA;&#xA;So, let&#39;s take the previous example of port number parsing from the command line. We can use the `flag.IntVar(&amp;port, &#34;p&#34;, 8000, &#34;Provide a port number&#34;)`, this will set the value of the variable port from the command line as the value of `-p 6789` or the default value as `8000`. The help text will be used if the user has provided a non-integer or an invalid value as an error message.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;flag&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;var port int&#xA;&#x9;var dir string&#xA;&#x9;var publish bool&#xA;&#xA;&#x9;flag.IntVar(&amp;port, &#34;p&#34;, 8000, &#34;Provide a port number&#34;)&#xA;&#x9;flag.StringVar(&amp;dir, &#34;dir&#34;, &#34;output_dir&#34;, &#34;Directory&#34;)&#xA;&#x9;flag.BoolVar(&amp;publish, &#34;publish&#34;, false, &#34;Publish the article&#34;)&#xA;&#xA;&#x9;flag.Parse()&#xA;&#xA;&#x9;fmt.Println(port)&#xA;&#x9;fmt.Println(dir)&#xA;&#x9;fmt.Println(publish)&#xA;&#xA;&#x9;if publish {&#xA;&#x9;&#x9;fmt.Println(&#34;Publishing article...&#34;)&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(&#34;Article saved as Draft!&#34;)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run flag.go&#xA;&#xA;8000&#xA;output_dir&#xA;false&#xA;Article saved as Draft!&#xA;&#xA;&#xA;$ go run flag.go -p 1234&#xA;&#xA;1234&#xA;output_dir&#xA;false&#xA;Article saved as Draft!&#xA;&#xA;&#xA;$ go run flag.go -p 1234 -dir site_out&#xA;&#xA;1234&#xA;site_out&#xA;false&#xA;Article saved as Draft!&#xA;&#xA;&#xA;$ go run flag.go -publish&#xA;&#xA;8000&#xA;output_dir&#xA;true&#xA;Publishing article...&#xA;```&#xA;&#xA;So, in the above, example, we have used a few types of values like `IntegerVar` for `port`, `StringVar` for `dir`, and `BoolVar` for `publish`. As explained earlier, the functions take 4 parameters in the same format, the reference to the variable to hold the parsed value, the name of the argument/flag, the default value the variable will hold, and the help text or usage string. The [BoolVar](https://pkg.go.dev/flag#BoolVar) is slightly different but it works logically well, if we parse `-publish` the value will be set as `true` and `false` otherwise. You can manually add the value like `-publish true` and so on but it is not mandatory and understood as true.&#xA;&#xA;In the above example, we have parsed different arguments in the output and displayed the values of these flags. If we don&#39;t specify a value, we can see the default value being parsed, in the case of the `bool` variable, the default value is taken as `false`. Hence we can see how easily we can use and parse flags from the command line in golang, it&#39;s simple, quick, and also extensible.&#xA;&#xA;For other data types, the flag package has functions like [Float64Var](https://pkg.go.dev/flag#Float64Var) for float64 values, [DurationVar](https://pkg.go.dev/flag#DurationVar) for time duration values and [TextVar](https://pkg.go.dev/flag#TextVar) for other types as inferred by the unmarshalling of the text.&#xA;&#xA;### Set flags from the script&#xA;&#xA;We can set the value of a flag/argument from the script rather than from the command line using the [Set](https://pkg.go.dev/flag#Set) method in the flag package. The `Set` method takes in two values as parameters the name of the argument and the value of that argument to set as. It returns an error if any arise during the setting of the argument.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;flag&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;var port int&#xA;&#x9;var dir string&#xA;&#x9;var publish bool&#xA;&#xA;&#x9;flag.IntVar(&amp;port, &#34;p&#34;, 8000, &#34;Provide a port number&#34;)&#xA;&#x9;flag.StringVar(&amp;dir, &#34;dir&#34;, &#34;output_dir&#34;, &#34;Directory&#34;)&#xA;&#xA;&#x9;flag.Parse()&#xA;&#xA;    fmt.Println(port)&#xA;    fmt.Println(dir)&#xA;    flag.Set(&#34;dir&#34;, &#34;dumps&#34;)&#xA;    fmt.Println(dir)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run flag.go -p 8080&#xA;8080&#xA;output_dir&#xA;dumps&#xA;```&#xA;&#xA;So, it is clearly visible that the value of an argument can be changed within the script, it also changes the value of the associated variable. Remember, we gave the two-parameter as strings so the first parameter is the name of the argument and not necessarily the variable name.&#xA;&#xA;### Use Reference to arguments (pointers)&#xA;&#xA;Also, there are functions like [Int](https://pkg.go.dev/flag#Int), [Float64](https://pkg.go.dev/flag#Float64), [String](https://pkg.go.dev/flag#String), [Bool](https://pkg.go.dev/flag#Bool) in the flag package that can allow getting the values of the arguments without using the `Parse` method. We use the reference of the value stored in as the arguments instead of defining the variables as a data value; we have a pointer to that value of data.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;flag&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;port := flag.Int(&#34;p&#34;, 8000, &#34;Provide a port number&#34;)&#xA;&#x9;dir := flag.String(&#34;dir&#34;, &#34;output_dir&#34;, &#34;Directory&#34;)&#xA;&#x9;publish := flag.Bool(&#34;publish&#34;, false, &#34;Publish the article&#34;)&#xA;&#x9;help := flag.Bool(&#34;help&#34;, false, &#34;Help&#34;)&#xA;&#xA;&#x9;if *help {&#xA;&#x9;&#x9;flag.PrintDefaults()&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(*port)&#xA;&#x9;&#x9;fmt.Println(*dir)&#xA;&#x9;&#x9;flag.Set(&#34;dir&#34;, &#34;dumps&#34;)&#xA;&#x9;&#x9;fmt.Println(*dir)&#xA;&#xA;&#x9;&#x9;fmt.Println(flag.NFlag())&#xA;&#x9;&#x9;fmt.Println(flag.NArg())&#xA;&#xA;&#x9;&#x9;fmt.Println(*publish)&#xA;&#xA;&#x9;&#x9;if *publish {&#xA;&#x9;&#x9;&#x9;fmt.Println(&#34;Publishing article...&#34;)&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;fmt.Println(&#34;Article saved as Draft!&#34;)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;vals := flag.Args()&#xA;&#x9;&#x9;fmt.Println(vals)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run flag.go -p 80 -dir node_mods 1234&#xA;80&#xA;node_mods&#xA;dumps&#xA;2&#xA;1&#xA;false&#xA;Article saved as Draft!&#xA;[1234]&#xA;```&#xA;&#xA;As we can it performs the same task, but we have to use pointers as references to the arguments instead of storing them in an actual memory address. We have performed the same set of operations on the arguments and flags as we do with the other examples.&#xA;&#xA;We first, use the `Int` method or other methods appropriate that `String` can be used in general use cases, the function returns a reference (memory address) of the actual stored value of the arguments/flag. We can access the value from its memory address using the `*` operator. We have covered the [pointer](https://www.meetgor.com/golang-pointers/) arithmetic in the last part of the series. When we use `*port` we get the value from the memory address and thereby we can use it for the required task in the program, we can also store a copy of the variable by creating a new variable with the value of that argument.&#xA;&#xA;### Parse Arguments&#xA;&#xA;So, if we want to parse flags, with a single value, we have seen the use of the [flag.Args](https://pkg.go.dev/flag#Args) function to get the values of the arguments passed from the command line which don&#39;t have any flag labels attached to them(just raw arguments from the CMD). Just as we used the `os.Args` variable but this function is much clean and filtered out the path to the program argument. So we can directly have the arguments which are clearly passed by the user from the command line.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;flag&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;var port int&#xA;&#x9;flag.IntVar(&amp;port, &#34;p&#34;, 8000, &#34;Provide a port number&#34;)&#xA;&#x9;flag.Parse()&#xA;&#x9;fmt.Println(port)&#xA;&#x9;vals := flag.Args()&#xA;&#x9;fmt.Println(vals)&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run flag.go -p 8123&#xA;8123&#xA;[]&#xA;&#xA;&#xA;$ go run flag.go -p 8123 1234 hello true&#xA;8123&#xA;[1234 hello true]&#xA;&#xA;&#xA;$ go run flag.go -p 8123 1234 hello true -p 9823 world&#xA;8123&#xA;[1234 hello true -p 9823 world]&#xA;```&#xA;&#xA;In the above example, we can see that we have used a few non-flagged arguments from the command line. The return value of the `Args` function is a slice of string, we can then convert it into appropriate types using type casting and functions. Once the flagged arguments are parsed, if we use the `Args` function, it won&#39;t be possible to again use flagged arguments in the command line. It will be considered a simple string thereafter.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/files/write/) GitHub repository.&#xA;&#xA;### Get Help text with PrintDefaults&#xA;&#xA;We can use the [flag.PrintDefaults](https://pkg.go.dev/flag#PrintDefaults) method for just printing the default values and the help text for the expected arguments from the command line in the script. We can simply use it as a help flag or use it in error messages for guiding the user to the proper arguments and flags.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;flag&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;var port int&#xA;&#x9;var help bool&#xA;&#x9;flag.IntVar(&amp;port, &#34;p&#34;, 8000, &#34;Provide a port number&#34;)&#xA;&#x9;flag.BoolVar(&amp;help, &#34;help&#34;, false, &#34;Help&#34;)&#xA;&#x9;flag.Parse()&#xA;&#x9;if help {&#xA;&#x9;&#x9;flag.PrintDefaults()&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(port)&#xA;&#x9;&#x9;vals := flag.Args()&#xA;&#x9;&#x9;fmt.Println(vals)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run help.go -h&#xA;&#xA;Usage of /tmp/go-build121267600/b001/exe/help:&#xA;  -help&#xA;        Help&#xA;  -p int&#xA;        Provide a port number (default 8000)&#xA;&#xA;&#xA;$ go run help.go&#xA;&#xA;8000&#xA;[]&#xA;```&#xA;&#xA;So, we can see the `PrintDefaults` function will simply print the helper text for the flags expected in the script and the default value of those flags as well. This can be used to provide a good user-friendly interface for a simple terminal application.&#xA;&#xA;### Get the number of arguments&#xA;&#xA;We can use the [NFlag](https://pkg.go.dev/flag#NFlag) method in the `flag` package. The function returns an integer that indicates a count of the arguments that have been set from the command line.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;flag&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;var port int&#xA;&#x9;var dir string&#xA;&#x9;var publish bool&#xA;&#xA;&#x9;flag.IntVar(&amp;port, &#34;p&#34;, 8000, &#34;Provide a port number&#34;)&#xA;&#x9;flag.StringVar(&amp;dir, &#34;dir&#34;, &#34;output_dir&#34;, &#34;Directory&#34;)&#xA;&#xA;&#x9;flag.Parse()&#xA;&#xA;    fmt.Println(port)&#xA;    fmt.Println(dir)&#xA;    fmt.Println(flag.NFlag())&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run flag.go&#xA;8000&#xA;output_dir&#xA;0&#xA;&#xA;&#xA;$ go run flag.go -p 8080 8999 false hello&#xA;8080&#xA;output_dir&#xA;1&#xA;&#xA;&#xA;$ go run flag.go -p 8080 -dir dumps hello 1234&#xA;8080&#xA;dumps&#xA;2&#xA;```&#xA;&#xA;The `port` flag has been set from the command line, so we just have one argument set, hence the function `NFlag` returns `1` as the number of set flags.&#xA;&#xA;Also, the [NArg](https://pkg.go.dev/flag#NArg) method will return an integer that will count the number of arguments that have been provided leaving out the flag arguments.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;flag&#34;&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;var port int&#xA;&#x9;var dir string&#xA;&#x9;var publish bool&#xA;&#xA;&#x9;flag.IntVar(&amp;port, &#34;p&#34;, 8000, &#34;Provide a port number&#34;)&#xA;&#x9;flag.StringVar(&amp;dir, &#34;dir&#34;, &#34;output_dir&#34;, &#34;Directory&#34;)&#xA;&#xA;&#x9;flag.Parse()&#xA;&#xA;    fmt.Println(port)&#xA;    fmt.Println(dir)&#xA;    fmt.Println(flag.NArg())&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ go run flag.go 1234&#xA;8000&#xA;output_dir&#xA;1&#xA;&#xA;&#xA;$ go run flag.go -p 8080 -dir dumps hello 1234&#xA;8080&#xA;dumps&#xA;2&#xA;&#xA;&#xA;$ go run flag.go -p 8080 hello 1234 false&#xA;8080&#xA;dumps&#xA;3&#xA;```&#xA;&#xA;In the first example, we don&#39;t have any flag arguments set, we just have one unflagged argument as `1234`, hence the `NArg` function returns `1`. The second example has 2 values that are not flagged, we have set the values of `port` and `dir` as `8080` and `dumps` respectively, so the remaining unflagged values are `hello` and `1234` hence the return value as `2`. The third example has 3 unflagged values as `hello 1234 false`, hence we return `3`.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/cmd-args/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;We have seen how to parse command line arguments in golang with the `os` and the `flag` packages. Though these two are not the only options for building CLI applications, they provide a clean and easy-to-start approach, also they come with the standard library which makes it even better as we don&#39;t have to mingle with third-party libraries. We saw the basics of parsing flags and arguments from a command line program.&#xA;&#xA;Thank you for reading. If you have any queries, questions, or feedback, you can let me know in the discussion below or on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: File Write</title>
      <link>meetgor.com/golang-file-write</link>
      <description>Using system calls to write files in Golang. Performig writing, appending, deleting, replacing operations to a file</description>
      <pubDate>Sun, 18 Dec 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the 24th post of the series, we will be taking a look at how we can perform write operations to a file using golang. We will be using the `os` package in most operations along with `bufio` text manipulations. We will be performing write operations like appending, deleting, and replacing a file using golang. We will be heavily leveraging standard library packages like `os`, `bufio`, `bytes` and `fmt`. We will also be looking into overwriting and string formatting to a file.&#xA;&#xA;## Write to a File&#xA;&#xA;The first part of this section is the basic write operation to a file, we assume we are writing to a fresh file and overriding the contents of the existing file. The next section will cover the appending of content to the file and so on. In this example, we will see how we perform basic writing operations to write a string, a slice of string to a file.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func HandleError(err){&#xA;    if err != nil {&#xA;        log.Fatal(err)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;str := &#34;Hi, I am a gopher!&#xA;&#34;&#xA;&#x9;f, err := os.OpenFile(&#34;abc.txt&#34;, os.O_WRONLY, 0660)&#xA;    // f, err := os.Create(&#34;abc.txt&#34;)&#xA;&#x9;HandleError(err)&#xA;&#x9;_, err = f.Write([]byte(str))&#xA;&#x9;HandleError(err)&#xA;&#x9;defer f.Close()&#xA;}&#xA;```&#xA;&#xA;```bash&#xA;$ cat abc.txt&#xA;&#xA;$ go run main.go&#xA;&#xA;$ cat abc.txt&#xA;Hi, I am a gopher!&#xA;```&#xA;&#xA;So, we have used a simple golang script to write to a file that exists/has already been created. If you don&#39;t want errors while having to write on a file that does not exist, use the [Create](https://pkg.go.dev/os#Create) method instead which is similar to the `Open` method but creates a file if it doesn&#39;t exist. We use the [Write](https://pkg.go.dev/os#File.Write) method to overwrite contents to the file, it takes in a parameter as a slice of byte, so we typecast the string `str` into `[]byte` using the `[]byte(str)` syntax. Thereby we write the contents of the string into the file. We use the defer keyword for closing the file at the end of the script or the end of the main function scope.&#xA;&#xA;### Write slice of strings to file&#xA;&#xA;We can even write slice of string to file using a for loop and appending each string with a new line character.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func HandleError(err){&#xA;    if err != nil {&#xA;        log.Fatal(err)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;f, err := os.Create(&#34;abc.txt&#34;)&#xA;&#x9;//f, err := os.Open(&#34;abc.txt&#34;, os.O_WRONLY, 0660)&#xA;&#x9;langs := []string{&#34;golang&#34;, &#34;python&#34;, &#34;rust&#34;, &#34;javascript&#34;, &#34;ruby&#34;}&#xA;&#x9;for _, lang := range langs {&#xA;&#x9;&#x9;_, err := f.WriteString(lang + &#34;&#xA;&#34;)&#xA;&#x9;&#x9;HandleError(err)&#xA;&#x9;}&#xA;&#x9;defer f.Close()&#xA;}&#xA;```&#xA;&#xA;```plaintext&#xA;$ cat abc.txt&#xA;&#xA;$ go run main.go&#xA;&#xA;$ cat abc.txt&#xA;golang&#xA;python&#xA;rust&#xA;javascript&#xA;ruby&#xA;```&#xA;&#xA;We have used the [WriteString](https://pkg.go.dev/os#File.WriteString) method which will take in a string as a parameter instead of a slice of bytes. So, we don&#39;t have to type cast into slice of bytes. So, as we can see we have written the string slice into a file.&#xA;&#xA;### Over Write&#xA;&#xA;The minimal code to write to a file is the [WriteFile](https://pkg.go.dev/os#WriteFile) function in the [os](https://pkg.go.dev/os) package, it overrides the content of the file with the provided slice of bytes, the name of the file, and the necessary permission to write. The funciton additionally creates a file if it does not exist, which is one less reason for the error. Though it returns an error object, the error might be created due to not right permissions to write to the file, encoding issues, etc.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;data := []byte{115, 111, 109, 101, 65}&#xA;&#x9;err := os.WriteFile(&#34;test.txt&#34;, data, 0660)&#xA;    log.Println(err)&#xA;&#xA;&#x9;s := &#34;Hello&#34;&#xA;&#x9;err = os.WriteFile(&#34;test.txt&#34;, []byte(s), 0660)&#xA;    log.Println(err)&#xA;}&#xA;```&#xA;&#xA;```plaintext&#xA;$ go run main.go&#xA;2022/12/17 19:24:13 &lt;nil&gt;&#xA;2022/12/17 19:24:13 &lt;nil&gt;&#xA;&#xA;$ cat test.txt&#xA;Hello&#xA;```&#xA;&#xA;So, we have used the `WriteFile` method two times in the script, it first takes in a slice of bytes as it is defined as `data` which corresponds to `115 -&gt; s`, `111 -&gt; o`, `65 -&gt; A`, ASCII mapped to strings. The slice of bytes can be taken as a string like `someA` as the literal value of the underlying slice of the byte. So, we take that slice of byte and parse it to the second parameter of the WriteFile function. The first parameter is a string path of the file we want to write the contents to, the third parameter is the file permission. We have set it as `0660` indicating read(4) + write(2) to the group and the user and no permission to the other users. The function will return an error if any, or else it simply overwrites the data in the file.&#xA;&#xA;In this case, we have called the `WriteFile` method with string `s` type cast to slice of bytes at the end of the script so we see the file has contents as `Hello` instead of `someA`. If we reverse the action, we don&#39;t see the `Hello` string in the file.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;s := &#34;Hello&#34;&#xA;&#x9;err := os.WriteFile(&#34;test.txt&#34;, []byte(s), 0660)&#xA;    log.Println(err)&#xA;&#xA;&#x9;data := []byte{115, 111, 109, 101, 65}&#xA;&#x9;err = os.WriteFile(&#34;test.txt&#34;, data, 0660)&#xA;    log.Println(err)&#xA;}&#xA;```&#xA;&#xA;```plaintext&#xA;$ go run main.go&#xA;2022/12/17 19:24:13 &lt;nil&gt;&#xA;2022/12/17 19:24:13 &lt;nil&gt;&#xA;&#xA;$ cat test.txt&#xA;someA&#xA;```&#xA;&#xA;As we can see the `Hello` has been overwritten by `someA`.&#xA;&#xA;### Write formatted string&#xA;&#xA;We can even use fmt to write formatted strings to a file. Just like we can take inputs with `Scanf`, we can use [Fprint](https://pkg.go.dev/fmt#Fprint) and other similar functions like [Fprintf](https://pkg.go.dev/fmt#Fprintf), and [Fprintln](https://pkg.go.dev/fmt#Fprintln) functions to print/add contents to the file.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func HandleErr(err error) {&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;}&#xA;func main() {&#xA;&#x9;f, err := os.Create(&#34;temp.txt&#34;)&#xA;&#x9;HandleErr(err)&#xA;&#x9;name, lang, exp := &#34;John&#34;, &#34;go&#34;, 2&#xA;&#x9;_, err = fmt.Fprint(f, &#34;Hi, I am &#34;, name, &#34;&#xA;&#34;)&#xA;&#x9;HandleErr(err)&#xA;&#x9;_, err = fmt.Fprintf(f, &#34;Language of choice: %s.&#xA;&#34;, lang)&#xA;&#x9;HandleErr(err)&#xA;&#x9;_, err = fmt.Fprintln(f, &#34;Having&#34;, exp, &#34;years of experience.&#34;)&#xA;&#x9;HandleErr(err)&#xA;&#x9;defer f.Close()&#xA;}&#xA;```&#xA;&#xA;```plaintext&#xA;$ cat temp.txt&#xA;cat: temp.txt: No such file or directory&#xA;&#xA;$ go run format.go&#xA;&#xA;$ cat test.txt&#xA;Hi, I am John.&#xA;Language of choice: go.&#xA;Having 2 years of experience.&#xA;```&#xA;&#xA;So, we can see that we have used all three methods having their own use cases, we can use `Fprint` for simple strings, `Fprintf` for formatting the block of a string with multiple placeholders, and the `Fprintln` which works simply like `Fprint` but it adds a new line itself, we don&#39;t need to specify it explicitly.&#xA;&#xA;### Append&#xA;&#xA;If we want to append text to a file, we can use the [OpenFile](https://pkg.go.dev/os#OpenFile) function and provide a few parameters to append the contents instead of overwriting.&#xA;&#xA;Here, we have two steps, open the file and then write the contents in the file. So while opening the file, we provide a few options as parameters to make the fine-tuned system call like only open for read, write or append modes. These options are defined as constant int values in the [os package](https://pkg.go.dev/os#pkg-constants).&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func HandleError(err error) {&#xA;    if err != nil {&#xA;        log.Fatal(err)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;s := &#34;Hello&#34;&#xA;&#x9;err := os.WriteFile(&#34;test.txt&#34;, []byte(s), 0660)&#xA;    HandleError(err)&#xA;&#xA;&#x9;s = &#34;World&#34;&#xA;&#x9;f, err := os.OpenFile(&#34;test.txt&#34;, os.O_APPEND|os.O_WRONLY, 0660)&#xA;&#x9;HandleError(err)&#xA;&#x9;_, err = f.WriteString(s)&#xA;&#x9;HandleError(err)&#xA;&#x9;defer f.Close()&#xA;}&#xA;```&#xA;&#xA;```plaintext&#xA;$ go run main.go&#xA;&#xA;$ cat test.txt&#xA;HelloWorld&#xA;```&#xA;&#xA;So, from the above example, we are able to append text into a file, we have first added the `Hello` world string into the file using the `WriteFile` method to indicate we overwrite the previous contents of the file. We then use the [OpenFile](https://pkg.go.dev/os#OpenFile) method to open a file provided in the first parameter as a string path. The second parameter is the options to be passed for performing operations on the opened file, we always have to use them `defer` to close the file or other resource-locking operations.&#xA;&#xA;We have specified the `os.O_WRONLY` and the `os.O_APPEND` options indicating we want to write to the file while the file is open and specifically append to the file. So this is fine-tuning the opened file operation. We can use the ReadFile or WriteFile operation which is just used for simple read and write operations respectively.&#xA;&#xA;We use the [WriteString](https://pkg.go.dev/os#File.WriteString) method, but we can even use the [Write](https://pkg.go.dev/os#File.Write) method to write a slice of byte instead. This is just used for exploring the different options in the file types of the os package.&#xA;&#xA;### Append at a specific line&#xA;&#xA;We can also add content to a specific line or a portion of the file. There are no direct functions in golang to do the same, we will have to do some manual fine-tuning of file operations to append a particular text at a specific line.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;bufio&#34;&#xA;    &#34;bytes&#34;&#xA;    &#34;log&#34;&#xA;    &#34;os&#34;&#xA;)&#xA;&#xA;func HandleError(err error) {&#xA;    if err != nil {&#xA;        log.Fatal(err)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;    /* test.txt&#xA;    Hi&#xA;    Hello&#xA;    World&#xA;    Gopher&#xA;    */&#xA;&#x9;f, err = os.OpenFile(&#34;test.txt&#34;, os.O_RDWR, 0660)&#xA;&#x9;defer f.Close()&#xA;&#x9;HandleError(err)&#xA;&#x9;m := bufio.NewScanner(f)&#xA;&#x9;bytes_till := 0&#xA;&#x9;// line to be appended&#xA;&#x9;line_till := 2&#xA;&#x9;var lines_after string&#xA;&#x9;var lines_till string&#xA;&#x9;i := 0&#xA;&#x9;for m.Scan() {&#xA;&#x9;&#x9;line := m.Text()&#xA;&#x9;&#x9;if i &lt; line_till {&#xA;&#x9;&#x9;&#x9;bytes_till += bytes.Count([]byte(line), []byte{})&#xA;&#x9;&#x9;&#x9;if i &gt; 0 {&#xA;&#x9;&#x9;&#x9;&#x9;lines_till += &#34;&#xA;&#34;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;lines_till += line&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;lines_after += &#34;&#xA;&#34; + line&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;i += 1&#xA;&#x9;}&#xA;&#x9;HandleError(m.Err())&#xA;&#x9;insert_text := lines_till + &#34;&#xA;Inserted content&#34;&#xA;&#x9;insert_text_bytes := bytes.Count([]byte(insert_text), []byte{})&#xA;&#x9;lines_after_bytes := bytes.Count([]byte(lines_after), []byte{})&#xA;&#xA;&#x9;err = os.WriteFile(&#34;test.txt&#34;, []byte(insert_text), 0660)&#xA;&#x9;HandleError(err)&#xA;&#x9;_, err = f.WriteAt([]byte(lines_after), int64(lines_after_bytes)+int64(insert_text_bytes))&#xA;&#x9;HandleError(err)&#xA;    /* test.txt&#xA;    Hi&#xA;    Hello&#xA;    Inserted content&#xA;    World&#xA;    Gopher&#xA;    */&#xA;}&#xA;```&#xA;&#xA;```plaintext&#xA;$ cat test.txt &#xA;Hi&#xA;Hello&#xA;World&#xA;Gophers&#xA;&#xA;$ go run append.go &#xA;&#xA;$ cat test.txt &#xA;Hi&#xA;Hello&#xA;Inserted content&#xA;World&#xA;Gophers&#xA;```&#xA;&#xA;We have inserted `Inserted content` after the second line because the `line_till` the variable is set to `2`&#xA;&#xA;So, in the above example, we have used a bunch of packages to append a string or any form of text to a particular line. We first read the contents of the file, by using the `OpenFile` method which will open the file with certain permissions. We need to close the file at the end of the script so we simply use the `defer` keyword before the `f.Close()` method call. We then start to scan the file buffer, by creating a `Scanner` object with the `NewScanner` method. Then, with the scanner object of the file content, we then can use the `Scan()` method to scan the file contents line by line. By converting the content at each line from a slice of bytes to a string using the `Text`, we append to a string `line`, this will be used for keeping the count of bytes for appending text before the newly inserted text.&#xA;&#xA;The `line_till` variable is used for the line number from which we want to append to the text after.&#xA;&#xA;We count the bytes for the current line and add it to the `bytes_till` variable indicating the number of bytes there before appending content. We have a simple if-else check for the first line that is for appending a new line of characters. We append the lines into a single string `lines_till`. The string `insert_text` is created by appending all the lines before the line number `line_till` with the actual content to be inserted. We calculate the number of bytes using the [Count](https://pkg.go.dev/bytes#Count) method in the bytes package. The separator is kept blank. The `lines_after` is also been created as a single string of lines after the line number in the file.&#xA;&#xA;We add the `insert_text` (lines before + inserted text) into the file using the `WriteFile` which will override the contents of the file. Then we append the `lines_after` string as a slice of bytes to the `insert_text_bytes + lines_after_bytes` so we get the byte number position to append the `lines_after` string.&#xA;&#xA;In short, we basically overwrite the file by creating two strings (slice of bytes) one which has the lines before the line number with the text to be inserted and the second string has all the lines after the line number.&#xA;&#xA;## Replace text in a file&#xA;&#xA;Using the [bytes.Replace](https://pkg.go.dev/bytes#Replace) method, we can first read all the bytes and replace the old with the new text, and store them as a slice of bytes. We then write these slices of bytes to the file again, so we first read the contents into slices of bytes, replace the content of the byte and then overwrite the contents with the slice of bytes. It&#39;s quite simple.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bytes&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func HandleError(err error) {&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;filename := &#34;test.txt&#34;&#xA;&#x9;file, err := os.ReadFile(filename)&#xA;&#x9;HandleError(err)&#xA;&#x9;old_text := &#34;Hello&#xA;World&#34;&#xA;&#x9;new_text := &#34;Bye&#34;&#xA;&#x9;new_content := bytes.Replace(file, []byte(old_text), []byte(new_text), -1)&#xA;&#x9;err = os.WriteFile(filename, new_content, 0660)&#xA;&#x9;HandleError(err)&#xA;}&#xA;```&#xA;&#xA;```plaintext&#xA;$ cat test.txt&#xA;Hi&#xA;Hello&#xA;World&#xA;Gophers&#xA;&#xA;$ go run main.go&#xA;&#xA;&#xA;$ cat test.txt&#xA;Hi&#xA;Bye&#xA;Gophers&#xA;```&#xA;&#xA;As we can see we have replaced `Hello&#xA;World` it with `Bye`. So, the \[Replace\] method in the bytes package takes in the parameters like the slice of bytes which should be the actual contents of the file, the old text to be replaced with again as a slice of bytes, and the new text to replace also as the slice of bytes, the final parameter is the number of replacements to be made. Here `-1` indicates there are no limits on how many replacements can be done, it can be `1`, `2` for replacing the first n occurrence of the old text, depending on how many times you want to replace the content in the file.&#xA;&#xA;## Delete Text from a File&#xA;&#xA;We can use the [os.Truncate](https://pkg.go.dev/os#File.Truncate) method to delete the contents of the file. The `Truncate` method takes in the parameters like the file path string and the size of the file to truncate or set to. If we set the second parameter to `0`, the file size will be zero and all the contents will be deleted or removed.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    /* test.txt&#xA;    Hi&#xA;    Hello&#xA;    World&#xA;    Gophers&#xA;    */&#xA;&#x9;err := os.Truncate(&#34;test.txt&#34;, 0)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;    /* test.txt is empty&#xA;    */&#xA;}&#xA;```&#xA;&#xA;```plaintext&#xA;$ cat test.txt&#xA;Hi&#xA;Hello&#xA;World&#xA;Gophers&#xA;&#xA;$ go run delete.go&#xA;&#xA;$ cat test.txt&#xA;```&#xA;&#xA;As we can see that the contents of the file are emptied if we set the second parameter(size) of the `Truncate` method as 0.&#xA;&#xA;We can also set the value of the size as the number of bytes to keep, so instead of `0` we can set it to `n` positive integer to only save the first `n` bytes in the file.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    /* test.txt&#xA;    Hi&#xA;    Hello&#xA;    World&#xA;    Gophers&#xA;    */&#xA;&#x9;err := os.Truncate(&#34;test.txt&#34;, 6)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;    /* test.txt &#xA;    Hi&#xA;    Hel&#xA;    */&#xA;}&#xA;```&#xA;&#xA;```plaintext&#xA;$ cat test.txt&#xA;Hi&#xA;Hello&#xA;World&#xA;Gophers&#xA;&#xA;$ go run delete.go&#xA;&#xA;$ cat test.txt&#xA;Hi&#xA;Hel&#xA;```&#xA;&#xA;So, in the above example, if we set the size parameter to the Truncate method as `6`, it will keep the size of the file to 6 bytes. So we only see `Hi&#xA;Hel`, the new line is a single byte. The rest of the content is deleted. This is how we previously deleted all the bytes from the file by setting the size to `0`.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/files/write/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this section of the series, we were able to perform write operations on a file using golang. We used the packages from the standard library and performed operations like write, append, overwrite, delete and replace to a simple text file, but it could have been any file format.&#xA;&#xA;Thank you for reading. If you have any queries, questions, or feedback, you can let me know in the discussion below or on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Read a Rss Feed with a URL in Golang</title>
      <link>meetgor.com/golang-read-rss-feed</link>
      <description>Reading Rss Feed with a Rss XML Link/URL in golang using encoding package</description>
      <pubDate>Fri, 11 Nov 2022 00:00:00 UTC</pubDate>
      <content>## Reding Rss Feed&#xA;&#xA;We can use golang&#39;s [encoding/xml](https://pkg.go.dev/encoding/xml) package to read a Rss feed. Though we have to be speicific of what type of structure the Rss feed has, so it is not dynamic but it works really well with structs. I have covered a few nuances of reading XML file in the [config file reading](https://www.meetgor.com/golang-config-file-read/#reading-xml-file) post of the 100 days of golang series.&#xA;&#xA;### Get request to Rss feed&#xA;&#xA;We first need to send a `GET` request to the Rss feed, we can use the [http](https://pkg.go.dev/net/http) package to grab the response.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;url := &#34;https://meetgor.com/rss.xml&#34;&#xA;&#x9;response, err := http.Get(url)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;    log.Println(response.Body)&#xA;&#x9;defer response.Body.Close()&#xA;&#xA;}&#xA;```&#xA;&#xA;So, in the above example, we have used the `net/http` package to send a `GET` request with the [Get](https://pkg.go.dev/net/http#Get) funciton. The function takes in a string as a `URL` and returns either the object as response or an error. If there arose any error, we simply exit out of the program and log the error. If the error is `nil`, we return the response in the `response` variable. This builds up a good foundation for the next step to read the response body and fetching the actual bytes from the response.&#xA;&#xA;### Fetch the content from the Link&#xA;&#xA;Since we have the `response` object, we can use the [io.ReadAll](https://pkg.go.dev/io#ReadAll) function to read the bytes in the response body. The function takes in the [Reader](https://pkg.go.dev/io#Reader) object in this case it is [ReadCloser](https://pkg.go.dev/io#ReadCloser) object as a http object. The function then returns the slice of bytes/int8. The slice then can be interpreted as string or other form data that can be used for parsing the xml from the response.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;    &#34;io&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;url := &#34;https://meetgor.com/rss.xml&#34;&#xA;&#x9;response, err := http.Get(url)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;data, err := io.ReadAll(response.Body)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;    log.Println(string(data))&#xA;    log.Printf(&#34;Type -&gt; %T&#34;, data)&#xA;}&#xA;```&#xA;&#xA;```&#xA;&lt;rss&gt;&#xA;    &lt;channel&gt;&#xA;        &lt;item&gt;&#xA;        ...&#xA;        ...&#xA;        ...&#xA;        &lt;/item&gt;&#xA;    &lt;/channel&gt;&#xA;&lt;/rss&gt;&#xA;&#xA;&#xA;Type -&gt; []uint8 &#xA;&#xA;```&#xA;&#xA;So, we can see that the parsed content is indeed xml, it is type casted to string from the slice of bytes. This can be further used for the parsing the text as Rss structure and fetch the required details.&#xA;&#xA;## Parsing Rss with a struct&#xA;&#xA;We can now move into creating a struct for individual tags required in the parsing.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;encoding/xml&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type Rss struct {&#xA;&#x9;XMLName xml.Name `xml:&#34;rss&#34;`&#xA;&#x9;Channel Channel  `xml:&#34;channel&#34;`&#xA;}&#xA;&#xA;type Channel struct {&#xA;&#x9;XMLName     xml.Name `xml:&#34;channel&#34;`&#xA;&#x9;Title       string   `xml:&#34;title&#34;`&#xA;&#x9;Description string   `xml:&#34;description&#34;`&#xA;&#x9;Item        []Item   `xml:&#34;item&#34;`&#xA;}&#xA;&#xA;type Item struct {&#xA;&#x9;XMLName xml.Name `xml:&#34;item&#34;`&#xA;&#x9;Title   string   `xml:&#34;title&#34;`&#xA;&#x9;Link    string   `xml:&#34;link&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;url := &#34;https://meetgor.com/rss.xml&#34;&#xA;&#x9;response, err := http.Get(url)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;data, err := io.ReadAll(response.Body)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;    log.Println(string(data))&#xA;}&#xA;```&#xA;&#xA;If you would look at the [rss feed](https://meetgor.com/rss.xml), you can see it has a structure of tags and elements. The `rss` tag is the root tag, followed by `channel` and other types of nested tags speicific for the type of information to be stored like `title` for the title in the feed, `link` for the link to the feed, etc. &#xA;&#xA;So, we create those as structure, the root structure is the `Rss` which we will create with a few attributes like `Channel` and the name of the current tag. In the `Rss` case the name of the tag/element is `rss`, so it is given the `xml.Name` as `xml:&#39;rss&#39;` in backticks indicating the type hint for the field. The next field is the `Channel` which is another type(custom type struct). We have defined `Channel` as a struct just after it that will hold information like the `title`, `description` of the website. We also have the `xml.Name` as `xml:&#34;channel&#34;` which indicates the current struct is representation of `channel` tag in the rss feed. Finally, we also have a custom type struct as `Item`. The `Item` struct has a few attributes like `Title`, `Link` and you can now start to see the pattern, you can customize it as per your requirements and speicifications.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;encoding/xml&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type Rss struct {&#xA;&#x9;XMLName xml.Name `xml:&#34;rss&#34;`&#xA;&#x9;Channel Channel  `xml:&#34;channel&#34;`&#xA;}&#xA;&#xA;type Channel struct {&#xA;&#x9;XMLName     xml.Name `xml:&#34;channel&#34;`&#xA;&#x9;Title       string   `xml:&#34;title&#34;`&#xA;&#x9;Description string   `xml:&#34;description&#34;`&#xA;&#x9;Item        []Item   `xml:&#34;item&#34;`&#xA;}&#xA;&#xA;type Item struct {&#xA;&#x9;XMLName xml.Name `xml:&#34;item&#34;`&#xA;&#x9;Title   string   `xml:&#34;title&#34;`&#xA;&#x9;Link    string   `xml:&#34;link&#34;`&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;url := &#34;https://meetgor.com/rss.xml&#34;&#xA;&#x9;response, err := http.Get(url)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;data, err := io.ReadAll(response.Body)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;    // New Code&#xA;&#xA;&#x9;d := Rss{}&#xA;&#x9;err = xml.Unmarshal(data, &amp;d)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;for _, item := range d.Channel.Item {&#xA;&#x9;&#x9;log.Println(item.Title)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;Why and How to make and use Vim as a text editor and customizable IDE&#xA;Setting up Vim for Python&#xA;Setting up Vim for BASH Scripting&#xA;Vim: Keymapping Guide&#xA;...&#xA;...&#xA;...&#xA;Django + HTMX CRUD application&#xA;PGCLI: Postgres from the terminal&#xA;Golang: Closures&#xA;Golang: Interfaces&#xA;Golang: Error Handling&#xA;Golang: Paths&#xA;Golang: File Reading&#xA;Golang: JSON YAML TOML (config) File Reading.&#xA;```&#xA;&#xA;So, here we have initialized the `Rss` struct as empty and then used the [Unmarshal](https://pkg.go.dev/encoding/xml#Unmarshal) method in the `xml` package. The Unmarshal method will parse the data as per the type of either int, float, bool or string, any other type of data will be discarded as interface or struct. We can usually parse any valid type of data into `Unmarshal` method and it generally gives a proper expected outcome.&#xA;&#xA;The Unmarshal method takes in the slice of byte and the second paramter as pointer to a struct or any variable that will store the parsed xml content from the slice of byte. The function just returns the error type, either `nil` in case of no errors, and returns the actual error obejct if there arise any type of error.&#xA;&#xA;So we parse the `data` which is a slice of byte to the funciton and the reference to the `d` object which is a empty `Rss` object. This will get us the data in the `d` object. We can then iterate over the object as per the struct and use the perform operations like type casting or converting types, etc to get your required data back.&#xA;&#xA;In the above example, we simply iterate over the `d.Channel.Item` which is a list of elements of tag `item` in the rss feed. Inside the for loop, we can access the object and simply print or perform any sort of operations. I have simply printed the list of articles with titles. &#xA;&#xA;Links for the code available on the [100 days of golang](https://github.com/Mr-Destructive/100-days-of-golang/blob/main/scripts/files/read/config_files/xml/rss.go) GitHub repository.&#xA;&#xA;So, that&#39;s how we parse an XML feed in golang. Just plug and play if you have a similar type of structure of the Rss XML feed. Happy Coding :)&#xA;</content>
      <type>til</type>
    </item>
    <item>
      <title>Golang: JSON YAML TOML (config) File Reading.</title>
      <link>meetgor.com/golang-config-file-read</link>
      <description>Reading specific files used generally for configuration and storing data, as well as for web development. Reading file formats like JSON, YAML, TOML, CSV, and XML.</description>
      <pubDate>Tue, 01 Nov 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Reading specific file types (JSON, YAML, TOML)&#xA;&#xA;In the previous post, we have seen how to read files in golang, in this extended post of that part, we will look into reading some specific files used for configuration and storing data like JSON, YAML, TOML, CSV, etc.&#xA;&#xA;We will see how to read files and get individual pieces in the files. We&#39;ll use packages like `os`, `ioutil` and `encoding` to perform reading operations on file and file objects.&#xA;&#xA;### Reading a JSON File&#xA;&#xA;Golang has built-in support for reading JSON files, but still, we can and need to have low-level controls on how to parse and extract content from the file.&#xA;&#xA;Let&#39;s say we have a `json` file named `blog.json`, we can use the [encoding/json](https://pkg.go.dev/encoding/json) package to convert the JSON data into a GO object (an object that is native and understandable to go). The [Unmarshal](https://pkg.go.dev/encoding/json#Unmarshal) function is used to convert the slice of bytes from the file, into a map object.&#xA;&#xA;&#xA;```json&#xA;{&#xA;    &#34;title&#34;: &#34;Golang Blog Series&#34;,&#xA;    &#34;date&#34;: &#34;22nd October 2022&#34;,&#xA;    &#34;tags&#34;: [&#34;go&#34;, &#34;files&#34;],&#xA;    &#34;words&#34;: 1500,&#xA;    &#34;published&#34;: true&#xA;}&#xA;```&#xA;&#xA;The above is a simple JSON file, this file has a few types of key-value pairs like string, list, integer, and boolean. But we can also have nested objects and a list of those nested objects.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/json&#34;&#xA;&#x9;&#34;log&#34;&#xA;    &#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;f, err := os.ReadFile(&#34;blog.json&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Println(err)&#xA;&#x9;}&#xA;&#x9;var data map[string]interface{}&#xA;&#x9;json.Unmarshal([]byte(f), &amp;data)&#xA;&#xA;&#x9;log.Println(data)&#xA;&#x9;for k, v := range data {&#xA;&#x9;&#x9;log.Println(k, &#34;:&#34;, v)&#xA;&#x9;}&#xA;&#xA;}&#xA;```&#xA;&#xA;**I have removed the time stamp from the logs below so as to clearly see the output. We can use `fmt` to print the simple things while keeping consistent with the rest of the snippets in the series.**&#xA;&#xA;```&#xA;$ go run json.go&#xA;&#xA;map[date:22nd October 2022 published:true tags:[go files] title:Golang Blog Series words:1500]&#xA;published : true&#xA;title : Golang Blog Series&#xA;date : 22nd October 2022&#xA;tags : [go files]&#xA;words : 1500&#xA;```&#xA;The file is read using the [os.ReadFile](https://pkg.go.dev/os#ReadFile) method, that takes in a string as a path to the file and returns a slice of bytes or an error if there was an issue in reading the file. The parsed slice of byte is than passed as the first argument to the `Unmarshal` method in the `encoding/json` package. The second parameter is the output reference where the parsed JSON will be stored or returned. The function does not return the parsed content instead returns an error if there arose any while parsing the JSON content.&#xA;&#xA;As we can see we have got a map of `string` with an `interface`. The interface is used because the value of the key can be anything. There is no fixed value like a `string`, `int`, `bool`, or a nested `map`, `slice`. Hence we have mapped the JSON object as a map of `string` with an `interface`. The type of the value is identified with the interface it has attached to it. Let&#39;s take a look what is the type of each value in the map.&#xA;&#xA;```&#xA;published : true&#xA;bool&#xA;&#xA;title : Golang Blog Series&#xA;string&#xA;&#xA;date : 22nd October 2022&#xA;string&#xA;&#xA;tags : [go files]&#xA;[]interface {}&#xA;&#xA;words : 1500&#xA;float64&#xA;```&#xA;&#xA;Here, we can see it has correctly identified the string type of the fields like bool in case of true or false, a string for string type of values, the fourth field however has a list interface attached to it. The default precedence for `float64` over integer is the reason the `1500` value is of type `float64`. &#xA;&#xA;&#xA;### Reading a YAML File&#xA;&#xA;Though there is no standard package for parsing/unmarshaling `YAML` files in golang, it&#39;s quite easy to use a third-party package and use it to read YAML files.&#xA;&#xA;The package [gopkg.in/yaml.v3](https://pkg.go.dev/gopkg.in/yaml.v3) is used for encoding and decoding YAML files. We&#39;ll be just using it for decoding a YAML file by reading it and converting the file object into native Go objects like maps, lists, strings, etc.&#xA;&#xA;The below steps can be used for setting up the package and installing the YAML package locally.&#xA;&#xA;```&#xA;go mod init &lt;your_project_package_name&gt;&#xA;go get gopkg.in/yaml.v3&#xA;```&#xA;&#xA;This should create two files namely `go.mod` and `go.sum` with the dependency of the `gopkg.in/yaml.v3` package.&#xA;&#xA;```yml&#xA;title: &#34;Golang Blog Series&#34;&#xA;date: &#34;22nd October 2022&#34;&#xA;tags: [&#34;go&#34;, &#34;files&#34;]&#xA;published: false&#xA;words: 1500&#xA;```&#xA;&#xA;The above file is a simple YAML config, we&#39;ll follow similar kind of examples for the dummy files used in the examples.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;    &#34;os&#34;&#xA;&#xA;&#x9;yaml &#34;gopkg.in/yaml.v3&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;f, err := os.ReadFile(&#34;blog.yaml&#34;)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;var data map[string]interface{}&#xA;&#xA;&#x9;err = yaml.Unmarshal(f, &amp;data)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;log.Println(data)&#xA;&#x9;for k, v := range data {&#xA;&#x9;&#x9;log.Println(k, &#34;:&#34;, v)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run yaml.go&#xA;&#xA;map[date:22nd October 2022 published:false tags:[go files] title:Golang Blog Series words:1500]&#xA;published : false&#xA;words : 1500&#xA;title : Golang Blog Series&#xA;date : 22nd October 2022&#xA;tags : [go files]&#xA;```&#xA;&#xA;The above code and output demonstrate the usage of the `yaml.v3` package for reading a YAML file.&#xA;&#xA;Firstly, we read the file into a single-string object with the [os.ReadFile()](https://pkg.go.dev/os#ReadFile) method. The method will return a `[]byte` (slice of byte) or an error. If there is an error, we simply log or panic out of the program, else we can use the [yaml.Unmarshal](https://pkg.go.dev/gopkg.in/yaml.v3#Unmarshal) method to convert the string/slice of the byte into a map or a pre-defined struct. In this example, we just keep things simple by storing the file content as `map [string, interface{}]`, i.e. a map of `string` and an `interface`. The key for YAML can be only a string or an integer. It can&#39;t have unrestricted data types like the value can have. Though if you want to be unrestrictive, you can use a map of `map[interface{}]interface{}` to make the key any shape you like to have.&#xA;&#xA;So, we have created a variable called `data` as a map of `string` and `interface{}`, basically key can be a string and the value can be any type of interface depending on the parsed literally from the file object. The `Unmarshal` function takes in two parameters, the first being the slice of byte i.e. the file contents, and the second being the output variable. Now, the method does not return the parsed YAML, it can return an error if there arose, so we need to set the second parameter as a pointer to the object into which we want to store the parsed YAML.&#xA;&#xA;In the example, we have called `Unmarshal(f, &amp;data)` which will fetch the contents from the slice of bytes `f` and output the parsed YAML from the slice of bytes into the memory location of `data` and hence using `&amp;data` indicating the pointer to the variable(fetch the memory address).&#xA;&#xA;So, that is how we obtain the map of keys and values from the YAML config, thereafter, you can iterate on the map, access the keys and values, type caste them as per requirement, and basically have control over what processing needs to be done to the parsed YAML content.&#xA;&#xA;```&#xA;published : false&#xA;bool&#xA;&#xA;words : 1500&#xA;int&#xA;&#xA;title : Golang Blog Series&#xA;string&#xA;&#xA;date : 22nd October 2022&#xA;string&#xA;&#xA;tags : [go files]&#xA;[]interface {}&#xA;```&#xA;&#xA;I have just printed the types of the values in the above output as `log.Printf(&#34;%T&#34;, v)`, we can see the types are being correctly recognized and being parsed. The last object is indeed a `slice` so it has an interface of the slice(array) attached to it.&#xA;&#xA;### Reading a TOML file&#xA;&#xA;YAML and TOML are almost identical, though toml has more restrictive configuration options, but is more readable than YAML, as YAML can get complicated pretty quickly. Though both of them have their pros and cons, YAML is used everywhere in the DevOps world, configs, whereas TOML is the format of choice for python packaging, and static site generation configs.&#xA;&#xA;Let&#39;s see how we can use golang to read TOML files.&#xA;&#xA;```&#xA;$ go mod init &lt;your_project_package_name&gt;&#xA;$ go get github.com/pelletier/go-toml&#xA;```&#xA;&#xA;The above commands are used for setting up a golang package or project and installing the [go-toml](https://pkg.go.dev/github.com/pelletier/go-toml) package. Once the above commands are done executing, it will generate `go.mod` and `go.sum` files used for storing dependencies and packages installed for the project locally.&#xA;&#xA;```toml&#xA;[blog]&#xA;name=&#39;techstructive-blog&#39;&#xA;tags=[&#39;go&#39;,&#39;django&#39;,&#39;vim&#39;]&#xA;author=&#39;meet gor&#39;&#xA;active=true&#xA;&#xA;[author]&#xA;name=&#39;Meet Gor&#39;&#xA;github=&#39;mr-destructive&#39;&#xA;twitter=&#39;meetgor21&#39;&#xA;posts=80&#xA;```&#xA;&#xA;The above is the sample file `blog.toml` which we will use to read in the go script below. The toml file has a similar structure as we have seen in the previous examples. We have different data types like string, boolean, integer, and list.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;    &#34;os&#34;&#xA;&#xA;&#x9;toml &#34;github.com/pelletier/go-toml&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;f, err := os.ReadFile(&#34;blog.toml&#34;)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;var data map[interface{}]interface{}&#xA;&#xA;&#x9;err = toml.Unmarshal(f, &amp;data)&#xA;&#x9;log.Println(data)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;for k, v := range data {&#xA;&#x9;&#x9;log.Println(k, &#34;:&#34;, v)&#xA;&#xA;&#x9;&#x9;switch t := v.(type) {&#xA;&#x9;&#x9;case map[string]interface{}:&#xA;&#x9;&#x9;&#x9;for a, b := range t {&#xA;&#x9;&#x9;&#x9;&#x9;log.Println(a, &#34;:&#34;, b)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run toml.go&#xA;&#xA;map[author:map[github:mr-destructive name:Meet Gor posts:80 twitter:meetgor21] blog:map[active:true author:meet gor&#xA;&#xA;name:techstructive-blog tags:[go django vim]]]&#xA;&#xA;blog : map[active:true author:meet gor name:techstructive-blog tags:[go django vim]]&#xA;name : techstructive-blog&#xA;tags : [go django vim]&#xA;author : meet gor&#xA;active : true&#xA;&#xA;author : map[github:mr-destructive name:Meet Gor posts:80 twitter:meetgor21]&#xA;&#xA;name : Meet Gor&#xA;github : mr-destructive&#xA;twitter : meetgor21&#xA;posts : 80&#xA;```&#xA;&#xA;So, in the above example and output, the YAML file was read and the key-value pairs inside them were read. The first thing we do is read the file `blog.toml` with `ioutil` package, with the `ReadFile` function. The function takes in the string as the path to the file to be read and returns a slice of byte. We use this slice of byte as a parameter to the [Unmarshal](https://pkg.go.dev/github.com/pelletier/go-toml#Unmarshal) method. The second paramter for the `Unmarshal` is the output variable(usually a pointer to a variable), we have created a map of `interface{]` with an `interface` as we see there can be nested keys which hold the name of the config.&#xA;&#xA;The variable `data` is a map of `interface{}` to an `interface{}`, and we parse the memory address to the `data` variable to the `Unmarshal` method. Thereby the parsed `TOML` content is stored in the data variable.&#xA;&#xA;```&#xA;name : techstructive-blog&#xA;string&#xA;&#xA;tags : [go django vim]&#xA;[]interface{}&#xA;&#xA;author : meet gor&#xA;string&#xA;&#xA;active : true&#xA;bool&#xA;&#xA;name : Meet Gor&#xA;string&#xA;&#xA;github : mr-destructive&#xA;string&#xA;&#xA;twitter : meetgor21&#xA;string&#xA;&#xA;posts : 80&#xA;int64&#xA;```&#xA;&#xA;The above is a verbose output for the type of the values as parsed by golang, we have `string`, `bool`, `int64`, and a `slice` (list with interface{} attached with it). Only types like `string`, `bool`, `int`, `float64` can be parsed from the Unmarshal function, other than these types, the type will have an interface attached to it.&#xA; &#xA; In such cases, where the type of value is not among the 4 types(string, bool, int float), we can use a pre-defined struct to parse the content from the file. Though it would require a strict structure and predictable response from the parsed file.&#xA;&#xA;### Reading CSV file&#xA;&#xA;We can even read a CSV file in golang, we have seen in the previous post, we have used custom delimiters in the parsing of the file.&#xA;&#xA;```csv&#xA;id,name,posts,exp&#xA;21,jim,23,2&#xA;33,kevin,39,1&#xA;45,james,70,2&#xA;56,chris,89,3&#xA;```&#xA;&#xA;The above file is a sample csv file, though the size is too small, we can use it as an example.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/csv&#34;&#xA;    &#34;log&#34;&#xA;    &#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;f, err := os.Open(&#34;temp.csv&#34;)&#xA;&#x9;check_error(err)&#xA;&#xA;&#x9;reader := csv.NewReader(f)&#xA;&#xA;&#x9;n, err := reader.ReadAll()&#xA;&#x9;check_error(err)&#xA;&#x9;for _, line := range n {&#xA;&#x9;&#x9;for _, text := range line {&#xA;&#x9;&#x9;&#x9;log.Println(text)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;id&#xA;name&#xA;posts&#xA;exp&#xA;21&#xA;jim&#xA;23&#xA;2&#xA;33&#xA;kevin&#xA;39&#xA;1&#xA;45&#xA;james&#xA;70&#xA;2&#xA;56&#xA;chris&#xA;89&#xA;3&#xA;```&#xA;&#xA;The CSV package has a [NewReader](https://pkg.go.dev/encoding/csv#NewReader) method that accepts an `io.Reader` and returns a `Reader` object. After parsing the reader, we use the [ReadAll](https://pkg.go.dev/encoding/csv#Reader.ReadAll) method to return a 2d string or an error if there exists an error while parsing the content. You can get a detailed explanation of the CSV parsing and reading in the [previous post](https://www.meetgor.com/golang-file-read/#Read%20File%20by%20a%20delimiter).&#xA;&#xA;&#xA;### Reading CSV from URL&#xA;&#xA;The CSV file can also be read from the URL, the content of the file is a `response.Body` in place of the file object reference, in the previous example, the [os.Open()](https://pkg.go.dev/os#Open) method returns a [os.File](https://pkg.go.dev/os#File) object. &#xA;&#xA;We use the `http.Get(string)` method to get the response from the URL for reading the CSV file present on the web.&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/csv&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;url := &#34;https://github.com/woocommerce/woocommerce/raw/master/sample-data/sample_products.csv&#34;&#xA;&#x9;response, err := http.Get(url)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Println(err)&#xA;&#x9;&#x9;return&#xA;&#x9;}&#xA;&#xA;&#x9;defer response.Body.Close()&#xA;&#xA;&#x9;reader := csv.NewReader(response.Body)&#xA;&#x9;n, err := reader.ReadAll()&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Println(err)&#xA;&#x9;}&#xA;&#xA;&#x9;for _, line := range n {&#xA;&#x9;&#x9;for _, text := range line {&#xA;&#x9;&#x9;&#x9;log.Println(text)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run csv.go&#xA;&lt;feff&gt;ID&#xA;Type&#xA;SKU&#xA;Name&#xA;Published&#xA;Is featured?&#xA;Visibility in catalog&#xA;Short description&#xA;Description&#xA;Date sale price starts&#xA;Date sale price ends&#xA;...&#xA;...&#xA;...&#xA;```&#xA;So, that&#39;s how we can read a CSV file from the URL. By fetching the CSV URL `https://github.com/woocommerce/woocommerce/raw/master/sample-data/sample_products.csv` from the [http.Get](https://pkg.go.dev/net/http#Client.Get) method, this will get us the [response.Body](https://pkg.go.dev/net/http#Response) that contains the actual CSV file content. The response than can be parsed to the `csv.NewReader(*Os.File).ReadAll()` i.e. [reader.ReadAll()](https://pkg.go.dev/encoding/csv#Reader.ReadAll). The function returns a multidimensional slice `[][]slice` that can be iterated and parsed as per requirement.&#xA;&#xA;### Reading XML file&#xA;&#xA;XML is the de facto standard for RSS feeds, it is widely used in many places and is still all over the web. We&#39;ll see an example to read an XML file locally, but as we saw in the above example, we can also read an RSS link from the web.&#xA;&#xA;Just like CSV, we have [encoding/xml](https://pkg.go.dev/encoding/xml), and the standard library has all the functions used for parsing the XML files.&#xA;&#xA;We will be using a local XML file called `rss.xml`, and reading the contents from the tags in the file.&#xA;&#xA;```xml&#xA;&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; ?&gt;&#xA;&lt;channel&gt;&#xA;&lt;title&gt;Meet Gor&lt;/title&gt;&#xA;&lt;description&gt;Techstructive Blog Feed&lt;/description&gt;&#xA;&lt;item&gt;&#xA;&lt;title&gt;Why and How to make and use Vim as a text editor and customizable IDE&lt;/title&gt;&#xA;&lt;link&gt;https://www.meetgor.com/vim-text-editor-ide&lt;/link&gt;&#xA;&lt;/item&gt;&#xA;&lt;item&gt;&#xA;&lt;title&gt;Setting up Vim for Python&lt;/title&gt;&#xA;&lt;link&gt;https://www.meetgor.com/vim-for-python&lt;/link&gt;&#xA;&lt;/item&gt;&#xA;&lt;/channel&gt;&#xA;```&#xA;&#xA;The above example is a short part of my blog&#39;s [rss](https://www.meetgor.com/rss) feed. I have just trimmed the unwanted part and will be just using the tags that we want to fetch. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/xml&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;type Channel struct {&#xA;&#x9;XMLName     xml.Name `xml:&#34;channel&#34;`&#xA;&#x9;Title       string   `xml:&#34;title&#34;`&#xA;&#x9;Description string   `xml:&#34;description&#34;`&#xA;&#x9;Item        []Item   `xml:&#34;item&#34;`&#xA;}&#xA;&#xA;type Item struct {&#xA;&#x9;XMLName xml.Name `xml:&#34;item&#34;`&#xA;&#x9;Title   string   `xml:&#34;title&#34;`&#xA;&#x9;Link    string   `xml:&#34;link&#34;`&#xA;}&#xA;&#xA;func check_error(err error) {&#xA;    if err != nil {&#xA;        log.Fatal(err)&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;f, err := os.ReadFile(&#34;rss.xml&#34;)&#xA;    check_error(err)&#xA;&#x9;defer f.Close()&#xA;&#xA;&#x9;d := Channel{}&#xA;&#x9;err = xml.Unmarshal(f, &amp;d)&#xA;    check_error(err)&#xA;&#xA;&#x9;for _, item := range d.Item {&#xA;&#x9;&#x9;log.Println(item.Title)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run xml.go&#xA;&#xA;{{ channel} Meet Gor Techstructive Blog Feed [{{ item} Why and How to make and use Vim as a text editor and customizable IDE https://www.meetgor.com/vim-text-editor-ide} {{ item} Setting up Vim for Python https://www.meetgor.com/vim-for-python}]}&#xA;&#xA;Why and How to make and use Vim as a text editor and customizable IDE&#xA;Setting up Vim for Python&#xA;```&#xA;&#xA;The above example uses a couple of `struct` like `Channel` and `Item` that stores the tag data like `title`, `description`, `link`, etc. Unlike the JSON, YAML, and toml files, XML can&#39;t parse the content directly we need a structure to parse into. And that&#39;s fine as XML is not much dynamic in terms of config, we usually have standard tags and elements which can be pre-defined in a struct type.&#xA;&#xA;In this example, the RSS feed has a `Channel` tag with `title`, `description`, and `item`. &#xA;&#xA;**NOTE: Use Title case for the fields of the structs. It will make the fields public, I spent a few hours debugging that really :)**&#xA;&#xA;So, we define the `Channel` struct with fields like `Title` as a string which is a tag in the file as `xml:&#34;title&#34;`. This means the title in the tag of the XML will be stored in the field as a string in the attribute name as `Title`. Similarly, we have fields like `Description` and `Item[]` this is a list or multiple of `item` tags that might be present in the XML file. The `XMLName` is used for identifying the parent tag for the struct, so we use `channel` for the first struct as it is the first tag appearing of the hierarchy in the XML file.&#xA;&#xA;So, we create an object for the root structure as `Channel{}` (an empty object instantiated). The `xml.Unmarshal` function is parsed with the content of the file as `data` which is a slice of byte as we have seen in the previous examples. The slice of byte is then used in the `Unmarshal` method as the first parameter and the reference of an empty `Channel` object as the second parameter. The second parameter will be to store the parsed XML content from the file.&#xA; &#xA;I have a few examples on the GitHub repository covering the reading of files from a URL for the CSV, and XML files. But, this concept in the example, can be applied to JSON, YAML, and other file formats as well.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/scripts/files/read/config_files) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, that&#39;s it from this post, we covered how to read specific configuration files like `JSON`, `CSV`, `YAML`, `TOML`, and `XML`. We saw how to read a local file and also touched on the concept to read contents from a file on the web with a URL. We also saw how we can use pre-defined structs to parse content from a file, especially for XML.&#xA;&#xA;Thank you for reading. If you have any queries, questions, or feedback, you can let me know in the discussion below or on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: File Reading</title>
      <link>meetgor.com/golang-file-read</link>
      <description>Using system calls to read files in Golang. Reading files using various styles like line by line, word, character, chunk and any other specifc delimiter. Using os, bufio, io, encoding packages for helper funcitons making system calls.</description>
      <pubDate>Sun, 23 Oct 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the 22nd post of the series, we will be looking into the file-handling process in golang, in the next few posts, we will cover the operations on file using golang. In this first entry of the file handling sub-series, we will understand the `READ` operation with files. We will see different ways to read a file, it can be word by word, line by line, or even custom chink by chunk. &#xA;&#xA;While dealing with files, we will also use standard library packages such as `os`, `bufio`, etc. We&#39;ll also touch on how we can read files from a remote location. Using golang, we will have a low-level interaction with file management but golang also abstracts the most of heavy lifting and management of files for us, so it becomes quite easy to work with files.&#xA;&#xA;&#xA;## Read the file as a single string (using os.ReadFile)&#xA;&#xA;We can use the [os](https://pkg.go.dev/os) package in golang, in which we have access to the [ReadFile](https://pkg.go.dev/os#ReadFile) funciton. The `ReadFile` function takes in a parameter as a string which should be a file name, it returns a slice of bytes or an error. We have discussed the error handling in the previous part of the series. So, we have to use the comma ok error syntax to get the appropriate return value from the funciton. We can grab the slice of bytes as the text we want or an error if there are errors like a file doesn&#39;t exist, it&#39;s a folder, etc. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;os&#34;&#xA;&#x9;&#34;log&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;text, err := os.ReadFile(&#34;sample.txt&#34;)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;log.Println(string(text))&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go                                                                                                                                                         &#xA;2022/10/23 22:39:11 Golang is a programming language.                                                                                                                    &#xA;created: 2007                                                                                                                                                            &#xA;type:static &#xA;```&#xA;&#xA;So, under the hood here, we have text as a slice of bytes. We can iterate over the text as a slice and get the character by character-in the content of the file. Though we don&#39;t directly interact with the file content, we are storing it in a variable. In technical words, the file is directly loaded into the memory at once. We thereby return a single string object containing the content of the file.&#xA;&#xA;&#xA;## Read file line by line &#xA;&#xA;We can even read a file line by line. Using the [bufio.NewScanner()](https://pkg.go.dev/bufio#NewScanner), the function takes in a [Reader](https://pkg.go.dev/io#Reader) object in our case it will be a file object. The function returns a scanner object that can be used to read the text with a particular scanner method. The returned object can be used in the loop to iterate over the content, in our case, we use the [Scan](https://pkg.go.dev/bufio#Scanner.Scan) method to split the file into lines. But we can use other methods like [ScanWords](https://pkg.go.dev/bufio#ScanWords) for scanning words, [ScanRunes](https://pkg.go.dev/bufio#ScanRunes) for scanning character by character, [ScanBytes](https://pkg.go.dev/bufio#ScanBytes) for scanning byte by byte. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bufio&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;f, err := os.Open(&#34;sample.txt&#34;)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#x9;line_list := []string{}&#xA;&#xA;&#x9;defer f.Close()&#xA;&#x9;scanner := bufio.NewScanner(f)&#xA;&#x9;for scanner.Scan() {&#xA;&#x9;&#x9;line := scanner.Text()&#xA;&#x9;&#x9;line_list = append(line_list, line)&#xA;&#x9;}&#xA;&#x9;if err := scanner.Err(); err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#x9;for _, line := range line_list {&#xA;&#x9;&#x9;log.Println(line)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run line.go&#xA;&#xA;2022/10/23 22:39:50 Golang is a programming language.&#xA;2022/10/23 22:39:50 created: 2007&#xA;2022/10/23 22:39:50 type:static&#xA;```&#xA;&#xA;In the above example, the file is read in with the `bufio.NewScanner` and is iterated line by line with the help of the `Scan` function. The text in the line is scanned and stored in the variable `line` which is a string, this is further appended to the string slice `line_list`. Hence we can iterate over the file content line by line and store the results as a string array.&#xA;&#xA;Here we have used the `defer` keyword before calling the `f.Close()` method because we want to close the file after performing operations on the file. The defer will call the function at almost the end of the main function i.e. at the end of the program.&#xA;&#xA;## Read File by a delimiter&#xA;&#xA;We can even read a file with a custom delimiter which can be used to read CSV or other delimiters. The [csv](https://pkg.go.dev/encoding/csv) package has a [NewReader](https://pkg.go.dev/encoding/csv#NewReader) function which takes in a object of file content, and it will return a [Reader](https://pkg.go.dev/encoding/csv#Reader) object. We can alter the attribute `Comma` in the `Reader` object and set it to any value we want as a delimiter. Thereafter we can read the whole content or read it as words, lines, bytes, or chunks as per your criteria. The extracted content will be split as a slice of the data separated by the delimiter set in the `Comma` attribute.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;encoding/csv&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;f, err := os.Open(&#34;delimeter.txt&#34;)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#x9;defer f.Close()&#xA;&#xA;&#x9;reader := csv.NewReader(f)&#xA;&#xA;&#x9;reader.Comma = &#39;:&#39;&#xA;&#x9;&#xA;    data, err := reader.ReadAll()&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#x9;log.Println(data)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ cat delimiter.txt&#xA;&#xA;10:22:2022&#xA;golang:21:read&#xA;&#xA;&#xA;$ go run delimiter.go&#xA;&#xA;2022/10/23 22:40:44 [[10 22 2022] [golang 21 read]]&#xA;```&#xA;&#xA;In the above example, the delimiter is set as `:` so by using the `Comma` attribute we can set the delimiter. By using the `NewReader` function, we fetch the reader object and by using the `ReadAll` function associated to the reader object, we read the contents. The content is fetched as a slice of strings which will be separated by the delimiter.&#xA;&#xA;&#xA;### Reading File word by word&#xA;&#xA;We can even use [ScanWords](https://pkg.go.dev/bufio#ScanWords) to read a file word by word. A word can be a collection of characters that are separated by space. Instead of reading it line by line, this function reads the file content after a space. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bufio&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;f, err := os.Open(&#34;sample.txt&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#x9;defer f.Close()&#xA;&#xA;&#x9;scanner := bufio.NewScanner(f)&#xA;&#x9;scanner.Split(bufio.ScanWords)&#xA;&#xA;&#x9;if err := scanner.Err(); err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;wordlist := []string{}&#xA;&#x9;for scanner.Scan() {&#xA;&#x9;&#x9;word := scanner.Text()&#xA;&#x9;&#x9;wordlist = append(wordlist, word)&#xA;&#x9;&#x9;log.Println(word)&#xA;&#x9;}&#xA;&#x9;log.Println(wordlist)&#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run word.go&#xA;&#xA;2022/10/23 22:42:03 Golang&#xA;2022/10/23 22:42:03 is&#xA;2022/10/23 22:42:03 a&#xA;2022/10/23 22:42:03 programming&#xA;2022/10/23 22:42:03 language.&#xA;2022/10/23 22:42:03 created:&#xA;2022/10/23 22:42:03 2007&#xA;2022/10/23 22:42:03 type:static&#xA;&#xA;2022/10/23 22:42:03 [Golang is a programming language. created: 2007 type:static] &#xA;```&#xA;&#xA;With the `ScanWords` function, we can read the contents of the file word by word. The scanner object which has the actual content of the file is split by the `Split` function, the split criteria are used as Word, where the delimiter will be used as space. The `wordlist` is a slice of strings to which we append the string `word` that in turn is read from the `scanner.Text()` function.&#xA;&#xA;### Reading Files in chunks&#xA;&#xA;We can even read files in chunks, a chunk is a collection/array of bytes. We can specify the number of bytes we want to read in one go and the file reader will scan the content as a slice of that number of bytes each iteration. The [Read](https://pkg.go.dev/bufio#Reader.Read) funciton takes in a slice of bytes and will return the number of bytes in the reader object.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bufio&#34;&#xA;&#x9;&#34;io&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;f, err := os.Open(&#34;sample.txt&#34;)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;defer f.Close()&#xA;&#xA;&#x9;reader := bufio.NewReader(f)&#xA;&#x9;chunk_size := 16&#xA;&#x9;chunk_list := []string{}&#xA;&#x9;buf := make([]byte, chunk_size)&#xA;&#xA;&#x9;for {&#xA;&#x9;&#x9;n, err := reader.Read(buf)&#xA;&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;if err != io.EOF {&#xA;&#x9;&#x9;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;break&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;chunk_list = append(chunk_list, string(buf[0:n]))&#xA;&#x9;}&#xA;&#x9;for _, chunk := range chunk_list {&#xA;&#x9;&#x9;log.Print(chunk)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run chunks.go&#xA;&#xA;2022/10/23 22:44:41 Golang is a prog&#xA;2022/10/23 22:44:41 ramming language&#xA;2022/10/23 22:44:41 .&#xA;created: 2007&#xA;2022/10/23 22:44:41 type:static&#xA;```&#xA;&#xA;In the above example, we have opened the file and loaded the content into the `f` variable. the contents are read with the help of the `NewReader` function which returns a reader object which further can be used to read contents into chunks of bytes. The `chunk_size` defines the size we want to use for reading the content, `chunk_list` as a slice of strings which will hold the slice of chunks/bytes as a type caste into a slice of strings. With the `Read` function, the bytes are read into the function, and the buffer is split as per the chunk size obtained in the `Read` function. We append the slice of bytes into the sliced array and thereby we obtain the slice of strings.&#xA;&#xA;&#xA;### Read file character by character&#xA;&#xA;We can even read file each character at a time, using the [ScanRunes](https://pkg.go.dev/bufio#ScanRunes) function, this function scans a single rune/byte at a time. So, we can scan these runes one at a time and store them as a slice of bytes. Thereby we will have the content of the file stored as a slice of bytes.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;bufio&#34;&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;f, err := os.Open(&#34;sample.txt&#34;)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#x9;defer f.Close()&#xA;&#xA;&#x9;scanner := bufio.NewScanner(f)&#xA;&#x9;scanner.Split(bufio.ScanRunes)&#xA;&#xA;&#x9;if err := scanner.Err(); err != nil {&#xA;&#x9;&#x9;log.Fatal(err)&#xA;&#x9;}&#xA;&#xA;&#x9;charlist := []byte{}&#xA;&#x9;for scanner.Scan() {&#xA;&#x9;&#x9;char := byte(scanner.Text()[0])&#xA;&#x9;&#x9;charlist = append(charlist, char)&#xA;&#x9;}&#xA;&#x9;log.Println(charlist)&#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run char.go&#xA;&#xA;2022/10/23 22:48:55 [71 111 108 97 110 103 32 105 115 32 97 32 112 114 111 103 114 97 109 109 105 110 103 32 108 97 110 103 117 97 103 101 46 10 99 114 101 97 116 101 100 58 32 50 48 48 55 10 116 121 112 101 58 115 116 97 116 105 99 10]&#xA;```&#xA;&#xA;We can see in the above example, the output is a slice of byte, hence these are `uint8`, we can cast them to `string` and obtain the equivalent ASCII representation of the bytes. The `ScanRunes` function allows us to read the content from the reader object as a rune as we split the reader object into the unit bytes/runes.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/files/read/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;In this section, we explored the functions and packages related to file reading. We saw how we can use packages like `os`, `bufio`, `encoding`, etc. to read files in a different way. We saw how to read files as a single string, line by line, word by word, character by character, in chunks, and also with a custom delimiter. Hopefully, the basics of file reading will have been cleared and with the examples, the syntactical construct was understood. &#xA;&#xA;Thank you for reading. If you have any queries, questions, or feedback, you can let me know in the discussion below or on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Paths</title>
      <link>meetgor.com/golang-paths</link>
      <description>Woking with Path and Filesystems using path, filepath, io, os packages in golang.</description>
      <pubDate>Sun, 02 Oct 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the 21st post of the series, we will be exploring the file paths in golang, we will be exploring how we can deal with paths. By using packages like `os`, `path`, `io`, we can work with file systems and operating system-specific details. In this section, we will see how to resolve paths, details from paths, extract relative or absolute paths, iterate over file systems, etc. &#xA;&#xA;Starting from this post, it will follow a specific topic in the upcoming few posts which will be covering files and paths. We will be talking about dealing with paths and files in golang. This post is just about working with paths.&#xA;&#xA;## Resolving and Parsing Path&#xA;&#xA;In golang, the [os](https://pkg.go.dev/os) and the [path](https://pkg.go.dev/path) packages are quite helpful in working with paths. We use the `path�ilpath` package specifically for working with paths and file structures. &#xA;&#xA;### Get the current working directory&#xA;&#xA;To get the path for the current working directory, we can use the [os.Getwd()](https://pkg.go.dev/os#Getwd) function. The function returns a-ok, an error-like object if the working directory exists it will return the absolute path to the directory else if the path is deleted or corrupted while processing, it will give an error object.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;os&#34;&#xA;    &#34;log&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    dir, err := os.Getwd()&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    } else {&#xA;        log.Println(dir)&#xA;    }&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ pwd&#xA;/home/meet/code/techstructive-blog&#xA;&#xA;$ go run main.go&#xA;2022/10/01 19:19:09 /home/meet/code/techstructive-blog&#xA;```&#xA;&#xA;So, as we can see the `Getwd` the function returns an absolute path to the current working directory which will be the path from which you will be executing/running the script file.&#xA;&#xA;### Get the path to the home directory&#xA;&#xA;We can even get the home directory path like the `/home` followed by the user name on Linux and the User Profile with the name for Windows. The [UserHomeDir()](https://pkg.go.dev/os#UserHomeDir), returns the home directory for the user from which the file is being executed. The return value is simply an string just like the `Getwd` function.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;os&#34;&#xA;    &#34;log&#34;&#xA;&#xA;)&#xA;&#xA;func main() {&#xA;    dir, err := os.UserHomeDir()&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    } else {&#xA;        log.Println(dir)&#xA;    }&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ echo $HOME&#xA;/home/meet/&#xA;&#xA;$ go run main.go&#xA;2022/10/01 19:35:50 /home/meet&#xA;```&#xA;&#xA;So, as expected, the `UserHomeDir` function returns the path string to the home directory of the user.&#xA;&#xA;### Get path from a file name string &#xA;&#xA;Let&#39;s say, we give in a filename and we want the absolute path of it. The [path/filepath](https://pkg.go.dev/path/filepath) package provides the [Abs](https://pkg.go.dev/path/filepath#Abs) function that does exactly that. The function returns a path string of the parameter parsed as a string to a directory or a file name. The function might as well return an error as the file path might not existing or the file might have got deleted, so we&#39;ll have to call the function with the ok, error syntax.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;path/filepath&#34;&#xA;    &#34;log&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    file_name := &#34;default.md&#34;&#xA;    log.Println(file_name)&#xA;    dir, err := filepath.Abs(file_name)&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    } else {&#xA;        log.Println(dir)&#xA;    }&#xA;}&#xA;&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;2022/10/01 19:52:23 default.md&#xA;2022/10/01 19:52:23 /home/meet/code/techstructive-blog/default.md&#xA;&#xA;```&#xA;&#xA;As we can see the file `default.md` was parsed in the `Abs()` function and it returned the absolute path of the file.&#xA;&#xA;### Get Parent Directory from a Path&#xA;&#xA;We can get the parent directory for a given path, if the path is to a file, we return the absolute path to the parent directory of the file, or if the path is to a folder, we return the folder&#39;s parent directory.&#xA;&#xA;```go&#xA;&#xA;package main&#xA;&#xA;import(&#xA;    &#34;path/filepath&#34;&#xA;    &#34;log&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    file_name := &#34;drafts/default.md&#34;&#xA;    //file_name := &#34;drafts/&#34;&#xA;    path, err := filepath.Abs(file_name)&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    } else {&#xA;        //log.Println(path)&#xA;        log.Println(filepath.Dir(path))&#xA;    }&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;2022/10/01 19:58:45 /home/meet/code/techstructive-blog/drafts&#xA;&#xA;$ go run main.go&#xA;2022/10/01 19:58:45 /home/meet/code/techstructive-blog &#xA;&#xA;```&#xA;&#xA;As we can see when we parse in a file path i.e. `drafts/default.md`, the `Dir` the method returns a path to the parent folder, and even if we parse the directory path i.e. `drafts/`, the method returns the parent of that directory.&#xA;&#xA;### Get the last file/folder for a given Absolute Path&#xA;&#xA;Golang also provides a way to get the file/directory name from a path string using the [Base](https://pkg.go.dev/path/filepath#Base) function provided in the [path/filepath](https://pkg.go.dev/path/filepath) package. &#xA;&#xA;```go&#xA;file_name := &#34;default.md&#34;&#xA;dir, err := filepath.Abs(file_name)&#xA;&#xA;if err != nil {&#xA;    log.Println(err)&#xA;} else {&#xA;    log.Println(dir)&#xA;    log.Println(filepath.Base(dir))&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;2022/10/01 19:58:45 /home/meet/code/techstructive-blog/drafts/default.md&#xA;2022/10/01 20:19:28 default.md &#xA;```&#xA;&#xA;So, the function `Base` will return the last element in the path, it can be a file or a directory, just returns the name before the last `\`. In the above example, we start with a filename `default.md` but set the dir as the absolute path to that file and again grab the file name using the `Base` function.&#xA;&#xA;## Fetching details from a Path&#xA;&#xA;We can even use utility functions for dealing with paths in golang like for checking if a file or path exists, if a path is a file or a directory, grabbing file name and extension, etc. The `path/filepath` and the `os` the package helps with working with these kinds of operations.&#xA;&#xA;### Check if a path exists&#xA;&#xA;We can use the [os.Stat](https://pkg.go.dev/os#Stat) function along with the [os.IsNotExist](https://pkg.go.dev/os#IsNotExist) for finding if a path is existing or not. The Stat function returns a [FileInfo](https://pkg.go.dev/io/fs#FileInfo) object or an error. The `FileInfo` object will have methods such as `Name()`, `IsDir()`, `Size()`, etc. If we get an error, inside the Stat method, the error will probably arise if the path does not exist, so inside the `os` package, we also have the `IsNotExist()` method, that returns a `boolean` value. The method returns `true` if the parsed error indicates that the path doesn&#39;t exist and `false` if it exists.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;path/filepath&#34;&#xA;    &#34;log&#34;&#xA;    &#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    file_name := &#34;drafts/default.md&#34;&#xA;    path, err := filepath.Abs(file_name)&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    } else {&#xA;        if _, err := os.Stat(path); os.IsNotExist(err) {&#xA;            log.Println(&#34;No, &#34; + path + &#34; does not exists&#34;)&#xA;        } else {&#xA;            log.Println(&#34;Yes, &#34; + path + &#34; exists&#34;)&#xA;        }&#xA;    }&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;2022/10/01 20:51:31 Yes, /home/meet/code/techstructive-blog/drafts/default.md exists&#xA;```&#xA;&#xA;So, from the above example, the program will log if the path is present in the system or not. The error is parsed from the `Stat` method to the `IsNotExist` method for logging relevant messages. Since the directory exists, we get the path exists log.&#xA;&#xA;### Check if a path is a file or directory &#xA;&#xA;The `FileInfo` object returned from the `Stat` the method provides a few methods such as `IsDir()` that can be used for detecting if a given path is a directory or not. The function simply returns a `boolean` value if the provided path points to a directory or not. Since we have to parse the path to the `IsDir()` function, we convert the file string into a path using the `Abs` method and then check if the path actually exist with the `Stat()` method.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;path/filepath&#34;&#xA;    &#34;log&#34;&#xA;    &#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    file_name := &#34;drafts/default.md&#34;&#xA;    //file_name := &#34;drafts/&#34;&#xA;    path, err := filepath.Abs(file_name)&#xA;    if err != nil {&#xA;            log.Println(err)&#xA;    } else {&#xA;        if t, err := os.Stat(path); os.IsNotExist(err) {&#xA;            log.Fatal(&#34;No, &#34; + path + &#34; does not exists&#34;)&#xA;        } else {&#xA;            log.Println(path)&#xA;            log.Println(t.IsDir())&#xA;        }&#xA;    }&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;2022/10/01 20:55:20 /home/meet/code/techstructive-blog/drafts/default.md&#xA;2022/10/01 20:55:20 false&#xA;&#xA;$ go run main.go&#xA;2022/10/01 20:55:20 /home/meet/code/techstructive-blog/drafts/&#xA;2022/10/01 20:55:20 true&#xA;```&#xA;&#xA;So, by running the program for a file and a directory, we can see it returns `true` if the path is a directory and `false` if the provided path is a file. In the above example, since the `drafts/defaults.md` is a file, it returned `false`, and for the next example, when we set the path  `drafts/` it returns `true` as the path provided is a directory.&#xA;&#xA;### Get File Extension from path&#xA;&#xA;By using the [path](https://pkg.go.dev/path) package, the extension of a given path can be fetched. The [Ext](https://pkg.go.dev/path#Ext) method can be used for getting the extension of the provided path string, it doesn&#39;t matter if the provided path is exists or not, is absolute or relative, it just returns the text after the last . in the string. But if we are working with real systems it is good practice to check if the file or path actually exists.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;path/filepath&#34;&#xA;    &#34;log&#34;&#xA;    &#34;path&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    file_name := &#34;default.md&#34;&#xA;    dir, err := filepath.Abs(file_name)&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    } else {&#xA;        file_ext := path.Ext(dir)&#xA;        log.Println(file_ext)&#xA;    }&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;2022/10/01 21:03:23 .md&#xA;```&#xA;&#xA;The above example demonstrates how we can get the extension of a file using the `Ext()` method in the `path` package. Given the string path as `default.md`, the function returned `.md` which is indeed the extension of the provided file.&#xA;&#xA;### Get Filename from path&#xA;&#xA;We can even get the file name from a path in golang using the [TrimSuffix](https://pkg.go.dev/strings#TrimSuffix) method in the [strings](https://pkg.go.dev/strings) package. The `TrimSuffix` method trim the string from the provided suffix, like if we have a string `helloworld` and we provide the suffix as `world`, the `TrimSuffix` the method will return the string `hello`, it will remove the suffix string from the end of the string.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;path/filepath&#34;&#xA;    &#34;log&#34;&#xA;    &#34;path&#34;&#xA;    &#34;strings&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;    file_name := &#34;default.md&#34;&#xA;    dir, err := filepath.Abs(file_name)&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    } else {&#xA;        file_ext := path.Ext(dir)&#xA;        log.Println(file_ext)&#xA;        log.Println(strings.TrimSuffix(dir, file_ext))&#xA;        log.Println(strings.TrimSuffix(file_name, file_ext))&#xA;        //log.Println(strings.TrimSuffix(dir, path.Ext(dir)))&#xA;        //log.Println(strings.TrimSuffix(file_name, path.Ext(dir)))&#xA;    }&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;&#xA;2022/10/01 21:09:39 .md&#xA;2022/10/01 21:09:39 /home/meet/code/techstructive-blog/default&#xA;2022/10/01 21:09:39 default&#xA;```&#xA;&#xA;We can use the `TrimSuffix` method to remove the extension as the suffix and it returns the path which we get as the file name. The `TrimSuffix` method returns the path after removing the extension from the path.&#xA;&#xA;## List Files and Directories in Path&#xA;&#xA;In golang, we can use the `io` and the `path/filepath` packages to iterate over the file paths. Suppose, we want to list out all the files or directories in a given path, we can use certain functions such as `Walk`, `WalkDir` to iterate over a path string.&#xA;&#xA;There are certain types of iterations we can perform based on the constraints we might have, like iterating over only files, or directories, not including nested directories, etc. We&#39;ll explore the basic iterations and explain how we fine-tune the iteration based on the constraints.&#xA;&#xA;## List only the files in the Path&#xA;&#xA;The first example, we can take is to simply list out only the files in the current path directory, we don&#39;t want to list out the file in nested directories. So, it will be like a simple ls command in Linux. Let&#39;s see how we can list out the files in the given path.&#xA;&#xA;We can even use `path/filepath` package to iterate over a given path and list out the directories and files in it. The [filepath.Walk](https://pkg.go.dev/path/filepath#Walk) or the [WalkDir](https://pkg.go.dev/path/filepath#WalkDir) method is quite useful for this kind of operation, the function takes in a path string and a [WalkFunc](https://pkg.go.dev/path/filepath#WalkFunc) or the [WalkDirFunc](https://pkg.go.dev/io/fs#WalkDirFunc) Function, the walk function are simply used for walking of a path string. Both functions take two parameters, the first being the string which will be the file system path where we want to iterate or walk, and the next parameter is the function either [WalkFunc](https://pkg.go.dev/path/filepath@go1.19.1#WalkFunc) or [WalkDirFun](https://pkg.go.dev/io/fs#WalkDirFunc) respectively. Both functions are similar but a subtle difference in the type of parameter both take in.&#xA;&#xA;### WalkDir Function&#xA;&#xA;The `WalkDir` function takes in the parameters such as a `string` of the file path, the [fs.DirEntry](https://pkg.go.dev/io/fs#DirEntry) object and the `error` if any. The function returns an `error` if there arises any. We have to call the function with the parameters of a string and a function object which will be of type `type WalkDirFunc func(path string, d DirEntry, err error) error`.&#xA;&#xA;We can even use Walk the function to iterate over the given path.&#xA;&#xA;### Walk Function&#xA;&#xA;The `Walk` function takes in the parameters such as a `string` of the file path, the [fs.FileInfo](https://pkg.go.dev/io/fs#FileInfo) object and the `error` if any. The function returns an `error` if there arises any. We have to call the function with the parameters of a string and a function object which will be of type `type WalkFunc func(path string, info fs.FileInfo, err error) error`.&#xA;&#xA;It might be a user preference to select one of the functions for iterating over the file system, but the [documentation](https://pkg.go.dev/path/filepath#Walk) says, the `Walk` function is a little bit inefficient compared to the `WalkDir` function. But if performance is not an issue, you can use either of those based on which type of file system object you are currently working with.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;path/filepath&#34;&#xA;    &#34;log&#34;&#xA;    &#34;io/fs&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;var files []string&#xA;&#x9;dir_path := &#34;.&#34;&#xA;&#x9;err := filepath.WalkDir(dir_path, func(path string, info fs.DirEntry, err error) error {&#xA;&#x9;&#x9;dir_name := filepath.Base(dir_path)&#xA;&#x9;&#x9;if info.IsDir() == true &amp;&amp; info.Name() != dir_name{&#xA;&#x9;&#x9;&#x9;return filepath.SkipDir&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;files = append(files, path)&#xA;&#x9;&#x9;&#x9;return nil&#xA;&#x9;&#x9;}&#xA;&#x9;})&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;for _, file:= range files {&#xA;&#x9;&#x9;log.Println(file)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run walk.go&#xA;&#xA;2022/10/02 12:07:17 .&#xA;2022/10/02 12:07:17 .dockerignore&#xA;2022/10/02 12:07:17 .gitignore&#xA;2022/10/02 12:07:17 CNAME&#xA;2022/10/02 12:07:17 Dockerfile&#xA;2022/10/02 12:07:17 README.md&#xA;2022/10/02 12:07:17 markata.toml&#xA;2022/10/02 12:07:17 requirements.txt&#xA;2022/10/02 12:07:17 textual.log&#xA;```&#xA;&#xA;In the above example, we have used the `WalkDir` method for iterating over the file system, the directory is set as `.` indicating the current directory. We parse the first paramter as the string to the `WalkDir` function, the next parameter is a function so we can either create it separately or just define an `anonymous function`. It becomes a lot easier to write an `anonymous function` rather than writing the function separately.&#xA;&#xA;So, we have created the `dir_name` variable which parses the `dir_path` from the parameter to the function and gets the name of the directory or file. We can then fine-tune the requirements of the iteration of the directory, i.e. make checks if the path is a file or a directory and if we want to exclude any specific files with certain extensions or directories with a certain name, etc. In this example, we have added a check if the path is a directory(using `info.IsDir()`) and if the directory name is not the same as the parsed path(i.e. exclude the nested directories) we skip these types of directories (using [filepath.SkipDir](https://pkg.go.dev/io/fs#SkipDir)). So we only look for the files in the current directory or the directory which we provided in the paramter as `dir_path`. We append those paths into the files array using the `append` method. Finally, we check for errors in the parsed parameter while iterating over the file system and `panic` out of the function. We can then simply iterate over the files slice and print or perform operations as required.&#xA;&#xA;### All the files in the Path (inside directories)&#xA;&#xA;We can also list all the files within the folders provided in the path string by removing the directory name check. We will only append the file type to the file slice rather than appending all the directories.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;path/filepath&#34;&#xA;    &#34;log&#34;&#xA;    &#34;io/fs&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;var files []string&#xA;&#x9;root := &#34;static/&#34;&#xA;&#x9;err := filepath.WalkDir(root, func(path string, info fs.DirEntry, err error) error {&#xA;&#x9;&#x9;if info.IsDir() {&#xA;&#x9;&#x9;&#x9;return nil&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;files = append(files, path)&#xA;&#x9;&#x9;&#x9;return nil&#xA;&#x9;&#x9;}&#xA;&#x9;})&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;&#x9;for _, file:= range files {&#xA;&#x9;&#x9;log.Println(file)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run walk.go&#xA;&#xA;2022/10/02 12:08:22 static/404.html&#xA;2022/10/02 12:08:22 static/CNAME&#xA;2022/10/02 12:08:22 static/index.html&#xA;2022/10/02 12:08:22 static/main.css&#xA;2022/10/02 12:08:22 static/projects/index.html&#xA;2022/10/02 12:08:22 static/social-icons.svg&#xA;2022/10/02 12:08:22 static/tbicon.png&#xA;```&#xA;&#xA;As we can see the iteration resulted in printing all the files in the given path including the files in the subdirectories. The static directory had the projects directory as a subdirectory in the path, hence we are listing the files in that directory as well.&#xA;&#xA;### Recursive directories in the Path&#xA;&#xA;We can also append the directory names as well as file names by completely removing the `info.IsDir()` check and add the printing out of the relevant information as dir and files depending on the type. We can also maintain different lists or slices for directory and file and append them accordingly.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;path/filepath&#34;&#xA;    &#34;log&#34;&#xA;    &#34;io/fs&#34;&#xA;func main() {&#xA;&#xA;&#x9;var files []string&#xA;&#x9;root := &#34;static/&#34;&#xA;&#x9;err := filepath.WalkDir(root, func(path string, info fs.DirEntry, err error) error {&#xA;        files = append(files, path)&#xA;&#x9;&#x9;var f string&#xA;&#x9;&#x9;if info.IsDir() {&#xA;&#x9;&#x9;&#x9;f = &#34;Directory&#34;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;f = &#34;File&#34;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;log.Printf(&#34;%s Name: %s&#xA;&#34;, f, info.Name())&#xA;        return nil&#xA;&#x9;})&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;&#x9;for _, file:= range files {&#xA;&#x9;&#x9;log.Println(file)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run walk.go&#xA;&#xA;2022/10/02 12:09:48 Directory Name: static&#xA;2022/10/02 12:09:48 File Name: 404.html&#xA;2022/10/02 12:09:48 File Name: main.css&#xA;2022/10/02 12:09:48 Directory Name: projects&#xA;2022/10/02 12:09:48 File Name: index.html&#xA;2022/10/02 12:09:48 File Name: social-icons.svg&#xA;2022/10/02 12:09:48 File Name: tbicon.png&#xA;&#xA;2022/10/02 12:09:48 static/&#xA;2022/10/02 12:09:48 static/404.html&#xA;2022/10/02 12:09:48 static/index.html&#xA;2022/10/02 12:09:48 static/main.css&#xA;2022/10/02 12:09:48 static/projects&#xA;2022/10/02 12:09:48 static/projects/index.html&#xA;2022/10/02 12:09:48 static/social-icons.svg&#xA;2022/10/02 12:09:48 static/tbicon.png&#xA;```&#xA;&#xA;We can see that the directories and files getting logged which are present in the given path. In the output above, the projects the directory is getting walked along with the files present inside the directory. This is how we can use the Walk method to iterate over directories in a file system.&#xA;&#xA;### All the folders in the Path (only directories)&#xA;&#xA;If we want to print only the directories, we can again add checks in the funciton body, we can simply append the path name when the path returns `true` on `IsDir` function call.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;    &#34;path/filepath&#34;&#xA;    &#34;log&#34;&#xA;    &#34;io/fs&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;var folders []string&#xA;&#x9;root := &#34;static/&#34;&#xA;&#x9;err := filepath.WalkDir(root, func(path string, info fs.DirEntry, err error) error {&#xA;&#x9;&#x9;dir_name := filepath.Base(root)&#xA;&#x9;&#x9;if info.IsDir() {&#xA;            folders = append(folders, info.Name())&#xA;            return nil&#xA;&#x9;&#x9;} else if info.IsDir() &amp;&amp; dir_name != info.Name() {&#xA;&#x9;&#x9;&#x9;return filepath.SkipDir&#xA;&#x9;&#x9;}&#xA;        return nil&#xA;&#x9;})&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;&#x9;for _, folder := range folders{&#xA;&#x9;&#x9;log.Println(folder)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run walk.go&#xA;&#xA;2022/10/02 12:13:25 static&#xA;2022/10/02 12:13:25 projects&#xA;```&#xA;&#xA;Here, we can see it lists all the folder names present in the given path, it will log all the nested directories as well. In the above example, the `static/` path in the local system had a projects directory and hence it prints the same, but that can be till the final depth of the file system.&#xA;&#xA;For all the examples on the `Walk` functions, you can check out the links on the GitHub repository:&#xA;&#xA;- [Walk and WalkDir function examples](https://github.com/Mr-Destructive/100-days-of-golang/blob/main/scripts/paths/walk.go)&#xA;&#xA;- [Walk and WalkDir function as anonymous function](https://github.com/Mr-Destructive/100-days-of-golang/blob/main/scripts/paths/walk_anonymous.go)&#xA;&#xA;## Relative or Absolute Paths&#xA;&#xA;We have been using absolute paths in the above examples, but while navigating from one directory to other, we heavily make use of relative paths as they make it easier to move around.&#xA;&#xA;### Check if a path is Absolute&#xA;&#xA;We can check if a path is absolute using the [IsAbs](https://pkg.go.dev/path#IsAbs) function, the function takes in a path string as a parameter and returns a boolean value. It returns `true` if the provided path is absolute else it returns `false`.&#xA;&#xA;### Check if a path is Absolute&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#x9;&#34;path/filepath&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;dir, err := os.Getwd()&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#x9;log.Println(dir)&#xA;&#x9;log.Println(filepath.IsAbs(dir))&#xA;&#xA;    dir = &#34;../math&#34;&#xA;&#x9;log.Println(dir)&#xA;&#x9;log.Println(filepath.IsAbs(dir))&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run rel_abs.go                                                                                                            &#xA;2022/10/02 14:38:44 /home/meet/code/techstructive-blog&#xA;2022/10/02 14:38:44 true&#xA;2022/10/02 14:38:44 ../math&#xA;2022/10/02 14:38:44 false&#xA;```&#xA;&#xA;In the above example, we can see that when we parse `../math` indicating there&#39;s a `/math` directory, before the current directory(parent directory) we get `false`.&#xA;&#xA;But when we parse the path obtained from `Getwd()` function call or a path which is located from the root path will get the return value as `true`.&#xA;&#xA;### Get the relative path from base to target path&#xA;&#xA;Let&#39;s say we are in a certain directory `/a/b/c/`, we want to move into `/a/c/d/`, we will have to move back two times and then move into `c` followed by the `d` directory. The relative path from `/a/b/c/` to `/a/c/d/` can be described as `../../c/d/`. We have a function in golang that does the same, basically creating a relative path from the base directory path to a target path. The function is provided in the path/filepath package as [Rel](https://pkg.go.dev/path/filepath@go1.19.1#Rel), the function takes in two parameters, both as a string representing paths. The first is the base path(like you are in) and the second is the target path (as the target to reach). The function returns the string representation of the absolute path from the base to the target directory.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;os&#34;&#xA;&#x9;&#34;path/filepath&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;dir, err := os.Getwd()&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;}&#xA;&#xA;    dir, err = filepath.Abs(&#34;plugins/&#34;)&#xA;&#x9;s, err := filepath.Abs(&#34;static/projects/&#34;)&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    }&#xA;&#xA;&#x9;log.Println(s)&#xA;&#x9;log.Println(dir)&#xA;&#x9;log.Println(filepath.Rel(s, dir))&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run rel_abs.go&#xA;&#xA;2022/10/02 12:26:09 /home/meet/code/techstructive-blog/static/projects&#xA;2022/10/02 12:26:09 /home/meet/code/techstructive-blog/plugins&#xA;2022/10/02 12:26:09 ../../plugins &lt;nil&gt;&#xA;```&#xA;&#xA;We can see that the relative path from the two directories is given as the return string from the Rel function.&#xA;&#xA;### Join paths&#xA;&#xA;The [Join](https://pkg.go.dev/path/filepath@go1.19.1#Join) method provided in the `filepath` package, is used for combining `n` number of path strings as one path. It separates the file paths with the operating system-specific separator like `/` for Linux and `\` for windows.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;log&#34;&#xA;&#x9;&#34;path/filepath&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;dir, err := filepath.Abs(&#34;operators/arithmetic/&#34;)&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    }&#xA;&#xA;&#x9;log.Println(filepath.Join(&#34;golang&#34;, &#34;files&#34;))&#xA;&#x9;log.Println(filepath.Join(dir, &#34;/files&#34;, &#34;//read&#34;))&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run rel_abs.go&#xA;&#xA;2022/10/02 12:30:37 golang/files&#xA;2022/10/02 12:30:37 /home/meet/code/techstructive-blog/operators/arithmetic/files/read&#xA;```&#xA;&#xA;In the above example, we can see that it parses the path accurately and ignore any extra separators in the string path.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/paths) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from the following post, we were able to explore the path package along with a few functions  io as well as os package. By using various methods and type objects, we were able to perform operations and work with the file paths. By using functions to iterate over file systems, checking for absolute paths, checking for the existence of paths, etc, the fundamentals of path handling in golang were explored.&#xA;&#xA;Thank you for reading, if you have any queries, feedback, or questions, you drop them below on the blog as a [github discussion](https://www.meetgor.com/golang-paths/#comments), or you can ping me on my social handles as well. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Error Handling</title>
      <link>meetgor.com/golang-error-handling</link>
      <description>Understanding the concept of errors in golang. How to handle errors in funciton calls, create custom error class with interfaces</description>
      <pubDate>Sat, 17 Sep 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Error handling is quite an important feature of any programming language to improve the quality and transparency between the user and the application. By raising appropriate error messages, the user can get a clear idea about the things happening in the interface as well as the application can handle the errors with appropriate actions.&#xA;&#xA;In the 20th post of the series, we will be exploring the concept of error handling in golang. From this article, we will be able to learn the fundamentals of error or exception handling in golang, create custom error classes, raise and ignore error messages, and exit or redirect the flow of state of the application when an error is raised.&#xA;&#xA;## Why we need Error Type&#xA;&#xA;We need [error handling](https://go.dev/blog/error-handling-and-go) and catching in order to stop or divert the flow of the application which will restrict the dubious or unintentional execution of the code. Let&#39;s say, for example, we have a string as an input, and the user skipped the input and the string is returned as empty, we don&#39;t want to execute the further program as the execution might depend on the value of the string. So, in order to catch these kinds of events, we might use errors and log the results for better transparency.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;var s string&#xA;&#x9;n, err := fmt.Scanf(&#34;%s&#34;, &amp;s)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;&#x9;// panic(err)&#xA;        // OR&#xA;        // return&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(n)&#xA;&#x9;&#x9;if s[0] == &#39;a&#39; {&#xA;&#x9;&#x9;&#x9;fmt.Println(s)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run main.go&#xA;asdf&#xA;1&#xA;asdf&#xA;&#xA;&#xA;$ go run main.go&#xA;&#xA;unexpected newline&#xA;&#xA;&#xA;$ go run main.go&#xA;wsd&#xA;1&#xA;```&#xA;&#xA;In the above example, we have a simple string `s` input, we will input the string using the `Scanf` function that will return an integer as the number of variables it has scanned and error if any. Here, as the function might return two values, we need two variables to call the function. The `n` variable stores the number of variables successfully scanned and the `err` as the err from the function generated. If there is an error, that is the value stored in `err` is not empty, we will log the error. And move into the rest of the program.&#xA;&#xA;This might be looking cool, but it doesn&#39;t break out of the program if there is an error. We want it to log the error as well as exit from the program. We can do that using the panic function.&#xA;&#xA;## Catching Errors&#xA;&#xA;We&#39;ll see a few examples, where we will catch errors in some of the regularly used functions. These error messages can be used in deciding the next procedure to be run.&#xA;&#xA;### Comma OK/Error syntax&#xA;&#xA;We use the [comma ok, error](https://go.dev/doc/effective_go#:~:text=is%20called%20the%20%E2%80%9C-,comma%20ok,-%E2%80%9D%20idiom.%20In%20this) syntax where we want multiple return values from a function. It is a narrowed syntax for a two-type return value function, we either return a value that we are expecting as `OK`, or we get an `error` from the function call.&#xA;&#xA;```go&#xA;&#xA;ok, err := function()&#xA;if err != nil {&#xA;    // handle error&#xA;    panic(err)&#xA;} else {&#xA;    // work with the ok object&#xA;    fmt.Println(ok)&#xA;}&#xA;&#xA;```&#xA;&#xA;In the above code, we have used the comma-ok, error syntax, the function call will return two objects either an expected object or an error object if there were errors in the processing. We handle the error if the error object is not empty i.e. it contains something, else we can do the rest of the required processing of the program.&#xA;&#xA;We can even ignore the `err` or the `ok` object using the `_` i.e. to say a don&#39;t care variable. Remember you can ignore either of the values and not both. It is not recommended to ignore errors but if you know the obvious thing to process, you might as well sometimes.&#xA;&#xA;A more compressed code might look something like below:&#xA;&#xA;```go&#xA;&#xA;if ok, err := function(); err != nil {&#xA;    // handle error&#xA;    panic(err)&#xA;} else {&#xA;    // work with the ok object&#xA;    fmt.Println(ok)&#xA;}&#xA;```&#xA;&#xA;The above code wraps the initialization of `ok, err` objects by calling the function inside the if statement and checking for the error.&#xA;&#xA;### Making HTTP requests&#xA;&#xA;Let&#39;s say we have a URL, and we want to check if the site exists or not, we can run the [http.Get](https://pkg.go.dev/net/http@go1.19.1#Client.Get) function from the [net/http](https://pkg.go.dev/net/http) package. We will parse a URL in the function and this function also returns a [Response](https://pkg.go.dev/net/http#Response) type object and an error object if there are any errors generated during the function call. If there is an error while we call the function, we simply log the error and panic out of the program. Else we can log the status code and do further processing.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;url := &#34;https://meetgor.com/&#34;&#xA;&#x9;resp, err := http.Get(url)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(resp.StatusCode)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run web.go&#xA;URL: https://meetgor.com/&#xA;200&#xA;&#xA;&#xA;&#xA;$ go run web.go&#xA;&#xA;URL: htts://meetgor.com/&#xA;Get &#34;htts://meetgor.com/&#34;: unsupported protocol scheme &#34;htts&#34;&#xA;panic: Get &#34;htts://meetgor.com/&#34;: unsupported protocol scheme &#34;htts&#34;&#xA;&#xA;goroutine 1 [running]:&#xA;main.main()&#xA;        /home/meet/code/100-days-of-golang/scripts/errors/https.go:14 +0x170&#xA;exit status 2&#xA;```&#xA;&#xA;&#xA;This is how we can validate a URL handling the error if the parsed URL is invalid or does not exist.&#xA;&#xA;There is one more variation of the above code style, it is a bit compressed and might be just a syntactic change.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;url := &#34;https://meetgor.com/&#34;&#xA;&#x9;if resp, err := http.Get(url); err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;&#x9;panic(err)&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(resp.StatusCode)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;This can be used wherever you are using the `ok, err` kind of syntax, but I prefer the clean syntax so I won&#39;t move ahead with this.&#xA;&#xA;### Opening or Handling of File&#xA;&#xA;We can even use error handling while dealing with Files or Folders. We can use the [os](https://pkg.go.dev/os) package to read the file in golang. The [Open](https://pkg.go.dev/os#Open) function will read the file if it exists or else it will return an error. We can catch the error from the comma `ok,error` syntax and do the required processing in the program.&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;os&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;file_name := &#34;hello.txt&#34;&#xA;&#x9;file, err := os.Open(file_name)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(&#34;Error: &#34;, err)&#xA;&#xA;        // Create a File &#xA;&#xA;&#x9;&#x9;// _, err := os.Create(file_name)&#xA;&#x9;&#x9;// if err != nil {&#xA;&#x9;&#x9;// &#x9;fmt.Println(err)&#xA;&#x9;&#x9;// }&#xA;&#x9;&#x9;// fmt.Println(&#34;Created File&#34;, file_name)&#xA;&#x9;&#x9;// file, _ = os.Open(file_name)&#xA;&#x9;}&#xA;&#x9;fmt.Println(file.Stat())&#xA;}&#xA;```&#xA;&#xA;![File handling Error](https://res.cloudinary.com/techstructive-blog/image/upload/v1663425619/blog-media/golang-file-error.png)&#xA;&#xA;We can use the error as a hint that the file doesn&#39;t exist and create a file and then move toward the actual execution of the program. We can also ignore the file object while creating the file, as we are interested in only knowing that the file is just created without any errors, we use the `_` to ignore the variable in the assignment in the function call.&#xA;&#xA;Inside the commented code, we use the [Create](https://pkg.go.dev/os#Create) function to create a file and check for any errors in the process. We finally create the file and `Open` the newly created file.&#xA;&#xA;## Custom Error&#xA;&#xA;We can create custom error types in golang with the help of interfaces and structs. An Error struct will simply consist of a string `message`, that string will display the error. By overriding or creating the `Error` method as an interface for the struct we can construct custom errors.&#xA;&#xA;```go&#xA;type Invalid_URL_Error struct {&#xA;&#x9;message string&#xA;}&#xA;&#xA;func (e Invalid_URL_Error) Error() string {&#xA;&#x9;return &#34;Invalid URL&#34;&#xA;}&#xA;&#xA;```&#xA;&#xA;Here, we have the `Invalid_URL_Error` as the custom struct name and the `Error()` method as an interface that will print the error log. This Error method will be used while raising errors in the program. It might be called from another function while doing the actual processing of the URL while sending a GET request.&#xA;&#xA;Further, we can call this custom error method when we wish, by using the package functions, we can override the function call with the custom method.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;net/http&#34;&#xA;)&#xA;&#xA;type Invalid_URL_Error struct {&#xA;&#x9;message string&#xA;}&#xA;&#xA;func (e Invalid_URL_Error) Error() string {&#xA;&#x9;return &#34;Invalid URL&#34;&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;url := &#34;htt://meetgor.com&#34;&#xA;&#x9;response, err := http.Get(url)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(Invalid_URL_Error{})&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(response)&#xA;&#x9;&#x9;defer response.Body.Close()&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run custom_error.go&#xA;Invalid URL &#xA;Get &#34;htt://meetgor.com&#34;: unsupported protocol scheme &#34;htt&#34;&#xA;&#xA;```&#xA;&#xA;In the above code, we are basically calling the function `http.Get` that will return a `Response` or an `err` object. We can even call the custom error method with an empty `Invalid_URL_Error` object, this will call the function `Error` from that interface. The function will print the custom error message and thereby we are able to log the custom error message for the invalid URL example.&#xA;&#xA;Also, we can parse the default error method to the custom error method which will get us additional information inside the error interface method.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type Invalid_URL_Error struct {&#xA;&#x9;message string&#xA;}&#xA;&#xA;func (e Invalid_URL_Error) Error() string {&#xA;&#x9;return &#34;Invalid URL : &#34; + e.message&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;url := &#34;htt://meetgor.com&#34;&#xA;&#x9;response, err := http.Get(url)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(Invalid_URL_Error{err.Error()})&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(response)&#xA;&#x9;&#x9;defer response.Body.Close()&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run custom_error.go&#xA;Invalid URL : Get &#34;htt://meetgor.com&#34;: unsupported protocol scheme &#34;htt&#34;&#xA;&#xA;```&#xA;When the URL is invalid, we will call the custom error interface by parsing the default `err.Error` method. This will get us the error object from the main method to our custom interface. That is how we will be able to fetch additional information about the error from the interface with the `.` operator as `e.message`. So, the syntax is `Invalid_URL_Error{err.Error()}`, i.e. an object of type `Invalid_URL_Error` with the message set as the value returned from the default `Error()` function. hence we can implement the custom error message.&#xA;&#xA;We also need to look for the response object and close the Response Body as it is mandatory to do so and the responsibility of the caller.&#xA;&#xA;### Creating a function that returns two values (ok,error)&#xA;&#xA;We can even nest the calling of this error method inside another function. This will give us a good overview of how to deal with errors more thoroughly. We will construct a function with two return values one can be any normal desirable object (which we want from the function call) and the other as an error. This will check for any cases that we can call the custom error and return that error interface and the object which was to be returned will be nil if there is an error. If there are no errors, we will return the object and set the error as nil. This way, we can use the `ok, error` syntax while calling this function and thereby make it a lot easier in case of complex programs or multiple types of errors.&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type Invalid_URL_Error struct {&#xA;&#x9;message string&#xA;}&#xA;&#xA;func (e Invalid_URL_Error) Error() string {&#xA;&#x9;return &#34;Invalid URL&#34;&#xA;}&#xA;&#xA;func get_resp(url_link string) (http.Response, error) {&#xA;&#xA;&#x9;resp, err := http.Get(url_link)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return http.Response{}, &amp;Invalid_URL_Error{}&#xA;&#x9;} else {&#xA;&#x9;&#x9;defer resp.Body.Close()&#xA;&#x9;&#x9;return *resp, nil&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;url := &#34;htts://meetgor.com&#34;&#xA;&#x9;resp, err := get_resp(url)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(resp)&#xA;&#x9;}&#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run errors.go&#xA;Invalid URL&#xA;```&#xA;&#xA;This is the simple function `get_resp` which will either fetch the `Response` or `error`. We call the `http.Get` method internally in the function and if something is invalid, it will return an empty Response but the error will be an `Invalid_URL_Error` object which is the custom error class. This means, that if we have an error, we will return a string object from the `Error` method in the interface and if there is no error, we will return the `Response` object and the error will be set as `nil`. Hence, you can now realize, why we check for `err != nil`, it is used for checking if an error object has returned a string or not. As said earlier, we also need to close the request Body.&#xA;&#xA;Further, we can pass the default error method to the custom error class as `Invalid_URL_Error{err.Error()}`. This will ensure, we get additional context from the custom error interface.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;net/http&#34;&#xA;)&#xA;&#xA;type Invalid_URL_Error struct {&#xA;&#x9;message string&#xA;}&#xA;&#xA;func (e Invalid_URL_Error) Error() string {&#xA;&#x9;return &#34;Invalid URL : &#34; + e.message&#xA;}&#xA;&#xA;func get_resp(url_link string) (http.Response, error) {&#xA;&#xA;&#x9;resp, err := http.Get(url_link)&#xA;&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return http.Response{}, &amp;Invalid_URL_Error{err.Error()}&#xA;&#x9;} else {&#xA;&#x9;&#x9;defer resp.Body.Close()&#xA;&#x9;&#x9;return *resp, nil&#xA;&#x9;}&#xA;&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;url := &#34;htts://meetgor.com&#34;&#xA;&#x9;resp, err := get_resp(url)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(resp)&#xA;&#x9;}&#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run custom_error&#xA;Invalid URL : Get &#34;htts://meetgor.com&#34;: unsupported protocol scheme &#34;htts&#34;&#xA;```&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/error-handling/main.go) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;From this article, we were able to understand the basics of error handling in golang. We can now work with handling errors in function calls and create custom error interfaces. Thank you for reading, if you have any queries, feedback, or questions, you can freely ask me on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Interfaces</title>
      <link>meetgor.com/golang-interfaces</link>
      <description>Understanding the baiscs of interfaces in Golang. Exploring the concept of polymorphism in golang with the help of interfaces and structs.</description>
      <pubDate>Sat, 10 Sep 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the 19th post of the series, we will be taking a look into interfaces in golang. Interfaces allow us to create function signatures common to different structs or types. So, we can allow multiple structs to have a common interface(method) that can have different implementations.&#xA;&#xA;## What are Interfaces&#xA;&#xA;Interface as the name suggests is a way to create methods that are common to different structures or types but can have different implementations. It&#39;s an interface to define the method or function signatures but not the implementation. Let&#39;s take an example of `Laptop` and `Phone` having the functionality of wifi. We can connect to wifi more or the less in a similar way on both devices. The implementation behind the functionality might be different but they share the same operation. The WiFi can act as an interface for both devices to connect to the internet.&#xA;&#xA;## Define an Interface&#xA;&#xA;To declare an interface in golang, we can use the `interface` keyword in golang. An interface is created with the type keyword, providing the name of the interface and defining the function declaration. Inside the interface which acts as a struct of general method signatures. The method signatures usually consist of the name of the function with its parameters if any and the return type of the function.&#xA;&#xA;```go&#xA;&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;&#xA;type Player struct {&#xA;&#x9;name   string&#xA;&#x9;health int&#xA;}&#xA;&#xA;type Mob struct {&#xA;&#x9;name     string&#xA;&#x9;health   int&#xA;&#x9;is_passive bool&#xA;}&#xA;&#xA;type Creature interface {&#xA;&#x9;intro() string&#xA;&#x9;//attack() int&#xA;&#x9;//heal() int&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;player := Player{name: &#34;Steve&#34;}&#xA;&#x9;mob := Mob{name: &#34;Zombie&#34;}&#xA;&#x9;fmt.Println(player)&#xA;&#x9;fmt.Println(mob)&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run main.go&#xA;&#xA;{Steve 0}&#xA;{Zombie 0 false}&#xA;```&#xA;&#xA;In this above example, we have created an interface called `Creature`. There are a few structs that we have to define like `Player` and `Mob`, these two methods have a few attributes like `name` as `string` and `health` as `int` which are common in both structs but the `Mob` struct has an additional attribute `is_passive` as a `boolean` value. The `Creature` is an interface that will define certain function signatures, here we have declared `intro`, `attack`, and `heal` as the methods bound to the Creature interface. This means, that any object which satisfies the Creature interface, can define the methods associated with the interface.&#xA;&#xA;## Defining Interfaces&#xA;&#xA;Once we have declared the interface method signatures, we can move into defining the functionality of these methods depending on the struct. If we want a different working method for different types of struct objects passed we can define those for each type of struct that we want. Here, we have two types of structs namely `Creature` and `Mob`, based on the struct we can define the `intro` method for them individually.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type Creature interface {&#xA;&#x9;intro() string&#xA;&#x9;attack(*int) int&#xA;}&#xA;&#xA;type Player struct {&#xA;&#x9;name   string&#xA;&#x9;health int&#xA;}&#xA;&#xA;type Mob struct {&#xA;&#x9;name     string&#xA;&#x9;health   int&#xA;&#x9;category bool&#xA;}&#xA;&#xA;func (p Player) intro() string {&#xA;&#x9;fmt.Println(&#34;Player has spawned&#34;)&#xA;&#x9;return p.name&#xA;}&#xA;&#xA;func (p Player) attack(m_health *int) int {&#xA;&#x9;fmt.Println(&#34;Player has attacked!&#34;)&#xA;&#x9;*m_health = *m_health - 50&#xA;&#x9;return *m_health&#xA;}&#xA;&#xA;func (m Mob) intro() string {&#xA;&#x9;fmt.Printf(&#34;A wild %s has appeared!&#xA;&#34;, m.name)&#xA;&#x9;return m.name&#xA;}&#xA;func (m Mob) attack(p_health *int) int {&#xA;&#x9;fmt.Printf(&#34;%s has attacked you! -%d&#xA;&#34;, m.name, 30)&#xA;&#x9;*p_health = *p_health - 30&#xA;&#x9;return *p_health&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;player := Player{name: &#34;Steve&#34;, health: 100}&#xA;&#x9;mob := Mob{name: &#34;Zombie&#34;, health: 140}&#xA;&#x9;fmt.Println(player.intro())&#xA;&#x9;fmt.Println(mob.intro())&#xA;&#x9;fmt.Println(mob)&#xA;&#x9;fmt.Println(player)&#xA;&#x9;fmt.Println(player.attack(&amp;mob.health))&#xA;&#x9;fmt.Println(mob.attack(&amp;player.health))&#xA;&#x9;fmt.Println(mob)&#xA;&#x9;fmt.Println(player)&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run main.go&#xA;&#xA;Player has spawned&#xA;Steve&#xA;A wild Zombie has appeared!&#xA;Zombie&#xA;{Zombie 140 false}&#xA;{Steve 100}&#xA;Player has attacked!&#xA;90&#xA;Zombie has attacked you! -30&#xA;70&#xA;{Zombie 90 false}&#xA;{Steve 70}&#xA;```&#xA;&#xA;As we can see, the method `intro()` is bound to both the struct depending on what struct signature is associated with the method. The method `intro` takes in the object struct associated as per the call and returns `string` as defined in the method signature. &#xA;&#xA;The `attack` method in the `Creature` interface is also implemented separately for the two structs. For the `Player` method, we simply take in a pointer to an integer and return an `int`. The parameter is the pointer to the mob health, and it returns the modified health. We take in a pointer to the mob or player health so as to parse in the actual value and not the copy of the value. If we modify the value, we want to reflect those changes in the actual object. So that is how we can use interfaces to construct dynamic operations on objects as well as different types of structs.&#xA;&#xA;We have seen a simple example of how to declare and define interfaces for given type structs. Also, we can pass by value as well as by pointers so as to define the behavior of the method whether to dynamically modify or change the values of the object associated with it.&#xA;&#xA;## Examples of Interfaces&#xA;&#xA;There are quite some use cases of interfaces, in object-oriented programming, the above example fits the polymorphism feature quite well. The ability to reuse certain method signatures and define the functions as per requirement brings flexibility to the code structure.&#xA;&#xA;We will see a few examples for understanding how we can use interfaces in various ways.&#xA;&#xA;### Type Switch Interface&#xA;&#xA;We can use an empty interface to check for the type of variable we have parsed. Using this empty interface we can create a kind of dynamic parameter to a function.  &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;strconv&#34;&#xA;)&#xA;&#xA;func parse_int(n interface{}) int {&#xA;&#x9;switch n.(type) {&#xA;&#x9;case int:&#xA;&#x9;&#x9;return (n).(int) * (n).(int)&#xA;&#x9;case string:&#xA;&#x9;&#x9;s, _ := strconv.Atoi(n.(string))&#xA;&#x9;&#x9;return s&#xA;&#x9;case float64:&#xA;&#x9;&#x9;return int(n.(float64))&#xA;&#x9;default:&#xA;&#x9;&#x9;return n.(int)&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;num := parse_int(4)&#xA;&#x9;fmt.Println(num)&#xA;&#x9;num = parse_int(&#34;4&#34;)&#xA;&#x9;fmt.Println(num)&#xA;&#x9;num = parse_int(4.1243)&#xA;&#x9;fmt.Println(num)&#xA;}&#xA;&#xA;```&#xA;&#xA;```&#xA;go run main.go&#xA;&#xA;16&#xA;4&#xA;4&#xA;```&#xA;&#xA;Here, we can see we have an interface as a parameter to the function `parse_int`, the return type is `int`, so the incoming parameter can be any valid type. But if we don&#39;t convert the given type into an appropriate int, it will result in an error as we are returning the int value of the parsed parameter. We are taking the parameter as `interface{}` which is an empty interface, this will contain the parameter parsed as an interface type. That&#39;s why we need to convert the interface object into an int or the parsed type of the interface.&#xA;&#xA;### Interface Slice&#xA;&#xA;We can even create a slice of interfaces, which means we can initialize or group together various objects of different structs in a single slice. This might be helpful for calling functions associated with different objects via the interface very easily and in a much cleaner way.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type Creature interface {&#xA;&#x9;intro() string&#xA;}&#xA;&#xA;type Player struct {&#xA;&#x9;name   string&#xA;&#x9;health int&#xA;}&#xA;&#xA;type Mob struct {&#xA;&#x9;name     string&#xA;&#x9;health   int&#xA;&#x9;category bool&#xA;}&#xA;&#xA;func (p Player) intro() string {&#xA;&#x9;fmt.Println(&#34;Player has spawned&#34;)&#xA;&#x9;return p.name&#xA;}&#xA;&#xA;func (m Mob) intro() string {&#xA;&#x9;var name string&#xA;&#x9;if m.name != &#34;&#34; {&#xA;&#x9;&#x9;name = m.name&#xA;&#x9;} else {&#xA;&#x9;&#x9;name = &#34;Mob&#34;&#xA;&#x9;}&#xA;&#x9;fmt.Printf(&#34;A wild %s has appeared!&#xA;&#34;, name)&#xA;&#x9;return m.name&#xA;}&#xA;&#xA;&#xA;func main() {&#xA;&#x9;entity := []Creature{Player{}, Mob{}, Mob{}, Player{}}&#xA;&#xA;&#x9;for _, obj := range entity {&#xA;&#x9;&#x9;fmt.Println(obj.intro())&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;Player has spawned&#xA;A wild Zombie has appeared!&#xA;A wild Zombie has appeared!&#xA;Player has spawned&#xA;```&#xA;&#xA;In the above example, we can see that the entity variable is created as a slice of interfaces `Creature`, i.e. various objects associated with the `Creature` interface can be contained in a single slice. There are 2 instances of Player and Mob each in the slice. We can further iterate over the slice as a range-based loop and thereby the functions associated with the interfaces can be called. Here, we have called the `intro` function.&#xA;&#xA;So, there are a lot of things that can be done with interfaces, we can create multiple interfaces for a single object struct and nest interfaces. Based on the use case of the program, interfaces can be used to reduce the boilerplate code as well as improve the readability of the code.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/interfaces/main.go) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;From this part of the series, we were able to understand the basics of interfaces using a few examples. We explored how interfaces can be used to bring in polymorphism in golang, also we can improve the readability of the code. The boilerplate code can be considerably reduced by using interfaces when dealing with structs and types. Hopefully, you found this post helpful and understood even the basics of interfaces in golang. Thank you for reading, if you have any queries, questions, or feedback, you can ping me on my social handles or in the comments. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Closures</title>
      <link>meetgor.com/golang-closures</link>
      <description>Understanding the baiscs of closures in Golang. Creating some simple examples for exploring the concept of closures with Golang.</description>
      <pubDate>Thu, 11 Aug 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the previous part of the series, we covered [anonymous functions](https://meetgor.com/golang-anonymous-functions/) and in this section, we will look into `closures` which are quite a cool concept for various things. Closures are basically a function that returns a function instead of a value, so basically we will leverage anonymous functions for creating closures.&#xA;&#xA;## Simple Closures&#xA;&#xA;A simple closure can be constructed for understanding how we can use closures in golang. We will return a function from a function, that is a simple closure. So, in the below code example, we have created a function `gophy()` which takes no parameters but returns a function that returns a `string`.  The function simply returns an anonymous function that returns a string.&#xA;&#xA;We will initialize the variable `g` that is assigned to the function `gophy` which will simply return a function call. We are not calling the function simply returning the call to the function `gophy` that has the return value as the anonymous function. We will simply have the function in the variable `g` rather than the simple value string. So we will have to call the `g` variable for actually returning the string.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func gophy() func() string{&#xA;  return func() string{&#xA;    return &#34;Hello, Gophers!&#34;&#xA;  }&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;&#x9;// using clousure/anonymous function to return a value&#xA;&#x9;// that value can be assigned to the variable&#xA;&#x9;g := gophy()&#xA;&#x9;fmt.Println(g())&#xA;}&#xA;&#xA;```&#xA;&#xA;```&#xA;$ go run simple.go&#xA;Hello, Gophers!&#xA;&#xA;```&#xA;&#xA;So, that is how we can call the function `g` that will return a string, so we have the function body stored in the variable `g`. We can call it as many times as we want.&#xA;&#xA;## Variable Scope in Closures&#xA;&#xA;We can even use variables that will remain in the function scope once it is initialized. So, let’s say we have a function that will increment the counter, but if we want to keep the counter the same throughout the program, we might have to use a global variable so as to maintain the context, but with closures, we will retain the value once we have initialized the function call.&#xA;&#xA;In the below example, we are creating the function `incrementer` that is a closure with int as the return type. We are initializing the variable `counter` that will be acting as the counter in the program, the function returns an anonymous function that will increment the counter and return it.&#xA;&#xA;Here, when we create an instance of the `increment` function it basically initializes the `counter` to `0` and returns the anonymous function as a call. Now, `c` will act as a function that has the counter variable bound to it and we can call `c` that will, in turn, call the anonymous function keeping the scope of the `counter` variable.  So, each time we call the function `c` it will increment the counter and thus we keep the counter inside the scope of the function `incrementer` in the `c` variable.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func inrementer() func() int{&#xA;  counter := 0&#xA;  return func() int{&#xA;    counter += 1&#xA;    return counter&#xA;  }&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;  c := inrementer()&#xA;&#xA;  fmt.Println(c())&#xA;  fmt.Println(c())&#xA;  fmt.Println(c())&#xA;  fmt.Println(c())&#xA;  fmt.Println(c())&#xA;&#xA;}&#xA;&#xA;```&#xA;&#xA;```&#xA;$go run simple.go&#xA;1&#xA;2&#xA;3&#xA;4&#xA;5&#xA;&#xA;```&#xA;&#xA;If we want to extend the functionality,  we can even assign the function call `c()` to a variable and access the returned value which will be the current state of the counter.&#xA;&#xA;We can even use different scope or closures tied to a particular function, that is we can bind data to a different instances of a closure.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func inrementer() func() int{&#xA;  counter := 0&#xA;  return func() int{&#xA;    counter += 1&#xA;    return counter&#xA;  }&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;  c1 := inrementer()&#xA;&#xA;  fmt.Println(c1())&#xA;  fmt.Println(c1())&#xA;  fmt.Println(c1())&#xA;&#xA;  c2 := inrementer()&#xA;&#xA;  fmt.Println(c2())&#xA;  fmt.Println(c2())&#xA;  fmt.Println(c2())&#xA;  fmt.Println(c2())&#xA;&#xA;}&#xA;&#xA;```&#xA;&#xA;```&#xA;$go run simple.go&#xA;1&#xA;2&#xA;3&#xA;1&#xA;2&#xA;3&#xA;4&#xA;&#xA;```&#xA;&#xA;Here we have `c1` and `c2` forming different closures and thereby we can have different scopes of the variables associated with it. The variable is bound to the instance it which was initialized, so we can see the different closure instances having different values.&#xA;&#xA;## Factorial of a function with Closures&#xA;&#xA;We can create some interesting programs with closures, we will implement the calculation of factorial with closures in golang.&#xA;&#xA;This will be a `factorial` function that returns an anonymous function with the return type as `int`. The function will initialize the variable `fact` which will store the actual factorial value and `n` as the initial number for calculating the factorial of it.&#xA;&#xA;Inside the anonymous function, we will calculate the factorial and increment the number and simply return the factorial value from the function. The `fact` variable will contain the factorial of the number n, so here we can leverage the use of closures as we will maintain the state of the variable `fact` and `n` from the previous calls or the initialization of the function.&#xA;&#xA;Inside the `main` function, we have created the `f` variable and called the `factorial` function, so that will initialize the `fact` and `n` of the variable and thereby returning the anonymous function call. Now we can call the variable `f` as many times as we want that will simply return the factorial of the number incremented each time we call the function.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func factorial() func() int{&#xA;&#x9;fact, n := 1, 1&#xA;&#x9;return func() int{&#xA;    fact = fact * n&#xA;    n += 1&#xA;&#x9;&#x9;return fact&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;  f := factorial()&#xA;  fmt.Println(f())&#xA;  fmt.Println(f())&#xA;  fmt.Println(f())&#xA;  fmt.Println(f())&#xA;  fmt.Println(f())&#xA;&#xA;}&#xA;&#xA;```&#xA;&#xA;```&#xA;$ go run simple.go&#xA;1&#xA;2&#xA;6&#xA;24&#xA;120&#xA;&#xA;```&#xA;&#xA;So, we can see that the factorial is getting printed for each call and the number is being incremented at each call.&#xA;&#xA;So that&#39;s the basics of closures in golang, we can use closures to keep the content secured and encapsulated from different function calls. We can bind data with closures, with the help of anonymous functions a closure can be constructed and data can be bound to a particular function called scope.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/closures/main.go) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;From this post, we could understand the fundamentals of closures in golang. The basic concept of closures in golang was understood with a few examples. Thank you for reading, if you have any queries or feedback please leave them in the comments or on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Anonymous Functions</title>
      <link>meetgor.com/golang-anonymous-functions</link>
      <description>Understanding the concept of the Anonymous functions in golang</description>
      <pubDate>Sun, 24 Jul 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;We have looked at the defer keyword in golang in the [previous](https://www.meetgor.com/golang-defer/) part of the series, in this section, we will understand how we can use anonymous functions in golang. We will explore how to declare and use anonymous functions with a few examples.&#xA;&#xA;## What are Anonymous Functions&#xA;&#xA;Anonymous functions are quite simple to understand, we don&#39;t define a function, we declare it and call it instantly. An anonymous function doesn&#39;t have a name so hence it is called an anonymous function. As a normal function it can take in parameters and return values. With anonymous functions, we can bind the operations to a variable or a constant as a literal(value). If an anonymous function takes in a parameter, it needs to be parsed immediately after the end of the function body. We will see how we define the syntax and specifications of the anonymous functions in golang. &#xA;&#xA;## Simple Anonymous functions&#xA;&#xA;To create a simple anonymous function we use the same function syntax without giving it a name like `func() {}`, inside the function body i.e. `{}`, you can define the operations that need to be performed. &#xA;&#xA;Here, we have created an anonymous function that simply calls the `fmt.Println` function with a string. So, we have made things a little too much as we can even directly call the `fmt.Println` function from the main function, instead we have called an anonymous function that in turn calls the `fmt.Println` function. It might not make sense to use an anonymous function here, but it can be helpful for other complex tasks that you want to isolate the logic without creating a dedicated function for the process.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;  func() {&#xA;    fmt.Println(&#34;Hello, Anonymous functions&#34;)&#xA;  }()&#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run anonymous_function.go&#xA;&#xA;Hello, Anonymous functions&#xA;```&#xA;&#xA;So, this is how we create a basic anonymous function in golang, this can be further used for returning values from the function or passing parameters into the function and also assigning the function call to a variable or a constant.&#xA;&#xA;## Assigning anonymous function to variables&#xA;&#xA;We can assign the call to the anonymous function to a variable or a constant and call the function as many times as we require. So, we can basically store the function logic in a variable and call it whenever we require the function with the `()` parenthesis as an indication to call the function.&#xA;&#xA;In the following example, we have used the variable `draw` to store the function call which prints `Drawing` with the help of the `fmt.Println` function. The draw variable now contains the function and not its value. So be careful here, the anonymous function which we have defined as the `draw` variable&#39;s literal value, it&#39;s like we are giving a name to this anonymous function and the name will be the variable name so we have created the function `draw` which is an anonymous function stored in a variable.&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;  draw := func() {&#xA;    fmt.Println(&#34;Drawing&#34;)&#xA;  }&#xA;  draw()&#xA;  draw()&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run anonymous_function.go&#xA;&#xA;Drawing&#xA;Drawing&#xA;```&#xA;&#xA;We see that we call the variable `draw` as a function call by appending `()` parenthesis to it as `draw()` this thereby calls the anonymous function stored inside the variable value.&#xA;&#xA;The main thing to note here is that we are not adding `()` at the time of declaring the anonymous function, as it will call the function directly. The problem then will arise because the function is not returning anything so we can&#39;t assign it to a variable.&#xA;&#xA;```go&#xA;draw := func() {&#xA;  fmt.Println(&#34;Drawing&#34;)&#xA;}()&#xA;```&#xA;&#xA;```&#xA;functions/anonymous_functions.go:10:11: func() {…}() (no value) used as value&#xA;```&#xA;&#xA;So, we are trying to assign a variable to a function call that has no return value. This has no value, not even nil, so we get an error for assigning a variable to nothing.&#xA;&#xA;Though if you had a return value from the function, we can directly assign the function call to the variable as it has returned a valid value defined in the function literal.&#xA;&#xA;## Parsing parameters&#xA;&#xA;We can even parse parameters to the anonymous functions as any other normal function. We define the name of the variable followed by the type of the variable in the parenthesis to use these parameters inside the anonymous function.&#xA;&#xA;We need to keep in mind that these function parameters can either be passed with the variable call or directly at the time of defining the function.&#xA;&#xA;In the below example, we have created a variable `call` and are assigning it to an anonymous function that takes in a parameter `name` which is a `string`, and prints some text to the console. So, we call the funciton `call` with a parameter as a string, as we have `&#34;Meet&#34;` and `person := &#34;Chris&#34;` as a string passed to the `call` function.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;  call := func(name string) {&#xA;    fmt.Println(&#34;Calling,&#34;, name)&#xA;  }&#xA;&#xA;  call(&#34;Meet&#34;)&#xA;  person := &#34;Chris&#34;&#xA;  call(person)&#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run anonymous_function.go&#xA;&#xA;Calling, Meet&#xA;Calling, Chris&#xA;```&#xA;&#xA;Here, we can see that the function `call` prints the text that we have defined to call the `fmt.Println` function. We parse the function with the string literal as the anonymous function takes a parameter in the form of a string. We can parse multiple parameters to the anonymous function as we can with the normal function like slices, maps, arrays, struct, etc.&#xA;&#xA;## Returning values&#xA;&#xA;We can even return values from the anonymous function if we want to instantly call the function and save the `returned` value in the variable. We can return single or multiple values as per our requirements just like any normal function in golang.&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;  is_divisible := func(x int, y int) bool{&#xA;    var res bool &#xA;    if x % y == 0 {&#xA;      res = true&#xA;    } else{&#xA;      res = false&#xA;    }&#xA;    fmt.Println(res)&#xA;    return res&#xA;  }&#xA;&#xA;  fmt.Printf(&#34;%T&#xA;&#34;, is_divisible)&#xA;  is_divisible(10, 5)&#xA;  is_divisible(33, 5)&#xA;&#xA;  divisblity_check := is_divisible(45, 5)&#xA;  fmt.Printf(&#34;%T : %t&#xA;&#34;, divisblity_check, divisblity_check) &#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run anonymous_function.go&#xA;&#xA;func(int, int) bool &#xA;true&#xA;false&#xA;bool : true&#xA;```&#xA;&#xA;As we can see the function has returned a boolean value and we store it in a variable `divisblity_check`, the variable which contains the function i.e. `is_divisible` can then be called, and thereby we get the returned value in the variable as a boolean as we print the type and the value of the variable `divisblity_check`. We also can see that the type of the variable `is_divisible` is of type function literal which takes `int, int` and has a return value as `bool`.&#xA;&#xA;We can also do one more interesting here, which we were restricted previously in the above examples. We can directly call the function and store it as a value rather than the function itself. So, we can only use the value returned from the function but can&#39;t call the function later.&#xA;&#xA;```go&#xA;is_divisible := func(x int, y int) bool{&#xA;  var res bool &#xA;  if x % y == 0 {&#xA;    res = true&#xA;  } else{&#xA;    res = false&#xA;  }&#xA;  fmt.Println(res)&#xA;  return res&#xA;}(13, 4)&#xA;&#xA;fmt.Printf(&#34;%T&#xA;&#34;, is_divisible)&#xA;fmt.Printf(is_divisible) &#xA;```&#xA;&#xA;```&#xA;go run anonymous_function.go&#xA;&#xA;bool&#xA;false&#xA;```&#xA;&#xA;So, in the above-modified example, we have passed in the parameter instead of a callable function. This will store the returned value of the function call. So, we will store the boolean value in the `is_divisible` and we will have to pass the integer values to the function which we have parsed as `(13, 4)` to the anonymous function call.&#xA;&#xA;&#xA;In the below example, we have created an anonymous function that takes in three parameters like `(string, int, string)` and returns a string. We have used `fmt.Sprintf` function to format the variable and store it in a variable, we then return the string. This anonymous function is then directly called and we store the returned value instead of the function.&#xA;&#xA;So, in this example, the `format_email` variable will store a string instead of acting it as a function as a callable object.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;  format_email := func(name string, age int, company string) string{&#xA;    email := fmt.Sprintf(&#34;%s.%d@%s.com&#34;, name, age, company)&#xA;    return email&#xA;  }(&#34;john&#34;, 25, &#34;gophersoft&#34;)&#xA;&#xA;  fmt.Println(format_email)&#xA;  fmt.Printf(&#34;%T&#xA;&#34;,format_email)&#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run anonymous_function.go&#xA;&#xA;john.25@gophersoft.com   &#xA;string&#xA;```&#xA;&#xA;As we can see the `format_email` variable only returns a string instead of a callable object. We have directly parsed the parameters to the anonymous function and hence it instantly calls it and we return the string.&#xA;&#xA;## Passing Anonymous function to function parameters&#xA;&#xA;We can even pass an anonymous function to a parameter to a function. This can be quite helpful for writing some simple logic inside a complex script. We can pass the function type as a parameter to the parameter and theere we can parse the actual data and perform the desired operation.&#xA;&#xA;The below example is a bit of code to write but makes a lot of sense to understand anonymous functions in golang. The function `get_csv` is a function which takes in three parameters `int, string, func(string)[] string`. The third parameter is a function literal that takes in a string and returns a slice of string. So, we are basically converting a string `&#34;kevin,21,john,33&#34;` into a slice of the slice like `[[kevin 21] [john 33]]`, this is basically separating values with `,` comma as the delimiter and then processing slices to create a single slice.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;import &#34;strings&#34;&#xA;&#xA;func get_csv(index int, str string, t func(csv string)[]string) [][]string{&#xA;  s := t(str)&#xA;  var res [][]string&#xA;  for i := 1; i&lt;len(s); i+=2 {&#xA;    var data []string&#xA;    data = append(data, s[i-1], s[i])&#xA;    res = append(res, data)&#xA;  }&#xA;  return res&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;  csv_slice := func (csv string) []string{&#xA;    return strings.Split(csv, &#34;,&#34;)&#xA;  }&#xA;  csv_data := get_csv(2,&#34;kevin,21,john,33,george,24&#34;, csv_slice)&#xA;  fmt.Println(csv_data)&#xA;  for _, s := range csv_data{&#xA;    fmt.Printf(&#34;%s - %s&#xA;&#34;,s[0],s[1])&#xA;  }&#xA;```&#xA;&#xA;```&#xA;go run functions/anonymous_function.go&#xA;&#xA;[[kevin 21] [john 33] [george 24]]&#xA;&#xA;kevin - 21&#xA;john - 33&#xA;george - 24&#xA;```&#xA;&#xA;Let&#39;s break down the code one by one, we will start with the main function, where we have `csv_slice` as a function literal and is an anonymous function that takes in a string and returns a slice of string. The function returns a call to the function [strings.Split](https://pkg.go.dev/strings#Split) taking in the string from the function parameter. We then call the function `get_csv` with parameters `(2, &#34;kevin,21....&#34;, csv_slice)`, this function is defined outside the main. The function takes in three parameters as discussed and parsed from the main function and it returns a slice of type string. &#xA;&#xA;So, inside the `get_csv` function, we define `s` as the function call to `t(str)` which if you look carefully is a function call to `csv_slice` with parameter as a string. This function call returns a slice of strings separated by `,`. So that&#39;s all the logic we need to understand anonymous function from parameters. We have used a function literal to call the function from another function. In this case, the funciton is an anonymous function assigned to a variable. &#xA;&#xA;```&#xA;&#34;kevin,21,john,33,george,24&#34;&#xA;            ||&#xA;            \/&#xA;[kevin 21 john 33 george 24]&#xA;            ||&#xA;            \/&#xA;[[kevin 21] [john 33] [george 24]]&#xA;&#xA;```&#xA;&#xA;Further, after we have `s` which would look like `[kevin 21 john 33 george 24]` as each individual element. Thereafter we create an empty [slice of slice](https://www.geeksforgeeks.org/slice-of-slices-in-golang/) string as `res` and operate a loop through the slice jumping 2 indexes at a time. Why? because we want a slice of two elements combined. So, we also create a slice of string named `data` and we add the two components to it like `[kevin 21]` with the [append](https://pkg.go.dev/builtin#append) function, and this slice is appended to a slice of slices `res` as `[[kevin 21]]` thereby iterating over the entire slice and creating the desired slice data. We return the `res` from the function. This get&#39;s us back to the main function which simply iterates over the slice and we get the desired data from it.&#xA;&#xA;So, this is how we convert an extremely easy task to extremely complicated code :)&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/functions/anonymous_function.go) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;That is it from this part, we covered a little bit about anonymous functions in golang. Anonymous functions are simply function literals that can be used to do a lot of quick operations without needing to write an explicit function in the program. Further, in the next part look into closures which are a bit complex to understand and require the understanding of anonymous functions.&#xA;&#xA;Thank you for reading, if you have any queries, feedback, or questions, you can freely ask me on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Defer</title>
      <link>meetgor.com/golang-defer</link>
      <description>Understanding the concpet of the defer keyword in golang</description>
      <pubDate>Wed, 29 Jun 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In this part of the series, we will be taking a look at the `defer` keyword in golang. The defer keyword is used for delaying the function call in a particular block of program(function or a loop).&#xA;&#xA;## Defer Keyword&#xA;&#xA;The `defer` keyword is an interesting keyword in golang, it basically holds up the execution of the statement until all the statements around the local scope has been executed. It is basically like a stack holding the execution of statements. You can have multiple defer keywords in the single code block(function or a loop), those will be called by the principle of **first in last out**. &#xA;&#xA;So, let&#39;s take a simple example, the syntax is quite simple just add `defer` before the statement you want to hold up.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(&#34;First&#34;)&#xA;&#x9;defer fmt.Println(&#34;Second Ahhh..&#34;)&#xA;&#x9;fmt.Println(&#34;Third&#34;)&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run defer.go                                                                                                               &#xA;&#xA;First&#xA;Third&#xA;Second Ahhh..&#xA;```&#xA;&#xA;As, you can see the function call `Second` was executed at the end of all the function calls in the main function. This is because of the defer keyword. It will halt or postpone the calling of a statement/function before all the statements have bee executed in the local scope. This keyword can be stacked for calling different statements at the specific time in the state of the program.&#xA;&#xA;### Multiple defer keyword&#xA;&#xA;We can understand the `defer` keyword in a better way if we modify the previous example a bit. We will use multiple defer statements in it for understanding the flow of the program.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(&#34;bag&#34;)&#xA;&#x9;defer fmt.Println(&#34;book&#34;)&#xA;&#x9;defer fmt.Println(&#34;cap&#34;)&#xA;&#x9;fmt.Println(&#34;laptop&#34;)&#xA;&#x9;defer fmt.Println(&#34;wallet&#34;)&#xA;&#x9;fmt.Println(&#34;headphones&#34;)&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run defer.go                                                                                                            &#xA;&#xA;bag&#xA;laptop&#xA;headphones&#xA;wallet&#xA;cap&#xA;book&#xA;```&#xA;&#xA;   Here, we can see that the `bag` is printed out first, then `laptop` and then `headphones`, but after these, we have maintained a stack for calling out the defer statements. &#xA;&#xA;Initially, consider a empty stack `[]` for storing defer statements. Firstly, the `bag` statement will be printed. After printing the `bag` keyword, there is a defer key word, so we add the statement to the stack `[&#34;book&#34;]`. Just for convenience, ignore the function syntax and the actual statements, just focus on what is printed when. So, we have printed `bag` and we have stack as `[&#34;book&#34;,]`. We again encounter a `defer` keyword, so we push the statement `cap` into the stack `[&#34;book&#34;, &#34;cap&#34;,]`. Further, we encounter the normal statement, so we print `&#34;laptop&#34;`. Next up, we encounter a defer keyword and thereby we push `&#34;wallet&#34;` into the stack, which then becomes `[&#34;book&#34;, &#34;cap&#34;, &#34;wallet&#34;]`. The last statement in the main function is `&#34;headphones&#34;`, so we print `&#34;headphones&#34;` with the `Println` function. Since, there are no further statements to execute in the main function, we start poping out the function calls from the stack. Remember last in first out, so we will print the statement which were pushed last into the stack. Since the stack is `[&#34;book&#34;, &#34;cap&#34;, &#34;wallet&#34;]`, so we will pop out `&#34;wallet&#34;` from the stack since we have pushed it last in the stack. Thereby we print `&#34;wallet&#34;` after `&#34;headphones&#34;` and the stack now becomes `[&#34;book&#34;, &#34;cap&#34;]`. Next, we have to pop out the second last element that we pushed into the stack which was `&#34;cap&#34;`, thus we print `&#34;cap&#34;`. The stack only has one element in the stack and we pop out that as well which is `&#34;book&#34;`. So, this is how the defer keyword stacks up in golang.&#xA;&#xA;**NOTE: The defer keyword calls functions after the execution of all other functions in it&#39;s scope but the parameters are evaluated before handed which means just the function is executed later, but the parameters are already loaded**&#xA;&#xA;### defer keyword in function call&#xA;&#xA;The defer keyword is quite similarly used while calling the functions. The `fmt.Println` is also a function, but writing custom functions gives a different feeling to us.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func square(x int) int {&#xA;&#x9;fmt.Println(x * x)&#xA;&#x9;return x * x&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;// defer keyword in function&#xA;&#x9;defer square(12)&#xA;&#x9;defer square(10)&#xA;&#x9;square(15)&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run defer.go                                                                                                            &#xA;&#xA;225&#xA;100&#xA;144&#xA;```&#xA;&#xA;   So, we have created the `square` function and called it thrice and twice we have used the `defer` keyword. The defer keyword first pushes the function call `square(12)` to the stack, so the stack is `[square(12) ]`. Next, we again have the defer keyword, so we push the `square(10)` to the stack which becomes `[square(12) square(10)]`. The next statement is immediately called the function `square(15)` and thereby we end the main function. So, we have to pop the function calls from the stack. The last element `square(10)` is called first and then the only call to the `square(12)`. Thereby, the order of the calling becomes `225 100 144`. &#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/tree/main/scripts/defer/defer.go) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this post, we were able to understand the defer keyword in golang. We were able to explore how we can delay the calling of a function in a particular scope of the program.&#xA;&#xA;Thank you for reading, if you have any queries, feedback, or questions, you can freely ask me on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: String Manipulation</title>
      <link>meetgor.com/golang-strings</link>
      <description>Understanding a few terms and tricks to play with Strings in Golang.</description>
      <pubDate>Tue, 28 Jun 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction &#xA;&#xA;In the 15th post of the Series, we will be looking into the details of the String manipulation and performing types of operations in Golang. We will explore string manipulation, concatenation, helper functions, etc. which will help in working with strings in Golang. &#xA;&#xA;## String Concatenation&#xA;&#xA;String Concatenation refers to the combining and formatting of strings in Golang. We can combine multiple strings and formating the way we display the strings in Golang. We have a few ways and functions to concatenate strings in Golang.&#xA;&#xA;### Using the + operator&#xA;&#xA;We can simply concatenate strings using the `+` operator, though keep in mind you should only concatenate the string with a string and not any other data type like integer, or float, it will throw out errors for mismatched string types.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;)&#xA;func main() {&#xA;    s1 := &#34;Go&#34;&#xA;    s2 := &#34;Programming&#34;&#xA;    s3 := &#34;Language&#34;&#xA;&#xA;    s := s1 + s2 + s3&#xA;    fmt.Println(s)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run concatenate.go&#xA;&#xA;GoProgrammingLanguage&#xA;&#xA;```&#xA;&#xA;The `+` operator will literally join the strings as it is and form a string. &#xA;&#xA;### Using the += operator&#xA;&#xA;The other way to continuously append a string to an existing string, we can use the `+=` operator. This operator will append the provided string to the end of the original string. &#xA;&#xA;```go&#xA;p := &#34;Story&#34;&#xA;p += &#34;Book&#34;&#xA;fmt.Println(p)&#xA;```   &#xA;&#xA;```&#xA;go run concatenate.go&#xA;&#xA;StoryBook&#xA;```&#xA;&#xA;### Using the Join method &#xA;&#xA;The join method is a function available in the string package in Golang. We can join strings elements in a slice or an array using the [Join](https://pkg.go.dev/strings#Join) method in the strings [package](https://pkg.go.dev/strings) in golang. The Join method will combine all the elements in between the elements with a particular string. So, the function takes two parameters `Join(array, string)`, the array or a slice is parsed into the function which will be used to insert the provided string in between the elements of the slice.&#xA;&#xA;#### Join&#xA;&#xA;- Parameters   : array/slice, string&#xA;- Return Value : string&#xA;&#xA;```go&#xA;q := []string{&#34;meetgor.com&#34;, &#34;tags&#34;, &#34;golang&#34;, &#34;string&#34;}&#xA;r := strings.Join(q, &#34;/&#34;)&#xA;fmt.Println(r)&#xA;```   &#xA;&#xA;```&#xA;go run concatenate.go&#xA;&#xA;meetgor.com/tags/golang/string&#xA;```&#xA;&#xA;   In the above example, we use have used the `Join` method to insert a string in between the elements of a slice of strings. The string `&#34;/&#34;` has been inserted in between the elements, and the elements are combined as a single string. So, each individual element starting from the `0` index `meetgor.com` is appended the string `/` and further the next element `tags` have been appended and the procedure caries on till the last element. Note that the string is not inserted after the last element. The function `Join` returns a string and thereby we store the string in a variable.&#xA;&#xA;### Using Sprintf method&#xA;&#xA;We can use the [Sprintf](https://pkg.go.dev/fmt#Sprintf) function from the fmt package to format the string by storing the string rather than printing it to the console. The sprintf function is quite similar to the `Printf` but it only parses strings rather than printing them directly to the console.&#xA;&#xA;```go&#xA;// Using Sprintf function to format strings&#xA;&#xA;name := &#34;peter&#34;&#xA;domain := &#34;telecom&#34;&#xA;service := &#34;ceo&#34;&#xA;&#xA;email := fmt.Sprintf(&#34;%s.%s@%s.com&#34;, service, name, domain)&#xA;fmt.Println(email)&#xA;```   &#xA;&#xA;```&#xA;go run concatenate.go&#xA;&#xA;ceo.peter@telecom.com&#xA;```&#xA;&#xA;The sprintf function basically allows us to concatenate strings in a defined format just like we use `printf` to print formatted strings. In the above example, we have formatted three strings in the form of an email by assigning a placeholder for the string i.e. `%s`, and adding the required characters in the formatted string.&#xA;&#xA;### Using Go string Builder method&#xA;&#xA;The [Builder](https://pkg.go.dev/strings#Builder) type is provided by the strings package in Golang. The Builder type helps in building strings in an efficient way. By creating a string builder object, we can perform operations on a String.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;func main() {&#xA;  // Using Builder function&#xA;&#xA;  c := []string{&#34;j&#34;, &#34;a&#34;, &#34;v&#34;, &#34;a&#34;}&#xA;  var builder strings.Builder&#xA;  for _, item := range c {&#xA;    builder.WriteString(item)&#xA;  }&#xA;  fmt.Println(&#34;builder = &#34;, builder.String())&#xA;  b := []byte{&#39;s&#39;, &#39;c&#39;, &#39;r&#39;, &#39;i&#39;, &#39;p&#39;, &#39;t&#39;}&#xA;  for _, item := range b {&#xA;    builder.WriteByte(item)&#xA;  }&#xA;  fmt.Println(&#34;builder = &#34;, builder.String())&#xA;  builder.WriteRune(&#39;s&#39;)&#xA;  fmt.Println(&#34;builder = &#34;, builder.String())&#xA;  fmt.Println(&#34;builder = &#34;, builder)&#xA;}&#xA;```   &#xA;&#xA;```&#xA;go run concatenate.go&#xA;&#xA;builder =  java&#xA;builder =  javascript&#xA;builder =  javascripts&#xA;builder =  {0xc000088dd8 [106 97 118 97 115 99 114 105 112 116 115]}&#xA;```&#xA;&#xA;   The builder structure provided by the strings package is quite important for working with strings in an efficient manner. Its usually used for string concatenation operations. We can perform write operations to the buffer which is a byte slice.  Here we have created the `builder` variable which is of type `strings.Builder`, further we have appended the string to it in a for a loop. So, we construct a string from the string list elements, they can be even rune slice or byte slice.&#xA;   We have used three methods here, the `WriteString`, `WriteByte`, and `WriteRune` which are quite obliviously used for writing `string`, `byte`, and `rune`to the string builder object.&#xA;   &#xA;&#xA;### Using the Bytes buffer method&#xA;&#xA;The `bytes` package also has something similar to `Builder` type in `string` as [Buffer](https://pkg.go.dev/bytes#Buffer.Bytes). It has almost the same set of methods and properties. The main difference is the efficiency, `strings.Builder` is comparatively faster than the `bytes.Buffer` type due to several low-level implementations. We can discuss those fine details in a separate article but right now we&#39;ll focus on the ways we can utilize this type for string concatenation.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;bytes&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// Using bytes buffer method&#xA;&#xA;&#x9;var buf bytes.Buffer&#xA;&#xA;&#x9;for i := 0; i &lt; 2; i++ {&#xA;&#x9;&#x9;buf.WriteString(&#34;ja&#34;)&#xA;&#x9;}&#xA;&#x9;fmt.Println(buf.String())&#xA;&#xA;&#x9;buf.WriteByte(&#39;r&#39;)&#xA;&#xA;&#x9;fmt.Println(buf.String())&#xA;&#xA;&#x9;k := []rune{&#39;s&#39;, &#39;c&#39;, &#39;r&#39;, &#39;i&#39;, &#39;p&#39;, &#39;t&#39;}&#xA;&#x9;for _, item := range k {&#xA;&#x9;&#x9;buf.WriteRune(item)&#xA;&#x9;}&#xA;&#x9;fmt.Println(buf.String())&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run concatenate.go&#xA;&#xA;jaja&#xA;jajar&#xA;jajarscript&#xA;{[106 97 106 97 114 115 99 114 105 112 116] 0 0}&#xA;```&#xA;&#xA;   So, like for the `strings.Builder` type, we have [WriteString](https://pkg.go.dev/bytes#Buffer.WriteString), [WriteByte](https://pkg.go.dev/bytes#Buffer.WriteByte), and [WriteRune](https://pkg.go.dev/bytes#Buffer.WriteRune) in the `bytes.Buffer` type. We can use it exactly the way we do with the previous example. Also, the `bytes.Buffer` type returns a slice of bytes so we will have to use the [String()](https://pkg.go.dev/strings#Builder.String) method to format it as a string.&#xA;&#xA;   If we look at the [bytes.Buffer](https://go.dev/src/bytes/buffer.go) type, it returns a slice of bytes and two more properties viz. `off` and `lastRead`. These two properties are used for indicating the index of the byte in the buffer and reallocation of the buffer. This is too low-level stuff that can be explored and explained in a separate section. For further readings on the bytes Buffer or String Builder types, you can follow up with these articles: &#xA;&#xA;   - [bytes.Buffer vs strings.Builder](https://medium.com/@felipedutratine/string-concatenation-in-golang-since-1-10-bytes-buffer-vs-strings-builder-2b3081848c45)&#xA;   - [Bytes Buffer](https://syslog.ravelin.com/bytes-buffer-i-thought-you-were-my-friend-4148fd001229)&#xA;   - [Best ways to use bytes.Buffer](https://stackoverflow.com/a/49295215)&#xA;&#xA;&#xA;## String Comparison&#xA;&#xA;Now, we can move into the comparison of Strings in Golang. We have quite a few ways to compare strings in golang. We cover some of them in this section.&#xA;&#xA;### Using Comparison operators&#xA;&#xA;The basic comparison can be done with the comparison operators provided by Golang. Just like we compare numeric data we can compare strings. Though the factor with which we compare them is different. We compare them by the lexical order of the string characters.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;s1 := &#34;gopher&#34;&#xA;&#x9;s2 := &#34;Gopher&#34;&#xA;&#x9;s3 := &#34;gopher&#34;&#xA;&#xA;&#x9;isEqual := s1 == s2&#xA;&#xA;  //&#34;gopher&#34; is not same as &#34;Gopher&#34; and hence `false`&#xA;&#x9;fmt.Printf(&#34;S1 and S2 are Equal? %t &#xA;&#34;, isEqual)&#xA;&#x9;fmt.Println(s1 == s2)&#xA;&#xA;  // &#34;gopher&#34; is not equal to &#34;Gopher&#34; and hence `true`&#xA;&#x9;fmt.Println(s1 != s2)&#xA;&#xA;  // &#34;Gopher&#34; comes first lexicographically than &#34;gopher&#34; so return true &#xA;  // G -&gt; 71 in ASCII and g -&gt; 103&#xA;&#x9;fmt.Println(s2 &lt; s3)&#xA;&#x9;fmt.Println(s2 &lt;= s3)&#xA;&#xA;  // &#34;Gopher&#34; is not greater than &#34;gopher&#34; as `G` comes first in ASCII table&#xA;  // So G value is less than g i.e. 71 &gt; 103 which is false&#xA;&#x9;fmt.Println(s2 &gt; s3)&#xA;&#x9;fmt.Println(s2 &gt;= s3)&#xA;&#xA;}&#xA;```   &#xA;&#xA;```&#xA;go run comparison.go&#xA;&#xA;S1 and S2 are Equal? false &#xA;false&#xA;true&#xA;true&#xA;true&#xA;false&#xA;false&#xA;```&#xA;&#xA;In the above examples, we are able to see the comparison of two strings. There are three strings, two of which are identical, and the third is identical as well but is not equal considering the case of the characters in the string. We have compared the strings in order of the ASCII value of the characters of the strings. For example, A (65) comes before a (97). Similarly, numbers come before letters. So accordingly the comparison of these string characters decides the result.&#xA;&#xA;For the ASCII table, you can take a look over the below image:&#xA;&#xA;![ASCII Table](https://res.cloudinary.com/techstructive-blog/image/upload/v1656423519/blog-media/ascii_table.png)&#xA;&#xA;### Using Compare method&#xA;&#xA;We also have the [Compare](https://res.cloudinary.com/techstructive-blog/image/upload/v1656423519/blog-media/ascii_table.png) method in the strings package for comparing two strings. The comparison method returns an integer value of either -1, 0, or 1. If the two strings are equal, it will return 0. Else if the first string is lexicographically smaller than the second string, it will return -1, else it will return +1.&#xA; &#xA;&#xA;#### strings.Compare &#xA;&#xA;- Return Type: Int (-1, 0, 1)&#xA;- Parameters: string, string&#xA;&#xA;You can check out the [source code](https://go.dev/src/strings/compare.go) for further clarity.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;  &#34;fmt&#34;&#xA;  &#34;strings&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;s1 := &#34;gopher&#34;&#xA;&#x9;s2 := &#34;Gopher&#34;&#xA;&#x9;s3 := &#34;gopher&#34;&#xA;&#xA;&#x9;fmt.Println(strings.Compare(s1, s2))&#xA;&#x9;fmt.Println(strings.Compare(s1, s3))&#xA;&#x9;fmt.Println(strings.Compare(s2, s3))&#xA;}&#xA;```   &#xA;&#xA;```&#xA;go run comparison.go&#xA;&#xA;1&#xA;0&#xA;-1&#xA;```&#xA;&#xA;   In the above example, the two strings `s1` and `s2` are compared and it returns the integer value `+1`, indicating the first string is lexicographically greater than the second string which is true `&#34;gopher&#34;` will be lexicographically after `&#34;Gopher&#34;` due to the presence of `G`.&#xA;&#xA;   In the second example, we are comparing the strings `s1` and `s3` which are equal, and hence the function returns `0` as expected.&#xA;&#xA;   In the third example, we are comparing the strings `s2` and `s3` identical to the first case but here order matters. We are comparing `&#34;Gopher&#34;` with `&#34;gopher&#34;` so the first string is lexicographically smaller than the second string and thereby returning `-1` as discussed.&#xA;&#xA;### Using strings EqualFold&#xA;&#xA;We also have another method in the strings library called [EqualFold](https://pkg.go.dev/strings#EqualFold) which compares two strings lexicographically but without considering the case precedence. That is the upper case or lower case is ignored and considered equal. So we are truly case-insensitively comparing the strings.&#xA;&#xA;#### strings.EqualFold&#xA;&#xA;- Return Type: bool (true or false)&#xA;- Parameters: string, string&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import(&#xA;  &#34;fmt&#34;&#xA;  &#34;strings&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;s1 := &#34;gopher&#34;&#xA;&#x9;s2 := &#34;Gopher&#34;&#xA;&#x9;s3 := &#34;gophy&#34;&#xA;&#xA;&#x9;fmt.Println(strings.EqualFold(s1, s2))&#xA;&#x9;fmt.Println(strings.EqualFold(s1, s3))&#xA;&#x9;fmt.Println(strings.EqualFold(s2, s3))&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run comparison.go&#xA;&#xA;true&#xA;false&#xA;false&#xA;```&#xA;&#xA;   So, in the above example, we are comparing the strings `&#34;gopher&#34;` and `&#34;Gopher&#34;` i.e. `s1` and `s2`, which are equal if we think case-insensitively. Hence the method returns true, they are equal.&#xA;   In the next example, we compare the strings, `s1` and `s3` i.e. `&#34;gopher&#34;` `&#34;gophy&#34;` which are not equal, and hence we return `false`. Similar is the case for `&#34;Gopher&#34;` and `&#34;gophy&#34;` which is `false`. Also, if we consider two strings `&#34;gophy&#34;` and `&#34;gophy&#34;` it will quite obliviously return `true`.&#xA;&#xA;## String Manipulation and utility methods&#xA;&#xA;The strings package in golang has some great utility methods for working with string or any form of text. We will explore some of the quite useful and widely used utilities in the strings package.&#xA;&#xA;### ToLower, ToUpper and Title functions&#xA;&#xA;The strings package also provides some utility functions for operating on the case of the characters in the strings. We have functions like [ToLower](https://pkg.go.dev/strings#ToLower), [ToUpper](https://pkg.go.dev/strings#ToUpper), and [Title](https://pkg.go.dev/golang.org/x/text/cases#Title) which can be used to convert the string into lower case, uppercased or Capitalised(Title) cased characters respectively.&#xA;&#xA;#### strings.ToLower&#xA;&#xA;- Return Type: string &#xA;- Parameters: string&#xA;&#xA;&#xA;#### strings.ToUpper&#xA;&#xA;- Return Type: string &#xA;- Parameters: string&#xA;&#xA;&#xA;#### cases.Title&#xA;&#xA;- Return Type: Caser&#xA;- Parameters: Language Options &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;strings&#34;&#xA;&#xA;&#x9;&#34;golang.org/x/text/cases&#34;&#xA;&#x9;&#34;golang.org/x/text/language&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;s1 := &#34;Ubuntu 22&#34;&#xA;&#x9;s2 := &#34;meet&#34;&#xA;&#x9;s3 := &#34;IND&#34;&#xA;&#x9;fmt.Println(strings.ToLower(s1))&#xA;&#x9;fmt.Println(strings.ToLower(s2))&#xA;&#x9;fmt.Println(strings.ToLower(s3))&#xA;&#xA;&#x9;fmt.Printf(&#34;&#xA;&#34;)&#xA;&#x9;fmt.Println(strings.ToUpper(s1))&#xA;&#x9;fmt.Println(strings.ToUpper(s2))&#xA;&#x9;fmt.Println(strings.ToUpper(s3))&#xA;&#xA;&#x9;fmt.Printf(&#34;&#xA;&#34;)&#xA;&#x9;cases := cases.Title(language.English)&#xA;&#x9;fmt.Println(cases.String(s1))&#xA;&#x9;fmt.Println(cases.String(s2))&#xA;&#x9;fmt.Println(cases.String(s3))&#xA;}&#xA;```&#xA;&#xA;```&#xA;# 100-days-of-golang/scripts/strings&#xA;&#xA;go mod init&#xA;go get golang.org/x/text/cases&#xA;go get golang.org/x/text/language&#xA;&#xA;go run utility.go                                                                                             &#xA;ubuntu 22&#xA;meet&#xA;ind&#xA;&#xA;UBUNTU 22&#xA;MEET&#xA;IND&#xA;&#xA;Ubuntu 22&#xA;Meet&#xA;Ind&#xA;```&#xA;&#xA;   Here, we can see that the function, `ToLower` has converted all the characters of a string to the lower case of the alphabet. Similarly, the `ToUpper` function has turned the characters of the strings to their respective alphabetical upper case. &#xA;&#xA;   The [Title](https://pkg.go.dev/strings#Title) method in the strings package has been deprecated due to incompatibility with certain languages and cases. So, we are using the [text/cases](https://pkg.go.dev/golang.org/x/text/cases) package to get the [Title](https://pkg.go.dev/strings#Title) method that appropriately converts a string to Title cased. &#xA;  To set up this function, you need to perform a certain package installation process which is quite straightforward. Just create a go mod which is used for managing dependencies and packages for a project. So run the commands given below in the same order in your local setup:&#xA;&#xA;```&#xA;go mod init&#xA;go get golang.org/x/text/cases&#xA;go get golang.org/x/text/language&#xA;```&#xA;   This will set up a go.mod file and install the packages namely the `cases` and `language` packages. After doing this you will be able to access the functions `Title` from the cases package which can be imported by the format `&#34;golang.org/x/text/cases&#34;` and `&#34;golang.org/x/text/language&#34;`. Now, we can use the Title function and parse the parameters which is the language type. Here we have used the `language.English` which is a [language Tag](https://pkg.go.dev/golang.org/x/text@v0.3.7/language#Tag) to say use the semantics of English language while parsing the title cased characters. We now assign the value of the function `Title` to a variable as it will be of type `Caseer` and we want to still parse the string into the function. The [caser](https://pkg.go.dev/golang.org/x/text/cases#Caser) object will have certain methods and properties attached to it, we will use the method [Strings](https://pkg.go.dev/golang.org/x/text/cases#Caser.String) that will convert the given string into the title cased string. Hence we return the title cased string using the title function with the help of cases and language packages.&#xA;&#xA;### Contains and ContainsAny functions&#xA;&#xA;In the strings package, we have the [Contains](https://pkg.go.dev/strings#Contains) and [ContainsAny](https://pkg.go.dev/strings#ContainsAny) method which checks for the presence of substrings within a string. This will help in looking up hidden patterns and find for substrings in a string.&#xA;&#xA;#### strings.Contains&#xA;&#xA;- Parameters: string, string&#xA;- Return Type: bool (true, false)&#xA;&#xA;The Contains method helps in getting the exact match of the substring in the given string. Firstly, the method takes two parameters one being the actual string and the other being the substring that you want to find inside the string. Let&#39;s say we have the `string=&#34;bootcamp&#34;` and `substr=&#34;camp&#34;`, then the `Contains` method will return true because the string contains the substring `camp`.&#xA;&#xA;#### strings.ContainsAny&#xA;&#xA;- Parameters: string, string&#xA;- Return Type: bool (true, false)&#xA;&#xA;The `ContainsAny` method just like the Contains method takes two parameters string and the other as the substring, but it would return true if it finds any character or a single byte(Unicode chars) inside the string. Let&#39;s say the `string=&#34;google photos&#34;` and `substring=&#34;abcde&#34;`, then the `ContainsAny` method will return true because the string contains at least one character in the substring which is `e`. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;str := &#34;javascript&#34;&#xA;&#x9;substr := &#34;script&#34;&#xA;&#x9;s := &#34;python&#34;&#xA;&#xA;&#x9;fmt.Println(strings.Contains(str, substr))&#xA;&#x9;fmt.Println(strings.Contains(str, s))&#xA;&#xA;&#x9;fmt.Println(strings.ContainsAny(str, &#34;joke&#34;))&#xA;&#x9;fmt.Println(strings.ContainsAny(str, &#34;xyz&#34;))&#xA;&#x9;fmt.Println(strings.ContainsAny(str, &#34;&#34;))&#xA;}&#xA;```&#xA;&#xA;Here, we have used the string methods like `Contains` and `ContainsAny` to find the substring inside a string. In the first example, the `str` variable is assigned as `&#34;javascript&#34;` and `substr` string as `&#34;script&#34;`. We use the `Contains` function with parameters `(str, substr)`. This will return `true` as we can see the `&#34;script&#34;` is a substring of `&#34;javascript&#34;`. Also, we have initialized the variable `s` to `&#34;python&#34;`. We use the `Contains` method with the parameters `(str, s)` which will return `false` as `&#34;python&#34;` is not a substring of `&#34;javascript&#34;`. &#xA;&#xA;The next set of examples is of the `ContainsAny` method which will return true for any character present in the substring is present in the string :). Quite a Simple right, Just understand that any character in your substring present in the string will return `true`. As we see in the example, `ContainsAny` method is used with the parameters  `(&#34;javascript&#34;, &#34;joke&#34;)`, It will return `true` as `j` is present inside the string, though the entire substring is not present. &#xA;&#xA;The next example is by passing `(&#34;javascript&#34;, &#34;xyz&#34;)` to the method `ContainsAny` will return `false` as we don&#39;t have either `&#34;x&#34;`, `&#34;y&#34;`, or `&#34;z&#34;` in the string. So this is how the `ContainsAny` method works. &#xA;&#xA;Other similar methods you might be interested in learning are: [Index](https://pkg.go.dev/strings#Index), [IndexAny](https://pkg.go.dev/strings#IndexAny), [LastIndex](https://pkg.go.dev/strings#LastIndex), etc. you can find the list of methods in the [strings package](https://pkg.go.dev/strings#pkg-functions).&#xA;&#xA;### Split and SplitAfter functions&#xA;&#xA;We also have methods to manipulate the string for splitting the characters or bytes with certain patterns. In the strings package, the [Split](https://pkg.go.dev/strings#Split) and [SplitAfter](https://pkg.go.dev/strings#SplitAfter) methods are quite handy to know about.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// Split method for splitting string into slice of string&#xA;&#x9;link := &#34;meetgor.com/blog/golang/strings&#34;&#xA;&#x9;fmt.Println(strings.Split(link, &#34;/&#34;))&#xA;&#x9;fmt.Println(strings.SplitAfter(link, &#34;/&#34;))&#xA;&#xA;&#x9;// SplitAfter method for splitting string into slice of string with the pattern&#xA;&#x9;data := &#34;200kms50kms120kms&#34;&#xA;&#x9;fmt.Println(strings.Split(data, &#34;kms&#34;))&#xA;&#x9;fmt.Println(strings.SplitAfter(data, &#34;kms&#34;))&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run utility.go&#xA;&#xA;[meetgor.com blog golang strings]&#xA;[meetgor.com/ blog/ golang/ strings]&#xA;[200 50 120 ]&#xA;[200kms 50kms 120kms ]&#xA;```&#xA;&#xA;   So, from the above examples, we can see how `Split` and `SplitAfter` methods work. The Split method splits the text before and after the pattern string also removing the pattern string whereas the `SplitAfter` method keeps the pattern and splits it after it, hence we see the pattern string getting attached to the left string.&#xA;&#xA;   In the first example, we see the `link` variable being split into strings as `&#34;/&#34;` being the separator. The Split method returns the slice of the string elements which have been split. In the `data` variable, the `&#34;kms&#34;` is the separator, so we get the resultant slice as `[200, 50, 120]`, the `&#34;kms&#34;` string acts as a separator and it is ignored.&#xA;&#xA;   In the next example, we see the `link` variable being split into strings as `&#34;/&#34;` being the separator as previously but here, the splitting occurs after the separator has been parsed. So, we see `&#34;meetgor/&#34;` being split after the separator string and then `&#34;blog/&#34;` and so on. Also the next example, in the `data` variable, we see `&#34;200kms&#34;` being split instead of `200` using Split.&#xA;&#xA;#### Repeat and Fields functions&#xA;&#xA;In the strings package, we have methods like [Repeat](https://pkg.go.dev/strings#Repeat) and [Fields](https://pkg.go.dev/strings#Fields) for manipulating the text inside the string. These methods are used to populate or extract data from the string. &#xA;&#xA;##### strings.Repeat&#xA;&#xA;- Parameters: string, int&#xA;- Return Type: string&#xA;&#xA;The `Repeat` method is used to create a string by repeating it n number of times and appending it to the string which is returned as the final string. So, the `Repeat` method takes in two parameters the string to repeat, an integer as a count to repeat the string, and returns a string.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// Repeat method for creating strings with given string and integer&#xA;&#x9;pattern := &#34;OK&#34;&#xA;&#x9;fmt.Println(strings.Repeat(pattern, 3))&#xA;}&#xA;```&#xA;```&#xA;go run utility.go&#xA;&#xA;OKOKOK&#xA;```&#xA;&#xA;   So in this example, we can see that the string `&#34;OK&#34;` is passed to the method `Repeat` with the integer `3` and thus it is appended into itself three times and the resultant string becomes `&#34;OKOKOK&#34;`.&#xA;&#xA;##### strings.Fields&#xA;&#xA;- Parameters: string&#xA;- Return Type: []string&#xA;&#xA;The `Fields` method is used to extract the words from the string, that is the characters/bytes and group them with one or more consecutive white spaces. The function returns a slice of string.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;strings&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// Fields method for extracting string from the given string with white space as delimiters&#xA;&#x9;text := &#34;Python is a prgramming language.   Go is not&#34;&#xA;&#x9;text_data := strings.Fields(text)&#xA;&#x9;fmt.Println(text_data)&#xA;&#x9;for _, d := range text_data {&#xA;&#x9;&#x9;fmt.Println(&#34;data = &#34;, d)&#xA;&#x9;}&#xA;}&#xA;```   &#xA;&#xA;```&#xA;go run utility.go&#xA;&#xA;[Python is a prgramming language. Go is not]&#xA;data =  Python&#xA;data =  is&#xA;data =  a&#xA;data =  prgramming&#xA;data =  language.&#xA;data =  Go&#xA;data =  is&#xA;data =  not&#xA;```&#xA;&#xA;   The above example demonstrates the usage of `Fields` which will extract characters and split after encountering whitespace. So, we return a slice of string in which the string elements are split before white space. Thus, using the Fields method we get the words or characters as space-separated values in the slice. &#xA;&#xA;   You can even expand on this method with the [FieldsFunc](https://pkg.go.dev/strings#FieldsFunc) method which allows you to write a custom delimiter option and extract data according to your requirement. There are tons of methods in the strings package for working with strings, you can see a detailed list of functions in the [documentation](https://pkg.go.dev/strings#pkg-functions).&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this post, we were able to understand the different methods and types to concatenate and interpolate strings in golang. We explored different types of concatenating strings, string comparison, and various methods for manipulating and interpolating strings. &#xA;&#xA;Thank you for reading, if you have any queries, feedback, or questions, you can freely ask me on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Mutable and Immutable Data Types</title>
      <link>meetgor.com/golang-mutable-immutable</link>
      <description>Understanding and Exploring immutable and mutable data types in Golang. Learning why the variable behaves in golang as they do.</description>
      <pubDate>Tue, 21 Jun 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction &#xA;&#xA;In this 14th Post of the 100 days of GOlang, we will be understanding about the mutable and immutable data types in Golang. Firstly, we will understand the concept of mutability and understand the differences in mutable and immutable data types, further we will explore which data types in Golang are Mutable and Immutable.&#xA;&#xA;## Mutable Data Type&#xA;&#xA;Mutable data type is a data type which can be modified without reallocating any chunk of the memory assigned at the time of initialization. In simple words, a variable is mutable if its value can be altered without reallocating itself to a new memory space.&#xA;&#xA;In mutable data type the value located in a memory address can be modified. This means we do not have to reallocate any memory or change the pointer of a variable to point to other address in order to change the value of the variable.&#xA;&#xA;```&#xA;// Initialization &#xA;&#xA;int age = 12&#xA;&#xA;// The value of age is 12 which is stored at some memory address let&#39;s sayy 0x12345&#xA;&#xA;&#xA;// Modifying the value&#xA;&#xA;int age = 13&#xA;&#xA;// If the data type is mutable, we can directly change the value in the memory address&#xA;```&#xA;&#xA;Mutable data type looks quite simple by using a single variable to demonstrate, but if we scale the example a little, things start to escalate pretty quickly.&#xA;&#xA;```&#xA;// Initialization &#xA;&#xA;int age = 12&#xA;// The value of age is 12 which is stored at some memory address let&#39;s sayy 0x12345&#xA;&#xA;int experience = age&#xA;&#xA;// This will make the experience variable point to the address which the age variable is pointing to.&#xA;// Yes, It will point to the same memory address&#xA;&#xA;// Variable    |  Memory Address  |  Value&#xA;&#xA;// age        -&gt;    0x12345       -&gt;   12&#xA;// experience -&gt;    0x12345       -&gt;   12&#xA;&#xA;// Modifying the value&#xA;&#xA;int experience = 17&#xA;&#xA;// A change in either of the variable will change the value in both the variables &#xA;// Since both the variables are poiting to the same memory address&#xA;&#xA;// Variable    |  Memory Address  |  Value&#xA;&#xA;// age        -&gt;    0x12345       -&gt;   17&#xA;// experience -&gt;    0x12345       -&gt;   17&#xA;&#xA;// If the data type is mutable, we can directly change the value in the memory address&#xA;&#xA;```   &#xA;&#xA;## Immutable Data Types&#xA;&#xA;Immutable data type is a data type which cannot be modified without allocating a new memory. So, the immutable data type has to reallocate memory for making changes to the value of a variable. This might be a downside if the variable is holding a large sets of values, it will require a lot of memory re-allocation for a slight change in the value. &#xA;&#xA;Immutable data types also mean that you cannot change the value in the memory address which the variable is pointing to, but you can make the variable point to a different memory location under the hood to change or modify the content of a variable.&#xA;&#xA;```&#xA;&#xA;// Initialization&#xA;&#xA;string fruit = &#34;apple&#34;&#xA;&#xA;// the value &#34;apple&#34; is stored in a memory location let&#39;s say 0x12345 originally&#xA;&#xA;&#xA;&#xA;// Modifying the value&#xA;&#xA;string fruit = &#34;orange&#34;&#xA;&#xA;// the value &#34;orange&#34; will be located in a different memory location say 0x98765&#xA;// The memory address that the variable fruit points to is changed and not the value of the memory address&#xA;// This is called immutablility in data types&#xA;```&#xA;&#xA;This is the basics of mutability and immutability, this might be a bit difficult to digest, but take your time and understand it thoroughly. This concept is critical for understanding the under the hood point of view while debugging in several occasions.&#xA;&#xA;&#xA;## Mutable data type in Golang&#xA;&#xA;In golang there are a few mutable data types &#xA;&#xA;1. Slice&#xA;2. Array&#xA;3. Map&#xA;4. Channels&#xA;&#xA;### Slice and Arrays&#xA;&#xA;Slice and Arrays are mutable data types in golang, this means the value of the elements in slice or array can be changed after initialization without re-allocations of memory.&#xA;&#xA;```&#x9;go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;&#x9;// Slice&#xA;&#x9;s := []int{1, 2, 3}&#xA;&#x9;fmt.Printf(&#34;S[1] -&gt; %p&#xA;&#34;, &amp;s[1])&#xA;&#x9;p := s&#xA;&#x9;p[1] = 4&#xA;&#x9;fmt.Printf(&#34;S[1] -&gt; %p&#xA;&#34;, &amp;s[1])&#xA;&#xA;&#x9;fmt.Println(&#34;s =&#34;,s)&#xA;&#x9;fmt.Println(&#34;p =&#34;,p)&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run mutable.go&#xA;&#xA;S[1] -&gt; 0xc000018200&#xA;S[1] -&gt; 0xc000018200&#xA;s = [1 4 3]&#xA;p = [1 4 3]&#xA;```&#xA;&#xA;In the above example, we can see that the slice has been initialized to `{1,2,3}` another slice has been referenced to that string i.e. it will point to the same address as the original string `s`. If we modify the slice `p`, since it is pointing to the same memory address as the slice `s` is pointing it will modify the slice `s` as well (they are the same slice).&#xA;&#xA;This is what mutability does, it modifies the value stored in a memory address directly, without allocating any extra memory to the variable.&#xA;&#xA;### Arrays&#xA;&#xA;You won&#39;t be able to see the concept of mutable data types with arrays as they are not referenced to any memory address, it is a collection of a single type of value and it is thus static. Since it is not a reference to any memory address, the value of the elements doesn&#39;t change if we change the value of an element in the copy of the array.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;&#x9;// Arrays &#xA;&#x9;a := [3]int{10, 20, 30}&#xA;&#x9;fmt.Printf(&#34;A[1] -&gt; %p&#xA;&#34;, &amp;a[1])&#xA;&#x9;b := a&#xA;&#x9;b[1] = 40&#xA;&#x9;fmt.Printf(&#34;A[1] -&gt; %p&#xA;&#34;, &amp;a[1])&#xA;&#xA;&#x9;fmt.Println(&#34;a =&#34;, a)&#xA;&#x9;fmt.Println(&#34;b =&#34;, b)&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run mutable.go&#xA;&#xA;A[1] -&gt; 0xc0000aa038&#xA;A[1] -&gt; 0xc0000aa038&#xA;a = [10 20 30]&#xA;b = [10 40 30]&#xA;```&#xA;&#xA;   In the above example, we can see the array `a` is initialized with a fixed length and initialized values. We then create another array by assigning the array `a` to it, this creates a copy of a collection of the elements in a different memory location. So, if we change an element in the array `b`, there won&#39;t be any change in the elements of array `a` as the elements are stored in a completely different memory location.&#xA;&#xA;### Map&#xA;&#xA;Map is similar to slices in a way they are references to the memory address. A map as we have explored in the [seventh part](https://www.meetgor.com/golang-maps) of the series], they are a pair of key and value pairs. The map is internally a reference to a hash map, a hash map is an abstract data type or a structure in Golang, it basically is an array of buckets. Buckets contain high-order bits with a hash(random value) to make the keys distinct in the map. The number of buckets is initially 8, but it expands as required so it doubles the number of buckets and assigns the value to the map elements. For a detailed reference, you can look at the source implementation of [golang&#39;s map](https://github.com/golang/go/blob/master/src/runtime/map.go).&#xA;&#xA;So, a map is mutable, which means if we change the value of a key it is changed directly to the memory rather than reallocating the memory space for the entire map.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;// Map&#xA;&#x9;m := map[string]int{&#34;level&#34;: 5, &#34;health&#34;: 9}&#xA;&#x9;fmt.Println(&#34;m =&#34;, m)&#xA;&#x9;n := m&#xA;&#x9;n[&#34;food&#34;] = 12&#xA;&#xA;&#x9;fmt.Println(&#34;m =&#34;, m)&#xA;&#x9;fmt.Println(&#34;n =&#34;, n)&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run mutable.go&#xA;&#xA;m = map[health:9 level:5]&#xA;m = map[food:12 health:9 level:5]&#xA;n = map[food:12 health:9 level:5]&#xA;```&#xA;&#xA;In the above example, we can see the map `m` is a string integer map with 2 keys. We create a new map called `n` and reference it as the map `m` this will make the map `n` point to the same hash map as the map `m` does. Hence, if we change the value of a key in the map `n` it will thereby change the map `m` as maps `m` and `n` both point to the same map (in memory address).&#xA;&#xA;## Immutable data type in Golang&#xA;&#xA;In golang, there are a few immutable data types as well like string, pointers, boolean, and core data types like integer, float, etc. As we discussed immutable data types, are data types that don&#39;t change the value of the variable directly into the provided memory address, it re-allocates the memory address with the new value/edited value. &#xA;&#xA;1. Boolean, Int, Float&#xA;3. Pointers&#xA;3. String&#xA;4. Interfaces&#xA;&#xA;### Boolean&#xA;&#xA;The boolean data type on golang is an immutable data type which means it re-allocates the memory for any change in the value of the boolean variable. Boolean variables are simple as they can have two values either `true` or `false`. If we declare a boolean variable initialize it with a value, if we further wanted to change the value of the variable, it is done by reallocating the memory address which was initially holding the value. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;&#x9;// bool&#xA;&#x9;boolean := true&#xA;&#x9;b := boolean&#xA;&#x9;b = false&#xA;&#x9;fmt.Println(&#34;boolean = &#34;, boolean)&#xA;&#x9;fmt.Println(&#34;b = &#34;, b)&#xA;&#xA;}&#xA;```   &#xA;&#xA;```&#xA;go run immutable.go&#xA;&#xA;boolean =  true&#xA;b =  false&#xA;```&#xA;&#xA;   In this example, we can see that the boolean variable `boolean` (I have literally named it boolean) is initialized as `true`, next we declare another variable `b` and set it to the value of `boolean` which is the value `true`. We then change the value of the variable `b` but the value of `boolean` does not change. It doesn&#39;t give much clarity on the immutability of the boolean data type. This is because it is an under an hood process and a low-level process in programming in golang.&#xA;&#xA;Immutable doesn&#39;t mean you cannot change values, but the value is not directly changed, there happens some under-the-hood (low level) stuff to alter the value and change the memory address which is ben pointed as the location which holds the value. &#xA;&#xA;To get more clarity, you can refer to this [Stack-Overflow discussion](https://stackoverflow.com/questions/71589811/go-ints-and-strings-are-immutable-or-mutable/71590289#71590289).&#xA;&#xA;&#xA;### Pointers&#xA;&#xA;Pointer as well is an immutable data type in golang, we cannot change the value in this case the memory address of a variable which we are pointing to, directly but we need to re-allocate the memory for changing the value of the variable.&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;  // Pointer&#xA;&#x9;n := 567&#xA;&#x9;t := 123&#xA;&#x9;ptr := &amp;n&#xA;&#x9;ptr_new := ptr&#xA;&#x9;fmt.Println(&#34;ptr = &#34;, ptr)&#xA;&#x9;fmt.Println(&#34;ptr_new = &#34;, ptr_new)&#xA;&#xA;&#x9;ptr_new = &amp;t&#xA;&#xA;&#x9;fmt.Println(&#34;ptr = &#34;, ptr)&#xA;&#x9;fmt.Println(&#34;ptr_new = &#34;, ptr_new)&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run immutable.go&#xA;&#xA;ptr     =  0xc0000aa008&#xA;ptr_new =  0xc0000aa008&#xA;ptr     =  0xc0000aa008&#xA;ptr_new =  0xc0000aa020&#xA;```&#xA;&#xA;   Clearly, in the example, we have initially created a pointer `ptr` which points to the variable `n`, then we create another pointer `ptr_new` and assign it to the value of the pointer `ptr`. This will make both the pointers point to the same variable `n`. We then point the `ptr_new` pointer to the variable `t`, this changes the value of pointer `ptr_new` but since the pointer stores a memory address, it was not holding the actual value at the memory address. So, the change in the pointing value of `ptr_new` does not change the value of the pointer `ptr`.&#xA;&#xA;Again, immutable types cannot be seen actually changing the memory location of those variables, it is just the low-level implementation that sometimes needs to be kept in mind.&#xA;&#xA;### String&#xA;&#xA;Strings are the classical example of immutable data types in golang, this data type is quite commonly used and is quite important for creating a wide variety of applications. The value of the string variable can be changed but the process happens with/without changing the value of the memory address of the initial value, we have to change the memory address of the variable in order to change the value. This might not be evident by even using `&amp;variable_name` as it doesn&#39;t give the actual insight about the internal working of how the memory address might be processed at run time.&#xA;&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;&#x9;// String&#xA;&#x9;str := &#34;gopher&#34;&#xA;&#x9;str_copy := str&#xA;&#x9;str_copy = &#34;cooper&#34;&#xA;&#x9;fmt.Println(&#34;str = &#34;, str)&#xA;&#x9;fmt.Println(&#34;str_copy = &#34;, str_copy)&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run immutable.go&#xA;&#xA;str =  gopher&#xA;str_copy =  cooper&#xA;```&#xA;&#xA;Here, in the above example, we have created a variable `str` with a value `&#34;gopher&#34;` and then, another variable `str_copy` which is assigned the value of `str`. If we change the value of `str_copy`, the value of `str` is not changed, this is not giving any information on the immutability of a data type.&#xA;&#xA;What actually gives a clear understanding of the immutability of data type in the string is the modification of the character of a string. We cannot change the character at a particular index of the string in golang.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;&#x9;// Character at index cannot be changed in string&#xA;&#xA;&#x9;s := &#34;StarWars&#34;&#xA;&#x9;s[4] = &#39;C&#39;&#xA;&#x9;// s[4] = &#34;C&#34;&#xA;&#x9;// also won&#39;t work&#xA;&#x9;fmt.Println(s)&#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;go run immutable.go&#xA;&#xA;immutable.go:18:2: cannot assign to s[4] (value of type byte)&#xA;```&#xA;  &#xA;   So, we can see we cannot change the value of the internal characters of the string. This is why string data type is immutable, we cannot change the value of internal elements of the variable directly but we can change the value of the variable as a whole as we saw in the previous example. &#xA;&#xA;So this is how the immutable data types are perceived in golang, we cannot change the value directly at the memory address, we change the internal location for any change in the value which is dependent on the decision by the garbage collector.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/Mr-Destructive/100-days-of-golang/tree/main/scripts/im-mutable) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this small post, we were able to understand the different behaviors of data types in golang. We can understand it at the beginning of the variables part of the series, but it becomes more clear when we play with all the data types and then understand how and why they behave as they do. This was not a deep dive into the core working of immutable and mutable data types but gave a fair bit of understanding of the behavior of different data types in golang.&#xA;&#xA;Thank you for reading, if you have any queries, feedback, or questions, you can freely ask me on my social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Operators</title>
      <link>meetgor.com/golang-operators</link>
      <description>Understanding the basics of operators like arithmetic, logical, bitwise, assignment operators in Golang</description>
      <pubDate>Sat, 07 May 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction &#xA;&#xA;In this 13th part of the series, we will be exploring the fundamentals of operators in Golang. We will be exploring the basics of operators and the various types like Arithmetic, Bitwise, Comparison, Assignment operators in Golang.&#xA;&#xA;Operators are quite fundamentals in any programming language. Operators are basically expressions or a set of character(s) to perform certain fundamental tasks. They allow us to perform certain trivial operations with a simple expression or character. There are quite a few operators in Golang to perform various operations.&#xA;&#xA;## Types of Operators&#xA;&#xA;Golang has a few types of operators, each type providing particular aspect of forming expressions and evaluate conditions.&#xA;&#xA;1. Bitwise Operators&#xA;2. Logical Operators&#xA;3. Arithmetic Operators&#xA;4. Assignment Operators&#xA;5. Comparison Operators&#xA;&#xA;### Bitwise Operators&#xA;&#xA;Bitwise Operators are used in performing operations on binary numbers. We can perform operation on a bit level and hence they are known as bitwise operators. Some fundamental bitwise operators include, `AND`, `OR`, `NOT`, and `EXOR`. Using this operators, the bits in the operands can be manipulated and certain logical operations can be performed. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;x := 3&#xA;&#x9;y := 5&#xA;&#x9;// 3 -&gt; 011&#xA;&#x9;// 5 -&gt; 101&#xA;&#x9;fmt.Println(&#34;X AND Y = &#34;, x &amp; y)&#xA;&#x9;fmt.Println(&#34;X OR Y = &#34;, x | y)&#xA;&#x9;fmt.Println(&#34;X EXOR Y = &#34;, x ^ y)&#xA;&#x9;fmt.Println(&#34;X Right Shift 1  = &#34;, x &gt;&gt; 1)&#xA;&#x9;fmt.Println(&#34;X Right Shift 2  = &#34;, x &gt;&gt; 2)&#xA;&#x9;fmt.Println(&#34;Y Left Shift 1 = &#34;, y &lt;&lt; 1)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run bitwise/main.go&#xA;&#xA;X AND Y =  1&#xA;X OR Y =  7&#xA;X EXOR Y =  6&#xA;X Right Shift 1  =  1&#xA;X Right Shift 2  =  0&#xA;Y Left Shift 1 =  10&#xA;&#xA;```&#xA;&#xA;We use the `&amp;` (AND operator) for performing AND operations on two operands. Here we are logically ANDing `3` and `5` i.e. `011` with `101` so it becomes `001` in binary or 1 in decimal.&#xA;&#xA;Also, the `|` (OR operator) for performing logical OR operation on two operands. Here we are logically ORing `3` and `5` i.e. `011` with `101` so it becomes `111` in binary or 7 in decimal.&#xA;&#xA;Also the `^` (EXOR operator) for performing logical EXOR operation on two operands. Here we are logically EXORing `3` and `5` i.e. `011` with `101` so it becomes `110` in binary or 6 in decimal.&#xA;&#xA;We have a couple of more bitwise operators that allow us to shift bits in the binary representation of the number. We have two types of these shift operators, right sift and left shift operators. The main function of these operator is to shift a bit in either right or left direction. &#xA;&#xA;In the above example, we have shifted `3` i.e. `011` to right by one bit so it becomes `001`. If we would have given `x &gt;&gt; 2` it would have become `0` since the last bit was shifted to right and hence all bits were 0.&#xA;&#xA;Similarly, the left shift operator sifts the bits in the binary representation of the number to the left. So, in the example above, `5` i.e. `101` is shifted left by one bit so it becomes `1010` in binary i.e. 10 in decimal. &#xA;&#xA;This was a basic overview of bitwise operators in Golang. We can use these basic operators to perform low level operations on numbers.&#xA;&#xA;### Comparison Operators&#xA;&#xA;This type of operators are quite important and widely used as they form the fundamentals of comparison of variables and forming boolean expressions. The comparison operator is used to compare two values or expressions. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;a := 45&#xA;&#x9;b := 12&#xA;&#x9;fmt.Println(&#34;Is A equal to B ? &#34;, a == b)&#xA;&#x9;fmt.Println(&#34;Is A not equal to B ? &#34;, a != b)&#xA;&#x9;fmt.Println(&#34;Is A greater than B ? &#34;, a &gt; b)&#xA;&#x9;fmt.Println(&#34;Is A less than B ? &#34;, a &lt; b)&#xA;&#x9;fmt.Println(&#34;Is A greater than or equal to B ? &#34;, a &gt;= b)&#xA;&#x9;fmt.Println(&#34;Is A less than or equal to B ? &#34;, a &lt;= b)&#xA;&#xA;```&#xA;&#xA;```&#xA;$ go run comparison/main.go&#xA;&#xA;Is A equal to B ?  false&#xA;Is A not equal to B ?  true&#xA;Is A greater than B ?  true&#xA;Is A less than B ?  false&#xA;Is A greater than or equal to B ?  true&#xA;Is A less than or equal to B ?  false&#xA;```&#xA;&#xA;We use simple comparison operators like `==` or `!=` for comparing if two values are equal or not. The expression `a == b` will evaluate to `true` if the values of both variables or operands are equal. However, the expression `a != b` will evaluate to `true` if the values of both variables or operands are not equal.&#xA;&#xA;Similarly, we have the `&lt;` and `&gt;` operators which allow us to evaluate expression by comparing if the values are less than or grater than the other operand. So, the expression `a &gt; b` will evaluate to `true` if the value of `a` is greater than the value of `b`. Also the expression `a &lt; b` will evaluate to `true` if the value of `a` is less than the value of `b`. &#xA;&#xA;Finally, the operators `&lt;=` and `&gt;=` allow us to evaluate expression by comparing if the values are less than or equal to and greater than or equal to the other operand. So, the expression `a &gt;= b` will evaluate to `true` if the value of `a` is greater than or if it is equal to the value of `b`, else it would evaluate to `false`. Similarly, the expression `a &lt;= b` will evaluate to `true` if the value of `a` is less than or if it is equal to the value of `b`, else it would evaluate to `false`.&#xA;&#xA;These was a basic overview of comparison operators in golang.&#xA;&#xA;### Logical Operators&#xA;&#xA;Next, we move on to the logical operators in Golang which allow to perform logical operations like `AND`, `OR`, and `NOT` with conditional statements or storing boolean expressions. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;a := 45&#xA;&#x9;b := &#34;Something&#34;&#xA;&#x9;fmt.Println(a &gt; 40 &amp;&amp; b == &#34;Something&#34;)&#xA;&#x9;fmt.Println(a &lt; 40 &amp;&amp; b == &#34;Something&#34;)&#xA;&#x9;fmt.Println(a &lt; 40 || b == &#34;Something&#34;)&#xA;&#x9;fmt.Println(a &lt; 40 || b != &#34;Something&#34;)&#xA;&#x9;fmt.Println(!(a &lt; 40 || b != &#34;Something&#34;))&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run logical/main.go&#xA;&#xA;true&#xA;false&#xA;true&#xA;false&#xA;true&#xA;```&#xA;&#xA;Here, we have used logical operators like `&amp;&amp;` for Logical AND, `||` for logical OR, and `!` for complementing the evaluated result. The `&amp;&amp;` operation only evaluates to `true` if both the expressions are `true` and `||` OR operator evaluates to `true` if either or both the expressions are `true`. The `!` operator is used to complement the evaluated expression from the preceding parenthesis.&#xA;&#xA;### Arithmetic Operators&#xA;&#xA;Arithmetic operators are used for performing Arithmetic operations. We have few basic arithmetic operators like `+`, `-`, `*`, `/`, and `%` for adding, subtracting, multiplication, division, and modulus operation in golang. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;a := 30&#xA;&#x9;b := 50&#xA;&#x9;fmt.Println(&#34;A + B = &#34;, a+b)&#xA;&#x9;fmt.Println(&#34;A - B = &#34;, a-b)&#xA;&#x9;fmt.Println(&#34;A * B = &#34;, a*b)&#xA;&#x9;fmt.Println(&#34;A / B = &#34;, a/b)&#xA;&#x9;fmt.Println(&#34;A % B = &#34;, a%b)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run arithmetic/main.go&#xA;A + B =  80&#xA;A - B =  -20&#xA;A * B =  1500&#xA;A / B =  0&#xA;A % B =  30&#xA;```&#xA;&#xA;These are the basic mathematical operators in any programming language. We can use `+` to add two values, `-` to subtract two values, `*` to multiply to values, `/` for division of two values and finally `%` to get the remainder of a division of two values i.e. if we divide 30 by 50, the remainder is 30 and the quotient is 0. &#xA;&#xA;We also have a few other operators like `++` and `--` that help in incrementing and decrementing values by a unit value. Let&#39;s say we have a variable `k` which is set to `4` and we want to increment it by one, so we can definitely use `k = k + 1` but it looks kind of too long, we have a short notation for the same `k++` to do the same.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;k := 3&#xA;&#x9;j := 20&#xA;&#x9;fmt.Println(&#34;k = &#34;, k)&#xA;&#x9;fmt.Println(&#34;j = &#34;, j)&#xA;&#x9;k++&#xA;&#x9;j--&#xA;&#x9;fmt.Println(&#34;k = &#34;, k)&#xA;&#x9;fmt.Println(&#34;j = &#34;, j)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run arithmetic/main.go&#xA;&#xA;k =  3&#xA;j =  20&#xA;&#xA;k =  4&#xA;j =  19&#xA;```&#xA;&#xA;So, we can see that the variable `k` is incremented by one and variable `j` is decremented by `1` using the `++` and `--` operator.&#xA;&#xA;### Assignment Operators&#xA;&#xA;These types of operators are quite handy and can condense down large operations into simple expressions. These types of operators allow us to perform operation on the same operand. Let&#39;s say we have the variable `k` set to `20` initially, we want to add `30` to the variable `k`, we can do that by using `k = k + 30` but a more sophisticated way would be to use `k += 30` which adds `30` or any value provided the same variable assigned and operated on.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;var a int = 100&#xA;&#x9;b := 20&#xA;&#x9;fmt.Println(&#34;a = &#34;, a)&#xA;&#x9;fmt.Println(&#34;b = &#34;, b)&#xA;&#x9;a += 30&#xA;&#x9;fmt.Println(&#34;a = &#34;, a)&#xA;&#x9;b -= 5&#xA;&#x9;fmt.Println(&#34;b = &#34;, b)&#xA;&#x9;a *= b&#xA;&#x9;fmt.Println(&#34;a = &#34;, a)&#xA;&#x9;fmt.Println(&#34;b = &#34;, b)&#xA;&#x9;a /= b&#xA;&#x9;fmt.Println(&#34;a = &#34;, a)&#xA;&#x9;fmt.Println(&#34;b = &#34;, b)&#xA;&#x9;a %= b&#xA;&#x9;fmt.Println(&#34;a = &#34;, a)&#xA;&#x9;fmt.Println(&#34;b = &#34;, b)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run assignment/main.go&#xA;&#xA;a =  100&#xA;b =  20&#xA;&#xA;a =  130&#xA;b =  15&#xA;&#xA;a =  1950&#xA;b =  15&#xA;&#xA;a =  130&#xA;b =  15&#xA;&#xA;a =  10&#xA;b =  15&#xA;```&#xA;&#xA;From the above example, we are able to perform operations by using shorthand notations like `+=` to add the value to the same operand. These also saves a bit of time and memory not much but considerable enough. This allow us to directly access and modify the contents of the provided operand in the register rather than assigning different registers and performing the operations.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from the following part of the series, we were able to learn the basics of operators in golang. Using some simple and easy to understand examples, we were able to explore different types of operators like arithmetic, logical, assignment and bitwise operators in golang. These are quite fundamental in programming in general, this lays a good foundation for working with larger and complex projects that deal with any kind of logic in it, without a doubt almost all of the applications do have a bit of logic attached to it. So, we need to know the basics of operators in golang.&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Math Package</title>
      <link>meetgor.com/golang-math</link>
      <description>Exploring various functions in the Math package in the Golang standard Library</description>
      <pubDate>Mon, 25 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Moving on in the 100 days of golang series, we can take a look into the math package in golang&#39;s standard library. In programming, math is quite critical aspect, we need to perform certain mathematical operations quite regularly so golang&#39;s standard library has a package for serving some quite commonly used math functions and procedures. We&#39;ll take a look at some of the basic and common functions which are available in the math package.&#xA;&#xA;## Mathematical Constants&#xA;&#xA;We have some constants like `pi`, `e`, `Phi` already defined as constants in the math package of the standard library in golang. They have a precision till 15 digits stored in float64 values. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(&#34;Pi = &#34;, math.Pi)&#xA;&#x9;fmt.Println(&#34;E = &#34;, math.E)&#xA;&#x9;fmt.Println(&#34;Phi = &#34;, math.Phi)&#xA;&#x9;fmt.Println(&#34;Sqrt of 2 = &#34;, math.Sqrt2)&#xA;&#x9;fmt.Println(&#34;Naturla Log 2 = &#34;, math.Ln2)&#xA;&#x9;fmt.Println(&#34;Naturla Log 10 = &#34;, math.Ln10)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/constants.go&#xA;Pi =  3.141592653589793&#xA;E =  2.718281828459045&#xA;Phi =  1.618033988749895&#xA;Sqrt of 2 =  1.4142135623730951&#xA;Naturla Log 2 =  0.6931471805599453&#xA;Naturla Log 10 =  2.302585092994046&#xA;```&#xA;&#xA;We can use these constants in trigonometric calculations and also in scientific computing. Further, you can get a list of all constants defined in the math package of the go standard library from the [documentation](https://pkg.go.dev/math#pkg-constants).&#xA;&#xA;## Basic Math functions&#xA;&#xA;We have some quite basic and fundamental functions in the math package that can be used commonly in many programs. Let&#39;s take a look at a few of them.&#xA;&#xA;### - Abs :parameters (float64) , returns float64&#xA;&#xA;As the name suggest, the [Abs](https://pkg.go.dev/math#Abs) it returns the absolute result of a numbers. It takes a parameter as a float64 value and returns the absolute value of the provided number as a `float64` number.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;a := 45&#xA;&#x9;b := 100&#xA;&#x9;diff := a - b&#xA;&#x9;fmt.Println(diff)&#xA;&#xA;&#x9;absolute_diff := math.Abs(float64(a) - float64(b))&#xA;&#x9;fmt.Println(absolute_diff)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/main.go&#xA;-55&#xA;55&#xA;```&#xA;&#xA;As, we can see the `Abs` function takes in a float64 value and returns a absolute value of the given number that too a `float64` value. We need to cast the numbers `a` and `b` into `float64` as we have not provided the initial values and so the compiler has assigned the type to them as `int`. &#xA;&#xA;#### Type Casting&#xA;&#xA;We can caste a type into other by using the variable around the type name as `type_name(variable)`. In the above example we have converted the `int` value `45` into a `float64` as `float64(45)` which again yields `45` but as a float64 type. &#xA;&#xA;```go&#xA;foo := 77&#xA;fmt.Printf(&#34;Type of foo = %T &#xA;&#34;, foo)&#xA;fmt.Println(&#34;foo = &#34;, int(foo))&#xA;fmt.Println(&#34;String Cast: &#34;, string(foo))&#xA;fmt.Println(&#34;Float Cast: &#34;, float64(foo))&#xA;```&#xA;&#xA;Though not every type cannot be casted into due to quite oblivious reasons, for instance `77` or any other integer value (except for 0 or 1) cannot be converted into boolean value.&#xA;&#xA;**Hello Gopher! Just a small note, the math package almost deals with float64 types rather than int to avoid backwards compatibility to perform operations on floating point values which can be casted into integers rather than defining separate functions for decimal values and integers.**&#xA;&#xA;### - Min/Max: parameters(float64) , returns float64&#xA;&#xA;We can get the [minimum](https://pkg.go.dev/math#Min) and [maximum](https://pkg.go.dev/math#Max) value of the two numbers provided to the function.&#xA;&#xA;```go&#xA;var float64 a = 120&#xA;var float64 b = 54&#xA;&#xA;minimum := math.Min(float64(a), float64(b))&#xA;maximum := math.Max(float64(a), float64(b))&#xA;fmt.Printf(&#34;Min of %v and %v is %v &#xA;&#34;, a, b, minimum)&#xA;fmt.Printf(&#34;Max of %v and %v is %v &#xA;&#34;, a, b, maximum)&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/main.go&#xA;Min of 120 and 54 is 54&#xA;Max of 120 and 54 is 120&#xA;```&#xA;&#xA;### - Pow  : parameters(float64, float64) , returns float64&#xA;### - Pow10: parameters(int)              , returns float64&#xA;&#xA;The [Pow](https://pkg.go.dev/math#Pow) function is used to get the exponential result of the base number. So, if we provide the values x and y, we would get the result as the number x raised to y. &#xA;&#xA;```go&#xA;var x float64 = 3&#xA;var y float64 = 4&#xA;z := math.Pow(x, y)&#xA;z10 := math.Pow10(int(x))&#xA;fmt.Println(&#34;X ^ Y = &#34;, z)&#xA;fmt.Println(&#34;10 ^ X = &#34;, z10)&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/main.go&#xA;X ^ Y =  81&#xA;10 ^ X =  1000&#xA;```&#xA;&#xA;We also have the [Pow10](https://pkg.go.dev/math#Pow10) function which works just like the pow function except the x value is 10 and we don&#39;t have to provide it, there is just one parameter as a integer which returns a float64 value.&#xA;&#xA;### - Sqrt: parameters(float64) , returns float64&#xA;&#xA;The [Sqrt](https://pkg.go.dev/math#Sqrt) function as the name suggest, it is used to get the square root value of a floating point value which returns a float64 value.&#xA;&#xA;```go&#xA;var k float64 = 125&#xA;sqrt_of_k := math.Sqrt(k)&#xA;cbrt_of_k := math.Cbrt(k)&#xA;&#xA;fmt.Printf(&#34;Square root of %v = %v &#xA;&#34;, k, sqrt_of_k)&#xA;fmt.Printf(&#34;Cube root of %v = %v &#xA;&#34;, k, cbrt_of_k)&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/main.go&#xA;Square root of 125 = 11.180339887498949&#xA;Cube root of 125 = 5&#xA;```&#xA;&#xA;### - Trunc: parameters(float64) , returns float64&#xA;&#xA;The [Truncate](https://pkg.go.dev/math#Trunc) function provides the way to round off a decimal value(float64) to an integer but it returns a value in `float64`.&#xA;&#xA;```go&#xA;var p float64 = 445.235&#xA;trunc_p := math.Trunc(p)&#xA;fmt.Printf(&#34;Truncated value of %v = %v &#xA;&#34;, p, trunc_p)&#xA;p = 123.678&#xA;trunc_p = math.Trunc(p)&#xA;fmt.Printf(&#34;Truncated value of %v = %v &#xA;&#34;, p, trunc_p)&#xA;&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/main.go&#xA;Truncated value of 445.235 = 445&#xA;Truncated value of 123.678 = 123&#xA;```&#xA;&#xA;### - Ceil : parameters(float64) , returns float64&#xA;&#xA;We also can use the [Ceil](https://pkg.go.dev/math#Ceil) function to roud up the value to the next integer value but the value is returned as `float64`. &#xA;&#xA;```go&#xA;var c float64 = 33.25&#xA;ceil_c := math.Ceil(c)&#xA;fmt.Printf(&#34;Ceiled value of %v = %v &#xA;&#34;, c, ceil_c)&#xA;c = 134.78&#xA;ceil_c = math.Ceil(c)&#xA;fmt.Printf(&#34;Ceiled value of %v = %v &#xA;&#34;, c, ceil_c)&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/main.go&#xA;Ceiled value of 33.25 = 34&#xA;Ceiled value of 134.78 = 135&#xA;```&#xA;&#xA;### - Trigonometric Functions&#xA;&#xA;Trigonometric functions are quite helpful that can help in intense mathematical computations in backend projects or precision dependent projects. We have functions [Sin](https://pkg.go.dev/math#Sin), [Cos](https://pkg.go.dev/math#Cos), [SinCos](https://pkg.go.dev/math#Sincos), [Tan](https://pkg.go.dev/math#Tan), hyperbolic functions in Trigonometric functions like [Sinh](https://pkg.go.dev/math#Sinh), [Cosh](https://pkg.go.dev/math#Cosh), [Tanh](https://pkg.go.dev/math#Tanh), and Inverse Trigonometric functions like [Asin](https://pkg.go.dev/math#Asin), [Asinh](https://pkg.go.dev/math#Asinh), etc. &#xA;&#xA;- Sin: parameters(float64) , returns float64&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// basic trigonometric functions&#xA;&#x9;var x float64 = math.Pi / 2&#xA;&#x9;sinx := math.Sin(x)&#xA;&#x9;cosx := math.Cos(x)&#xA;&#x9;tanx := math.Tan(x)&#xA;&#x9;fmt.Printf(&#34;Sin(%v) = %v &#xA;&#34;, x, sinx)&#xA;&#x9;fmt.Printf(&#34;Cos(%v) = %v &#xA;&#34;, x, cosx)&#xA;&#x9;fmt.Printf(&#34;Tan(%v) = %v &#xA;&#34;, x, tanx)&#xA;&#xA;&#x9;// hyperbolic trigonometric functions&#xA;&#x9;var h float64 = math.Pi / 2&#xA;&#x9;sinh := math.Sinh(h)&#xA;&#x9;cosh := math.Cosh(h)&#xA;&#x9;tanh := math.Tanh(h)&#xA;&#x9;fmt.Printf(&#34;Sinh(%v) = %v &#xA;&#34;, h, sinh)&#xA;&#x9;fmt.Printf(&#34;Cosh(%v) = %v &#xA;&#34;, h, cosh)&#xA;&#x9;fmt.Printf(&#34;Tanh(%v) = %v &#xA;&#34;, h, tanh)&#xA;&#xA;&#x9;// Inverse Trigonometric functions&#xA;&#x9;var y float64 = -1&#xA;&#x9;arc_sin := math.Asin(y) // -pi/2 radians or 90 degrees&#xA;&#x9;arc_cos := math.Acos(y) // pi randians or 180 degrees&#xA;&#x9;arc_tan := math.Atan(y) &#xA;&#x9;fmt.Printf(&#34;Sin^-1(%v) = %v &#xA;&#34;, y, arc_sin)&#xA;&#x9;fmt.Printf(&#34;Cos^-1(%v) = %v &#xA;&#34;, y, arc_cos)&#xA;&#x9;fmt.Printf(&#34;Tan^-1(%v) = %v &#xA;&#34;, y, arc_tan)&#xA;&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/trignometric.go&#xA;Sin(1.5707963267948966) = 1&#xA;Cos(1.5707963267948966) = 6.123233995736757e-17&#xA;Tan(1.5707963267948966) = 1.6331239353195392e+16&#xA;Sinh(1.5707963267948966) = 2.3012989023072947&#xA;Cosh(1.5707963267948966) = 2.5091784786580567&#xA;Tanh(1.5707963267948966) = 0.9171523356672744&#xA;Sin^-1(-1) = -1.5707963267948966&#xA;Cos^-1(-1) = 3.141592653589793&#xA;Tan^-1(-1) = -0.7853981633974483&#xA;```&#xA;&#xA;Here we can see that the functions are working fine and giving a decently precise value. This might be enough for simple and smaller projects, though for higher precision and accuracy areas, other computations and programming is required to compute the values.&#xA;&#xA;### - Exponential and Logarithmic Functions&#xA;&#xA;We also have the exponential and logarithmic functions defined in the math package to leverage computations realted to formulae that deal with logarithmic or exponential calculations. &#xA;&#xA;- Exp  : parameters(flaot64) , returns float64&#xA;- Exp2 : parameters(flaot64) , returns float64&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// exponential function&#xA;&#x9;var x float64 = 2&#xA;&#x9;y := math.Exp(x)&#xA;&#x9;fmt.Println(&#34;e^x = &#34;, y)&#xA;&#x9;var n float64 = 3.5&#xA;&#x9;y = math.Exp2(n)&#xA;&#x9;fmt.Println(&#34;2^n = &#34;, y)&#xA;&#xA;&#x9;// Logarithmic function&#xA;&#x9;y = math.Log(x)&#xA;&#x9;fmt.Println(&#34;natural log x = &#34;, y)&#xA;&#xA;&#x9;n = 128&#xA;&#x9;y = math.Log2(n)&#xA;&#x9;fmt.Println(&#34;Log2 of 100 = &#34;, y)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/expo_log.go&#xA;e^x =  7.38905609893065&#xA;2^n =  11.31370849898476&#xA;natural log x =  0.6931471805599453&#xA;Log2 of 100 =  7&#xA;```&#xA;&#xA;Here, we have exponential functions such as `e^x` and `2^n` which might be useful in some common programming calculations. Also the logarithmic functions like `log x` which is natural log of x(base e), and `log2 n` which is logn to the base 2.&#xA;&#xA;## The Random package&#xA;&#xA;The `random` sub-package in golang provides some great tools for working with random numbers and generating them. It provides exhaustive list of functions and types that help in generating pseudo random numbers. &#xA;&#xA;- Int : parameters() , returns int&#xA;- Intn : parameters( int ) , returns int&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/rand&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;// random integer generation&#xA;&#x9;x := rand.Int()&#xA;&#x9;fmt.Println(x)&#xA;&#xA;&#x9;// random number generation till range&#xA;&#x9;for i := 0; i &lt; 5; i++ {&#xA;&#x9;&#x9;y := rand.Intn(10)&#xA;&#x9;&#x9;fmt.Println(y)&#xA;&#x9;}&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/rand.go&#xA;5577006791947779410&#xA;7&#xA;7&#xA;9&#xA;1&#xA;8&#xA;```&#xA;&#xA;In the above example, we have used the [Int](https://pkg.go.dev/math/rand@go1.18.1#Int) function in the random sub-package of the math package which generates a pseudo random integer of the range dependent on the system architecture generally `int32` or `int64`. We get a huge number which is pseudo random i.e. not truly random. If you try to execute the program a couple of time, you would notice the number remains the same and we are calling it random? Well we need to dive into random numbers and seeding for a different part of the series for sure. &#xA;&#xA;The [Intn](https://pkg.go.dev/math/rand@go1.18.1#Intn) function also generates a pseudo random number but this time, we define the range of the upper boundary to generate them. It is not inclusive of the number provided i.e. we have provide the value `10` so the number `10` is not included in the range. It&#39;s called half open interval. It starts from 0 so the range becomes mathematically `[0, n)` if n is the number provided to the Intn function. &#xA;&#xA;## The Bits package&#xA;&#xA;We also have a bit sub-package in the math package of the go standard library. This sub package is used for working around with bit manipulation and operations at the binary level. This is quite helpful in competitive programming , also in understanding the basics of data structures and fundamentals in computer science.&#xA;&#xA;- Add       : parameters(uint, uint, uint) , returns uint, uint &#xA;- Len       : parameters(uint) , returns int&#xA;- OnesCount : parameters(uint) , returns int&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/bits&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;s, c := bits.Add(0, 9, 1)&#xA;&#x9;fmt.Printf(&#34;Sum = %d &#xA;Carry = %d &#xA;&#34;, s, c)&#xA;&#xA;&#x9;// (45) in decimal = (1 0 1 1 0 1) in binary&#xA;&#x9;var n uint = 45&#xA;&#x9;length := bits.Len(n)&#xA;&#x9;ones_in_45 := bits.OnesCount(n)&#xA;&#x9;fmt.Printf(&#34;Minimum bits required to represent 45 = %d &#xA;&#34;, length)&#xA;&#x9;fmt.Printf(&#34;Set Bits in 45 = %d &#xA;&#34;, ones_in_45)&#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/bit.go&#xA;Sum = 10&#xA;Carry = 0&#xA;Minimum bits required to represent 45 = 6&#xA;Set Bits in 45 = 4&#xA;```&#xA;&#xA;Here, in the above example, we have used the bits sub pacakge in the math package, the [Add](https://pkg.go.dev/math/bits@go1.18.1#Add) function allows us to provide the two numbers and a carry bit on which it returns two values the sum and the carry. The sum is defined as the summation of `x + y + carry` the two numbers and the carry bit. The carry bit needs to be either 0 or 1. &#xA;&#xA;Also the value provided the function i.e. `x and y` need to be unsigned `uint` iorder to work with bits. &#xA;&#xA;We also have the [Len](https://pkg.go.dev/math/bits@go1.18.1#Len) function which returns the maximum number of bits required to represent the provided unsigned integer. We have used 45 which is equivalent to `10110` and hence the function returns `6` as teh number of bits. The [OnesCount](https://pkg.go.dev/math/bits@go1.18.1#OnesCount) Function is also similar but it returns the number of set bits(the `1` bit) in the number provided to it. &#xA;&#xA;We&#39;ll see this sub package in a separate section of its own. Bits is really a great pacakge to work with bits and low level manipulation of numbers in Golang.&#xA;&#xA;## The Complex package&#xA;&#xA;The complex subpackage is really specific to the operation to the complex numbers and its operations. Using complex numbers with basic operations and trigonometric functions are provided in the package. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;&#34;math/cmplx&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;x := complex(5, 8)&#xA;&#x9;y := complex(3, 4)&#xA;&#x9;mod_x := cmplx.Abs(x)&#xA;&#x9;mod_y := cmplx.Abs(y)&#xA;&#x9;conj_x := cmplx.Conj(x)&#xA;&#x9;phase_x := cmplx.Phase(x)&#xA;&#x9;mod, phase := cmplx.Polar(x)&#xA;&#xA;&#x9;fmt.Println(&#34;x = &#34;, x)&#xA;&#x9;fmt.Println(&#34;Modulus of x = &#34;, mod_x)&#xA;&#x9;fmt.Println(&#34;Modulus of y = &#34;, mod_y)&#xA;&#x9;fmt.Println(&#34;Conjugate of x = &#34;, conj_x)&#xA;&#x9;fmt.Println(&#34;Phase of x = &#34;, phase_x)&#xA;&#x9;fmt.Printf(&#34;Polar Form : %v, %v&#xA;&#34;, mod, phase)&#xA;&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run basic-functions/complex.go&#xA;x =  (5+8i)&#xA;Modulus of x =  9.433981132056603&#xA;Modulus of y =  5&#xA;Conjugate of x =  (5-8i)&#xA;Phase of x =  1.0121970114513341&#xA;Polar Form : 9.433981132056603, 1.0121970114513341&#xA;&#xA;```&#xA;&#xA;We have used the complex function to create complex numbers. The `cmplx` subpackage in the math package provides many functions to play with trignometric and simple operations with complex numbers. The [Abs](https://pkg.go.dev/math/cmplx@go1.18.1#Abs) function is used to get the modulus of the provided complex number. The modulus is calculated with `sqrt(x^2 + y^2)`, this gives the magnitude of the complex number. Here, we get the modulus as `9.43` as `sqrt(25 + 64)` for the complex number `5+8i`. Also, for `3+4i` the modulus becomes `sqrt(9+16)` which turns out to be `5`. The [Conjugate](https://pkg.go.dev/math/cmplx@go1.18.1#Conj) function is used to get the conjugate of the provided complex number. &#xA;&#xA;Also the phase or the Argument of the complex number can be obtained with the [Phase](https://pkg.go.dev/math/cmplx@go1.18.1#Phase) function. The phase is caluculated by the formula `tan^-1 (y/x)` but the angle is returned in randians. So for `x = 5+8i` the argument/Phase becomes `tan^-1( 8/5)` which is `57.995 degrees` or `1.012 radians`. &#xA;&#xA;We have the [Polar](https://pkg.go.dev/math/cmplx@go1.18.1#Polar) function which gives the polar form of the complex number i.e. `(modulus r, phase theta)` So this function returns two values the modulus and the argument/phase of the complex number. We have already calcualted both the values but this functions gets both of them in a single function. Quite neat, we can even ignore one value after the return of the function by using the ignore operator `_, phase := cmplx.Polar(5+7i)` to only care and get the phase/argument of the complex number or `modulus, _ := cmplx.Polar(5+7i)` to get the modulus from the complex number.&#xA;&#xA;So that&#39;s some basic operations on complex numbers, this might have very few use cases but it&#39;s still quite useful when needed. &#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So from this section we were able to get a bit deeper introduction to the `math` package in golang&#39;s standard library. We covered some few important functions and constants in the main math package along with the glimpse of other subpackages like `rand`, `cmplx` and `bits`. We didn&#39;t get too much in detail with those sub packages as they can be explored on a separate section of their own. Hopefully, you have got a godd overview of the math package in golang which again is really important aspect in programming.&#xA;&#xA;Thank you for reading. If you have any questions or feedback, please let me know in the comments or on social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Packages</title>
      <link>meetgor.com/golang-packages</link>
      <description>Exploring and understanding packages in Golang along with it&#39;s usage</description>
      <pubDate>Fri, 22 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In this 11th part of the series, we will be covering packages in golang. Package is a cool way to organize code in large projects. We can create a separate file which can include certain helper functions or variables from other files or scripts. There are couple of types of packages like packages from the standard library, open sourced community packages and custom packages that you can build of your own. In this particular section, we will be covering the fundamentals of packages and exploring the standard library in golang. &#xA;&#xA;## What is a Package ?&#xA;&#xA;Package in simplest of terms is a collection of go scripts that can serve a purpose. Just like `fmt` has several functions like `Println`, `Printf`, `Scan`, `Scanf`, etc. most packages have functions that we can use in our own programs to solve a simple problem. We have already created many packages but none of them have been super useful so far, we just used the statement `package main` and didn&#39;t use the package anywhere. Every package has a entry point called `main` along with a entry function `main` which is triggered when we run the package. &#xA;&#xA;```&#xA;- package_name&#xA;    - script_1.go&#xA;    - script_2.go&#xA;&#xA;    - sub_package_name&#xA;        - utility_1.go&#xA;    - go.mod&#xA;```&#xA;&#xA;The above is a simple folder structure for a package in golang, we have the package itself as the name of the folder. Inside of the package folder, we would have the scripts or sub-packages if any. Also there is a `go.mod` file in all go source package folders which contain the meta information about the package and it&#39;s dependencies. &#xA;&#xA;Let&#39;s take a look at the [fmt](https://github.com/golang/go/tree/master/src/fmt) package source code, it has a [print.go](https://github.com/golang/go/blob/master/src/fmt/print.go) file which has all the functions associated with printing, similarly separate files for different core functionality.&#xA;&#xA;We will soon into the details of packages in this series. Right now, we only care about the fundamentals of a package in golang.&#xA;&#xA;## Importing Packages&#xA;&#xA;We have been already importing a package since writing our hello world in go, the `fmt` package which holds some functions for formatting, printing, logging and various string input/output manipulation. &#xA;&#xA;```go&#xA;import &#34;fmt&#34;&#xA;```&#xA;&#xA;So, we have used the simple `import &#34;package&#34;` statement, but there are a couple of more ways to import packages if we have multiple packages to import.&#xA;&#xA;```go&#xA;import (&#xA;    &#34;fmt&#34;&#xA;    &#34;math&#34;&#xA;)&#xA;```&#xA;&#xA;Using the `()` and by specifying the name of the package we can import multiple packages at once. Also there is a harder way out there, if you really like to toil hard.&#xA;&#xA;```go&#xA;import &#34;fmt&#34;&#xA;import &#34;math&#34;&#xA;```&#xA;&#xA;This is generally avoided as it just looks too pythonic, we are in golang. &#xA;&#xA;### Aliasing Imported packages&#xA;&#xA;We can alias an package a name whatever we want for the usage in the rest of the script file. This allows a bit better semantics of longer package names into readable code. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;&#x9;r &#34;math/rand&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(r.Int())&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run import.go&#xA;3454565657742387432&#xA;```&#xA;&#xA;We have imported the package `math/rand`, here [rand](https://pkg.go.dev/math/rand@go1.18.1#Int) is a sub package of the main package math. Hence we have aliased the rand package as `r` and thus, we can use r to access all the functions and other types from the package. &#xA;&#xA;&#xA;### Blank Package Import&#xA;&#xA;We can even import the package but not use it without getting a compilation error. So, the blank identifier is used in golang to ignore the initialized or returned values from any context and avoid the compilation warning or errors.  &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;_ &#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run blank_import.go&#xA;```&#xA;&#xA;Here, we have imported `fmt` package with a `_` blank identifier but we didn&#39;t use it anywhere, still we don&#39;t get any error messages and it compiled the code successfully.&#xA;&#xA;## Standard Library Packages&#xA;&#xA;The Golang Standard Library has some good number of packages which can be used for some general tasks like formatting input/output, file handling, web requests, system commands, etc. You can check out the entire list along with the documentation on the [official website](https://pkg.go.dev/std). &#xA;&#xA;We can import these standard library packages just by parsing their name in the string quotes like we did with `fmt` as `&#34;fmt&#34;`. We have previously used the `rand` package from the math standard library package as a sub-package by using the statement `&#34;math/rand&#34;`, if we want we can import the entire `math` package as `&#34;math&#34;` but that&#39;s unwanted and we import only the package which we really need.&#xA;&#xA;There are other packages as well like `bufio` which is used for reading and performing operations with text, `os` for working with files systems and operating system level stuff, and other packages which are specific to use cases like rendering templates, time, sorting, math operations, encoding, etc. We will dive into some of them throughout this series. &#xA;&#xA;## Installing Packages&#xA;&#xA;We can now get into installing other packages which are not in the standard library. You can get the documentation along with all references for a particular package on the official Golang [package repository](https://pkg.go.dev/). We use the CLI command to grab the packages into our `GOPATH`. OK, GOPATH, we have not covered this!&#xA;&#xA;### GOPATH&#xA;&#xA;GOPATH is the path or the location in your system&#39;s disk where all the packages and modules are stored. You can get the default location of your GOPATH environment variable from the simple shell command.&#xA;&#xA;```&#xA;$ echo $GOPATH&#xA;C:\Users�cer\go&#xA;```&#xA;&#xA;It has a few folders namely, `bin`, `pkg`, and `src`. These folder server different purpose like: &#xA;&#xA;- `bin` for storing the binaries generated from `go install` command&#xA;- `pkg` for storing pre-compiled source files and objects for quicker generation of executables and compilation.&#xA;- `src` for storing all the go source files of packages and modules.&#xA;&#xA;### Go Get command&#xA;&#xA;Now, let&#39;s see how to install a package from the go community on GitHub.  &#xA;&#xA;```&#xA;go get github.com/gorilla/mux&#xA;```&#xA;&#xA;We have installed a package which is a powerful HTTP router and a URL dispatcher and it can also be used to make web applications. It&#39;s called `mux`, we won&#39;t be using it right away just to get a feel for installing and playing with packages at the moment. &#xA;&#xA;After executing the command `go get` you should see a folder to be added in the `$GOPATH\pkg\mod` as `github.com\gorilla` and inside of it we should have a mux folder with the latest version. So, the `go get` command is used to download and install a package along with its all dependencies.&#xA;&#xA;### Set up a project for using a package&#xA;&#xA;Now, we have got the package so we can import it from anywhere in our go environment. &#xA;&#xA;#### Create a new folder (any name)&#xA;&#xA;You can test a go package from a isolated environment from the GOPATH by creating using the mod command. &#xA;The `mod init` command is a official way to create modules in golang and it creates kind of a environment to work on a templated project and structure the project/module/package properly. &#xA;&#xA;```&#xA;go mod init&#xA;```&#xA;&#xA;#### Install the packages &#xA;&#xA;We have already installed the package but that was a global install in the GOPATH, so we need to install it in this module. &#xA;&#xA;```&#xA;go get github.com/gorilla/mux&#xA;```&#xA;&#xA;#### Use the package&#xA;&#xA;Now, we can move into actually using the package in our source go file. We won&#39;t do any thing complicated just a simple web server. It&#39;s too easy don&#39;t worry!&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;net/http&#34;&#xA;&#xA;&#x9;&#34;github.com/gorilla/mux&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#xA;&#x9;router := mux.NewRouter()&#xA;&#xA;&#x9;router.HandleFunc(&#34;/&#34;, Server)&#xA;&#xA;&#x9;http.ListenAndServe(&#34;:8000&#34;, router)&#xA;}&#xA;&#xA;func Server(writer http.ResponseWriter, request *http.Request) {&#xA;&#x9;writer.Write([]byte(&#34;Hello Mux!&#34;))&#xA;}&#xA;```&#xA;&#xA;We firstly setup a router(a pair of HTTP route with some logic) from the [NewRouter](https://pkg.go.dev/github.com/gorilla/mux#NewRouter) function provided by `mux`. We&#39;ll attach a function to this newly created router by pairing a URL with a function. So, in simple terms when the mentioned URL is visited or a GET request is sent(don&#39;t get into too much details) we want a function to be invoked or called which does something. Finally we will set up a web server that listens at a port with the created router.&#xA;&#xA;The final piece is the function which we will call when the URL is visited i.e. the `Server` function it can be any name. The function needs to have two arguments as it is invoked by a router, the writer and the request. The Writer is a Response writer i.e. to write the message to the server. We will simply use the [Write](https://pkg.go.dev/net/http#Header.Write) function to simply print a array of bytes. &#xA;&#xA;The type of the writer is specifically `http.ResponseWriter` as we want to write a simple HTTP response header. Also the request is a [http.Request](https://pkg.go.dev/net/http#Request) type as we simply accept a HTTP request.&#xA;&#xA;So, on running the following script, we will be able to see a simple HTTP response on the localhost at port `8000` or on your provided port.&#xA;&#xA;```&#xA;go run main.go&#xA;```&#xA;&#xA;![GO Gorilla MUX web server](https://res.cloudinary.com/techstructive-blog/image/upload/v1650645111/blog-media/gzje6ukyystp2x27u83o.png)&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, we were able to dive a bit deeper in golang packages and modules. We covered from installation to importing packages in Golang, we also touched on basics of initializing a module in Golang. Hopefully, we were able to get the basics covered when it comes to packages in Golang.&#xA;&#xA;Thank you for reading. If you have any questions or feedback, please let me know in the comments or on social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Pointers</title>
      <link>meetgor.com/golang-pointers</link>
      <description>Diving into the pointers and memory address(under the hood) things in Golang</description>
      <pubDate>Tue, 19 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;&#xA;## Introduction&#xA;&#xA;In the tenth part of the series, we will be looking into an interesting concept in programming i.e. Pointer. It&#39;s a simple thing but a really powerful concept. Using pointers we can do several things very easily rather than writing a lot of code for a simple thing. We will be looking into basic concepts like declaration, referencing, de-referencing, and some examples on passing by reference, along with a pointer to struct instances. &#xA;&#xA;&#xA;## Pointers&#xA;&#xA;Pointers are simple, it&#39;s just their use case that makes it a big concept. Pointers are really powerful, they can do a lot of things that might seem impossible for a given problem. A pointer is a variable but unlike another variable which stores values in the form of integers, string, boolean, etc. pointers store the memory address. Memory address can be any valid location in memory that generally holds a variable. &#xA;&#xA;So, using pointers we can play with the memory address of variables and modify the contents of the variable directly using the memory address rather than accessing the variable. In golang, we have ways to store pointers and perform operations for the same.&#xA;&#xA;## Declaring Pointers&#xA;&#xA;To declare pointers in golang, we can use the `*` before the type of data type we want to refer to. This means a pointer needs to specify which data type it is referencing as a measure of caution to mismatch types in the variable. Initially, the pointer variable is mapped to `&lt;nil&gt;` that is it points to nothing but a null pointer. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#x9;var ptr *int&#xA;&#x9;fmt.Println(ptr)&#xA;}&#xA;&#xA;```&#xA;&#xA;```&#xA;$ go run pointer.go&#xA;&lt;nil&gt;&#xA;```&#xA;&#xA;As we can see, the pointer that references an integer is initialized to nil. We have used `*` before the data type, this can be anything like `*string`, `*bool`, `*float64`, etc. &#xA;&#xA;## The * and &amp; in Pointers&#xA;&#xA;After declaring a pointer, we can now move into assigning a pointer a memory address. Using the `&amp;` or the ampersand operator we can get the memory address of a variable. &#xA;&#xA;```go&#xA;var n := 34&#xA;var a_pointer *int = &amp;n&#xA;fmt.Println(a_pointer)&#xA;```&#xA;&#xA;```&#xA;$ go run pointer.go&#xA;0xc0000a6080&#xA;```&#xA;&#xA;Here, we can see that the pointer variable is storing the memory address of an integer variable. Don&#39;t worry about the value of the pointer variable, it is just a memory location on your machine. So, we use the `&amp;` to access the memory address of any variable.&#xA;&#xA;We have seen that the `*` is used to declare a pointer variable, but it is also used for dereferencing a pointer. So, if we used `&amp;` to get the memory address of a variable, similarly we can use the `*` to get back the value from the memory address. Both are opposite in terms of accessing the value. &#xA;&#xA;```go&#xA;n := 34&#xA;var a_pointer *int = &amp;n&#xA;fmt.Println(a_pointer)&#xA;m := *a_pointer&#xA;fmt.Println(m)&#xA;```&#xA;&#xA;```&#xA;$ go run pointer.go&#xA;0xc0000a8080&#xA;34&#xA;```&#xA;&#xA;As we can see, we have accessed the value stored in the pointer variable(`a_pointer`) by using the `*`. Here, the variable which we have created `m` will be of type whatever is stored in the memory address of the provided pointer variable. In this case, it is `int`, it can anything.&#xA;&#xA;So, this is how `*` and the `&amp;` work in Golang. The `*` is used for declaring pointer variables as well as de-referencing pointer variables, and the `&amp;` operator is used for accessing the memory address of the variable. &#xA;&#xA;That&#39;s basically the concept of pointers in golang. It&#39;s that simple. Using the simple concept of referencing and de-referencing, we can perform some operations like passing by reference to functions which will allow us to actually pass the value rather than the copy of the variable&#39;s value. &#xA;&#xA;## Passing by Reference to Function&#xA;&#xA;Now we have the fundamentals of pointers cleared, we can move into actually using them to do some really useful operations. Generally, when we use parameters such as integers, strings, bool, etc. we are passing the copy of the variables into the function rather than the actual value of the variable. This is where pointers come in. By using pointers to pass the memory address of the variables we need to pass in we actually pass the location of the variables.&#xA;&#xA;Let&#39;s take a look at a simple example of a function that swaps the value of two variables.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func swap(x *int, y *int) {&#xA;&#x9;temp := *x&#xA;&#x9;*x = *y&#xA;&#x9;*y = temp&#xA;}&#xA;&#xA;func main() {&#xA;&#xA;    x := 3&#xA;&#x9;y := 6&#xA;&#x9;k := &amp;x&#xA;&#x9;p := &amp;y&#xA;&#x9;fmt.Printf(&#34;Before swapping : x = %d and y = %d.&#xA;&#34;, x, y)&#xA;&#x9;swap(k, p)&#xA;&#x9;fmt.Printf(&#34;After swapping  : x = %d and y = %d.&#xA;&#34;, x, y)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run pointer.go&#xA;Before swapping : x = 3 and y = 6.&#xA;After swapping  : x = 6 and y = 3.&#xA;```&#xA;&#xA;We can see here, that we have used pointers to pass the value of parameters to a function. Without using pointers, the value of the variable is passed as a copy but by using pointers, we are actually passing the memory address. In the main function, we first store the memory address of two variables `x` and `y` into two different pointer variables. We now can construct a function that accepts two memory addresses and perform further operations. &#xA;&#xA;Inside the function, we have de-referenced the pointer variables as with `*`. Don&#39;t confuse `x *int` with `*x`. We use `x *int` to make the function realize that we are passing a pointer variable of an integer value, and `*x` is used to de-reference the memory address which is stored in `x`. &#xA;&#xA;So, simply we &#xA;- store the value in the memory location stored at `x` in the temp variable&#xA;- store the value at the memory address stored in `y` into the memory address `x`. &#xA;- store the value of the temp variable into the memory address stored in `x`.&#xA;&#xA;We have successfully swapped two values without returning any values from the function.&#xA;&#xA;## Pointer to a Struct Instance/Object&#xA;&#xA;We can now even modify the values of Struct objects/instances by referencing the instance to a pointer. By assigning the pointer variable to a struct instance, we have access to its associated properties and function. Thereby we can modify the contents directly from the pointer variable.&#xA;&#xA;Let&#39;s take a look at a basic example of modifying properties using a pointer to a struct instance.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type Book struct {&#xA;&#x9;pages int&#xA;&#x9;genre string&#xA;&#x9;title string&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;new_book := Book{120, &#34;fiction&#34;, &#34;Harry Potter&#34;}&#xA;&#x9;fmt.Println(new_book)&#xA;&#x9;fmt.Printf(&#34;Type of new_book -&gt; %T&#xA;&#34;, new_book)&#xA;&#x9;book_ptr := &amp;new_book&#xA;&#x9;book_ptr.title = &#34;Games of Thrones&#34;&#xA;&#x9;fmt.Println(new_book)&#xA;}&#xA;&#xA;```&#xA;&#xA;```&#xA;$ go run pointer.go&#xA;{120 fiction Harry Potter}&#xA;Type of new_book -&gt; main.Book&#xA;{120 fiction Games of Thrones}&#xA;```&#xA;&#xA;So, we have created a pointer variable of the type which is a struct `Book`, this gives us access to the memory addresses associated with various properties defined in the struct. Using the pointer variable, we can access properties and thereby change the value directly as we have the memory address stored in `book_ptr`. So, if we say `book_ptr.title = &#34;Games of Thrones&#34;`, we are storing the string directly into the memory address of the `new_book` object as `book_ptr` refers to the memory addresses to the struct object `new_book`. &#xA;&#xA;Here, we have literally changed the value of a property in a struct object using pointers. This is really powerful and time-saving. If pointers were not a thing, you would have to write a separate function for doing the same. &#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, that&#39;s it we have covered enough basics of pointers so that we are able to understand the working of simple scripts or programs. Even simple data structures like slices or strings can be understood by using pointers in golang. From this part of the series, we were able to understand the declaration, referencing, and de-referencing of pointers along with passing by reference to functions and creating pointers to struct instances. &#xA;&#xA;Thank you for reading. If you have any questions or feedback, please let me know in the comments or on social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Structs</title>
      <link>meetgor.com/golang-structs</link>
      <description>Exploring the fundamentals of Structures in Golang</description>
      <pubDate>Thu, 14 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Moving on to the 9th part of the series, we will be understanding structs in golang. Structs are an important aspect of programming in Golang, they provide a way to define custom types and add functionality to them. We will be understanding the basics of operating on structs like declaration, initialization and adding functional logic into those structs. &#xA;&#xA;## Structs in Golang&#xA;&#xA;Structs or Structures in Golang are the sequences or collections of built-in data types as a single type interface. Just like we have int, string, float, and complex, we can define our own data types in golang. They can consist of built-in data types as mentioned and also certain functions or methods which can be used to operate on them. Using structs we can create custom data types that can meet the specific requirements of our problem. We can define structs and later inside functions we can create instances of those structures. &#xA;&#xA;Structures are like a template or blueprint representation of data. It doesn&#39;t hold the actual data in memory, it is just used to construct an object of that type. After defining a struct, we can create instances or objects of those structs. These instances actually hold data in memory in the run time, so we basically deal with objects in the actual program. We&#39;ll see certain concepts of creating instances, declaring and defining structs, accessing data from instances and so on in the following section of the article.&#xA;&#xA;```&#xA;Struct / Class &#xA;&#xA;Template / Structure for creating custom data types &#xA;&#xA;- Properties  (variables and constants defined inside a structure)&#xA;- Methods     (functions that are bound to a struct)&#xA;&#xA;```&#xA;&#xA;## Declaring Struct&#xA;&#xA;We can declare structs by using the keyword `type` followed by the name of the struct, after tha name, the `struct` keyword itself, and finally sets of parenthesis `{}`. Inside the parenthesis, we define the structure i.e. which type of data is to be stored and the name of those respective variables.&#xA;&#xA;```go&#xA;type Article struct {&#xA;    title string&#xA;    is_published bool&#xA;    words int&#xA;}&#xA;```&#xA;&#xA;We have declared a struct or a custom data-type or a class(not really) in golang with the name `Article` that has few associated properties/variables inside of it. We have `title` as a string, `is_published` as a boolean, and `words` as an integer value. This constructs a simple type of golang which has a defined structure. We can further use this Article struct as a data type in the main function or any appropriate scope for actually assigning the structure memory at runtime. &#xA;&#xA;### Struct Naming Convention&#xA;&#xA;There are a few things that we need to understand and make a note of, especially the naming convention.&#xA;&#xA;- The struct name should be capitalized if you want to make it publicly accessible.&#xA;- The variable/properties names i.e. `title`, `is_published`, and `words` should be also capitalized if you want to make them accessible from the struct instance.&#xA;&#xA;This might not be important right now but it is worth knowing for later use cases. Let&#39;s say we want to use a struct from other files or modules, for that the name of the struct in the file/script where the struct is defined should have the `Capitalized` convention. If you have a simple and single file script/program, you can keep it `lowercased` or `camelCased`. &#xA;&#xA;Leaving that aside, for now, we will try to focus on the essence of the structs in golang. &#xA;&#xA;## Creating Instances/Objects of Structs&#xA;&#xA;Now, after defining the struct we need to create instances or objects of them. This can be done in several ways like using Struct literal, Manual assignment, and using the new function. We&#39;ll look into each of them in this section.&#xA;&#xA;### Using struct literal&#xA;&#xA;The most simplest and straightforward way to initialize a struct is to use the struct literal just like we did with Maps, Slices, and Arrays. We basically parse the values of the respective fields in the struct.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type article struct {&#xA;&#x9;title        string&#xA;&#x9;is_published bool&#xA;&#x9;words        int&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;golang := article{&#34;Golang Intro&#34;, true, 2000}&#xA;&#x9;fmt.Println(golang)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run struct.go&#xA;{Golang Intro true 2000}&#xA;```&#xA;&#xA;We have created the object or instance of the struct `Article` using the shorthand notation or the walrus `:=` operator. Inside the `{}` braces, we can assign values but those values need to be in the same order as defined in the struct definition, else it gives a compilation error of `type mismatch`. So, here we have assigned the value `title`, `is_published`, and `word` as `Golang Intro`, `true`, and `2000` respective in that order. &#xA;&#xA;### Using Key-value pairs&#xA;&#xA;We can also use the `key-value` notation for assigning values in the instance. With the previous method, we need to specify and thus initialize all the properties at once, but using this method we have a bit more flexibility. &#xA;&#xA;```go&#xA;vim := Article{title: &#34;Vim: Keymapping&#34;, is_published: false}&#xA;fmt.Println(vim)&#xA;```&#xA;&#xA;```&#xA;$ go run struct.go&#xA;{Vim: Keymapping false 0}&#xA;```&#xA;&#xA;Here, we have provided the key i.e. the variable name inside the struct, and then provided the value to it separated by a colon `:`. Using this way of initializing instances of struct we have better control and flexibility in providing a default value for that object. In the example above, we didn&#39;t initialize the property `words` but it already initialized to `0` since the object is created hence the memory allocation is completed, and thereby it needs to have a default value.&#xA;&#xA;### Using the new function&#xA;&#xA;We can use the [new](https://pkg.go.dev/builtin#new) function to create a new instance of a struct. Though we can&#39;t provide an initial value, using the new function all the properties are initialized with their respective default values. Further, if we want to modify the values, we can access each property (variables in struct) using the `dot operator` and assign the desired values. &#xA;&#xA;```go&#xA;django := *new(Article)&#xA;fmt.Println(django)&#xA;```&#xA;&#xA;```&#xA;$ go run struct.go&#xA;{ false 0}&#xA;```&#xA;&#xA;We have used the new function to allocate memory for an instance of struct with the provided name. This function basically allocates all the properties of a default value and returns a pointer to that memory address. If we store the result of the new function in a variable object, we would get a pointer but we need the object itself, so we use `*` before the new function so as to de-reference the memory address from the pointer. &#xA;&#xA;So, we have stored the default values in the newly created object of Article structure in `django`, this gives the default values like an empty string `&#34;&#34;`, default boolean value `false` and default integer value `0`. If we don&#39;t dereference the pointer and use it like `djagno := new(Article)`, thereby we get a pointer in that variable as `&amp;{ false 0}`. Hence we use `*` before the new keyword. &#xA;&#xA;#### Accessing/Assigning values to properties&#xA;&#xA;We can now change the values of the properties in the object of the struct using the dot operator. We basically use the instance object name followed by a `.` and the property name to set its value.&#xA;&#xA;```go&#xA;django := *new(Article)&#xA;fmt.Println(django)&#xA;&#xA;django.title = &#34;Django View and URLs&#34;&#xA;django.words = 3500&#xA;django.is_published = true&#xA;fmt.Println(django)&#xA;```&#xA;&#xA;```&#xA;$ go run struct.go&#xA;{ false 0}&#xA;{Django View and URLs true 3500}&#xA;```&#xA;&#xA;So, here we have used the object name which is `django`, and access any property by name with the `dot operator`, thereby we set the value as per the requirement. Note, we have not used the `:=` operator as the properties have already been initialized, we simply need to modify the default value.&#xA;&#xA;&#xA;## Creating Functions associated to Structs&#xA;&#xA;We can now move into creating functions in the struct, by adding functions/methods in structs we can incorporate a lot of functionality into the structure of our data type. For instance, we can set the value of a string as `&#34;Empty&#34;` or `&#34;NA&#34;` beforehand rather than empty string `&#34;&#34;`. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type Mail struct {&#xA;&#x9;sender     string&#xA;&#x9;subject    string&#xA;&#x9;sent       bool&#xA;&#x9;word_count int&#xA;}&#xA;&#xA;func (m Mail) check_spam() {&#xA;&#x9;if m.subject == &#34;&#34; {&#xA;&#x9;&#x9;fmt.Println(&#34;Spam!&#34;)&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(&#34;Safe!&#34;)&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;mail_one := *new(Mail)&#xA;&#x9;fmt.Printf(&#34;Mail one: &#34;)&#xA;&#x9;mail_one.check_spam()&#xA;&#xA;&#x9;mail_two := Mail{&#34;xyz@xyz.com&#34;, &#34;Golang Structs&#34;, true, 100}&#xA;&#x9;fmt.Printf(&#34;Mail two: &#34;)&#xA;&#x9;mail_two.check_spam()&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run methods.go&#xA;Mail one: Spam!&#xA;Mail two: Safe!&#xA;```&#xA;&#xA;We define a function associated with a struct by providing the `struct-name` and a parameter name which can be just used inside of the function. Here, we have used `(m Mail)` so as to reference the object of the struct provided to it. This basically binds the function to the struct and hence it becomes a method of that struct. &#xA;&#xA;Further, we can access the properties from the struct by their name using the dot separator. We are just checking whether the subject property in the instance is empty or not and simply printing text to the console. We are accessing the function and calling it with the syntax as `instance_name.function_name()`, here the function name is `check_spam` and the object name is `mail_one` for the first instance. Thereby we have called the function which is bounded to the instance of the struct. As we have accessed the function after the instance name the binding of the function i.e. the statements `(m Mail)` has taken the current instance and parsed it as the instance of the struct. Hence we are able to access the current instance&#39;s properties within the function/method.&#xA;&#xA;#### Adding a return statement&#xA;&#xA;By simply providing the return type and return statement with value, we can create functions of specific return types. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type Mail struct {&#xA;&#x9;sender     string&#xA;&#x9;subject    string&#xA;&#x9;sent       bool&#xA;&#x9;word_count int&#xA;}&#xA;&#xA;func (m Mail) check_spam() bool {&#xA;&#x9;if m.subject == &#34;&#34; {&#xA;&#x9;&#x9;return true&#xA;&#x9;} else {&#xA;&#x9;&#x9;return false&#xA;&#x9;}&#xA;}&#xA;&#xA;func (m Mail) print_spam(spam bool) {&#xA;&#x9;if spam {&#xA;&#x9;&#x9;fmt.Println(&#34;Spam!!&#34;)&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(&#34;Safe!!&#34;)&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;mail_one := *new(Mail)&#xA;&#x9;fmt.Printf(&#34;Mail one: &#34;)&#xA;&#x9;is_mail_1_spam := mail_one.check_spam()&#xA;&#x9;mail_one.print_spam(is_mail_1_spam)&#xA;&#xA;&#x9;mail_two := Mail{&#34;xyz@xyz.com&#34;, &#34;Golang Structs&#34;, true, 100}&#xA;&#x9;fmt.Printf(&#34;Mail two: &#34;)&#xA;&#x9;is_mail_2_spam := mail_two.check_spam()&#xA;&#x9;mail_two.print_spam(is_mail_2_spam)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run methods.go&#xA;Mail one: Spam!!&#xA;Mail two: Safe!!&#xA;```&#xA;&#xA;We have modified the `check_spam` function which returns a boolean value. If the subject is empty it returns true else it returns false. Also, we have added a function `print_spam` function which takes in a parameter as a boolean value and prints text according to the value. This is how we work with functions in structs. We have parsed the return value of the `check_spam` function as a parameter to the `print_spam` function. &#xA;&#xA;&#xA;### Constructor in Structs&#xA;&#xA;Constructors are special methods that are invoked when the instance of a struct is created i.e. the properties are assigned an initial value or default value. In this way, we can perform basic operations which we need to perform after the instantiation of the struct.&#xA;&#xA;Golang does not have built-in constructors, but it is quite easy to create one. We simply need to create a function with an appropriate name(don&#39;t clash it with the struct name!!), by providing all the parameters that are in the struct so as to initialize them, and finally the return value as a reference to the struct instance. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;type Repository struct {&#xA;&#x9;name       string&#xA;&#x9;file_count int&#xA;}&#xA;&#xA;func New_Repository(name string, file_count int) *Repository {&#xA;&#x9;file_count++&#xA;&#x9;name = &#34;Test&#34;&#xA;&#x9;return &amp;Repository{name, file_count}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;blog := *New_Repository(&#34;&#34;, 0)&#xA;&#x9;fmt.Println(blog)&#xA;}&#xA;&#xA;```&#xA;&#xA;```&#xA;$ go run constructor.go&#xA;{Test 1}&#xA;```&#xA;&#xA;We have created a function that is technically acting like a constructor as it sets a default value to the properties in the structure. We have struct `Repository` containing `name` as a string and `file_count` as an integer. We created a Constructor function named `New_Repository` that basically takes in the properties in the struct, remember they haven&#39;t been initialized yet as we are writing the constructor for the very purpose. We have to parse the parameters with the initial value and let it modify once we have created the instance. &#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this part of the series, we are able to understand the basics of structs in golang. We covered declaration, definition, and adding methods in a struct. This gives a glimpse of Object-Oriented Programming in Golang. Thank you for reading. If you have any questions or feedback, please let me know in the comments or on social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Functions</title>
      <link>meetgor.com/golang-functions</link>
      <description>Understanding the basics of functions in Golang</description>
      <pubDate>Wed, 13 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the eighth part of the series, we will be exploring functions in golang. We will be diving into some basics of functions in golang like declaration, definition and calling. We won&#39;t be exploring all the topics of functions as it is quite a large topic to cover in one shot. So, building from the base, we will be starting from the basic declaration to simple return statements. &#xA;&#xA;## Functions in Golang&#xA;&#xA;Functions in golang are a simple way to structure a block of code that can be re-usable. Functions also allow us to process a piece of logic and return the output. Functions allow us to write readable and scalable code as we have to write the code once and we can re-use the functionality of it by calling it. &#xA;&#xA;## Declaring Functions &#xA;&#xA;We have already defined a function, if you have followed the series so far, or even written a `hello-world` application. The `main` function is the most fundamental function we can define in golang. The main is complicated if dive deeper but in the simplest of term it acts as a entry point for the entire program. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;func main() {&#xA;&#xA;}&#xA;```&#xA;&#xA;We have written the above code a lot of times till now, but never really talked about it&#39;s significance. Here we will understand the terminologies related to the main function. A function is declared with the `func` keyword along with the name of the function. There needs to be the `()` parenthesis after the name of the function, optionally it can take parameters inside the parameters to be used inside the function. &#xA;&#xA;We define the core functionality or the core logic of the function inside the braces `{}`. We also have the `return` keyword which can return values from the function to the block where we have called the function. Usually, we call a function from other function (most of the times it&#39;s the `main` function). The `return` keyword is not mandatory and it is usually added at the end of the function block, just before the closing braces `}`. &#xA;&#xA;```go&#xA;func hello_world_007() {&#xA;&#xA;}&#xA;```&#xA;&#xA;We can define a custom function outside the main function by giving it a appropriate name. For the time bwing we can leave it empty and further define the logic of the actual function. &#xA;&#xA;The name of the function can be given as per the following standards:&#xA;&#xA;- Using letters`a-z A-Z`, numbers`0-9`, underscore `_` as a name.&#xA;- Should not contain any spaces in-between the name.&#xA;- Should not begin with a number or underscore.&#xA;&#xA;## Defining Functions&#xA;&#xA;Inside the `{}` we define the actual functionality/logic of the function. The variables inside the function will remain local to the function and can&#39;t be accessed or altered from outside the function, though if we really want to access some global variables(from main or other functions) we can pass parameters, we will look into it in the next few sections. For time being, we will be focusing on the actual code block inside the function. &#xA;&#xA;```go&#xA;&#xA;func hello_world() {&#xA;    fmt.Println(&#34;Hello World&#34;)&#xA;}&#xA;```&#xA;&#xA;This is a basic function that just calls another function `Println` from the fmt package, which basically prints text in the console. Though, we are using the function Println, it won&#39;t print the content to the string as we are not using/calling the function. Now, we can get a step ahead and start working with variables inside the function.&#xA;&#xA;```go&#xA;func hello_world() {&#xA;    name := &#34;Gopher&#34;&#xA;    fmt.Println(&#34;Hello&#34;, name)&#xA;}&#xA;```&#xA;&#xA;We have now added the local variable `name `inside the function, so this variable can only we referred inside the particular function. &#xA;&#xA;## Calling Functions&#xA;&#xA;We can call the function from the main function or any other function by just specifying the name along with the `()` and optionally the parameters inside the parenthesis. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;    hello_world()    &#xA;}&#xA;&#xA;func hello_world() {&#xA;    name := &#34;Gopher&#34;&#xA;    fmt.Println(&#34;Hello&#34;, name)&#xA;}&#xA;&#xA;```&#xA;&#xA;```&#xA;$ go run func.go&#xA;Hello Gopher&#xA;```&#xA;&#xA;So, we define the function `hello_world` and call the function by using the statement `hello_world()` inside the main function and now, we are able to actually run the function. &#xA;&#xA;## Passing Parameters&#xA;&#xA;We can optionally parse variables from a function to other and process it for further computation and programming. So, we can pass parameters in a function by specifying the name to be used inside the function followed by the type of that variable. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;&#x9;greet_me(&#34;Meet&#34;)&#xA;&#x9;n := &#34;John&#34;&#xA;&#x9;greet_me(n)&#xA;}&#xA;&#xA;func greet_me(name string) {&#xA;&#x9;fmt.Println(&#34;Hello,&#34;, name, &#34;!&#34;)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run func.go&#xA;Hello, Meet !&#xA;Hello, John !&#xA;```&#xA;&#xA;We have used the parameter `name` as a string in the function and used it inside the function body. The parameter name which is to be called from the main function can be anything and not necessarily be the same as declared in the function declaration. For instance, we have used the variable in the main function `n` which is passed in the function call. We can even pass the value as it is to the function in golang.  &#xA;&#xA;## Return Keyword&#xA;&#xA;We can use the return keyword to actually return a value from the function and not just display the message. The returned value can be later used from other places in the program. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;&#x9;// return value&#xA;&#x9;y := line_eq(3, 1, 2)&#xA;&#x9;fmt.println(&#34;for x = 3 , y = &#34;, y)&#xA;}&#xA;&#xA;func line_eq(x int, m int, c int) int {&#xA;&#x9;return ((m * x) + c)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run func.go&#xA;for x = 3 , y =  5&#xA;```&#xA;&#xA;So, here we are able to fetch the returned value from the function and store it in another variable and further compute the required logic. We also need to specify the return type of the function after the parameters like `func (parameters) return-type { }`. Here, we need to return the specified type of the return value from the function else it would give a compilation error. &#xA;&#xA;So, we basically need to provide the return value and also the return statement to capture the value from the function call. &#xA;&#xA;### Multiple return values&#xA;&#xA;We can also provide multiple return values by providing a list of return values like `(type1 type2 type3 ....)`. We can return the values by separating the values by a comma. So, while calling the function, we need to specify the variables again as comma-separated name and this will capture the value from the function call.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;&#x9;// multiple return values&#xA;&#x9;s, c, odd := sqube(5)&#xA;&#x9;fmt.Println(&#34;for x = 5 , x^2 =&#34;, s, &#34;x^3 =&#34;, c)&#xA;&#x9;if odd == true {&#xA;&#x9;&#x9;fmt.Println(&#34;x is odd&#34;)&#xA;&#x9;} else {&#xA;&#x9;&#x9;fmt.Println(&#34;x is true&#34;)&#xA;&#x9;}&#xA;}&#xA;&#xA;func sqube(x int) (int, int, bool) {&#xA;&#x9;square := x * x&#xA;&#x9;cube := x * x * x&#xA;&#x9;var is_odd bool&#xA;&#x9;if x%2 == 0 {&#xA;&#x9;&#x9;is_odd = false&#xA;&#x9;} else {&#xA;&#x9;&#x9;is_odd = true&#xA;&#x9;}&#xA;&#x9;return square, cube, is_odd&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run func.go&#xA;for x = 5 , x^2 = 25 x^3 = 125&#xA;x is odd&#xA;```&#xA;&#xA;So, we have returned multiple values from the function like two integers and one boolean. The parameter is a single integer, now we need to parse 3 variables in order to capture all the values from the function call. Thus, we are able to get all the values from the function.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this part of the series, we are able to understand the basics of functions in golang. We covered from declaration, definition and simple return statements and function calling. Thank you for reading. If you have any questions or feedback, please let me know in the comments or on social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Maps</title>
      <link>meetgor.com/golang-maps</link>
      <description>Understanding the basics of Maps in Golang</description>
      <pubDate>Tue, 12 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the seventh part of the series, we will be covering Maps. We have covered some basic data structures like arrays and slices, and now we can move into maps or hash tables. Maps allow us to store key-value pairs of a particular type. In this part of the series, we will be covering the basics of Maps in Golang like declaration, iteration, and Creating, updating, and deleting keys from the map. &#xA;&#xA;## Maps in Golang&#xA;&#xA;Maps in golang are data structures that provide a way to store key-value pairs. It is also known as a hash table. Maps allow us to create unique keys which are associated with a value. It can be used to create a data structure that can have an item that is associated with a particular value, for example, the basic example of the map can be a frequency table of a list of numbers. We can store the frequency of each element occurring in the list. Let&#39;s say we have a list of numbers as `[3, 5, 9, 4, 9, 5, 5]`, we can create a map of the frequency of these elements as `[3:1, 5:3, 4:1, 9:2]`. Here, we have stored the information in the form of `key-value` pairs as a frequency. So, `3` has occurred one time, `5` 3 times, and so on. &#xA;&#xA;Maps are not stored in order of the numbers they are unordered so we need to manually sort them in the order we want. &#xA;&#xA;## Declaring Maps &#xA;&#xA;We can declare maps by defining the type of mapping like the two types we are mapping. We can map any type with any other, like a character with an integer, an integer with an integer as we saw earlier, etc. We have several ways to decalre maps in golang, like using map literal, make function, new function, and a few others. We&#39;ll look into each of them in a brief.&#xA;&#xA;### Simple map literal&#xA;&#xA;As we saw in the array and slices, we used the slice literals to declare and initialize an array or a slice. Similarly, we can use the map literal to create a map in golang. Here, we use the `map` keyword followed by the two types of data we are going to map with. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;&#xA;&#x9;char_freq := map[string]int{&#xA;&#x9;&#x9;&#34;M&#34;: 1,&#xA;&#x9;&#x9;&#34;e&#34;: 2,&#xA;&#x9;&#x9;&#34;t&#34;: 1,&#xA;&#x9;}&#xA;&#x9;fmt.Println(char_freq)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run map.go&#xA;map[M:1 e:2 t:1]&#xA;```&#xA;&#xA;We have used the map keyword to initialize a map with a `string` with `int`. The first data type is declared inside the square brackets`[]` and the second data type outside the square brackets. We use the `{}` to define the map values. We can even leave the `{}` empty. &#xA;&#xA;```&#xA;char_freq := map[string]int{}&#xA;```&#xA;&#xA;We initialize the values of the map by specifying the data for that data type in this example a string `&#34;&#34;` followed by a colon `:` and finally the value of the second pair data. Each value is separated by a comma(`,`). &#xA;&#xA;### Using make function&#xA;&#xA;We can even use the [make](https://pkg.go.dev/builtin#make) function to create a map in golang. The make function is used for allocating memory. The make function allocates memory which might be enough for the initial values provided. It allocates more memory as the map grows in size. We use the make function by providing the `map` keyword along with the data types of the key values pairs to be mapped. Optionally we can provide the capacity as we provided in the slice declaration. It basically doubles once it reaches the limit and is re-allocated. &#xA;&#xA;```go&#xA;marks := make(map[int]int)&#xA;marks[65] = 8&#xA;marks[95] = 3&#xA;marks[80] = 5&#xA;fmt.Println(marks)&#xA;```&#xA;&#xA;```&#xA;$ go run map.go&#xA;map[65:8 80:5 95:3]&#xA;```&#xA;&#xA;We have used the `make` function for declaring the map, the initial size is around 7 if not mentioned. After it hits 7, the capacity is mostly doubled and increased as per the modifications. &#xA;&#xA;### Using the new function&#xA;&#xA;We can even use the [new](https://pkg.go.dev/builtin#new) function(a bit hacky) to crated a map in golang. The new function basically is used to allocate memory but is not the same as the `make` function, it returns the memory address to an allocated pointer. So, we can set the value of the returned function call of the new function with a pointer variable. A pointer in golang is simply a reference to a memory address, we&#39;ll dive into pointers in a different section. After the pointer is assigned a memory address, we can refer to the address of that pointer and thus access the original value which is the map itself.&#xA;&#xA;```go&#xA;name := new(map[byte]int)&#xA;*name = map[byte]int{}&#xA;name_map := *name&#xA;&#xA;name_map[&#39;m&#39;] = 1&#xA;name_map[&#39;e&#39;] = 2&#xA;name_map[&#39;t&#39;] = 1&#xA;&#xA;fmt.Println(name_map)&#xA;&#xA;for k, _ := range name_map {&#xA;    fmt.Printf(&#34;%c&#xA;&#34;, k)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run map.go&#xA;map[101:2 109:1 116:1]&#xA;m&#xA;e&#xA;t&#xA;```&#xA;&#xA;So, we can see we created the map with the new function and stored the address into a pointer, later we initialized the empty map and stored the initial reference in the same pointer address. Then, we can finally store the map in another variable so that we can use it as a normal map. So, this is how we declare the map using the new function. &#xA;&#xA;## Access Keys and Values in Maps&#xA;&#xA;We can access the values by simply accessing them with the keys. Using the square bracket and the key literal into the braces, we get the value associated with that key. For example, the map `[&#34;M&#34;: 1, &#34;E&#34;: 2, &#34;T&#34;:1]`, we can use the `map_name[&#34;E&#34;]` which will get the value as `3`. &#xA;&#xA;### Length of Map&#xA;&#xA;The length of the map can be accessed using the len function, the len function returns the number of key-value pairs in the map. &#xA;&#xA;```go&#xA;char_freq := map[string]int{&#xA;    &#34;M&#34;: 1,&#xA;    &#34;e&#34;: 2,&#xA;    &#34;t&#34;: 1,&#xA;}&#xA;fmt.Println(char_freq)&#xA;fmt.Println(len(char_freq))&#xA;```&#xA;&#xA;```&#xA;$ go run map.go&#xA;map[M:1 e:2 t:1]&#xA;3&#xA;```&#xA;&#xA;## Check for existing Keys in Map&#xA;&#xA;We can check if a key exists in the map by using the comma-ok syntax. The key can be accessed using the first variable and if the key doesn&#39;t exist, the second variable is set to false. So, we can verify the existence of a key in the map using the two-variable approach.&#xA;&#xA;```go&#xA;name_map := map[byte]int{&#xA;    &#39;m&#39;: 1,&#xA;    &#39;e&#39;: 2,&#xA;    &#39;t&#39;: 1,&#xA;}&#xA;var key byte = &#39;t&#39;&#xA;value, exist := name_map[key]&#xA;if exist == true {&#xA;    fmt.Printf(&#34;The key %c exist and has value %d&#xA;&#34;, key, value)&#xA;} else {&#xA;    fmt.Printf(&#34;The key %c does not exist.&#xA;&#34;, key)&#xA;}&#xA;```&#xA;&#xA;```    &#xA;$ go run map.go&#xA;The key t exist and has value 1&#xA;```&#xA;&#xA;So, we can see the exist value is true if the key exists and false if it doesn&#39;t. So, we can then verify if a particular key exists in a map or not. &#xA;&#xA;## Adding and Modifying Keys/Values in Maps&#xA;&#xA;We can add a key-value pair in a map by just using the key as we did in the initialization process. We simply pass the key in the square braces `[]` and assign it a value appropriate to the data type used in the map. &#xA;&#xA;```go&#xA;cart_list := map[string]int{&#xA;    &#34;shirt&#34;: 2,&#xA;    &#34;mug&#34;: 4,&#xA;    &#34;shoes&#34;: 3,&#xA;}&#xA;&#xA;fmt.Println(cart_list)&#xA;&#xA;cart_list[&#34;jeans&#34;] = 1&#xA;cart_list[&#34;mug&#34;] = 3&#xA;fmt.Println(cart_list)&#xA;```&#xA;&#xA;```&#xA;$ go run map.go&#xA;map[mug:4 shirt:2 shoes:3]&#xA;map[jeans:1 mug:3 shirt:2 shoes:3]&#xA;```&#xA;&#xA;We can access the keys in the map by just using the key as it is and altering the value it holds, the same thing applies to the addition of the key-value pairs, we can use the key and assign the value associated with it. &#xA;&#xA;## Delete Keys in Maps&#xA;&#xA;We can delete the key-value pairs in the map, using the `delete` function. We pass in the `key` and the map to delete the key-value pair from the map. &#xA;&#xA;```go&#xA;cart_list := map[string]int{&#xA;    &#34;shirt&#34;: 2,&#xA;    &#34;mug&#34;:   4,&#xA;    &#34;shoes&#34;: 3,&#xA;}&#xA;fmt.Println(cart_list)&#xA;&#xA;cart_list[&#34;jeans&#34;] = 1&#xA;cart_list[&#34;mug&#34;] = 3&#xA;delete(cart_list, &#34;shoes&#34;)&#xA;&#xA;fmt.Println(cart_list)&#xA;```&#xA;&#xA;```&#xA;$ go run map.go&#xA;map[mug:4 shirt:2 shoes:3]&#xA;map[jeans:1 mug:3 shirt:2]&#xA;```&#xA;&#xA;So, we can see the key-value pair was deleted from the map. &#xA;&#xA;## Iterate over a Map&#xA;&#xA;We can iterate over a map similar to the range keyword iteration for slices and arrays, but the exception here, is that we use the key, value instead of the index, copy of an element in the map as the range. &#xA;&#xA;```go&#xA;is_prime := map[int]bool{&#xA;    7:  true,&#xA;    9:  false,&#xA;    13: true,&#xA;    15: false,&#xA;    16: false,&#xA;}&#xA;&#xA;for key, value := range is_prime {&#xA;    fmt.printf(&#34;%d -&gt; %t&#xA;&#34;, key, value)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run map.go&#xA;9 -&gt; false&#xA;13 -&gt; true&#xA;15 -&gt; false&#xA;16 -&gt; false&#xA;7 -&gt; true&#xA;```&#xA;&#xA;So, we can observe that we can access the keys and values in the map using the range keyword for iterating over the map. Inside the for loop, we can refer to the assigned values present in the map. &#xA;&#xA;### Use only key or value while iterating&#xA;&#xA;If we don&#39;t use either of the variables like `key` or  `value`, the compiler might give us the unused variable error, so we have an alternative to use don&#39;t care variables namely the `_` underscore character.&#xA;&#xA;```go&#xA;is_prime := map[int]bool{&#xA;    7:  true,&#xA;    9:  false,&#xA;    13: true,&#xA;    15: false,&#xA;    16: false,&#xA;}&#xA;&#xA;for key, _ := range is_prime {&#xA;    fmt.Printf(&#34;Key : %d&#xA;&#34;, key)&#xA;}&#xA;&#xA;for _, value := range is_prime {&#xA;    fmt.Printf(&#34;Value: %t&#xA;&#34;, value)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run map.go&#xA;Key : 7&#xA;Key : 9&#xA;Key : 13&#xA;Key : 15&#xA;Key : 16&#xA;Value: true&#xA;Value: false&#xA;Value: true&#xA;Value: false&#xA;Value: false&#xA;```&#xA;&#xA;So, we use the `_` to ignore the usage of the variable in the loop, if we are not sure of using any variable, we can ignore it completely with the underscore operator and thus prevent any compilation errors/warnings. So, here if we want to only access keys, we use `key, _` in order to fetch only keys and silence the values in the map. If we want to access only the values, we can use `_, value` so as to get all the values from the map. The variable name `key` or `value` can be anything but make sure to use those only inside the loop.&#xA;&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this part of the series, we were able to understand the basics of maps in golang. We covered some basics stuff including the declaration, initialization, and iteration. Maps are quite simple but important for creating interesting applications.&#xA;&#xA;Thank you for reading. If you have any questions or feedback, please let me know in the comments or on social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Slices</title>
      <link>meetgor.com/golang-slices</link>
      <description>Understanding the basics of slices in Golang</description>
      <pubDate>Thu, 07 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the sixth part of the series, we will be covering slices. Slices are almost like arrays but have a lot of advantages over them, including flexibility and control over them. We can adjust the size and capacity of the data which we will store at a place using slices. We will be covering basic declaration, initialization, capacity in slices, iteration, and accessing the elements of the slices.&#xA;&#xA;## Slices in Golang&#xA;&#xA;Slices are Arrays but can provide more control and are more flexible than arrays. In slices, we can increase the size of the array/list of elements whenever required. We can even have a capacity for slices i.e. the maximum length we wish to grow the initial slice. &#xA;&#xA;Though slices are dynamic, it has a few disadvantages like compile safety, access time, comparability, etc. Everything has its pros and cons, you have to decide on the right data structure as per your problem statement and requirements. &#xA;&#xA;## Declaring Slices &#xA;&#xA;There are a couple of different ways in which we can declare a slice that might be an uninitialized or initialized slice. Some of the standard ways include using the `make` function and the normal array-like declaration though there are other methods as well including using the `new` function. We&#39;ll explore some of the most easiest and handy ways to declare and initialize slices. &#xA;&#xA;### Using array-like declaration&#xA;&#xA;Slices can be declared quite similar to arrays but we don&#39;t enter the initial size(length). As discussed in the array part, we can use the var keyword and the square brackets. Though you don&#39;t have to enter the length inside the `[]` brackets, the type of the slice needs to enter.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;    var marks [] int&#xA;    fmt.Println(marks)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;[]&#xA;```&#xA;&#xA;So, initially, it is empty without an element as we have not initialized any elements. If you enter the length in the `[]` brackets, it would be an array and not a slice.&#xA;&#xA;We can also initialize the elements in the slice with the slice literal as we did with arrays using an array literal. &#xA;&#xA;```go&#xA;frameworks = []string{&#34;Django&#34;, &#34;Laravel&#34;, &#34;Flask&#34;, &#34;Rails&#34;}&#xA;fmt.Println(frameworks)&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;[Django Laravel Flask Rails]&#xA;```&#xA;&#xA;### Using make function&#xA;&#xA;We can even use the [make](https://pkg.go.dev/builtin#make) function to create a slice in golang. The make function basically allows us to create a slice by providing the length as well as the capacity. Let&#39;s clear the concept of Capacity and Slice first.&#xA;&#xA;#### Capacity in Slice&#xA;&#xA;Capacity in slices is the initial value provided during the declaration of a slice. It basically holds the capacity of the slice to grow beyond the length. OK, let&#39;s take an example, If you declare a slice using make with length 3 and capacity 5, you initially can access 3 elements but memory has been allocated for 5 elements, if your slice exceeds this capacity it will double its original capacity. &#xA;&#xA;#### Obtain Length and Capacity of Slice &#xA;&#xA;We can get the capacity by using the [cap](https://pkg.go.dev/builtin#cap) function just like the `len` function. In slices, we can use the lens function to get the length and the cap function to get its underlying capacity to grow.&#xA;&#xA;It&#39;s just a way for us to manage the memory reallocation for a slice. Slices under the hood are arrays with a more dynamic punch. So, now we can a bit confidently move to the make function for declaring slices.&#xA;&#xA;### Back to make function&#xA;&#xA;The Make function is used to declare and initialize a slice (not only slice but maps and channels as well). The function primarily takes in 3 parameters namely, the type of slice, the initial length of the slice, and optionally the capacity of the slice. If we don&#39;t provide the capacity, the capacity is set the same as the length.&#xA;&#xA;```go&#xA;var langs = make([]string, 3, 5)&#xA;&#xA;langs[0], langs[1], langs[2] = &#34;Python&#34;, &#34;Go&#34;, &#34;Javascript&#34;&#xA;fmt.Println(langs)&#xA;&#xA;fmt.Printf(&#34;Length = %d &#xA;Capacity = %d&#xA;&#34;, len(langs), cap(langs))&#xA;&#xA;langs = append(langs, &#34;Java&#34;, &#34;Kotlin&#34;, &#34;PHP&#34;)&#xA;&#xA;fmt.Println(langs)&#xA;fmt.Printf(&#34;Length = %d &#xA;Capacity = %d&#xA;&#34;, len(langs), cap(langs))&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;[Python Go Javascript]&#xA;Length = 3&#xA;Capacity = 5&#xA;[Python Go Javascript Java Kotlin PHP]&#xA;Length = 6&#xA;Capacity = 10&#xA;```&#xA;&#xA;So, there are a lot of things to take in here. We use the make function by parsing in three parameters as said the type in the form of `[]type` as a distinction for creating slices because we also use the map to create maps and channels. The next two parameters are length and capacity. So, we have initialized a slice of type string, length 3 i.e. we are saying we will initially access only three elements from the array, finally, the third parameter is the capacity which will be the already initialized array under the hood for the slice. So, we have already created an array(under the hood) with 5 elements initialized but only 3 accessible from the slice interface.&#xA;&#xA;Further, we initialize/modify the elements in the created slice. We set 3 elements to some strings and that way we have all elements filled with non-default values in the slice. Now if we say `langs[3] = &#34;Something&#34;` it would give an error like `panic: runtime error: index out of range [3] with length 3`. This is a panic in golang which can be triggered in one of the ways in the slice when you access an unreferenced element in it. We have initialized the element but not in the slice interface. So, we have a particular function called append which appends and thus grows the length beyond its current length and refers to the elements initialized from the capacity.&#xA;&#xA;So initially the capacity was 5 and after adding the 6th element, it doubled down to `10`. So, under the hood, all 5 elements in the array would have been re-allocated into a new memory location and the sixth element would have been added to the next location. This is how we efficiently re-allocate memory for elements in slices. We have a bit more control over the length and are more flexible than arrays.&#xA;&#xA;### Using new function&#xA;&#xA;The [new](https://pkg.go.dev/builtin#new) function in golang is used to allocate a slice/any other type. We can use the new function so as to mimic the make function by adding a bit of value like the initial capacity and length. You can refer to the [article](https://www.golangprograms.com/go-language/slices-in-golang-programming.html) for providing the original idea. &#xA;&#xA;```go&#xA;langs2 := new([3]string)[0:2]&#xA;&#xA;langs2[0], langs2[1] = &#34;Python&#34;, &#34;Go&#34;&#xA;fmt.Println(langs2)&#xA;&#xA;fmt.Printf(&#34;Length = %d &#xA;Capacity = %d&#xA;&#34;, len(langs2), cap(langs2))&#xA;&#xA;langs2 = append(langs2, &#34;Java&#34;, &#34;Kotlin&#34;, &#34;PHP&#34;)&#xA;&#xA;fmt.Println(langs2)&#xA;fmt.Printf(&#34;Length = %d &#xA;Capacity = %d&#xA;&#34;, len(langs2), cap(langs2))&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;Length = 2&#xA;Capacity = 3&#xA;[Python Go Java Kotlin PHP]&#xA;Length = 5&#xA;Capacity = 6&#xA;```&#xA;&#xA;So, it would work almost similar to the make function. But by default, it would work as nil if you don&#39;t provide any length in the `[]` brackets like `new([]string)`. This will create a empty slice `[]` with zero capacity and zero length.&#xA;&#xA;&#xA;## Adding elements in Slice&#xA;&#xA;We had a few spoilers for this already with the `append` function. The [append](https://pkg.go.dev/builtin#append) takes in the variable and then the list of values that we want to add. Here, if the capacity of the slice is exceeded, it re-allocates the slice to a new location, and the elements are moved to that location and then the provided elements are added. &#xA;&#xA;```go&#xA;var percentages = []float64{78.8, 85.7, 94.4, 79.8}&#xA;fmt.Println(percentages)&#xA;percentages = append(percentages, 60.5, 75.6)&#xA;fmt.Println(percentages)&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;[78.8 85.7 94.4 79.8]&#xA;[78.8 85.7 94.4 79.8 60.5 75.6]&#xA;```&#xA;&#xA;So, here we can see the append function adding the elements in a slice. You can pass as many elements(MaxInt i.e. int64 or int32 elements precisely) you require in the append function. Calling the append function, again and again, might degrade the efficiency though, so make sure to add a right number of elements in a single call.&#xA;&#xA;## Accessing and Modifying elements in Slice&#xA;&#xA;We can simply access the elements using the index in the `[]` brackets. But there is more to that in slices. We can actually get slices of slices. Even in arrays or slices, we can get the particular elements between a specific two indices like 2 and 4, so we can write `array[2:4]` to get elements at index `2`, and `3` the upper bound is non-inclusive. But if we want to have all the elements from a specific index to the last element, we can leave the number blank as `[2:]` would give elements from index 2 to the last index in the array/slice.&#xA;&#xA;```go&#xA;scores := []int{80, 85, 90, 75, 60, 56, 83}&#xA;fmt.Println(scores)&#xA;fmt.Println(&#34;From index 2 to 4&#34;, scores[2:5])&#xA;fmt.Println(&#34;From index 0 to 2&#34;, scores[:3])&#xA;fmt.Println(&#34;From index 3 to 5&#34;, scores[3:])&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;[80 85 90 75 60 56 83]&#xA;From index 2 to 4 [90 75 60]&#xA;From index 0 to 2 [80 85 90]&#xA;From index 3 to 5 [75 60 56 83]&#xA;```&#xA;&#xA;So, we are able to perform index slicing in golang on arrays and slices.&#xA;Further, as for the array, we can also modify elements in slices. Using the index of that element, we can access the element and perform operations on it and thus change the literal value of the element.&#xA;&#xA;```go&#xA;word := []byte{&#39;f&#39;, &#39;u&#39;, &#39;z&#39;, &#39;z&#39;, &#39;y&#39;}&#xA;fmt.Printf(&#34;%s&#xA;&#34;, word)&#xA;word[0] = &#39;b&#39;&#xA;word[len(word)-1] = &#39;z&#39;&#xA;fmt.Printf(&#34;%s&#xA;&#34;, word)&#xA;```&#xA;&#xA;```&#xA;fuzzy&#xA;buzzz&#xA;```&#xA;&#xA;So, now we can also modify existing values of elements in slices. &#xA;&#xA;## Deleting elements from Slice&#xA;&#xA;We can also remove an element from the slice i.e. shrink the length of the slice. There is no function to remove an element from the slice, but we can work around with the append function in golang. So, in the slice before the element&#39;s index to be deleted is appended with all the elements after the index of the element to be deleted.&#xA;&#xA;```&#xA;10 20 30 40 50 60&#xA;0  1  2  3  4  5&#xA;&#xA;Delete the element at index -&gt; 2&#xA;&#xA;Copy from 3 to 5 into the slice from 0 to 1&#xA;&#xA;// append(slice[:2], slice[2+1:]&#xA;            ^            ^&#xA;            |            | &#xA;          10 20       40 50 60        &#xA;&#xA;append 40 50 60 -&gt; 10 20&#xA;&#xA;10 20 40 50 60&#xA;```&#xA;&#xA;Here in the above example, we append the indices after the element to be deleted into the slice of elements before the `to be deleted element`.  &#xA;&#xA;```go&#xA;marklist := []int{80, 85, 90, 75, 60}&#xA;fmt.Println(marklist)&#xA;&#xA;var index int&#xA;fmt.Printf(&#34;Enter the index to be deleted: &#34;)&#xA;fmt.Scan(&amp;index)&#xA;&#xA;elem := marklist[index]&#xA;&#xA;&#xA;// append in such a way that the element to be removed is excluded&#xA;&#xA;marklist = append(marklist[:index], marklist[index+1:]...)&#xA;&#xA;&#xA;fmt.Printf(&#34;The element %d was deleted.&#xA;&#34;, elem)&#xA;fmt.Println(marklist)&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;&#xA;[80 85 90 75 60]&#xA;Enter the index to be deleted: 3&#xA;The element 75 was deleted.&#xA;[80 85 90 60]&#xA;```&#xA;&#xA;## Iterate through a slice&#xA;&#xA;As arrays are under the hood modifications of arrays, we have a quite similar approach to iterating over slices in golang.&#xA;&#xA;### Using three statements for loop&#xA;&#xA;We can use the three statements for loop i.e. the initialization, condition, and incrementation procedure. The counter is set from 0 or any other starting value as the index of the slice, next we have the end loop condition i.e. a condition to check until when to exit, and finally the amount to which we need to increment the counter.&#xA;&#xA;```go&#xA;code := [7]rune{&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;a&#39;, &#39;n&#39;, &#39;g&#39;}&#xA;for i := 0; i &lt; len(code); i++ {&#xA;    fmt.Printf(&#34;%c&#xA;&#34;, code[i])&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;g&#xA;o&#xA;l&#xA;a&#xA;n&#xA;g&#xA;```&#xA;&#xA;### Using Range-based for loop&#xA;&#xA;We can use range-based for loops to iterate over the slice elements. The range keyword is passed with the slice name or the slice of an array to iterate over. Using the two variables i.e. the iterator and the copy of the element, we can access the index and the element in the slice.&#xA;&#xA;```go&#xA;scores := []int{80, 85, 90, 75, 60, 56, 83}&#xA;for _, s := range scores {&#xA;    fmt.Println(s)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;80&#xA;85&#xA;90&#xA;75&#xA;60&#xA;56&#xA;83&#xA;```&#xA;&#xA;We can also use a slice of slice i.e. scores[:4] to access a specific element in the range using index slicing.&#xA;&#xA;```go&#xA;scores := []int{80, 85, 90, 75, 60, 56, 83}&#xA;for _, s := range scores[1:4] {&#xA;    fmt.Println(s)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;85&#xA;90&#xA;75&#xA;```&#xA;&#xA;### Using for loop with range&#xA;&#xA;We can even use them for loop as a while loop to look and get a bit of both the above methods like the range method and the typical for loop access. &#xA;&#xA;```go&#xA;start, i, end := 2, 2, 5&#xA;&#xA;modes := []string{&#34;normal&#34;, &#34;command&#34;, &#34;insert&#34;, &#34;visual&#34;, &#34;select&#34;, &#34;replace&#34;}&#xA;&#xA;for range scores[start:end] {&#xA;    fmt.Printf(&#34;Element at index %d = %s &#xA;&#34;, i, modes[i])&#xA;    i++&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run slices.go&#xA;Element at index 2 = insert&#xA;Element at index 3 = visual&#xA;Element at index 4 = select&#xA;```&#xA;&#xA;So by using the range keyword we were able to iterate over the slice but without assigning the iterator and the copy of the element, we manually set a counter `i` and increment it as per our liking. Using index slicing we were able to get the elements between particular indices.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this part of the series, we were able to understand the basics of slices in golang. We covered some basics stuff including the declaration, initialization, and iteration. We also covered the under the hood working of slices and how to relate with the arrays.&#xA;Thank you for reading. If you have any questions or feedback, please let me know in the comments or on social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Arrays</title>
      <link>meetgor.com/golang-arrays</link>
      <description>Understanding the basics of Arrays in Golang</description>
      <pubDate>Wed, 06 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In this fifth section of Golang, we will be understanding the basics of arrays. We will be covering some basic operations on arrays like declaration, initialization, modifications, and iterating over an array.&#xA;&#xA;## Declaring Arrays&#xA;&#xA;Arrays are type of data structure that allow us to store multiple items at continuous memory locations of the same type. In golang, we can create arrays similar to any variable but by adding a few bits and pieces like the `[]` square braces, length of the array, values, etc. In golang, we cannot resize the length once it is initialized.&#xA;&#xA;To create a basic array in golang, we can use the following code:&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;    var languages[4]string&#xA;    languages[0] = &#34;Python&#34;&#xA;    fmt.Println(languages)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run basic.go&#xA;[Python   ]&#xA;```&#xA;&#xA;   Here, we have initialized a string array of size 4 and not initialized any values of the elements in the declaration. We later set the value of the 0th index or the first element in the array to a string and still rest of the elements are by default set to empty strings `&#34;&#34;`. The point ot be noted here, is that the size of the array cannot be changed later nor you can leave the size empty while declaring an array in Golang.&#xA;   &#xA;We can even initialize elements at the time of declaring the array as follows:&#xA;&#xA;```go&#xA;lang_array := [4]string {&#34;Python&#34;, &#34;Go&#34;, &#34;Javascript&#34;, &#34;C++&#34;}&#xA;fmt.Println(lang_array)&#xA;```&#xA;&#xA;```&#xA;$ go run basic.go&#xA;[Python Go Javascript C++]&#xA;```&#xA;&#xA;So, we use the walrus operator `:=` to initialize an array with the values at the time of declaration.  &#xA;&#xA;### Letting Compiler makeout the array length&#xA;&#xA;We can even let the compiler decide the length of the array, using the `...` syntax inside the brackets. This is limited by using the array literal that is by initializing values in the `{}` braces. So, all the elements need to be declared in the array.&#xA;&#xA;```go&#xA;cart := [...]string {&#34;Bag&#34;, &#34;Shirt&#34;, &#34;Watch&#34;, &#34;Book&#34;}&#xA;fmt.Println(cart)&#xA;```&#xA;&#xA;```&#xA;$ go run basic.go&#xA;[Bag Shirt Watch Book]&#xA;```  &#xA;   &#xA;## Access and Modify Elements&#xA;&#xA;To access an element in the array, we can use the index of that element which starts from 0 as usual in programming.&#xA;&#xA;```go&#xA;marks := [6]int {85, 89, 75, 93, 98, 60}&#xA;fmt.Println(marks[1])&#xA;fmt.Println(marks[5])&#xA;fmt.Println(marks[3])&#xA;```&#xA;&#xA;```&#xA;$ go run basic.go&#xA;89&#xA;60&#xA;93&#xA;```&#xA;   We can now, access the element at a particular index in the array. Now, we will see how to modify or edit the elements which are already initialized.&#xA;&#xA;```go&#xA;name := [5]byte {&#39;f&#39;,&#39;u&#39;,&#39;z&#39;,&#39;z&#39;,&#39;y&#39;}&#xA;fmt.Printf(&#34;%s&#xA;&#34;,name)&#xA;name[0] = &#39;b&#39;&#xA;name[4] = &#39;z&#39;&#xA;fmt.Printf(&#34;%s&#xA;&#34;,name)&#xA;```&#xA;&#xA;```&#xA;$ go run basic.go&#xA;fuzzy&#xA;buzzz&#xA;```&#xA;   By accessing the index of the element we can set a appropriate value to the element in the array and thus we have modified the contents of the array.&#xA;&#xA;## Find Length of Array&#xA;&#xA;To find the length of the Array, we have the `len` function. The [len](https://pkg.go.dev/builtin#len) function takes in the array as the parameter and returns the size of the array(int).&#xA;&#xA;```go&#xA;code := [7]rune {&#39;#&#39;, &#39;5&#39;, &#39;g&#39;, &#39;t&#39;, &#39;m&#39;, &#39;y&#39;, &#39;6&#39;}&#xA;fmt.Println(&#34;The length of the array is :&#34;, len(code))&#xA;```&#xA;&#xA;```&#xA;$ go run basic.go&#xA;The length of the array is : 7&#xA;```&#xA;   In the previous few section, we talked about letting the compiler make out the length of the array while declaring and initializing the array, we can use the len function to calculate the length of the array for further computation&#xA;&#xA;```go&#xA;cart := [...]string {&#34;Bag&#34;, &#34;Shirt&#34;, &#34;Watch&#34;, &#34;Book&#34;}&#xA;fmt.Printf(&#34;There are %d items in your cart&#xA;&#34;, len(cart))&#xA;```&#xA;&#xA;```&#xA;$ go run basic.go&#xA;There are 4 items in your cart&#xA;```&#xA;&#xA;We can now get the length of the arrays even with `[...]` syntax using the len function.&#xA;&#xA;## Iterate over an Array&#xA;&#xA;We can move on to the most important aspect when it comes to arrays i.e. to iterate over each element. We can use various types of for loops like the three statement for loops, range based loop or while loop.&#xA;&#xA;### Three statement for loop&#xA;&#xA;We can use the three statement for loop, the initialization statement as to `0`, condition to be the counter (i) should be less than the length of the array by using the `len` function and increment each time by one.&#xA;&#xA;```go&#xA;code := [7]rune {&#39;#&#39;, &#39;5&#39;, &#39;g&#39;, &#39;t&#39;, &#39;m&#39;, &#39;y&#39;, &#39;6&#39;}&#xA;&#xA;for i := 0; i&lt;len(code); i++{&#xA;    fmt.Printf(&#34;%c&#xA;&#34;,code[i])&#xA;}&#xA;```  &#xA;&#xA;```&#xA;$ go run basic.go&#xA;#&#xA;5&#xA;g&#xA;t&#xA;m&#xA;y&#xA;6&#xA;```&#xA;&#xA;   Thus, we can iterate over the array with three statement for loop in golang.&#xA;&#xA;### Using range-based loop&#xA;&#xA;We can use the `range` keyword to iterate over the arrays in golang. The range keyword is used to iterate over the array by taking two variables i.e. the iterator and the copy of the element in the iterator. We don&#39;t have any use of the iterator so we say it as `_`, otherwise it gives a warning/error of not using declared variables. So, we only require the copy of the element in this case, so sayit as `s` or any other name you like.&#xA;&#xA;```go&#xA;cart := [...]string {&#34;Bag&#34;, &#34;Shirt&#34;, &#34;Watch&#34;, &#34;Book&#34;}&#xA;&#xA;for _, s := range cart{&#xA;    fmt.Println(s)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run basic.go&#xA;Bag&#xA;Shirt&#xA;Watch&#xA;Book&#xA;```    &#xA;Thus, using the range based for loops we were able to iterate over the array for each element without needing any check condition and incrementation of the counter/iterator.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this part of the series, we were able to understand the baiscs of arrays in golang. We covered from declaration of arrays to iteration.&#xA;Thank you for reading. If you have any questions or feedback, please let me know in the comments or on social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Input</title>
      <link>meetgor.com/golang-input</link>
      <description>Understanding to perform user input in Golang</description>
      <pubDate>Tue, 05 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In this fourth section of Golang, we will be understanding the basics of user input. In golang, we can get user input with several functions most of which are similar to the `C` programming language like `scanf`. This type of input is quite powerful and gives more control on the input to be received.&#xA;&#xA;## Scan Function&#xA;&#xA;The [Scan](https://pkg.go.dev/fmt#Scan) function helps in getting a value with space as delimiter i.e. The input is stored before a space is encountered. This means the input is only limited to adding a space or a new line. We can use the function by passing the reference to the variable we are going to store the input value. So, we can have a basic input in Golang as follows:&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;    var pname string&#xA;    fmt.Println(&#34;Enter your favourite programming language: &#34;)&#xA;    fmt.Scan(&amp;pname)&#xA;    fmt.Println(&#34;So, your favourite programming language is&#34;,pname)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run scan.go&#xA;Enter your favorite programming language:&#xA;python&#xA;So, your favorite programming language is python&#xA;```&#xA;&#xA;We need to declare the variable to take input as we need a reference of that variable to store the input. We will be talking about `&amp;` and pointers in a separate article. We use the `Scan` function by passing the reference to the variable `pname` like `&amp;pname` which means, fetch the memory address of the variable `name`, we just pass the address as `int` to the Scan function and it does the rest to store the input value in it. We then as usual access the variable and operations on it.&#xA;&#xA;Here, if you add a space in the input, the value after the space won&#39;t be picked by the Scan function. It strictly stops accepting values input after it sees space. We can use this to input multiple variables at once. We know scan gets input before encountering space, so we can pass multiple variable references and add them as input.&#xA;&#xA;```go&#xA;var (&#xA;    name   string&#xA;    age    int&#xA;    gender rune&#xA;)&#xA;fmt.Println(&#34;Enter your name age and gender: &#34;)&#xA;fmt.Scan(&amp;name, &amp;age, &amp;gender)&#xA;fmt.Printf(&#34;Hello %s, you are a %c and %d years old&#34;, name, gender, age)&#xA;```&#xA;&#xA;```&#xA;$ go run scan.go&#xA;Enter your name age and gender:&#xA;Meet 19 77&#xA;Hello Meet, you are a M and 19 years old&#xA;```&#xA;&#xA;Here, we are declaring multiple variables like `name`, `age`, and `gender` as `string`, `int`, and `rune` respectively. Then, we can input all of these in a single scan statement by comma-separated variables. Here, we need to input the `rune` as an int value because under the hood it is an integer alias. So, we inputted `77` which is equivalent to `M` in ASCII characters and even Unicode character sets. Thus, we were able to input multiple variables with the Scan function.&#xA;&#xA;## Scanf functions&#xA;&#xA;The [Scanf](https://pkg.go.dev/fmt#Scanf) function is quite similar to the `scanf` in C programming language as it allows to specify the type of the incoming input. This will solve the problem of us inputting `77` instead of `M` in the gender variable in the previous example. The Scanf function allows us to take input by specifying the placeholder types and the delimiters as well. The delimiter is basically the separator between two or more entities. We can either use space separation or `&#xA;` as an input delimiter i.e. the way we want to separate inputs from each other while taking input.&#xA;&#xA;```go&#xA;var (&#xA;    name   string&#xA;    age    int&#xA;    gender rune&#xA;)&#xA;fmt.Println(&#34;Enter your name age and gender: &#34;)&#xA;fmt.Scanf(&#34;%s %d %c&#34;, &amp;name, &amp;age, &amp;gender)&#xA;fmt.Printf(&#34;Hello %s, you are a %c and %d years old&#34;, name, gender, age)&#xA;```&#xA;&#xA;```&#xA;$ go run scanf.go&#xA;Enter your name age and gender:&#xA;Meet 12 M&#xA;Hello Meet, you are a M and 12 years old&#xA;&#xA;&#xA;```&#xA;&#xA;How cool is that? It definitely gives much more control on what and how to take input. We are taking input as only space-separated values. Let&#39;s now try to get more control over how the input will be taken and stored.&#xA;&#xA;```go&#xA;var (&#xA;    name   string&#xA;    age    int&#xA;    gender rune&#xA;)&#xA;fmt.Println(&#34;Enter your name age and gender: &#34;)&#xA;fmt.Scanf(&#34;%s &#xA; %d %c&#34;, &amp;name, &amp;age, &amp;gender)&#xA;fmt.Printf(&#34;Hello %s, you are a %c and %d years old&#34;, name, gender, age)&#xA;```&#xA;&#xA;```&#xA;$ go run scanf.go&#xA;Enter your name age and gender:&#xA;Meet&#xA;12 M&#xA;Hello Meet, you are a M and 12 years old&#xA;```&#xA;&#xA;By adding `&#xA;` between the `%s`(name) and `%d`(age), we want the user to type the name on one line and age with gender on a different line. The age and gender as before separated by space.&#xA;&#xA;&#xA;## Scanln function&#xA;&#xA;The [Scanln](https://pkg.go.dev/fmt#Scanln) function is a modification of the Scan function as it only stops the input after a newline/enter is pressed.  So, using this we can input multiple variables which are space-separated in a single line.&#xA;&#xA;```go&#xA;var s string&#xA;fmt.Println(&#34;Enter a string: &#34;)&#xA;fmt.Scanln(&amp;s)&#xA;fmt.Println(s)&#xA;```&#xA;&#xA;```&#xA;$ go run scanln.go&#xA;Enter a string:&#xA;&#xA;&#xA;&#xA;$ go run scanln.go&#xA;Enter a string:&#xA;Can&#39;t type&#xA;Can&#39;t&#xA;&#xA;$ ype&#xA;-bash: ype: command not found&#xA;```&#xA;&#xA;The Scanln function even accepts an empty string as input. It just needs to get the new line character and it will exit, it also only accepts space-separated values. The rest of the input after space is thrown away and is basically exited from the program stream. More specifically, the input `Can&#39;t Type` was treated only as `Can&#39;t` anything after the space is not considered in the input value.&#xA;&#xA;The key difference between Scan and Scanln is that Scanln will not accept input that is space-separated, Scan function considers the newline/enter as a space if there are multiple inputs. The below example will make things absolutely clear.&#xA;&#xA;```go&#xA;// scan.go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;    var (&#xA;        name   string&#xA;        age    int&#xA;        gender rune&#xA;    )&#xA;    fmt.Println(&#34;Enter your name age and gender: &#34;)&#xA;    fmt.Scan(&amp;name, &amp;age, &amp;gender)&#xA;    fmt.Printf(&#34;Hello %s, you are a %c and %d years old&#34;, name, gender, age)&#xA;}&#xA;&#xA;```&#xA;&#xA;```go&#xA;//scanln.go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;    var s string&#xA;    fmt.Println(&#34;Enter a string: &#34;)&#xA;    fmt.Scanln(&amp;s)&#xA;    fmt.Println(&#34;Inputted string : &#34;, s)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run scan.go&#xA;Enter your name age and gender:&#xA;&#xA;Meet&#xA;&#xA;14&#xA;&#xA;&#xA;&#xA;77&#xA;Hello Meet, you are a M and 14 years old&#xA;&#xA;$ go run scanln.go&#xA;Enter a string:&#xA;&#xA;Inputted string :&#xA;```&#xA;&#xA;We can see that, The Scan function won&#39;t exit until it has inputted all its input values even with newline and spaces. Whereas the Scanln function just waits for the newline character (Enter Key) to be pressed and it exits, thereby even allowing an empty string as input.&#xA;&#xA;That&#39;s it from this part. Reference for all the code examples and commands can be found in the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang/) GitHub repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, these are the basic input techniques in Golang. We saw functions in the `fmt` package like `Scan`, `Scanf`, and `Scanln` which allow us to get input in a specific pattern. Hopefully, from this article part, we can build a firm base for further exploration like Strings, Arrays, and the ways to input them. Thank you for reading. If you have any questions or feedback, please let me know in the comments or on social handles. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Conditionals and Loops</title>
      <link>meetgor.com/golang-conditionals-loops</link>
      <description>Getting familiar with condition statements and loops in golang.</description>
      <pubDate>Mon, 04 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Moving to the fourth part, we will be doing conditional statements and loops in golang. We will be seeing the basics of conditional statements like if-else and switch along with loops like for, while, and range-based loops. We won&#39;t be covering iterating over arrays in a loop as this requires an understanding of arrays. &#xA;&#xA;## Conditional statements&#xA;&#xA;Conditional statements are quite a fundamental aspect of learning a programming language. In golang, we have if-else conditional statements as well as switch cases. We will be exploring both of them in this section. Firstly, we will dive into if-else statements which are quite easy to understand.&#xA;&#xA;### if else&#xA;&#xA;An `if` statement is used for checking the validity of a condition. If the condition is true(condition is met), a particular sets of statements are executed else (condition is not satisfied) different statements gets executed. We can use a basic `if-else` statement in go with the following syntax:&#xA;&#xA;```go&#xA;if condition {&#xA;    // statements&#xA;}else{&#xA;    //statements&#xA;}&#xA;```&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import &#34;fmt&#34;&#xA;&#xA;func main() {&#xA;    age := 16&#xA;    if age &lt; 13{&#xA;        fmt.Println(&#34;Kid&#34;)&#xA;    }else{&#xA;        fmt.Println(&#34;Teenager&#34;)&#xA;    }&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run if_else.go&#xA;Teenager&#xA;```&#xA;&#xA;We can also use else if for evaluating more than one condition rather than using nested if and else. &#xA;&#xA;```go&#xA;if condition {&#xA;    // statements&#xA;}else if condtion {&#xA;    //statements&#xA;}else if condition {&#xA;    //statements&#xA;}else {&#xA;    //statements&#xA;}&#xA;```&#xA;&#xA;```go&#xA;year := 2&#xA;&#xA;if year &lt; 1 {&#xA;    fmt.Println(&#34;Freshman&#34;)&#xA;} else if year == 2 {&#xA;    fmt.Println(&#34;Sophomore&#34;)&#xA;} else if year == 3 {&#xA;    fmt.Println(&#34;Junior&#34;)&#xA;} else if year == 4 {&#xA;    fmt.Println(&#34;Senior&#34;)&#xA;} else {&#xA;    fmt.Println(&#34;Probably a Graduate&#34;)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run if_else.go&#xA;Sophomore&#xA;```&#xA;&#xA;Using `else if` we can evaluate multiple conditions. This style is much better than using nested `if else` statements as it becomes harder to read for complex cases.&#xA;&#xA;&#xA;### switch &#xA;&#xA;We also have switch statements in golang which allow us to write cases for a given state of a variable. We can simply add cases for a given variable, the case should be a valid value that the variable can take. If a case is matched it breaks out of the switch statement without executing any statements below the matched case.&#xA;&#xA;The basic structure of the switch statements in golang is as follows:&#xA;&#xA;```go&#xA;switch variable{&#xA;case value1:&#xA;    //statements&#xA;case value2:&#xA;    //statements&#xA;&#xA;}&#xA;```&#xA;&#xA;```go&#xA;age := 19&#xA;var result string&#xA;switch {&#xA;case age &lt; 13:&#xA;    result = &#34;Kid&#34;&#xA;case age &lt; 20:&#xA;    result = &#34;Teenager&#34;&#xA;case age &lt; 25:&#xA;    result = &#34;Adult&#34;&#xA;case age &lt; 35:&#xA;    result = &#34;Senior&#34;&#xA;}&#xA;fmt.Println(&#34;The person is a&#34;,result)&#xA;```&#xA;&#xA;```&#xA;$ go run switch.go&#xA;The person is a Senior with age 27.&#xA;&#xA;$ go run switch.go&#xA;The person is a Teenager with age 19.&#xA;&#xA;$ go run switch.go&#xA;The person is a Kid with age 11.&#xA;```&#xA;&#xA;This gives a good understanding of switch-case statements. We can give a variable to the switch statement and pick its value in the respective case statements to evaluate the result accordingly. The `default` statement is evaluated when there is no match among the given cases. &#xA;&#xA;```go&#xA;language := &#34;&#34;&#xA;var devs string&#xA;switch language{&#xA;case &#34;go&#34;:&#xA;    devs = &#34;gopher&#34;&#xA;case &#34;rust&#34;:&#xA;    devs = &#34;rustacean&#34;&#xA;case &#34;python&#34;:&#xA;    devs = &#34;pythonista&#34;&#xA;case &#34;java&#34;:&#xA;    devs = &#34;Duke&#34;&#xA;default:&#xA;    language = &#34;javascript&#34;&#xA;    devs = &#34;developer&#34;&#xA;}&#xA;fmt.Println(&#34;A person who codes in&#34;,language,&#34;is called a&#34;,devs)&#xA;```&#xA;&#xA;```&#xA;$ go run switch.go&#xA;A person who codes in javascript is called a developer&#xA;&#xA;$ go run switch.go&#xA;A person who codes in python is called a pythonista&#xA;&#xA;$ go run switch.go&#xA;A person who codes in go is called a gopher&#xA;```&#xA;&#xA;This code will by default pick `javascript` and `developer` as the values for `language` and `devs` respectively if there is no match for the provided language or the language is left empty. &#xA;&#xA;We also have `fallthrough` in the golang switch which allows evaluating more than one case if one of them is matched. This will allow the switch and check for all the cases sequentially and evaluate all the matched and satisfied cases. &#xA;&#xA;```go&#xA;character := &#39;t&#39;&#xA;fmt.Printf(&#34;The input character is = %c&#xA;&#34;, character)&#xA;switch {&#xA;case character == 97:&#xA;    fmt.Printf(&#34;Its %c&#xA;&#34;, character)&#xA;    fallthrough&#xA;case character &lt; 107 &amp;&amp; character &gt; 96:&#xA;    fmt.Println(&#34;It&#39;s between a and k&#34;)&#xA;    fallthrough&#xA;case character &lt; 117 &amp;&amp; character &gt; 98:&#xA;    fmt.Println(&#34;It&#39;s between a and t&#34;)&#xA;    fallthrough&#xA;case character &lt; 122 &amp;&amp; character &gt; 98:&#xA;    fmt.Println(&#34;It&#39;s between u and z&#34;)&#xA;default:&#xA;    fmt.Println(&#34;Its not a lowercase alphabet&#34;)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run switch.go&#xA;The input character is = f&#xA;It&#39;s between a and k&#xA;It&#39;s between a and t&#xA;It&#39;s between a and u&#xA;&#xA;$ go run switch.go&#xA;The input character is = k&#xA;It&#39;s between a and t&#xA;It&#39;s between a and u&#xA;&#xA;$ go run switch.go&#xA;The input character is = a&#xA;Its a&#xA;It&#39;s between a and k&#xA;It&#39;s between a and t&#xA;It&#39;s between a and u&#xA;```&#xA;&#xA;So, here we can see that the fallthrough hits multiple cases. This is unlike the base case which exits the switch statement once a case has been satisfied. This can be helpful for situations where you really want to evaluate multiple conditions for a given variable.&#xA;&#xA;## Loops&#xA;&#xA;We can now move on to loops in golang. We only have a `for` loop so to speak but this can be used as any other looping statement like the `while` loop or range-based loop. We will first see the most fundamental loop statement in golang which is a three-component loop. &#xA;&#xA;### for loop&#xA;&#xA;We can have a simple for loop in golang by using the three statements namely `initialize`, `condition`, and `increment`. The structure of the loop is quite similar to the other programming languages.&#xA;&#xA;```go&#xA;for k := 0; k &lt; 4; k++ {&#xA;    fmt.Println(k)&#xA;}&#xA;```&#xA;&#xA;### Range-based loop&#xA;&#xA;We can even iterate over a string, using the range keyword in golang. We need to have two variables for using a range-based for loop in golang one is the index or the 0 based position of the element and the copy of the element in the array or string. Using the range keyword, we can iterate over the string one by one. &#xA;&#xA;```go&#xA;name := &#34;GOLANG&#34;&#xA;for i, s := range name{&#xA;    fmt.Printf(&#34;%d -&gt; %c&#xA;&#34;,i, s)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run for.go&#xA;0 -&gt; G&#xA;1 -&gt; O&#xA;2 -&gt; L&#xA;3 -&gt; A&#xA;4 -&gt; N&#xA;5 -&gt; G&#xA;```&#xA;&#xA;So, here we can see we have iterated over the string by each character. Using the range keyword in golang, The `i, s` is the index and the copy of the element at that index as discussed earlier. Using the index we get the value which we don&#39;t have to index the array for accessing it, that is already copied in the second variable while using the range loop. &#xA;&#xA;### while loop (Go&#39;s while is for)&#xA;&#xA;There are no while loops as such in golang, but the for loop can also work similarly to the while loop. We can use a condition just after the for a keyword to make it act like a while loop. &#xA;&#xA;&#xA;```go&#xA;for condition {&#xA;    // statements&#xA;}&#xA;```&#xA;&#xA;```go&#xA;count := 3&#xA;for count &lt; 9 {&#xA;&#x9;fmt.Println(count)&#xA;&#x9;count++&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run while.go&#xA;3&#xA;4&#xA;5&#xA;6&#xA;7&#xA;8&#xA;```&#xA;&#xA;We can see here that the condition is evaluated and the statements in the loop body are executed, if the condition evaluates to false, the flow is moved out of the loop and we exit the loop. &#xA;&#xA;### Infinite loop&#xA;&#xA;We can run an infinite loop again using a keyword. We do not have any other keywords for loops in golang. &#xA;&#xA;```go&#xA;for {&#xA;    // statements&#xA;    // should have conditons to exit&#xA;}&#xA;```&#xA;&#xA;```go&#xA;flag := 4&#xA;for {&#xA;&#x9;flag++&#xA;&#x9;fmt.Println(flag)&#xA;}&#xA;```&#xA;&#xA;This might be used with a base condition to exit the loop otherwise there should be a memory overflow and the program will exit with errors.&#xA;&#xA;### Break &#xA;&#xA;If we want to exit out of a loop unconditionally, we can use the `break` keyword. This will break the loop and help us to exit out of an infinite or a condition-bound-based loop too.&#xA;&#xA;```go&#xA;flag := 1&#xA;for {&#xA;    fmt.Println(flag)&#xA;    flag++&#xA;    if flag == 7 {&#xA;        fmt.Println(&#34;It&#39;s time to break at&#34;, flag)&#xA;        break&#xA;    }&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run infinite.go&#xA;1&#xA;2&#xA;3&#xA;4&#xA;5&#xA;6&#xA;It&#39;s time to break at 7&#xA;```&#xA;&#xA;As, we can see inside an infinite loop, we were able to break out of it by using a conditional statement and `break` keyword. This also applies to switch cases it basically is the opposite of `fallthrough` in switch-case statements. But by default(without using fallthrough), the case statement breaks the switch after a match has been found or the default case has been encountered. &#xA;&#xA;### Continue&#xA;&#xA;We also have the opposite of `break` i.e. `continue` which halts the execution of the loop and directs back to the post statement increment(in case of for loops) or evaluation(in case of while loop). We basically are starting to iterate over the loop again after we encounter the continue but by preserving the counter/iterator state values. &#xA;&#xA;```go&#xA;counter := 2&#xA;for counter &lt; 4 {&#xA;    counter++&#xA;    if counter &lt; 4 {&#xA;        continue&#xA;    }&#xA;    fmt.Println(&#34;Missed the Continue? at counter =&#34;, counter)&#xA;}&#xA;```&#xA;&#xA;```&#xA;$ go run infinite.go&#xA;Missed the Continue? at counter = 4&#xA;```&#xA;&#xA;For following up with the code for this and all parts of the series, head over to the [100 days of Golang](https://github.com/mr-destructive/100-days-of-golang) GitHub repository. &#xA;&#xA;## Conclusion&#xA;&#xA;So, from this section, we were able to understand the basics of conditional statements and loops in golang. We covered the things which are more important for understanding the core of the language than some specific things. There are certain parts that need to be explored further like iterating over arrays and slices which we&#39;ll cover after we have understood arrays and slices. Hopefully, you have understood the basics of the conditional statements and loops in golang. Thank you for reading, if you have any questions, or feedback please let me know in the comments or social handles. Until next time, Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Variables and Types</title>
      <link>meetgor.com/golang-variables</link>
      <description>Understanding and creating variables and their types in Golang</description>
      <pubDate>Sun, 03 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;In the third part of the series, we will be covering the fundamentals for learning any programming language i.e. variables and data types. We will be covering from data types to variable declaration. We won&#39;t be seeing each and every detail related to the data types as some of them require a knowledge of loops and other topics, so that can be left for the different part.&#xA;&#xA;## Types in golang&#xA;&#xA;In Golang there are 3 major types : Numeric, Bool and String. Further we also have specific types for the three data types like int, float, rune, byte, etc. We will first see how to declare a simple variable and then explore the data types in Golang. &#xA;&#xA;```go&#xA;var name string&#xA;```&#xA;&#xA;This the variable declaration in Golang, we have the keyword `var` similar to Javascript but we optionally have to specify the type of the variable if we are not immediately assigning/defining it a value. &#xA;&#xA;To assign variable values, we can write the datatype of the assigned value but it is optional as the go compiler will know the datatype according to the assigned value. Further you cannot change the type of that variable once it is initialized.&#xA;&#xA;```go&#xA;var name string = &#34;Gopher&#34;&#xA;&#xA;OR &#xA;&#xA;var name string&#xA;name = &#34;Gopher&#34;&#xA;&#xA;OR&#xA;&#xA;var name = &#34;Gopher&#34;&#xA;&#xA;```&#xA;&#xA;We also have `const` for assigning constant values to a particular value set. You cannot change the value for a constant type, doing this will result in compile time error. An important property of `const` can be noted here, if you simply declare a `const` without initializing the value and try to access that constant, the go-compiler will throw an compilation error.&#xA;&#xA;```go&#xA;const name string = &#34;David&#34;&#xA;&#xA;OR&#xA;&#xA;const name string&#xA;name = &#34;Calvin&#34;&#xA;&#xA;OR&#xA;&#xA;const name = &#34;Smith&#34;&#xA;```&#xA;&#xA;By default, the values for string is an empty string`&#34;&#34;`, for integer and float it is `0` and for bool it is `false`.&#xA;&#xA;Each of these are valid declaration of variables in golang. Let&#39;s now dive into the data types and follow up with variable declaration in detail later.&#xA;&#xA;| Numeric    | String | Bool |&#xA;|------------|--------|------|&#xA;|            |        |      |      &#xA;|  int       | string | bool |&#xA;|            |        |      |&#xA;|  float     |        |      |&#xA;|            |        |      |&#xA;|  complex   |        |      | &#xA;|            |        |      | &#xA;|  rune      |        |      |&#xA;|            |        |      |  &#xA;|  byte      |        |      | &#xA;   &#xA;### Numeric&#xA;&#xA;Let&#39;s first explore the `numeric` data types in golang as you have guessed correctly, we have `int` and `float` as distinct categories but further we also have fine grained storage types for both of the types. &#xA;&#xA;#### Integer&#xA;&#xA;In integers as well we have two categories `signed` and `unsigned`, we can basically store only positive integers in `unsigned` integers giving us an extra bit to play with. &#xA;&#xA;For Integers, we have specific data storage types depending on the bits it can store like `int8` for storing 8 bit integers, `int16` for storing 16 bit integer value, `int32` and `int64` for the given number of bits in the integer. Similarly we will have these storage based integer values for unsigned integers like `uint8`, `uint16`, `uint32` and `uint64`. We can basically store double amount of positive integers in unsigned integers as `uint` than in signed integers `int`, this is because the most significant bit is not used as a sign bit since all values in the variable are positive and hence no sign bit is required. &#xA;&#xA;```go&#xA;var likes int = 140&#xA;fmt.Println(likes)&#xA;```&#xA;&#xA;```&#xA;$ go run int.go&#xA;140&#xA;```&#xA;&#xA;```go&#xA;var age int8 = 140&#xA;fmt.Println(&#34;Age = &#34;,age) &#xA;```&#xA;&#xA;```&#xA;$ go run int.go&#xA;# command-line-arguments&#xA;.\int.go:6:9: constant 140 overflows int8&#xA;```&#xA;&#xA;This will give us an error as `140` is above the limit for `int8`. So, unless you have specific requirements as storage limitation, you should be using `int` as the default data type for storing integers.&#xA;&#xA;So, we need to define variables as per the limits to which we are going to use them, if you just specify `int` the type will be selected based on your operating system, if it is `32bit`, it will take `int32`, for `64bit` OSes it will take as `int64` integer. If you define a variable with let say `16` bit storage and if it exceeds the limit for `16` bit storage, it would give a `overflow limit` error. &#xA;&#xA;Below are the limits for all the integer types in Golang: &#xA;&#xA;```&#xA;uint8 -&gt;  0  to  255&#xA;uint16 -&gt;  0  to  65535&#xA;uint32 -&gt;  0  to  4294967295&#xA;uint64 -&gt;  0  to  18446744073709551615&#xA;&#xA;int8 -&gt;  -128  to  127&#xA;int16 -&gt;  -32768  to  32767&#xA;int32 -&gt;  -2147483648  to  2147483647&#xA;int64 -&gt;  -9223372036854775808  to  9223372036854775807&#xA;```&#xA;&#xA;If you want to reality check for the boundary values of this data types, you can code a program in `go` as below: &#xA;&#xA;- To find the maximum value of uint, we can flip all the bits in `0` to get all the set bits in the integer thus we use `^` operator.&#xA;- To find the maximum value for signed integers, we can right shit one bit so as to unset the sign bit.&#xA;- The minimum value for uint is the default value `0`.&#xA;- The minimum value for int can be calculated by subtracting one from the negative of the max limit.&#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;    &#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;    var min_uint = 0&#xA;    var max_uint8 uint8 = ^uint8(0)&#xA;    var max_uint16 uint16 = ^uint16(0)&#xA;    var max_uint32 uint32 = ^uint32(0)&#xA;    var max_uint64 uint64 = ^uint64(0)&#xA;&#xA;    var max_int8 int8 = int8(max_uint8&gt;&gt;1)&#xA;    var min_int8 int8 = -max_int8 - 1&#xA;    var max_int16 int16 = int16(max_uint16&gt;&gt;1)&#xA;    var min_int16 int16 = -max_int16 - 1&#xA;    var max_int32 int32 = int32(max_uint32&gt;&gt;1)&#xA;    var min_int32 int32 = -max_int32 - 1&#xA;    var max_int64 int64 = int64(max_uint64&gt;&gt;1)&#xA;    var min_int64 int64 = -max_int64 - 1&#xA;&#xA;    fmt.Println(&#34;uint8 -&gt; &#34;, min_uint, &#34; to &#34;, max_uint8)&#xA;    fmt.Println(&#34;uint16 -&gt; &#34;, min_uint, &#34; to &#34;, max_uint16)&#xA;    fmt.Println(&#34;uint32 -&gt; &#34;, min_uint, &#34; to &#34;, max_uint32)&#xA;    fmt.Println(&#34;uint64 -&gt; &#34;, min_uint, &#34; to &#34;, max_uint64)&#xA;    fmt.Println(&#34;&#34;)&#xA;    fmt.Println(&#34;int8 -&gt; &#34;, min_int8, &#34; to &#34;, max_int8)&#xA;    fmt.Println(&#34;int16 -&gt; &#34;, min_int16, &#34; to &#34;, max_int16)&#xA;    fmt.Println(&#34;int32 -&gt; &#34;, min_int32, &#34; to &#34;, max_int32)&#xA;    fmt.Println(&#34;int64 -&gt; &#34;, min_int64, &#34; to &#34;, max_int64)&#xA;}&#xA;```&#xA;&#xA;This was the basic overview of Integers in Golang.&#xA;&#xA;Though rune and byte are Integer aliases, we will explore them in the String section as they make a lot of sense over there.&#xA;&#xA;#### Float&#xA;&#xA;Similar to integers, we also have floats in the numeric category. A float is a numeric data type that can allow numbers with decimal values. A simple float can be of either `float32` or `float64`. The two types are defined as the precision of the decimal values. Obliviously, the `float64` type is more precise than the counterpart and is also the default type assigned if not provided.&#xA;&#xA;```go&#xA;const percent = 30.5&#xA;fmt.Println(percent+50)&#xA;```&#xA;&#xA;You optionally provide the `float32` type to have a bit less precision than usual using the `float32` keyword as follows:&#xA;&#xA;```go&#xA;const percent float32 = 46.34&#xA;fmt.Println(percent - 3.555)&#xA;```&#xA;&#xA;The floating value precision of the float types in golang are as follows:&#xA;&#xA;```&#xA;float32&#x9;  --&gt;   -3.4e+38 to 3.4e+38.&#xA;float64&#x9;  --&gt;   -1.7e+308 to +1.7e+308.&#xA;```&#xA;&#xA;As quite logical reasons, the precision is almost double in the `float64` compared to `float32`. If we try to add(any operation) a `float64` number with a `flaot32`, we get an error as performing operations on two differently stored types can&#39;t be operated. &#xA;&#xA;#### Complex Numbers&#xA;&#xA;We also have complex numbers in golang. This are the numbers which deal with a real and a imaginary numbers. We initialize the complex variable using the `complex` function which takes two parameters the `real` part and the `imagianry` part. Both the parts or numbers are stored as float in the complex data type.&#xA;&#xA;So, since golang has `float32` and `float64` data types, we will have `complex64` and `complex128` as complex types. Since we are storing two `flaot64`, it has a `complex128` type and `complex64` for both parts as `float32`. Here as well, you cannot store the two parts(real and imaginary) as different float types i.e. You need to have both real and imaginary as either `flaot32` or `flaot64`.&#xA;&#xA;```go&#xA;var percent = 30.738&#xA;var f = 4.545&#xA;var comp1 = complex(f, percent)&#xA;var comp2 = complex(percent, f)&#xA;fmt.Println(comp1 - comp2)&#xA;```&#xA;&#xA;```&#xA;(-26.192999999999998+26.192999999999998i)&#xA;```&#xA;&#xA;Golang automatically adds the `i` or iota in the complex/imaginary part for better readability. &#xA;&#xA;### Strings &#xA;&#xA;We can now move onto the `string` data type in golang. It has several data types like `byte`, `rune`, `string`. In golang, `byte` and `rune` store individual characters whereas `string` can hold multiple characters. &#xA;&#xA;#### Byte&#xA;&#xA;A byte in golang is an unsigned 8 bit integer, which means it can hold numeric data from 0 to 255. So how is this displaying characters if it stores integer. Well, because each number it stores is mapped to the ASCII character set which is used to represent characters. &#xA;&#xA;A byte can be stored in a single quote `&#39;&#39;`, if we use double quotes`&#34;&#34;`, the variable is considered as string if we aren&#39;t specifying the data type.&#xA;&#xA;```go&#xA;const c byte = &#39;t&#39;&#xA;fmt.Println(c)&#xA;```&#xA;&#xA;```&#xA;$ go run byte.go&#xA;116&#xA;```&#xA;&#xA;This gives the output as a number between 0 and 255 depending on the character which you have stored. To print the actual character you need to type caste into a string like:&#xA;&#xA;```go&#xA;const c byte = &#39;t&#39;&#xA;fmt.Printf(&#34;Character = %c &#xA;Integer value = %d&#xA;&#34;, c, c)&#xA;```&#xA;&#xA;```&#xA;$ go run byte.go&#xA;Character = t&#xA;Integer Value = 116&#xA;```&#xA;&#xA;We can get the character equivalent of the byte representation number using the [Printf](https://cs.opensource.google/go/go/+/go1.18:src/fmt/print.go;l=212) function and the `%c` place holder for a character. The `&#xA;` is used to end the line just for displaying proper output.&#xA;&#xA;We can even store numbers between `0` and `255` as it is internally an `uint8`.&#xA;&#xA;#### Rune&#xA;&#xA;A rune is extended type of byte as it stores `int32` numbers and hence it represents `Unicode` characters. This is the default type if you do not specify `byte` and use single quotes to assign a character. Using rune, we can assign it an unicode characters to display some rich characters and literals like emoji or expressions.&#xA;&#xA;```go&#xA;var smiley_emoji = &#39;☺&#39;&#xA;fmt.Printf(&#34;Smiley Emoji --&gt; %c&#34;, smiley_emoji)&#xA;```&#xA;&#xA;![GO Rune Smiley Emoji](https://res.cloudinary.com/techstructive-blog/image/upload/v1648962460/blog-media/obw9ihlxsvhytbe8ito3.png)&#xA;&#xA;So, rune is pretty amazing type to play with characters in golang. As it is a default type assigned against byte if not provided while assignment. &#xA;&#xA;#### String&#xA;&#xA;Strings are basically a slice(list) of bytes. Each character in a string is a byte. By default the string will be empty if you don&#39;t initialize it with a value. &#xA;&#xA;```go&#xA;const language string&#xA;language = &#34;C++&#34;&#xA;&#xA;OR&#xA;&#xA;const language string= &#34;Python&#34;&#xA;&#xA;OR&#xA;&#xA;const language = &#34;Javascript&#34;&#xA;```&#xA;&#xA;We can even access particular character in the string using it&#39;s index.&#xA;&#xA;```go&#xA;const code = &#34;12AB34CD&#34;&#xA;fmt.Println(code[6])&#xA;```&#xA;&#xA;```&#xA;$ go run string.go&#xA;67&#xA;```&#xA;&#xA;This gives us a integer as we are accessing the byte from the string using its index. Thus, we can use `%c` in the `Printf` function to format and print the equivalent characters of the byte.&#xA;&#xA;```go&#xA;const code = &#34;12AB34CD&#34;&#xA;fmt.Printf(&#34;2nd Character in string = %c&#xA;&#34;, code[4])&#xA;```&#xA;&#xA;```&#xA;$ go run string.go&#xA;2nd Character in string = A&#xA;```&#xA;&#xA;We can also declare strings using backticks/backquotes or whatever you call it (```), assigning string with this allows us to write multi line string.   &#xA;&#xA;```go&#xA;var statement = `This is the first line&#xA;The next line&#xA;The last line`&#xA;&#xA;fmt.Println(statement)&#xA;```&#xA;&#xA;```&#xA;$ go run str-backticks.go&#xA;This is the first line&#xA;The next line&#xA;The last line&#xA;```&#xA;&#xA;Further in the loop article we will see how to loop/iterate over a string.&#xA;&#xA;### Boolean &#xA;&#xA;This type is used to store either `true` or `false` in golang. The default value of a boolean variable is `false`.&#xA;&#xA;```go&#xA;var power bool&#xA;fmt.Println(power)&#xA;```&#xA;&#xA;```&#xA;$ go run bool.go&#xA;false&#xA;```&#xA;&#xA;We can assign the variable as either `true` or `false`.  &#xA;&#xA;```go&#xA;const result = true&#xA;fmt.Printf(&#34;The statement is %t&#34;, result)&#xA;```&#xA;&#xA;```&#xA;$ go run bool.go&#xA;The statement is true&#xA;```&#xA;&#xA;So, using the `%t` we can print the value of a boolean value in golang in the `Printf` function.&#xA;&#xA;## Creating Variables &#xA;&#xA;Now, we have familiar with data types in golang, we can more expressively create, declare, initialize variables in golang.&#xA;&#xA;There are 3-4 primary ways to define a variable most of which we have already seen.&#xA;&#xA;### Declaring a Variable &#xA;&#xA;We can declare a variable without assigning it any value but for that we need to then provide the data type, this can be done using the following command:&#xA;&#xA;```go&#xA;var expereience int&#xA;&#xA;expereience = 2&#xA;```&#xA;&#xA;We can even use `const` for constant value in the given scope. &#xA;&#xA;Here, we can even declare multiple variables by separating each variable/constant with comma `,` which can be done as follows:&#xA;&#xA;```go&#xA;var a, b, c int&#xA;&#xA;OR&#xA;&#xA;const i, j, k bool&#xA;```&#xA;&#xA;### Defining and Initializing at the same time&#xA;&#xA;We can initialize a variable/constant in golang by explicitly giving it a value. We can do that by using `var` for variable value or `const` for a constant value. We can optionally provide the data type at this moment as golang will automatically detect the type and assign the memory according to the value given.&#xA;&#xA;```go&#xA;var place string = &#34;home&#34;&#xA;```&#xA;&#xA;Here, there is no compulsion to provide the `datatype` as the compiler will be able to know it from the asisgned value. Though if you want to provide a non-default value you can specify the datatype. &#xA;&#xA;### Declaring Multiple Variables&#xA;&#xA;We can assign multiple variables at once by separating them with comma`,`. The variable name to the left and the values to the right needs to separated with comm on both sides.&#xA;&#xA;```go&#xA;var x, y, z = 100, &#39;#&#39;, &#34;days&#34;&#xA;&#xA;fmt.Printf(&#34; x = %d &#xA; y = %c &#xA; z = %s &#xA;&#34;,x,y,z)&#xA;```&#xA;&#xA;```&#xA;$ go run multiplvar.go&#xA; x = 100&#xA; y = #&#xA; z = daysofcode&#xA;```&#xA;&#xA;We can are declaring and assigning multiple variables, the `x` variable is assigned an integer value, `y` with a `rune`(by default) and `z` with a string. We are using `Printf` function with place holders for int `%d`, rune/byte `%c` and string as `%s`. The `&#xA;` is for a new line.&#xA;&#xA;If we want to assign the variables with a particular data type, we can use the var keyword as a list of values.&#xA;&#xA;```go&#xA;var (&#xA;    x int8 = 100&#xA;    y byte = &#39;#&#39;&#xA;    z =  &#34;daysofcode&#34;&#xA;)&#xA;&#xA;fmt.Printf(&#34; x = %T &#xA; y = %T &#xA; z = %T &#xA;&#34;,x,y,z)&#xA;```&#xA;&#xA;```&#xA;$ go run multiplvar.go&#xA; x = int8&#xA; y = uint8&#xA; z = string&#xA;```&#xA;&#xA;This is not only limited to `var` we can also use `const` to declare multiple constants with type constraint. Also, note we are using the `%T` placeholder for getting the type of the data stored in the variable.&#xA;&#xA;Also, we can define(declare and initialize) multiple variable with same data type with command separated as follows:&#xA;&#xA;```go&#xA;var pi, e, G float32 = 3.141, 2.718, 6.67e-11   &#xA;var start, end byte = 65, 90&#xA;fmt.Println(pi, e, G)&#xA;fmt.Printf(&#34;%c %c&#xA;&#34;,start, end)&#xA;```&#xA;&#xA;```&#xA;$ go run multp.go&#xA;3.141 2.718 6.67e-11&#xA;A Z&#xA;```&#xA;&#xA;### Assigning Variable using Walrus Operator (Shorthand Declaration)&#xA;&#xA;We can skip usign `var` or the `datatype` by using the `:=` walrus operator. This type of assignment using `walruns` operator can only be allowed in the function body and not anywhere else, in the global scope this type of assignment is not allowed.&#xA;&#xA;```go&#xA;place := &#34;school&#34;&#xA;```&#xA;&#xA;This is such a simple shorthand for assigning variables though only in a function body.&#xA;&#xA;Also, multiple variable declaration is possible with walrus operator.&#xA;&#xA;```go&#xA;x, y, z := &#34;foo&#34;, 32, true&#xA;fmt.Println(x, y, z)&#xA;fmt.Printf(&#34;%T %T %T&#34;, x, y, z)&#xA;```&#xA;&#xA;```shell&#xA;$ go run walrus.go&#xA;foo 32 true&#xA;string int bool&#xA;```&#xA;&#xA;Links to all code and links are visible on the [GitHub](https://github.com/Mr-Destructive/100-days-of-golang) repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this part of the series, we were able to understand variables and the various data types in Golang. Though we didn&#39;t got too much in detail still we can find ourselves a bit comfortable in understanding basic go scripts. In the next section, we will looking into conditional statements and loops. This would give a good grasp on iterating over a string and even learn arrays(just the basics) we will explore Arrays and slices(remember strings?) after that. &#xA;&#xA;So, if you have any questions, suggestions, or feedback please let me know in the comments or on the social handles. See you next time, Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: Installation and Hello-World</title>
      <link>meetgor.com/hello-golang</link>
      <description>Installing and Setting up the development environment for Go lang, also writing the hello-world in GO!</description>
      <pubDate>Sat, 02 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Moving on to the second day, we will be installing and setting up Go lang on our systems. The installation and setup are quite simple and not much demonstration is required, so further in the article, I will also make a hello-world program in GO. We will explore the basic program in GO and how to compile, run and build a GO program in this section. &#xA;&#xA;## Installing Go&#xA;&#xA;Installing Go is pretty straightforward. You have to install the binaries from the official website as per your operating system. &#xA;&#xA;Head on to the [go.dev](https://go.dev/) which is the official website for the Go language. Click on the [Download](https://go.dev/doc/install) Tab and there should be all the required information. Install the installer as per your specific operating system. &#xA;&#xA;If you wish not to lead to any errors, keep the configuration for the installer as default and complete the installation process. &#xA;&#xA;## Setting up Environment variables&#xA;&#xA;To make sure Go lang is perfectly installed in your system, type in CMD/Terminal/Powershell the following command:&#xA;&#xA;```&#xA;go version&#xA;```&#xA;&#xA;If you get a specific version of golang along with the platform and architecture of your system, you have successfully installed Go lang in your system. &#xA;&#xA;```&#xA;$ go version&#xA;go version go1.17.8 windows/amd64&#xA;```&#xA;&#xA;If you get an output as a command not found or anything else, this is an indication that your Go installation was not successful. You need to configure your Environment variables properly or re-install the installation script. &#xA;&#xA;```&#xA;$ go version&#xA;bash: go: command not found&#xA;```&#xA;&#xA;&#xA;## Hello Gophers&#xA;&#xA;Once the Go lang has been successfully installed in your system, we can start writing our first program. Yes, a `Hello World` program. It is not as simple as `print(&#34;hello world&#34;)` but a lot better than 10-15 lines of Java or C/C++. &#xA;&#xA;```go&#xA;package main&#xA;&#xA;import (&#xA;&#x9;&#34;fmt&#34;&#xA;)&#xA;&#xA;func main() {&#xA;&#x9;fmt.Println(&#34;Hello,Gophers!&#34;)&#xA;}&#xA;```&#xA;&#xA;So, this is so-called the `hello-world` program in Go, we will see each of the terms in detail next. But before that, let&#39;s get an idea of the style of the code. It is definitely similar if you are coming from C/C++ or Java, the package the main function. It will even feel like Python or Javascript when we explore other aspects. It has really a unique style of programming but feels familiar to programmers coming from any programming language, this might not be true for all programming languages though. &#xA;&#xA;### Packages &#xA;&#xA;A package in Go lang is a way to bundle up some useful functions or any other constructs. Using packages we can reuse components of a specific app in another. Packages in golang also help in optimizing the execution/compilation time by letting the compiler only compile the required packages. &#xA;&#xA;Here, we have the main package, which provides the entry point for the entire project. This is mandatory for creating executable programs as we need to have a start point. The file name can be anything, but for executing the code, you need to have a main package where your main function resides. It provides an entry point as a package, when we will run the file, we provide the file which actually acts as a package and the file that has a tag of main is the entry point for the program.&#xA;&#xA;### Main Function&#xA;&#xA;We have the main function where the main package is defined. It acts as a start point for a package. The main package will look for a main function inside the package. The main function doesn&#39;t take any parameter and nor does it return any value. When the function&#39;s scope ends, the program exits. &#xA; &#xA;The main function has significance only in the main package, if you define the main function in other packages excluding `main`, it works as a normal function. &#xA;&#xA;### Import Statements&#xA;&#xA;We have an `import` keyword for importing packages from the standard library or other external packages from the internet. There are a lot of ways to import packages in golang like single, nested, multiple, aliased, dot import, and blank imports. We will see these different import styles in a dedicated section. Right now, we are directly importing a package, a single package. The pacakge is called the [fmt](https://pkg.go.dev/fmt) pacakge. It handles the format, input, and output format in the console. It is a standard package to perform some basic operations in golang.  &#xA;&#xA;We can import it as a single direct import like:&#xA;&#xA;```go&#xA;import &#34;fmt&#34;&#xA;```&#xA;&#xA;OR &#xA;&#xA;Make multiple imports like:&#xA;&#xA;```go&#xA;import (&#xA;    &#34;fmt&#34;&#xA;)&#xA;```&#xA;&#xA;We can add multiple packages on each line, this way we do not have to write the keyword `import` again and again. It depends on what you want to do in the program. &#xA;&#xA;### Println function&#xA;&#xA;We can access the functions from the imported packages, in our case we can use the functions from the `fmt` package. We have access to one of the functions like `Println`, which prints string on a new line. Syntactically, we access the function and call it by using the `dot` operator like:&#xA;&#xA;```go&#xA;fmt.Println(&#34;Hi there!&#34;)&#xA;```&#xA;&#xA;The [Println]() function takes in a parameter as a string and multiple optional parameters that can be strings or any variable. We will see how to declare variables and types in the next section. &#xA;&#xA;Here, the `P` in `Println` has significance as it allows us to distinguish private methods(functions in structs aka classes) from public methods. If a function begins with an uppercase letter, it is a public function. In technical terms, if the first letter of a method is upper case, it can be exported to other packages. &#xA;&#xA;&#xA;## Running Scripts&#xA;&#xA;Let&#39;s run the code and GO programming language to our resume. You can run a go source file assuming it has a main package with the main function using the following command:&#xA;&#xA;```&#xA;go run &lt;filename.go&gt;&#xA;```&#xA;&#xA;![GO run command](https://res.cloudinary.com/techstructive-blog/image/upload/v1648833567/blog-media/o7i9spph2bfgemqonq8p.png)&#xA;&#xA;This will simply display the string which we have passed to the `Println` function. If you didn&#39;t have a main package this command won&#39;t run and return you an error:&#xA;&#xA;```&#xA;package command-line-arguments is not the main package&#xA;```&#xA;&#xA;By executing the run command, we can are creating a executable in a system&#39;s temp folder,&#xA;&#xA;For Windows, it&#39;s usually at:&#xA;```&#xA;C:\Users�cer\AppData\Local&#xA;```&#xA;&#xA;You can get the location of the temp directory using CMD/PowerShell:&#xA;&#xA;```&#xA;CMD:&#xA;echo %TEMP%&#xA;&#xA;PowerShell:&#xA;$env:Temp&#xA;```&#xA;&#xA;For Linux&#xA;```&#xA;/tmp&#xA;```&#xA;&#xA;You can get the location of the temp folder using Terminal in Linux/macOS:&#xA;&#xA;```&#xA;echo $TMPDIR&#xA;```&#xA;&#xA;It doesn&#39;t create any executable in the current project or folder, it only runs the executable that it has built in the temp folder. The run command in simple terms **compiles and executes the main package**. As the file provided to the run command needs to have the main package with the main function, it will thus compile that source code in the provided file. &#xA;&#xA;To get the location of the executable file that was generated by the `run` command, you can get the path using the following command:&#xA;&#xA;```&#xA;go run --work &lt;filename&gt;.go&#xA;```&#xA;&#xA;![GO Run TMP file](https://res.cloudinary.com/techstructive-blog/image/upload/v1648833643/blog-media/maqfd73xmiivrckc2acn.png)&#xA;&#xA;This will print the path to the executable that it currently has compiled. &#xA;&#xA;For further readings on the `run` command in Go, you can refer to the [documentation](https://pkg.go.dev/cmd/go#hdr-Compile_and_run_Go_program).&#xA;&#xA;## Creating Executables&#xA;&#xA;We can go a step further by creating binary/executables with our source file using the `build` command:&#xA;&#xA;```&#xA;go build &lt;filename&gt;.go&#xA;```&#xA;&#xA;If you run this you would get an error as building a package requires a few things. The most important is the mod file.&#xA;&#xA;```&#xA;go: cannot find main module, but found .git/config in D:\meet\Code\go\100-days-of-golang&#xA;    to create a module there, run:&#xA;    cd .. &amp;&amp; go mod init&#xA;```&#xA;&#xA;We need to create a mod file first before we build our script. &#xA;A mod file in golang is the file that specifies the go version along with the packages and dependencies. It is like the `requirement.txt` but a bit different. &#xA;&#xA;We use the following command with the file that contains the main package among the other packages in the folder. We can even provide other packages to add to the mod file(see in detail in the future) &#xA;&#xA;```&#xA;go mod init &lt;filename&gt;.go&#xA;```&#xA;&#xA;![GO Mod Init](https://res.cloudinary.com/techstructive-blog/image/upload/v1648833683/blog-media/pdvkdpnanl3e0yzoenqb.png)&#xA;&#xA;This will generate a `go.mod` file, this is a file that contains the list of dependencies and packages in the project. &#xA;If you look at the mod file, it looks as follows:&#xA;&#xA;```go&#xA;module script.go&#xA;&#xA;go 1.17&#xA;```&#xA;&#xA;Currently, this is pretty simple and has very little detail, but as your project increases in complexity, this file populates with the modules and packages imported and used in the project. &#xA;&#xA;So, after creating the mod file, we can build the script which we tried earlier.&#xA;&#xA;```&#xA;go build &lt;filename&gt;.go&#xA;```&#xA;&#xA;![GO Build Command](https://res.cloudinary.com/techstructive-blog/image/upload/v1648833745/blog-media/i0hnwsxxl0gglhh3rdoe.png)&#xA;&#xA;So, this command generates an exe right in the current folder. This will generate the file named after the package which is mainly `filename.exe`. &#xA;&#xA;If you have a `go.mod` file in your project, just running the command will generate the exe file:&#xA;&#xA;```&#xA;go build&#xA;```&#xA;&#xA;![GO Build Command - Directory level](https://res.cloudinary.com/techstructive-blog/image/upload/v1648833832/blog-media/sdw9zrlff3odtnhallyq.png)&#xA;&#xA;NOTE: For the above command to work, you need to be in the directory which has the mod file for your project. It basically bundles the listed packages and creates the executable named after the package which is named `main`. Thus it generates a different file name as `filename.go.exe`&#xA;&#xA;We can also provide an output file as the exe file name, this can be done with the following command:&#xA;&#xA;```&#xA;go build -o &lt;filename&gt;&#xA;```&#xA;&#xA;![GO Build Output file](https://res.cloudinary.com/techstructive-blog/image/upload/v1648833932/blog-media/t5dfhx0va7reyjjygfnq.png)&#xA;&#xA;For further reading on the `go build` command, head over to this [documentation](https://pkg.go.dev/cmd/go#hdr-Compile_packages_and_dependencies) page.&#xA;&#xA;Link to all of the code and resources is mentioned in this [GitHub](https://github.com/Mr-Destructive/100-days-of-golang) repository.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from this second post, we were able to set up the Go language in our system and write our first `hello-world` program. This was a bit more than the setup and installation guide as it is quite boring to demonstrate the installation procedure being quite straightforward. Hopefully, you followed so far and you were able to pick up things in the go landscape. Thank you for reading and if you have any questions, suggestions, or feedback, let me know in the comments or the provided social handles. See you tomorrow, until then Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Golang: What and Why?</title>
      <link>meetgor.com/golang-intro</link>
      <description>Understanding what is special about Golang and why should you learn it</description>
      <pubDate>Fri, 01 Apr 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;This is the first entry in my 100 days of Go lang challenge. I will share the things I will learn each day for 100 days related to Golang or its configuration in my environment. In this post, we will understand what is golang and why you should learn it. It&#39;s not an in-depth guide but a high-level overview for understanding the context of learning Go lang. &#xA;&#xA;### A bit of Context&#xA;&#xA;In April 2021, I started learning Django and to date, I have more than 10 projects(not all deployed) created and publicly open on [GitHub](https://github.com/Mr-Destructive?tab=repositories&amp;q=django&amp;type=&amp;language=python&amp;sort=). It has been a great experience so far, I am still in between an internship with a project to be created in Django. The learning process after I started blogging in June 2021 has been a different fantasy, I have been enjoying the process of writing the things I learn. So, this Spring/Summer I am creating a challenge of 100 days for learning Go lang and documenting the process. Hopefully, this will be a useful place to learn for a beginner and more than that a place for me to reflect back on the future.&#xA;&#xA;Leaving the rant aside, let&#39;s start with the best question to answer, What is Golang?&#xA;&#xA;## What is Golang&#xA;&#xA;[Golang](https://go.dev/) (officially called Go) is a programming language developed by Google. It is statically typed like C\C++, Java, Kotlin, etc, and syntax is similar to dynamically languages like Python, Js, Ruby, Lua, etc. So, golang provides the best of both worlds, the swiftness to write code and also providing control and memory safety. Go is regarded as the language of the cloud i.e. it is heavily used in the cloud infrastructure, it involves creating microservices, APIs, containerization, orchestration, and a lot of other technologies. It can be a super useful programming language for DevOps folks and people into Cloud computing. &#xA;&#xA;Though Go is designed for Cloud Infrastructure, that doesn&#39;t mean you can&#39;t use it elsewhere. There are a lot of fields in which golang nicely fits. We&#39;ll discuss why you would want to learn golang and state the domains where it can be used.&#xA;&#xA;&gt; Go programmers are called Gophers&#xA;&#xA;## Why learn Golang?&#xA;&#xA;There are a lot of reasons for learning Go as your next programming language. Not only it is quite famous but it is significantly faster than other programming languages like python and javascript. It is a simple language to pick up, it is designed for modern world technologies. There is an added advantage to learning go lang as it is a new programming language(not as old as python). It was open-sourced in 2012, it got a great boost in the last five years as cloud companies are on the rise. &#xA;&#xA;### 1. GO lang is simple&#xA;&#xA;GO lang is a simple programming language, it is really easy to learn. It is quite similar to python in terms of its syntax, though it also inherits characteristics from the Java/C++ paradigm. It has a single entry point program via the `main` function similar to Java/C++ languages and is compiled into binary/executable code before running. It has the standard library that provides a lot of functionalities out of the box. It provides some quite handy tools and has support for creating web applications in the core language itself.&#xA;&#xA;### 2. GO lang is fast (Execution Speed)&#xA;&#xA;Though it might not be the fastest language of all time, it beats python and javascript by a significant magnitude in the context of backend development. Go lang is compiled language and hence it has no overhead of converting into byte code or the interpreter. Go lang also checks for unused variables, functions, identifiers, and packages, this can boost the speed of execution by a good amount additionally optimizing the memory footprint of the program. &#xA;&#xA;![Speed Comparison of programming languages](https://camo.githubusercontent.com/37d2b63be8996cd03b67e80d3dee322c698e9753d0602c7da8f8ef399fbed57a/68747470733a2f2f7261772e6769746875622e636f6d2f6e696b6c61732d686565722f73706565642d636f6d70617269736f6e2f6d61737465722f2e6769746875622f706c6f745f76312e342e706e67)&#xA;&#xA;We can see, that Go lang is almost equivalent to C and C++ porgramming language, though this might not be the best comparison of speed as it depends on quite a lot of factors and the context of programs. Still Go lang has a significant edge over Java and C++ which is a great factor because of the writing complexity involved in those programming languages.&#xA;&#xA;&#xA;### 3. GO lang is fast (Writing Speed)&#xA;&#xA;GO language is fast yes I get that, It is faster in terms of writing speed. If you sit down to write the same code in Java/C++ or Go, having time constraints, you will move out with Go as a winner. It is much easier to write code in Go than compared to C/C++, Java, or even Javascript. Golang prefers clear code over fast code, though it might not be as fastest as Rust or C++, it is definitely much easier and quicker to write than the other counterparts. Go is designed for writing software that can scale with large codebases and teams. So it&#39;s not a surprise it is used to create cloud computing technologies like Docker, Kubernetes, and other tons of cloud-native tools. &#xA;&#xA;### 4. GO lang is made for the modern world&#xA;&#xA;&gt; Go lang is the modern C&#xA;&#xA;Go lang is a modern language, it is not as ancient as C/C++ or Java. It is designed for Cloud-native applications which are scalable and optimized for performance meeting the needs of the modern demand for bleeding-edge technologies. It is designed by the people who created the UNIX operation, Ken Thompson. Though there were other go authors like Robert Griesemer and Rob Pike. Go lang has been designed keeping the idea of C but also considering the context of the modern world. It makes tasks like concurrency a lot simpler but it avoids dangerous and manual control of memory by not allowing pointer arithmetic.  &#xA;&#xA;## Where you can use Golang&#xA;&#xA;Go land finds its use case in a lot of domains including Cloud computing, Web applications, CLI and DevOps tools, and so on. As GO is a general-purpose programming language, you can use it anywhere in the relevant fields of technology. &#xA;&#xA;### Cloud-native application&#xA;&#xA;As Golang has capabilities to execute low-level system calls efficiently, cloud-native tools can be created in golang for improving efficiency and memory usage. As Go uses fewer resources like CPU and memory, it can optimally be used for applications that require almost no delay in the response. It also handles concurrency very well using goroutines which are way simpler to implement. All the factors contribute very well to constructing a modern cloud-native application.&#xA;&#xA;Golang is used in Cloud-native technologies like&#xA;&#xA;- [Docker](https://github.com/docker) - containerisation technology&#xA;- [Kubernetes](https://github.com/kubernetes/kubernetes) - Container Orchestration&#xA;- [Google Cloud](https://github.com/google/go-cloud) - Cloud Hosting Plaform&#xA;&#xA;This makes Golang widely adopted and has firm grounds for the future as well.&#xA;&#xA;### Web applications&#xA;&#xA;As Golang is highly efficient and fast it can be used to develop web applications. It can scale a web application very well as it is a statically typed ecosystem. It also has extensive support for integrating databases into web applications. Golang doesn&#39;t require any 3rd party integrations to create the web apps, it is developed using internal or external packages and modules. The performance of Golang is the core feature for creating web apps in it, it heavily outperforms Javascript(Node) and Python. As golang code is compiled before running, this makes a single executable depending on the operating system, this improves the performance to a great extent. So, golang should be an ideal choice for developing web applications.&#xA;&#xA;- [Soundcloud](https://developers.soundcloud.com/blog/go-at-soundcloud) - Music System Webapp&#xA;- [Uber](https://www.slideshare.net/RobSkillington/go-at-uber) - Cab Booking/Ride Sharing App&#xA;- [Allergo](https://github.com/allegro/marathon-consul/#marathon-consul-) - E-commerce Webappp&#xA;&#xA;### DevOps tools&#xA;&#xA;A lot of DevOps tools like Prometheus, Grafana, Terraform, Hugo are written natively in Go. Having appropriate features like simplicity, scalability, efficiency, and concurrency, go lang fits the DevOps space really well. Golang is already used in cloud-native technologies as mentioned earlier adopting it in the DevOps space is a great choice as it creates an even and supportive ecosystem. The `Write once and Run anywhere` paradigm of java is surprisingly built-in golang as well without conversion into byte code. This is a great feature any DevOps engineer would dream of, using a single code base for multiple platforms can save a lot of time and improve productivity.  &#xA;&#xA;- [Prometheus](https://github.com/prometheus/prometheus) - Monitoring system and time series database&#xA;- [Grafana](https://github.com/grafana/grafana) - Platform for monitoring and observability&#xA;- [Terraform](https://github.com/hashicorp/terraform) - Building, Changing, and Versioning Infrastructure &#xA;- [Minikube](https://github.com/kubernetes/minikube) - Run kubernetes locally&#xA;- [Kit](https://github.com/go-kit/kit)- standard library for microservices&#xA;&#xA;## Who uses Golang?&#xA;&#xA;Golang is a widely used programmming language, it is used by some of the big companies around the world. Of course Google uses it, apart from Google, it is being used by companies like:&#xA;&#xA;1. Netflix&#xA;2. PayPal&#xA;3. Microsoft&#xA;4. Dropbox&#xA;5. Meta (facebook)&#xA;6. Uber&#xA;7. Twitter&#xA;8. Twitch&#xA;&#xA;There are so many tools created tools using golang like the [gh-cli](https://github.com/cli/cli), [cockrach-db](https://github.com/cockroachdb/cockroach), [jwt](https://github.com/dgrijalva/jwt-go), etc. You can see a whole list of applications/tools/frameworks written in Go from this [awesome list](https://github.com/avelino/awesome-go)&#xA;&#xA;## Conclusion&#xA;&#xA;Go lang is a excellent choice for any one into web developement, cloud native, DevOps, CLI tools. Go lang being a recently developed language it has grown a lot faster than any other language in the programming world. Learning Python over the span of two years, I might want to dabble into Go but not completely leave Python. Python has a great community and is widely adopted in almost all fields in developement. Still trying out new things is what keeps you in the hunt of oppurtunitiees and meeting new people. &#xA;&#xA;So starting from today, I will share my learning a new thing in Go lang every day for 100 days. At least that&#39;s the plan. The post might be in the form of a long post or a short TIL on the blog. Check out the GitHub repository for the 100 day challenge [here](https://github.com/mr-destructive/100-days-of-golang).If you have any queries, suggestions, or feedback please let me know in the comments or on the mentioned social handles. Thank you for reading.  Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
  </channel>
</rss>