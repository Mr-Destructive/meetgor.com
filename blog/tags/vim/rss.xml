<rss version="2.0">
  <channel>
    <title>Meet Gor - Tag: vim</title>
    <link>meetgor.com</link>
    <description>Posts tagged with vim</description>
    <language>en-us</language>
    <pubDate>Fri, 17 Oct 2025 16:57:38 UTC</pubDate>
    <item>
      <title>Neovim + Sourcegraph Cody Plugin Integration</title>
      <link>meetgor.com/neovim-sourcegraph-cody</link>
      <description>Installing and Setting up Sourcegraph Plugin and Cody into Neovim. Enabling code generations, chat and sourcegraph search feature in Neovim.</description>
      <pubDate>Sat, 06 Jan 2024 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Have you ever used Sourcegraph&#39;s Cody? It is a great tool for developers, it is not just another LLM, it is tailored specifically for developers. Cody has some good features that allow parsing of context for the prompt in a smarter way.&#xA;&#xA;### What is Sourcegraph&#39;s Cody&#xA;&#xA;Cody is an AI assistant for developers that understands code context and can generate code. It goes beyond just answering questions - it can write code for you.&#xA;&#xA;The major features of Cody from the rest of the LLMs or Chatbots are:&#xA;&#xA;* Cody understands your code context - it reads your open files, repositories, etc. So it can answer questions specifically about your codebase, not just general programming questions.&#xA;&#xA;* Cody can explain sections of code to you in plain English. This helps ramp up on unfamiliar code bases.&#xA;&#xA;* Cody integrates into popular editors like VS Code, IntelliJ, Neovim, and others for frictionless use while coding.&#xA;&#xA;For more insights, check out the blog [all you need is Cody](https://about.sourcegraph.com/blog/all-you-need-is-cody). This is a great article about what and how Cody is tailored specifically to assist developers.&#xA;&#xA;## Prerequisites&#xA;&#xA;To setup sourcegraph on neovim, you will require the following setup:&#xA;&#xA;* Neovim 0.9 or above&#xA;&#xA;* Node.js &amp;gt;= 18.17 (LTS)&#xA;&#xA;* Cargo (Rust) (optional)&#xA;&#xA;To install neovim latest/nightly release, you can follow the [INSTALL](https://github.com/neovim/neovim/blob/master/INSTALL.md) or [BUILD](https://github.com/neovim/neovim/blob/master/BUILD.md) documentation of the neovim project.&#xA;&#xA;Cargo is optional, as the plugin will install the binaries itself, however, if you prefer to have cargo, just install it in case something goes wrong.&#xA;&#xA;## Installing sg.nvim&#xA;&#xA;There is a specific plugin for neovim for interacting with the Sourcegraph products, and Cody is one of them. The [sg.nvim](https://github.com/sourcegraph/sg.nvim) is a plugin for integrating sourcegraph search, Cody, and other features provided by soucegraph.&#xA;&#xA;#### Using packer.nvim&#xA;&#xA;```lua&#xA;use { &#39;sourcegraph/sg.nvim&#39;, run = &#39;nvim -l build/init.lua&#39; }&#xA;use { &#39;nvim-lua/plenary.nvim&#39; }&#xA;```&#xA;&#xA;Source your lua file where you have configured all the plugins and then enter the command `:PackerInstall` or `:PackerSync` to install the plugin.&#xA;&#xA;#### Using vim-plug&#xA;&#xA;If you are using vim-plug as the plugin manager, you can add the plugin to the configuration as below:&#xA;&#xA;```plaintext&#xA;Plug &#39;sourcegraph/sg.nvim&#39;, { &#39;do&#39;: &#39;nvim -l build/init.lua&#39; }&#xA;&#xA;&#34; Required for various utilities&#xA;Plug &#39;nvim-lua/plenary.nvim&#39;&#xA;&#xA;&#34; Required if you want to use some of the search functionality&#xA;Plug &#39;nvim-telescope/telescope.nvim&#39;&#xA;```&#xA;&#xA;You can source the file and run the command `:PlugInstall` to install the plugin.&#xA;&#xA;#### Using Lazy.nvim&#xA;&#xA;If you are using Lazy.nvim as the plugin manager, you can add the plugin to the Configuration as below:&#xA;&#xA;```lua&#xA;return {&#xA;  {&#xA;    &#34;sourcegraph/sg.nvim&#34;,&#xA;    dependencies = { &#34;nvim-lua/plenary.nvim&#34;, &#34;nvim-telescope/telescope.nvim&#34; },&#xA;&#xA;    -- If you have a recent version of lazy.nvim, you don&#39;t need to add this!&#xA;    build = &#34;nvim -l build/init.lua&#34;,&#xA;  },&#xA;}&#xA;```&#xA;&#xA;You can source the file and run the command `:Lazy install` to install the plugin.&#xA;&#xA;For other installation instructions, you can refer to the [README](https://github.com/sourcegraph/sg.nvim?tab=readme-ov-file#install) of sg.nvim.&#xA;&#xA;### Installing Binaries and Building the Plugin&#xA;&#xA;After the plugin is installed, you can move into the building and setup process of the sourcegraph Cody plugin.&#xA;&#xA;To install the binaries which are the dependencies of the plugin, you can run the command `:SourcegraphDownloadBinaries` which will force downloading the binaries, making sure that the plugin is properly installed.&#xA;&#xA;![SourcegraphDownloadBinaries Command Output](https://meetgor-cdn.pages.dev/sg-nvim-build.png)&#xA;&#xA;To build the plugin, you can simply run the command from within neovim as `:SourcegraphBuild`, this will rebuild the Sourcegraph rust crates and its dependencies (which might have failed during installation).&#xA;&#xA;### Sourcegraph Authentication&#xA;&#xA;You need to now authenticate to your Sourcegraph account to use the sourcegraph features such as search and Cody.&#xA;&#xA;You can do that by running the command `:SourcegraphLogin` in neovim. This will require two inputs, the sourcegraph endpoint and the access token. If you are using sourcegraph cloud and not a self-hosted sourcegraph, you do not need to change the endpoint, just press enter and move ahead. This will redirect you to the browser for authentication and creating an access token. Log in with your credentials to sourcegraph and copy the access token.&#xA;&#xA;This will prompt you back to the neovim interface to provide the access token. Paste the access token there and you will be good to go.&#xA;&#xA;### Health Check&#xA;&#xA;Once the plugins are installed then you can check the plugin is correctly downloaded by checking the health with the `:checkhealth sg` command.&#xA;&#xA;Below is the health check report on the sourcegraph plugin in neovim.&#xA;&#xA;```plaintext&#xA;sg: require(&#34;sg.health&#34;).check()&#xA;&#xA;sg.nvim report ~&#xA;- Machine: x86_64, sysname: Linux&#xA;- OK Valid nvim version: table: 0x7ffa0b7bce38&#xA;- OK Found `cargo` (cargo 1.70.0) is executable&#xA;-     Use `:SourcegraphDownloadBinaries` to avoid building locally.&#xA;- OK Found `sg-nvim-agent`: &#34;/home/meet/.local/share/nvim/site/pack/packer/start/sg.nvim/dist/sg-nvim-agent&#34;&#xA;- OK Found `node` (config.node_executable) is executable.&#xA;  Version: &#39;20.10.0&#39;&#xA;- OK Found `cody-agent`: /home/meet/.local/share/nvim/site/pack/packer/start/sg.nvim/dist/cody-agent.js&#xA;- OK   Authentication setup correctly&#xA;- OK     endpoint set to: https://sourcegraph.com&#xA;- OK Found correct binary versions: &#34;1.0.5&#34; = &#34;1.0.5&#34;&#xA;- OK   Sourcegraph Connection info: {&#xA;  access_token_set = true,&#xA;  endpoint = &#34;https://sourcegraph.com&#34;,&#xA;  sg_nvim_version = &#34;1.0.5&#34;,&#xA;  sourcegraph_version = {&#xA;&#x9;&#x9;  build = &#34;256174_2023-12-30_5.2-dbb20677711c&#34;,&#xA;&#x9;&#x9;  product = &#34;256174_2023-12-30_5.2-dbb20677711c&#34;&#xA;  }&#xA;  }&#xA;- To manage your Cody Account, navigate to: https://sourcegraph.com/cody/manage&#xA;- OK Cody Account Information: {&#xA;&#x9;  chat_limit = 20,&#xA;&#x9;  chat_usage = 53,&#xA;&#x9;  code_limit = 500,&#xA;&#x9;  code_usage = 0,&#xA;&#x9;  cody_pro_enabled = false,&#xA;&#x9;  username = &#34;Mr-Destructive&#34;&#xA;  }&#xA;- OK sg.nvim is ready to run&#xA;```&#xA;&#xA;At this point, the sourcegraph plugin is ready to be used. However, we need to set up the plugin in neovim with the default configurations.&#xA;&#xA;### Configuration&#xA;&#xA;In your lua setup files, you can set the plugin like this:&#xA;&#xA;```lua&#xA;require(&#34;sg&#34;).setup()&#xA;```&#xA;&#xA;Source the lua file and restart neovim, this should properly make sourcegraph commands available in the editor. After these steps, Cody is right into neovim.&#xA;&#xA;## Usage&#xA;&#xA;To use the plugin, there are multiple commands available within the editor, the complete list of them is given below:&#xA;&#xA;```plaintext&#xA;SourcegraphBuild&#xA;SourcegraphClear&#xA;SourcegraphDownloadBinaries&#xA;SourcegraphInfo&#xA;SourcegraphLink&#xA;SourcegraphLogin&#xA;SourcegraphSearch&#xA;&#xA;CodyAsk&#xA;CodyChat&#xA;CodyDo&#xA;CodyRestart&#xA;CodyTask&#xA;CodyTaskAccept&#xA;CodyTaskNext&#xA;CodyTaskPrev&#xA;CodyTaskView&#xA;CodyToggle&#xA;```&#xA;&#xA;You can get more info about these commands with the `help :commandname` command. The command are however self explanatory and simple to use.&#xA;&#xA;### Cody Ask&#xA;&#xA;You can quickly parse a prompt as a string to the `:CodyAsk` command as `:CodyAsk &#34;what is neovim by the way?&#34;` and you will get Cody&#39;s response in the side vertical split.&#xA;&#xA;### Cody Chat&#xA;&#xA;You can start Cody chats from neovim with the command `:CodyChat`. This will open a vertical split with the Cody chat interface, the bottom split has the user input prompt and the upper window will have the generated Cody response. You can enter the prompt in the bottom buffer get into normal mode and hit enter to send the prompt to generate a response from Cody.&#xA;&#xA;![Sourcegraph Cody Chat Interface](https://meetgor-cdn.pages.dev/sg-nvim-cody-chat.png)&#xA;&#xA;## Conclusion&#xA;&#xA;Sourcegraph Cody is a great tool for getting quick solutions to trivial as well as specific problems to the current file/package or project. The context parsing of Cody makes it valuable for developers to ask for specific questions and it answers them really in a straightforward way, without the developer needing to parse the context for the prompt. Thank you for reading. Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Map Vimscript Keymaps to Lua with a single function</title>
      <link>meetgor.com/vimscript-to-lua-keymapper</link>
      <description>Takeout the vimscript keymaps into lua with a single function call in Neovim</description>
      <pubDate>Mon, 11 Jul 2022 00:00:00 UTC</pubDate>
      <content>## Introduction&#xA;&#xA;Are you bored of writing all the keymaps from vimscript to lua? Try the below function to create all your keymaps to lua equivalent maps in Neovim.&#xA;&#xA;Take your vimscript keymaps and put them in lua don&#39;t write any lua for it ;)&#xA;&#xA;## The Lua Function&#xA;&#xA;The below-provided snippet is a lua function that takes in a table of strings(list of strings), the strings will be your keymaps. The function then maps these keymaps using lua functions. You don&#39;t have to type out all the keymaps by yourself. It can also print out the lua equivalent function calls required to map the existing keymaps from vimscript to lua runtime in Neovim. Though it won&#39;t handle all the options, we have passed in a default value to the keymap.&#xA;&#xA;```lua&#xA;function key_mapper(keymaps)&#xA;  for _, keymap in ipairs(keymaps) do&#xA;    local mode = keymap:sub(1,1)&#xA;    local delimiter = &#34; &#34;&#xA;    local lhs = &#39;&#39;&#xA;    local rhs_parts = {}&#xA;    local m = 0&#xA;    local options = {noremap = true}&#xA;    for matches in (keymap..delimiter):gmatch(&#34;(.-)&#34;..delimiter) do&#xA;      if m == 1 then&#xA;        lhs = matches&#xA;      end&#xA;      if m &gt;= 2 then&#xA;        table.insert(rhs_parts, matches)&#xA;      end&#xA;      m = m + 1&#xA;    end&#xA;    rhs = &#39;&#39;&#xA;    for _, p in ipairs(rhs_parts) do&#xA;      rhs = rhs .. &#34; &#34; .. p&#xA;    end&#xA;    --print(&#34;vim.keymap.set(&#34;..&#34;\&#39;&#34;..mode..&#34;\&#39;&#34;..&#34;, &#34;..&#34;\&#39;&#34;..lhs..&#34;\&#39;&#34;..&#34;, &#34;..&#34;\&#39;&#34;..rhs..&#34;\&#39;&#34;..&#34;, &#34;..vim.inspect(options)..&#34;)&#34;)&#xA;    vim.keymap.set(mode, lhs, rhs, options)&#xA;  end&#xA;end&#xA;```&#xA;&#xA;You can uncomment the print statement **once** to grab the keymaps and paste them into the config file. If you leave it uncommented, it might print every time you open up a new neovim instance. The function can be called like below:&#xA;&#xA;```lua&#xA;key_mapper({&#xA;  &#39;nnoremap cpp :!c++ % -o %:r &amp;&amp; %:r&lt;CR&gt;i&#39;,&#xA;  &#39;nnoremap c, :!gcc % -o %:r &amp;&amp; %:r&lt;CR&gt;&#39;,&#xA;  &#39;nnoremap py :!python %&lt;cr&gt;&#39;,&#xA;  &#39;nnoremap go :!go run %&lt;cr&gt;&#39;,&#xA;  &#39;nnoremap sh :!bash %&lt;CR&gt;&#39;&#xA;})&#xA;```&#xA;&#xA;![Keymapper demonstration](https://res.cloudinary.com/techstructive-blog/image/upload/v1657559501/blog-media/neovim-lua-keymapper.gif)&#xA;&#xA;We pass in a table of strings, these strings are just the vimscript keymaps. This function call will then map the keymaps into equivalent lua maps. You can customize it as per your needs.&#xA;&#xA;For further references, you can check out my [dotfiles](https://github.com/Mr-Destructive/dotfiles) on GitHub.&#xA;&#xA;## How the function works&#xA;&#xA;The function is simply a text scrapping from lua strings. We extract the first character in the string for the mode, grab the strings which are space-separated and finally sort out which are lhs and rhs sides of the maps.&#xA;&#xA;We iterate over the table in lua with the help of ipairs function which allows us to iterate over an ordered list of items in a table. Using the gmatch function, we find a pattern to split the string with the space as the delimiter. Thereby, we can have separate sets of strings identified as rhs and lhs. We can store them in variables as strings as the lua functions require them as strings.&#xA;&#xA;We simply add those variables into the [vim.keymap.set](https://neovim.io/doc/user/lua.html#:~:text=set(%7Bmode%7D%2C%20%7Blhs%7D%2C%20%7Brhs%7D%2C%20%7Bopts%7D)%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20*vim.keymap.set()*) or [vim.api.nvim_set_keymap](https://neovim.io/doc/user/api.html#nvim_set_keymap():~:text=nvim_set_keymap(%7Bmode%7D%2C%20%7Blhs%7D%2C%20%7Brhs%7D%2C%20%7B*opts%7D)%20%20%20%20%20%20%20%20%20%20%20%20%20*nvim_set_keymap()*) functions. We by default set the value of `{noremap: True}` to avoid teh recursive mapping of the keys. These option parameter is the one which needs to be a bit more dynamic in terms of wide variety of keymaps.&#xA;&#xA;So, this is how we can convert the vimscript keymaps to lua in Neovim. Hope you found this useful. Thanks for reading. Happy Viming :)&#xA;</content>
      <type>til</type>
    </item>
    <item>
      <title>Configure Neovim in Lua</title>
      <link>meetgor.com/neovim-vimscript-to-lua</link>
      <description>Setting up or Migrating to Lua in Neovim Configuration. Using Lua in Neovim for configurations and moving out of Vimscript. Setting up Keymaps, Plugins, customizations</description>
      <pubDate>Sat, 09 Jul 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;It has been a while since I have written a Vim article. Finally, I got some ideas after configuring my Neovim setup for Lua. I recently migrated to Ubuntu a couple of months back and it has been a cool change from Windows 7! &#xA;&#xA;In this article, we&#39;ll see how you can set up neovim for Lua. Since Neovim 0.5, it supports lua out of the box, so in the recent release 0.7, it added more native support to lua making it a lot easier to configure and play with neovim. So, we will see how we can use lua to convert all the 200 liner vimscript into lua (We can even have packages and modules:) We will cover how to configure your keymaps, pull up all the plugins, vim options, and other customizations.&#xA;&#xA;## Why move to Lua?&#xA;&#xA;I have used Vimscript for quite a while now, configured it as per my needs, and also made a few plugins like [frontmatter](https://github.com/Mr-Destructive/frontmatter.vim), [dj.vim](https://github.com/Mr-Destructive/dj.vim), and [commenter](https://github.com/Mr-Destructive/commenter.vim) which are quite clunky and not robust in terms of usage and customizability. Vimscript is good but it&#39;s a bit messy when you want extreme customization. &#xA;&#xA;I recently wanted to go full Neovim, I was kind of stuck in Vimscript and some of my plugins work for me but it might not work for others, it might be a piece of gibberish vimscript dumped. So, Why not have full native experience in Neovim if you can. It has now baked-in support for LSP, Debugging, Autocommands, and so much more. If you have Neovim 0.5+ you should be good to go full lua.&#xA;&#xA;## Backup Neovim Config&#xA;&#xA;Firstly, keep your original neovim/vim init files safe, back them up, make a copy and save it with a different name like `nvim_config.vim`. If you already have all your config files backed up as an ansible script or dotfiles GitHub repository, you can proceed ahead. &#xA;&#xA;But don&#39;t keep the `init.vim` file as it is in the `~/.config/nvim` folder, it might override after we configure the lua scripts.&#xA;&#xA;## Basic Configuration&#xA;&#xA;So, I assume you have set up Neovim, If not you need to follow some simple steps like downloading the package and making sure your neovim environment is working with vimscript first. The [Neovim Wiki](https://github.com/neovim/neovim/wiki/Installing-Neovim) provides great documentation on how to install neovim on various platforms using different methods.&#xA;&#xA;After your neovim is set up and you have a basic configuration, you can now start to migrate into lua.&#xA;Create a `init.lua` file in the same path as your `init.lua` file is i.e. at `~/.config/nvim` or `~/AppData/Local/nvim/` for Windows. That&#39;s why it is recommended to keep the initial configuration vimscript file in a safe place. While migrating from vimscript to lua, once the lua file is created and the next time you restart neovim, the default settings will be from `init.lua` and not `init.vim`, so be prepared.&#xA;&#xA;Firstly, you need to configure some options like `number`, `syntax highlighting`, `tabs`, and some `keymaps` of course. We can use the `vim.opt` method to set options in vim using lua syntax. So, certain corresponding vim options would be converted as follows:&#xA;&#xA;If you have the following kind of settings in your vimrc or init.vim:&#xA;&#xA;```vimscript&#xA;-- vimscript&#xA;set number&#xA;set tabstop=4 &#xA;set shiftwidth=4 &#xA;set softtabstop=0 &#xA;set expandtab &#xA;set noswapfile&#xA;```&#xA;The above settings are migrated into lua syntax as follows:&#xA;&#xA;```lua&#xA;--lua&#xA;vim.opt.number = true&#xA;vim.opt.tabstop = 4&#xA;vim.opt.shiftwidth = 4&#xA;vim.opt.softtabstop = 0&#xA;vim.opt.expandtab = true&#xA;vim.opt.swapfile = false&#xA;```&#xA;&#xA;You can set other options in your config file accordingly. If you get sick of writing `vim.opt.` again and again, you can use a variable set to `vim.opt` and then access that variable to set the options. Something of the lines as below:&#xA;&#xA;```lua&#xA;local set = vim.opt&#xA;&#xA;set.number = true&#xA;set.tabstop = 4&#xA;set.shiftwidth = 4&#xA;set.softtabstop = 0&#xA;set.expandtab = true&#xA;set.swapfile = false&#xA;```&#xA;&#xA;We can create a variable in lua like `local variable_name = something` so, we have created a variable `set` which is assigned to the value of `vim.opt` which is a method(function) in lua to set the options from the vimscript environment. Finally, access the `set` keyword to set the options. Using the `set` word is not necessary, you can use whatever you want. &#xA;&#xA;After setting up the basic options, you can source the file with `:so %` from the command mode. Just normally as you source the config files.&#xA;&#xA;### Using Lua in Command Mode&#xA;&#xA;We can use the lua functions or any other commands from the command mode in neovim using the lua command. Just prefix the command with `:lua` and after that, you can use lua syntax like function calling or setting variables, logging things, etc.&#xA;&#xA;![Lua in Command Mode](https://res.cloudinary.com/techstructive-blog/image/upload/v1657380885/blog-media/lua_in_command_mode.gif)&#xA;&#xA;## Adding Keymaps&#xA;&#xA;Now, that we have some basic config setup, we can quickly get the keymaps. It&#39;s not that hard to make keymaps to set up in lua. To create keymaps, we have two options. One is compatible with Neovim and the other is compatible with Vim as well.&#xA;&#xA;1. vim.keymap.set OR &#xA;2. vim.api.nvim_set_keymap&#xA;&#xA;Personally, I don&#39;t see a difference in terms of usage but [vim.keymap.set](https://github.com/neovim/neovim/blob/master/runtime/lua/vim/keymap.lua#L51) is a wrapper around [nvim_set_keymap](https://github.com/neovim/neovim/blob/master/src/nvim/api/vim.c#L1451). So, it is really a matter of personal preference which you want to use. &#xA;&#xA;So, both the functions have quite similar parameters:&#xA;&#xA;```lua&#xA;vim.keymap.set({mode}, {lhs}, {rhs}, {options})&#xA;&#xA;vim.api.nvim_set_keymap({mode}, {lhs}, {rhs}, {options})&#xA;```&#xA;&#xA;The advantage of `vim.keymap.set` over `vim.api.nvim_set_keymap` is that it allows directly calling lua functions rather than calling vimscripty way like `:lua function()`, so we directly can use lua code in the RHS part of the function parameter.&#xA;&#xA;Let&#39;s take a basic example mapping:&#xA;&#xA;```&#xA;vim.keymap.set(&#39;n&#39;, &#39;Y&#39;, &#39;yy&#39;, {noremap = false})&#xA;```&#xA;&#xA;Here, we have mapped `Shift+y` with the keys `yy` in `n`ormal mode. The first argument is the mode, it can be a single-mode like `&#39;n&#39;`, `&#39;v&#39;`, `&#39;i&#39;`, etc., or a multi-mode table like `{&#39;n&#39;, &#39;v&#39;}`, `{&#39;v&#39;, &#39;i&#39;}`, etc. &#xA;&#xA;The next parameter is also a string but it should be the key for triggering the mapping. In this case, we have used `Y` which is `Shift + y`, it can be any key shortcut you want to map.&#xA;&#xA;The third parameter is the string which will be the command to be executed after the key has been used. Here we have used the keys `yy`, if the map is from a command mode, you will be using something like `&#39;:commands_to_be executed&#39;` as the third parameter.&#xA;&#xA;The fourth parameter which is optional can contain [special arguments](https://neovim.io/doc/user/api.html#:~:text=nvim_set_keymap(%7Bmode%7D%2C%20%7Blhs%7D%2C%20%7Brhs%7D%2C%20%7B*opts%7D)%20%20%20%20%20%20%20%20%20%20%20%20%20*nvim_set_keymap()*). We have set a default option which is `noremap` as true, the options are not string but lua tables instead, so it can be similar to python dictionary or a map kind of a structure with a key value pair.&#xA;&#xA;&#xA;One more important aspect in keymapping might about the leader key, you can set your leader key by using the global vim options with `vim.g` and access `mapleader` to set it to the key you wish. This will make the `leader` key available to us and thereafter we can map the leader key in custom mappings.&#xA;&#xA;```&#xA;vim.g.mapleader = &#34; &#34;&#xA;```&#xA;&#xA;Here, I have set my leader key to the `&lt;Space&gt;` key. Now, we can map keys to the existing keymaps in the vimscript. Let&#39;s map some basic keymaps first and then after setting up the plugins,we can move into plugin-specific mappings.&#xA;&#xA;You can also use `vim.api.nvim_set_keymap` function with the same parameters as well. &#xA;&#xA;```lua&#xA;vim.keymap.set(&#39;n&#39;, &#39;&lt;leader&gt;w&#39;, &#39;:w&lt;CR&gt;&#39;,{noremap = true})&#xA;vim.keymap.set(&#39;n&#39;, &#39;&lt;leader&gt;q&#39;, &#39;:q!&lt;CR&gt;&#39;,{noremap = true})&#xA;vim.keymap.set(&#39;n&#39;, &#39;&lt;leader&gt;s&#39;, &#39;:so %&lt;CR&gt;&#39;,{noremap = true})&#xA;vim.keymap.set(&#39;n&#39;, &#39;&lt;leader&gt;ev&#39;, &#39;:vsplit $MYVIMRC&lt;CR&gt;&#39;,{noremap = true})&#xA;vim.keymap.set(&#39;n&#39;, &#39;&lt;leader&gt;sv&#39;, &#39;:w&lt;CR&gt;:so %&lt;CR&gt;:q&lt;CR&gt;&#39;,{noremap = true})&#xA;&#xA;OR&#xA;&#xA;vim.api.nvim_set_keymap(&#39;n&#39;, &#39;&lt;leader&gt;w&#39;, &#39;:w&lt;CR&gt;&#39;,{noremap = true})&#xA;vim.api.nvim_set_keymap(&#39;n&#39;, &#39;&lt;leader&gt;q&#39;, &#39;:q!&lt;CR&gt;&#39;,{noremap = true})&#xA;vim.api.nvim_set_keymap(&#39;n&#39;, &#39;&lt;leader&gt;s&#39;, &#39;:so %&lt;CR&gt;&#39;,{noremap = true})&#xA;vim.api.nvim_set_keymap(&#39;n&#39;, &#39;&lt;leader&gt;ev&#39;, &#39;:vsplit $MYVIMRC&lt;CR&gt;&#39;,{noremap = true})&#xA;vim.api.nvim_set_keymap(&#39;n&#39;, &#39;&lt;leader&gt;sv&#39;, &#39;:w&lt;CR&gt;:so %&lt;CR&gt;:q&lt;CR&gt;&#39;,{noremap = true})&#xA;```&#xA;&#xA;If, you don&#39;t like writing `vim.keymap.set` or `vim.api.nvim_set_keymap` again and again, you can create a simpler function for it. In lua a function is created just like a variable by specifying the scope of the function i.e. local followed by the `function` keyword and finally the name of the function and parenthesis. The function body is terminated by the `end` keyword.&#xA;&#xA;```lua&#xA;function map(mode, lhs, rhs, opts)&#xA;    local options = { noremap = true }&#xA;    if opts then&#xA;        options = vim.tbl_extend(&#34;force&#34;, options, opts)&#xA;    end&#xA;    vim.api.nvim_set_keymap(mode, lhs, rhs, options)&#xA;end&#xA;```&#xA;Now, in this function `map`, we have passed in the same parameters like the `vim.keymap.set` function takes but we have just parsed the function in a shorter and safer way by adding `noremap = true` by default. So this is just a helper function or a verbose function for calling the vim.keymap.set function.&#xA;&#xA;To use this function, we can simply call `map` with the same arguments as given to the prior functions.&#xA;&#xA;```lua&#xA;map(&#39;n&#39;, &#39;&lt;leader&gt;w&#39;, &#39;:w&lt;CR&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;&lt;leader&gt;q&#39;, &#39;:q!&lt;CR&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;&lt;leader&gt;s&#39;, &#39;:so %&lt;CR&gt;&#39;)&#xA;```&#xA;&#xA;Notice here, though, we have not passed the `{noremap = true}` as it will be passed by default to the `vim.api.nvim_set_keymap` or `vim.keymap.set` function via the custom map function.&#xA;&#xA;If you want some more examples, here are some additional mapping specific to languages, meant for compiling or running scripts with neovim instance. &#xA;&#xA;```lua&#xA;-- vimscript&#xA;&#xA;nnoremap cpp :!c++ % -o %:r &amp;&amp; %:r&lt;CR&gt;&#xA;nnoremap c, :!gcc % -o %:r &amp;&amp; %:r&lt;CR&gt;&#xA;nnoremap py :!python %&lt;cr&gt;&#xA;nnoremap go :!go run %&lt;cr&gt;&#xA;nnoremap sh :!bash %&lt;CR&gt;&#xA;&#xA;&#xA;-- lua&#xA;&#xA;map(&#39;n&#39;, &#39;cpp&#39; &#39;:!c++ % -o %:r &amp;&amp; %:r&lt;CR&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;c,&#39; &#39;:!gcc % -o %:r &amp;&amp; %:r&lt;CR&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;py&#39; &#39;:!python %&lt;cr&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;go&#39; &#39;:!go run %&lt;cr&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;sh&#39; &#39;:!bash %&lt;cr&gt;&#39;)&#xA;&#xA;```&#xA;&#xA;So, this is how we can set up our keymaps in lua. You can customize this function as per your needs. These are just made for the understanding purpose of how to reduce the repetitive stuff in the setup.&#xA;&#xA;**If you are really stuck up and not feeling to convert those mappings into lua then I have a function that can do it for you, check out my dotfile repo -&gt; [keymapper](https://github.com/Mr-Destructive/dotfiles/blob/master/nvim/lua/destructive/options.lua#L9)**&#xA;&#xA;## Adding Plugin Manager&#xA;&#xA;Now, we really missing some plugins, aren&#39;t we? So, the neovim community has some good choices for using a new plugin manager written in core lua. It is usually a good idea to move into lua completely rather than switching to and fro between vimscript and lua.&#xA;&#xA;So, [Packer](https://github.com/wbthomason/packer.nvim) is the new plugin manager for Neovim in Lua, there is other plugin managers out there as well like [paq](https://github.com/savq/paq-nvim). If you don&#39;t want to switch with the plugin manager, you can still use vim-based plugin managers like [Vim-Plug](https://dev.to/vonheikemen/neovim-using-vim-plug-in-lua-3oom).&#xA;&#xA;So, let&#39;s install the Packer plugin manager into Neovim. We simply have to run the following command in the console and make sure the plugin manager is configured correctly.&#xA;&#xA;```&#xA;# Linux&#xA;&#xA;git clone --depth 1 https://github.com/wbthomason/packer.nvim\&#xA;~/.local/share/nvim/site/pack/packer/start/packer.nvim&#xA;&#xA;&#xA;# Windows&#xA;&#xA;git clone https://github.com/wbthomason/packer.nvim &#34;$env:LOCALAPPDATA&#xA;vim-data\site\pack\packer\start\packer.nvim&#34;&#xA;```&#xA;&#xA;Now, if you open a new neovim instance and try to run the command `:PackerClean`, and no error pops out that means you have configured it correctly. You can move ahead to installing plugins now. Yeah! PLUG-IN time! &#xA;&#xA;```lua&#xA;return require(&#39;packer&#39;).startup(function()&#xA;end)&#xA;```&#xA;&#xA;First try to source the file, if it throws out errors it shouldn&#39;t try to fix the installation path of Packer. If the command succeded we can finally pull up some plugins.&#xA;&#xA;Below are some of the plugins that you can use irrespective of what language preferences you would have. This includes basic dev-icons for the status line as well as the explorer window file icons. As usual, add your plugins and make them yours.&#xA;&#xA;```lua&#xA;&#xA;return require(&#39;packer&#39;).startup(function()&#xA;  use &#39;wbthomason/packer.nvim&#39;&#xA;  use &#39;tpope/vim-fugitive&#39;&#xA;  use {&#xA;    &#39;nvim-lualine/lualine.nvim&#39;,&#xA;    requires = { &#39;kyazdani42/nvim-web-devicons&#39;, opt = true }&#xA;  }&#xA;  use &#39;tiagofumo/vim-nerdtree-syntax-highlight&#39;&#xA;  use &#39;kyazdani42/nvim-web-devicons&#39;&#xA;  use &#39;vim-airline/vim-airline&#39;&#xA;  use &#39;vim-airline/vim-airline-themes&#39;&#xA;end)&#xA;```&#xA;&#xA;After adding the list of your plugins, you need to source the file and then install the plugins with the command `:PackerInstall`. This function will install all the plugins after the file has been sourced so make sure you don&#39;t forget it.&#xA;&#xA;## Colors and Color Themes&#xA;&#xA;You might fancy some good-looking and aesthetic setup for neovim of course! In Neovim, we already have a wide variety of configurations to set up like color schemes, GUI colors, terminal colors, etc. You can pick up a color scheme from a large list of awesome color schemes from [GitHub](https://github.com/topics/neovim-colorscheme). &#xA;&#xA;After choosing the theme, plug it in the packer plugin list which we just created and source the file and finally run `:PackerInstall`. This should install the plugin. You can then set the colorscheme as per your preference, first view the color scheme temporarily on the current instance with the command `:colorscheme colorscheme_name`. &#xA;&#xA;```lua&#xA;return require(&#39;packer&#39;).startup(function()&#xA;  use &#39;wbthomason/packer.nvim&#39;&#xA;  -- &#xA;  use &#39;Mofiqul/dracula.nvim&#39;&#xA;  --&#xA;end)&#xA;```&#xA;&#xA;You can then add the command to set it as the default color scheme for Neovim.&#xA;&#xA;```lua&#xA;vim.cmd [[silent! colorscheme dracula]]&#xA;```&#xA;&#xA;You can change the background color, text color, icons style and terminal and gui style separately with the augroup and setting the colorscheme commands.&#xA;&#xA;```lua&#xA;vim.api.nvim_command([[&#xA;    augroup ChangeBackgroudColour&#xA;        autocmd colorscheme * :hi normal termbg=#000030 termfg=#ffffff&#xA;        autocmd colorscheme * :hi Directory ctermfg=#ffffff&#xA;    augroup END&#xA;]])&#xA;vim.o.termguicolors = true&#xA;```&#xA;&#xA;Here, I have used the background and foreground colors of the terminal variant of Neovim. Also for the Directory Explorer i.e. netrw, I have changed the terminal foreground. This you can configure as per your needs, Though this is still vimscripty, there are Autocommands and autogroups available sooner in Neovim.&#xA;&#xA;## Separating Configurations&#xA;&#xA;If you wish to keep all your config in one file i.e. `init.lua` file, you can, though you can separate out things like `keymaps`, `plugins`, `custom_options` or if you have `lsp` configurations into separate lua packages or creating a separate module. This helps in loading up things as per requirement and also looks readable, making it a lot easier to test out things without breaking the whole config. &#xA;&#xA;Definitely, there will be personal preferences and pros and cons of both approaches, you can pick up whatever suits your style.&#xA;&#xA;### Creating separate packages &#xA;&#xA;To create a separate package, we can simply add a file in the same folder as `init.vim` i.e. in the folder `~/.config/nvim` or equivalent for windows. The package name can be any valid filename with the `lua` extension. &#xA;&#xA;For instance, you can create a package for all your keymaps and load it in the `init.lua` as per the order you want to load them. It can be at the top, or else if you have certain base settings lower in the init file, these might not reflect or load up in the keymap package so better to load them after some of the core settings have been set.&#xA;&#xA;Let&#39;s create the package and dump all our maps into the keymap file package.&#xA;&#xA;```lua&#xA;-- ~/.config/nvim/keymap.lua&#xA;&#xA;function map(mode, lhs, rhs, opts)&#xA;    local options = { noremap = true }&#xA;    if opts then&#xA;        options = vim.tbl_extend(&#34;force&#34;, options, opts)&#xA;    end&#xA;    vim.api.nvim_set_keymap(mode, lhs, rhs, options)&#xA;end&#xA;&#xA;map(&#39;n&#39;, &#39;&lt;leader&gt;w&#39;, &#39;:w&lt;CR&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;&lt;leader&gt;q&#39;, &#39;:q!&lt;CR&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;&lt;leader&gt;s&#39;, &#39;:so %&lt;CR&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;cpp&#39; &#39;:!c++ % -o %:r &amp;&amp; %:r&lt;CR&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;c,&#39; &#39;:!gcc % -o %:r &amp;&amp; %:r&lt;CR&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;py&#39; &#39;:!python %&lt;cr&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;go&#39; &#39;:!go run %&lt;cr&gt;&#39;)&#xA;map(&#39;n&#39;, &#39;sh&#39; &#39;:!bash %&lt;cr&gt;&#39;)&#xA;&#xA;-- more keymaps&#xA;&#xA;```&#xA;&#xA;So, this might work if you don&#39;t have any plugin-related keymaps as it would require those functions or objects available to execute. So, we might also want to separate plugins and load them first in our keymaps or in the init file.&#xA;&#xA;Now, there needs to be a way for grabbing a package. Yes, there is basically like import in python or any other programming language, lua has `require` keyword for importing packages. Since the `init` file and the `keymaps` are in the same folder path, we can simply say, `require(&#34;keymap&#34;)` in our `init.lua` file. Now, it depends on your config where you want to load this package. At the top i.e. at the beginning of neovim instance or after loading the plugins down.&#xA;&#xA;```lua&#xA;-- init.lua&#xA;&#xA;require(&#34;keymaps&#34;)&#xA;&#xA;-- At the top&#xA;-- OR&#xA;-- After loading Packer plugins&#xA;```&#xA;&#xA;So, now you can separate all your configs as per your requirement. It is like splitting up a puzzle and again combining them. Similar package can be created for `plugins`, `options` or `lsp` configurations.&#xA;&#xA;### Creating a separate module&#xA;&#xA;Now, we have seen how to create a lua package and loading in neovim. We also can create modules in neovim configuration. For instance, first, the init file is loaded, Other files might not be required hence it is not loaded by default, it is only loaded when `require`ed. So, we can create a module in lua with a folder, and inside of it, we can have packages as we had in the previous method. Also, every module can have a init file loaded first when we require that module. The rest of the packages in the module are thus made available thereafter.&#xA;&#xA;- Module is a component not loaded by default&#xA;- Only loaded when required (literally require)&#xA;- Every module can have a `init.lua` file loaded first when required.&#xA;- Require a package in module from outside -&gt; `require(&#39;module_name.package_name&#39;)`&#xA;&#xA;So, in neovim, we need to create a `lua` folder for placing all our modules so that the lua runtime is picked up correctly. Inside this lua folder, we can create a module basically a folder. This folder name can be anything you like, I like to keep it my nickname, you can use whatever you prefer. &#xA;&#xA;```&#xA;# ~/.config/nvim&#xA;&#xA;-- init.lua&#xA;-- lua/&#xA;    -- module_name/&#xA;        -- init.lua&#xA;        -- package_name.lua&#xA;        -- keymaps.lua&#xA;```&#xA;&#xA;Now, we can create packages in this module. You can move your keymaps package inside this folder. The keymaps package is nothing here but an example provided in the previous section for creating a package. You can basically dump all your keymaps in a single lua file and then import it from the init file. Similarly you can create a package inside a module and import it from the init file of the module(local init file `~/.config/nvim/lua/module_name/init.lua`) or the global init file(`~/.config/nvim/init.lua`). &#xA;&#xA;To load the packages, you have to use the same require statement irrespective of where you are importing from i.e. either from the module or from the global init file. The require statement would look like the following `require(&#34;module_name/package_name&#34;)`. Now, we can use the keymaps package to import from the module init file and then import the module from the global init file. To import a module, we can simply use the module name in the require string as `require(&#34;module_name&#34;)`.&#xA;&#xA;```lua&#xA;-- ~/.config/nvim&#xA;&#xA;-- lua/module_name/options.lua&#xA;&#xA;vim.opt.number = true&#xA;vim.opt.tabstop = 4&#xA;vim.opt.swapfile = false&#xA;&#xA;&#xA;-- lua/module_name/plugins.lua&#xA;&#xA;require(&#34;module_name.options&#34;)&#xA;return require(&#39;packer&#39;).startup(function()&#xA;  use &#39;wbthomason/packer.nvim&#39;&#xA;  --plugins&#xA;end)&#xA;&#xA;-- lua/module_name/keymap.lua&#xA;&#xA;require(&#34;module_name.plugins&#34;)&#xA;-- maps()&#xA;&#xA;&#xA;-- lua/module_name/init.lua&#xA;&#xA;require(&#34;module_name.keymaps)&#xA;&#xA;&#xA;-- init.lua&#xA;&#xA;require(&#34;module_name&#34;)&#xA;&#xA;```&#xA;&#xA;So, this is how we can create modules and packages for configurations in neovim using lua. This is also a kind of a structure for creating your own neovim plugin with lua!&#xA;&#xA;For further references, you can check out my [dotfiles](https://github.com/Mr-Destructive/dotfiles). &#xA;### References&#xA;&#xA;- [Configure Neovim for Lua](https://vonheikemen.github.io/devlog/tools/configuring-neovim-using-lua/)&#xA;- [Neovim with Lua for beginners](https://alpha2phi.medium.com/neovim-for-beginners-init-lua-45ff91f741cb)&#xA;- [TJ Devries Youtube](https://www.youtube.com/c/TJDeVries/videos)&#xA;&#xA;## Conclusion&#xA;&#xA;So, that is just a basic overview of how you can get your neovim configured for lua. It is a great experience to just create such a personalized environment and play with it and have fun. You might have hopefully configured Neovim for Lua from this little guide. Maybe in the next article, I&#39;ll set up LSP in Neovim. If you have any queries or feedback, please let me know. Thank you for reading.&#xA;&#xA;Happy Viming :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Autoformat Python file with Black after saving in Vim</title>
      <link>meetgor.com/vim-python-black-autoformat</link>
      <description>Automatically format python code in the current file after saving the file in Vim.</description>
      <pubDate>Tue, 29 Mar 2022 00:00:00 UTC</pubDate>
      <content>If you are like me who writes Python very badly, it has empty lines with whitespaces, no proper format in assigning variables, not formatted according to [PEP 8](https://peps.python.org/pep-0008/) standards, and you use Vim as your text editor then my friend you need a autocmd badly for it.&#xA;&#xA;## Install Black in Python&#xA;&#xA;Install the [black](https://pypi.org/project/black/) package in python globally or locally as per your preferences.&#xA;&#xA;```&#xA;pip install black&#xA;```&#xA;&#xA;OR with pipx&#xA;&#xA;```&#xA;pipx install black&#xA;```&#xA;&#xA;For a detailed guide about running packages with pipx head toward my article on [pipx](https://mr-destructive.github.io/techstructive-blog/pipx-intro/).&#xA;&#xA;## Set up Autocmd in Vim&#xA;&#xA;We can set up a autocmd. What is a autocmd? It is about running commands when certain events occur like running a command when a file is saved, a buffer is opened or closed, and so on. What we want is to run the black command from the shell when the current file is saved. &#xA;&#xA;So, we can create a autocmd as follows:&#xA;&#xA;```vimscript&#xA;autocmd BufWritePost * !black %&#xA;```&#xA;&#xA;Now, this will run when any type of file is saved, so we will make it specific to python by adding a `*.py` to add in the autocmd.&#xA;&#xA;```vimscript&#xA;autocmd BufWritePost *.py !black %&#xA;```&#xA;&#xA;This works, but it gives a prompt after the command has been executed, to run the command silently we can simply add the silent keyword before the execution of the command from the shell.&#xA;&#xA;```vimscript&#xA;autocmd BufWritePost *.py silent !black %&#xA;```&#xA;&#xA;This looks perfect! &#xA;&#xA;But still, we need to add a auto-group(`augroup`) that groups the autocmds and by adding `autocmd!` it will clear all the commands from the group. &#xA;&#xA;```vimscript&#xA;augroup python_format&#xA;    autocmd!&#xA;    autocmd BufWritePost *.py silent !black %&#xA;augroup end&#xA;```&#xA;We can now add it to the vimrc to work all the time.&#xA;&#xA;## Using pipx &#xA;&#xA;If you have used pipx to install black, you need to setup the autocmd a bit differently. &#xA;&#xA;```vimscript&#xA;autocmd BufWritePost *.py silent !pipx run black %&#xA;```&#xA;&#xA;It might be a bit slower than running with global installation, but it is a neat way to run python package. &#xA;&#xA;So, that&#39;s it we can now write clean and safe python code without breaking a sweat in Vim. Happy Coding :)&#xA;</content>
      <type>til</type>
    </item>
    <item>
      <title>Vim: Get the Text from Visual Selection</title>
      <link>meetgor.com/vim-get-visual-text</link>
      <description>Store the selected text in a variable in Vim Script</description>
      <pubDate>Sat, 05 Mar 2022 00:00:00 UTC</pubDate>
      <content>&#xA;## Using Registers &#xA;&#xA;We can get the selected text in a variable in Vim Script using registers. &#xA;&#xA;```vimscript&#xA;normal gv&#34;xy&#xA;let context = getreg(&#34;x&#34;)&#xA;```&#xA;&#xA;Lets break down the command&#xA;&#xA;```&#xA;normal mode -&gt; gv -&gt; (y)ank text -&gt; to the &#34;x&#34; register&#xA;               |                  |&#xA;               |               Copy the contents into x register(or any register you like)    &#xA;               |                  &#xA;            Select the previously selected text   &#xA;```&#xA;&#xA;Here, we are entering normal mode and selecting text which was previously selected and yank the contents into a register in this case we are using (x) register, it can be any register. &#xA;Now to get the contents of that register we can use the function `getreg(&#34;register_name&#34;)` or use `&#34;xp&#34;` to paste the contents of the `x` register or more generally for any register(`&#34;&lt;register-name&gt;p`). &#xA;&#xA;Hence we can store the contents of the selected text in a variable for further processing or manipulation.&#xA;&#xA;To quickly test this snippet from command mode, you can try the following steps:&#xA;&#xA;Select a text and press Escape, we just want the `gv` command to refresh and get it&#39;s contents to the latest visual selection.&#xA;&#xA;```vimscript&#xA;:normal! gv&#34;xy&#xA;```&#xA;&#xA;```vimscript&#xA;:let foo = getreg(&#34;x&#34;)&#xA;```&#xA;&#xA;```vimscript&#xA;:echo foo&#xA;```&#xA;&#xA;The echo command will simply print the text which we have selected in the file. &#xA;&#xA;![Visual Select Text](https://res.cloudinary.com/techstructive-blog/image/upload/v1646483173/blog-media/wlrxgtmegtycilyhvyiz.gif)&#xA;</content>
      <type>til</type>
    </item>
    <item>
      <title>Comment/Uncomment Code: Vim for Programmers</title>
      <link>meetgor.com/vim-un-comment-p1</link>
      <description></description>
      <pubDate>Thu, 07 Oct 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;We as programmers always fiddle with commenting out code for code testing, documenting the function of code, and most importantly debugging. So you can&#39;t wait to comment on a large chunk of code manually, as it is quite a tedious thing to do. Let&#39;s do it effectively in Vim.&#xA;&#xA;In this part of the series, I&#39;ll cover how to comment/uncomment chunks/blocks of code effectively in Vim. We will see and use some commands, keybindings for doing so, and also we would add certain components to our vimrc file as well to design some custom key mappings.  Let&#39;s get faster with Vim.&#xA;  &#xA;## How to comment multiple lines effectively&#xA;&#xA;To comment on multiple lines of code, we can use the Visual Block mode to select the lines, and then after entering into insert mode, we can comment a single line and it would be reflected on all the selected lines.&#xA;&#xA;1. Press `CTRL+V` and Select the line using j and k&#xA;&#xA;2. After Selecting the lines, Press `Escape`&#xA;&#xA;3. Press `Shift + I`, to enter insert mode&#xA;&#xA;4. Enter the comment code (`//`, `#`, or other)&#xA;&#xA;&#xA;![vimcoment.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1633518136135/06dfBTq2T.gif)&#xA;&#xA;So, using just simple steps you can comment out large chunks of code quite easily and effectively. If you are using some other language that has multiple characters for commenting like `//`, `- -`, etc, you can type in any number of characters while being in insert mode after selecting the lines.&#xA;&#xA; &#xA;![vimcppcom.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1633520509953/0q-k2ZHC7.gif)&#xA;&#xA;This might look a bit wired on the first try but just try it every day, It is a life-saving and very satisfying experience once applied in a real-world scenario.&#xA;&#xA;&#xA;## How to uncomment multiple lines effectively&#xA;&#xA;Now, as we have seen to comment out a large chunk of code, we can even uncomment the code very easily. It&#39;s even simpler than commenting the code.&#xA;&#xA;1. Press `CTRL + V` to enter Visual Block mode&#xA;&#xA;2. Select the commented characters&#xA;&#xA;3. Press `d` to delete the comments&#xA;&#xA;4. Press `Escape`&#xA;&#xA;![vimuncoment.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1633518156818/GJzRPTI3I.gif)&#xA;&#xA;We can simply use the CTRL + V to select the comment, and then press d to delete all the comment characters. &#xA;&#xA;**We are using the Visual Block mode as we only want the comment to be selected and not the entire code associated with the lines.**&#xA;&#xA;## Using Multiline Comments for Programming languages&#xA;&#xA;Now you might say, why use multiple single-line comments when we can use multiline comments in almost all programming languages. Well, Of course, you can do that, it&#39;s easier for reading the code if syntax highlighting is accurate and greys out the commented part. We can simply add those characters to the start of the block and at the end of the block.  &#xA;&#xA;But in Vim, we can customize that too, just imagine when you just select the chunk/block of code that you need to comment out and then simply press a few keystrokes (just 2) and the multiline comments are automatically (programmatically) added as per the programming language extension of the file.&#xA;&#xA;Isn&#39;t that cool? Well, you just need to copy-paste the below code to your Vimrc file and source it and you are good to go. &#xA;&#xA;```vim&#xA;function! Comment()&#xA;    let ext = tolower(expand(&#39;%:e&#39;))&#xA;    if ext == &#39;py&#39; &#xA;        let cmt1 = &#34;&#39;&#39;&#39;&#34;&#xA;&#x9;    let cmt2 = &#34;&#39;&#39;&#39;&#34;   &#xA;    elseif ext == &#39;cpp&#39; || ext ==&#39;java&#39; || ext == &#39;css&#39; || ext == &#39;js&#39; || ext == &#39;c&#39; || ext ==&#39;cs&#39; || ext == &#39;rs&#39; || ext == &#39;go&#39;&#xA;&#x9;    let cmt1 = &#39;/*&#39;&#xA;&#x9;    let cmt2 = &#39;*/&#39;&#xA;    elseif ext == &#39;sh&#39;&#xA;&#x9;    let cmt1 = &#34;:&#39;&#34;&#xA;&#x9;    let cmt2 = &#34;&#39;&#34;&#xA;    elseif ext == &#39;html&#39;&#xA;&#x9;    let cmt1 = &#34;&lt;!--&#34;&#xA;&#x9;    let cmt2 = &#34;--&gt;&#34;&#xA;    elseif ext == &#39;hs&#39;&#xA;&#x9;    let cmt1 = &#34;{-&#34;&#xA;&#x9;    let cmt2 = &#34;-}&#34;&#xA;    elseif ext == &#34;rb&#34;&#xA;&#x9;    let cmt1 = &#34;=begin&#34;&#xA;&#x9;    let cmt2 = &#34;=end&#34;&#xA;    endif&#xA;    exe line(&#34;&#39;&lt;&#34;).&#34;normal O&#34;. cmt1 | exe line(&#34;&#39;&gt;&#34;).&#34;normal o&#34;. cmt2 &#xA;endfunction&#xA;&#xA;function! UnComment()&#xA;    exe line(&#34;&#39;&lt;&#34;).&#34;normal dd&#34; | exe line(&#34;&#39;&gt;&#34;).&#34;normal dd&#34;   &#xA;endfunction&#xA;&#xA;&#xA;vnoremap ,m :&lt;c-w&gt;&lt;c-w&gt;&lt;c-w&gt;&lt;c-w&gt;&lt;c-w&gt;call Comment()&lt;CR&gt;&#xA;vnoremap m, :&lt;c-w&gt;&lt;c-w&gt;&lt;c-w&gt;&lt;c-w&gt;&lt;c-w&gt;call UnComment()&lt;CR&gt;&#xA;&#xA;```&#xA;The below screencast is an example of `HTML` snippet in a file that is getting commented using mapping with the keys `,m` you can put any other keybinding you like. &#xA;![htmcm.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1633595891674/hbhrbtRHd.gif)&#xA;&#xA;---&#xA;Similarly for the next screencast is of an `Javascript` snippet in a file which is getting commented using a mapping with the keys `,m` and uncommented using `m,` again you can put any other keybinding you like. &#xA;&#xA;![jscom.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1633595919104/xGTh5ztWu.gif)&#xA;&#xA;---&#xA;The following screencast is of a shell script(BASH) snippet.&#xA;![shcom.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1633596156121/tbGHQBSSA.gif)&#xA;&#xA;---&#xA;### Multiline Comments in various Programming Languages:&#xA;&#xA;#### 1. C / C++ / Java / Javascript / CSS / C# / Rust / Go / PHP / Swift / Dart / Kotlin&#xA;```&#xA;/*&#xA;*/&#xA;```&#xA;#### 2. Python&#xA;```&#xA;&#39;&#39;&#39;&#xA;&#39;&#39;&#39;&#xA;```&#xA;You can even use `&#34;&#34;&#34;` double quotes instead of single quotes&#xA;&#xA;#### 3. BASH (Shell Scripting)&#xA;```&#xA;: &#39;&#xA;&#39;&#xA;```&#xA;You can even use `: &#34;` and `&#34;` double quotes instead of single quotes&#xA;&#xA;#### 4. Haskell&#xA;&#xA;```&#xA;{-&#xA;-}&#xA;```&#xA;#### 5. Ruby&#xA;&#xA;```&#xA;=begin&#xA;=end&#xA;```&#xA;&#xA;#### 6. HTML&#xA;&#xA;```&#xA;&lt;!--&#xA;--&gt;&#xA;```&#xA;&#xA;#### 7. Julia&#xA;&#xA;```&#xA;#=&#xA;=#&#xA;```&#xA;&#xA;### Understanding the Commands / Keymapping&#xA;&#xA;**NOTE : You need to go from the top to bottom while commenting on the block of code, otherwise, it would be a mismatch in commenting for specific language syntax. While uncommenting the order doesn&#39;t matter.**&#xA;&#xA;&#xA;#### Getting the extension (filetype)&#xA;&#xA;In Vim, we can get the file extension i.e. we can get the programming language associated with the current file. To do that we can use, `expand(&#39;%:e&#39;)`.&#xA;&#xA;This will give us the file extension of the current file. Just for simplicity, `%` means the current file, added to it is `:e` for excluding the filename and keeping the extension. We convert the extension into lowercase just for keeping things safe and programmatic and store it in a variable `ext`. &#xA;&#xA;#### Checking for programming language&#xA;We then can then use an if-else ladder to check for the programming languages and assign two variables `cmt1` for the initial characters in the multiline comment and `cmt2` for enclosing the comment. &#xA;&#xA;#### Typing in the characters&#xA;&#xA;We can use the function `line(&#34;&#39;&lt;&#34;)` to get the line number of the previous visual selection. Similarly, `line(&#34;&#39;&gt;&#34;)` for the ending line. We are using the `exe` command to execute the function `line` and so we have to use a concatenation of the commands even to write the raw commands like `i` to insert mode, `o` to insert mode but a line below the cursor. So, we use `normal` command for that. This command indicates the interpreter to execute the following commands from the normal mode. &#xA;&#xA;We have to enclose the `normal` command in double-quotes/single quotes. We can simply use the variable again with concatenation.&#xA;&#xA;```vim&#xA;exe line(&#34;&#39;&gt;&#34;).&#34;normal o&#34;. cmt2 &#xA;```  &#xA;&#xA;The above command will fetch the last line&#39;s number of the previous visual selection followed by entering `o` from the normal mode and concatenated with the value of the variable `cmt2` which we have already initialized in the `Comment` function. We are using `|` for running multiple commands as we also need to include the comment at the beginning of the visual selection. &#xA;&#xA;For uncommenting the code, we are simply deleting the entire first and the last line in the visual selection. For that, we have used `dd` from the normal mode.  &#xA;&#xA;&#xA;### Conclusion&#xA;&#xA;So, from the following type of tutorial, we were able to set up our Vim editor for efficient code commenting/ uncommenting using some commands, key shortcuts, and configuring the vimrc for making custom keymappings. We were also able to understand the multiline comments in various programming languages and use them in Vim very effectively with a simple addon to the config vimrc file.&#xA;&#xA;Thank you for reading, hope you found this article helpful. If you have any queries or wanna add multiline comments for some more programming languages please let me know in the comments or contact section. &#xA;&#xA;Happy Coding :)&#xA;&#xA;### References&#xA;&#xA;- [StackOverflow - Commenting lines in Vim ](https://stackoverflow.com/questions/1676632/whats-a-quick-way-to-comment-uncomment-lines-in-vim/1676690)&#xA;&#xA;- [Liz Lam - 3 ways to comment code in Vim](https://dev.to/grepliz/3-ways-to-comment-out-blocks-of-code-in-vi-6j4)&#xA; &#xA;- [StackExchange - Use variable in normal command](https://vi.stackexchange.com/questions/9644/how-to-use-a-variable-in-the-expression-of-a-normal-command)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Vim for Competitive Programming</title>
      <link>meetgor.com/vim-for-cp</link>
      <description></description>
      <pubDate>Mon, 13 Sep 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Vim is not a bad text editor when it comes to using it for Competitive Programming. It&#39;s kind of one way or the other, you would love it or you could trash it as it can waste a tremendous amount of time to write code every time. But once you are in a decent setup including some key-bindings and plugins can improve your speed in using Vim. I personally have used it since the beginning and haven&#39;t regretted it even a tiny bit till date. It&#39;s a flawless and enjoyable experience. I&#39;ve used C++ for my CP journey, C is quite similar as well, but C++ has more library support and is a bit easier to write comparatively.&#xA;&#xA;Using Vim for CP is a bit challenging in the initial stage but just stay consistent and you&#39;ll be in flying colors on the other side. Here, I&#39;ll give some quick key-bindings and plugins to include to Vim to enhance the workflow for Competitive Programming.&#xA; &#xA;## Quick Boilerplate code&#xA;&#xA;Firstly, let&#39;s create a key-binding for the boilerplate code. We just need to map the key with the code we need to write which will be integrated with Vim commands.&#xA;&#xA;For C++&#xA;```vim&#xA;nnoremap cpf i#include&lt;iostream&gt;&lt;Esc&gt;ousing namespace std;&lt;Esc&gt;o&lt;CR&gt;int main(){&lt;Esc&gt;o&lt;Esc&gt;oreturn 0;&lt;Esc&gt;o}&lt;Esc&gt;kki&#xA;``` &#xA;&#xA;For C:&#xA;```vim&#xA;nnoremap cp i#include&lt;stdio.h&gt;&lt;Esc&gt;o&lt;CR&gt;int main(void){&lt;Esc&gt;o&lt;Esc&gt;oreturn 0;&lt;Esc&gt;o}&lt;Esc&gt;kki&#xA;```&#xA;&#xA;For Java:&#xA;```vim&#xA;nnoremap &lt;C-j&gt; iclass &lt;ESC&gt;&#34;%pxxxxxa {&lt;ESC&gt;opublic static void main(String args[]){&lt;Esc&gt;o&lt;Esc&gt;o}&lt;Esc&gt;o}&lt;Esc&gt;kki&lt;Tab&gt;&lt;Tab&gt;&#xA;```&#xA;&#xA;Now, you get the idea of creating such macros for your own programming language. I don&#39;t think Python can have boilerplate code, even it has it&#39;s quite small compared to C/C++/Java/etc. You can include those codes into the key map. Let me explain the map to you.&#xA;&#xA;Let&#39;s look at the Java example, the `nnoremap` is the map command with attributes like non-recursive and the mode of mapping. In this case `n` stands for normal mode map i.e. the map will get triggered in the normal mode, `nore` stands for non-recursive behavior of the map. For further readings, you can read my [Vim-keymapping Guide](https://mr-destructive.github.io/techstructive-blog/vim/2021/06/14/Vim-Keymapping.html) article. The map itself has the right and a left part, kind of a map of the key and command to execute. You can use any key to trigger it, I have used CTRL+J or `&lt;C-j&gt;` to activate the map. The command is quite long but let&#39;s break it down into smaller chunks.&#xA;&#xA;- Starting with `i`, we enter into insert mode and we type in class and hit `&lt;ESC&gt;` key and this is a special trick to deal with java for the class name as it should be the name of the file itself. We use the `%` register for copying the current file&#39;s entire name (with extension), so we have to remove the `.java` part so, you see five x&#39;s to delete those after we have pressed a to get into insert mode just ahead of the cursor. We then insert `{` for the class and again hit escape to go back to normal mode.&#xA;- We type `o` to go into insert mode to the next line, type in `public static void main(String args[])` and this is the same stuff of escaping and going in next line. &#xA;- Finally, we hit `kk` to move up twice and enter the insert mode with `i` and hit tab twice to get the indentation correct. &#xA;&#xA;So, you can add more as per your preference of pre-defined constants and functions and the rest stuff involved in your language of choice.&#xA;&#xA;&#xA;## Running Code by a Key-binding&#xA;&#xA;After the boilerplate code being taken care of, we can now move to the building and running of the code file in Vim. We can add some more custom key bindings to auto compile and run the code within Vim. &#xA;&#xA;We can compile the code with the compilers or interpreters for the languages from the Vim using `!` which executes the commands from the terminal and pass in `%` i.e. the current file name and output file as `%:r` i.e. current file name without the extension in case of C/C++/Java. &#xA;&#xA;**Compile -&gt; `c++ hello.cpp -o hello`**&#xA;&#xA;**Run -&gt; `%:r` for Windows**&#xA;&#xA;and&#xA;&#xA;**`./%:r` for Linux/macOS**&#xA;&#xA;We have added those two commands i.e (compile and run) using `&amp;&amp;` to make things more clear and compact. &#xA;For C++&#xA;```vim&#xA;nnoremap cpp :!c++ % -o %:r &amp;&amp; %:r&lt;CR&gt;&#xA;```&#xA;&#xA;For C&#xA;```vim&#xA;nnoremap c, :!gcc % -o %:r &amp;&amp; %:r&lt;CR&gt;&#xA;```&#xA;&#xA;For Java&#xA;```vim&#xA;nnoremap ,j :!javac % &amp;&amp; java %:r&lt;CR&gt;&#xA;```&#xA;&#xA;For Python&#xA;```vim&#xA;nnoremap py :python %&lt;CR&gt;&#xA;```&#xA;&#xA;Again, you can apply this to any programming language you use. Also kindly note that their could be some differences for compiling the code in Linux and Windows so just be careful which command you use in which Operating system.&#xA;&#xA;![vimjv.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1631540728028/2puTZUXwK.gif)&#xA;&#xA;The above gif demonstrates the usage of those commands and key bindings to make the workflow of running and building process much easier and smoother.&#xA;&#xA;&#xA;&#xA;## Opening Terminal to compile and run code&#xA;&#xA;We can use the terminal to compile and run code if you wish to do it this way as well. Vim is quite a terminal-friendly editor, you can open any terminal from Vim.&#xA;&#xA;You can enter `:term` to open the default terminal in a horizontal split. You can explicitly enter the terminal/shell name to open it like `:term bash` to open bash, `:term powershell` to open PowerShell, `:term zsh` to open zsh, and so on. This is quite a great utility that vim provides with it. You can switch between windows using `&lt;C-w&gt;` or CTRL+W **twice** or use HJKL keys along with `&lt;C-w&gt;` to move with ease. More on Vim and Integrated Terminals in [this article](https://mr-destructive.github.io/techstructive-blog/vim/2021/06/29/Vim-Terminal.html).&#xA;&#xA;You can now explore the terminal world yourself and execute the commands from therein. &#xA;&#xA;## Plugins&#xA;&#xA;When it comes to Vim, there are a ton of plugins made for everything you can imagine and couldn&#39;t imagine. We can use Plugin managers to manage those plugins for us or manually manage those yourself. You can go with one of the three well-known plugin managers like `Vim-Plug`, `Vundle` or `Pathogen`. &#xA;&#xA;Using those plugin managers, we can install plugins like some of the useful ones are:&#xA; &#xA;### NERDTree&#xA;&#xA;NERDTree is a great plugin for beginners and also for people doing competitive programming as it saves a bit of time as well. You can install the NERDTree plugin from the GitHub docs. You can read about the detail of configuring the NERDTree plugin in [this article](https://mr-destructive.github.io/techstructive-blog/vim/2021/08/31/Vim-NERDTree.html). This plugin allows you to have a graphical representation of the files and folder structures in the current directory. You can extend its capabilities to auto-refresh and auto open/close using some custom configuration as provided in the above-mentioned article. &#xA;&#xA;You basically open the NERDTree with the command `:NERDTree` after installing and configuring. You can make key-bindings and shortcuts to use as you like and prefer.&#xA; &#xA;### Autocompletion and LSP&#xA;&#xA;Autocompletion is quite important when it comes to competitive programming as you have to save time on the **stuff you know** and let the application process it for you. We do have some plugins for auto-completion and also LSPs for this specific task. LSP is quite great and provides much more accurate predictions when it comes to autocompletion. You can check out the LSP [unofficial plugin for vim](https://github.com/prabirshrestha/vim-lsp) for more information. &#xA;&#xA;For normal plugins like [AuotoComplPop](https://github.com/vim-scripts/AutoComplPop) are also decent and provide a great beginner experience.&#xA;&#xA;Not many plugins would be required for competitive programming just some autocompletion and a nice interface with a file system will work for the basic set-up but that is not the end, you can extend it as per your needs and skills. Vim is quite epic in terms of the customization it can offer.&#xA;&#xA;![vimcpt.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1631768130787/ccDyyJ45y.gif)&#xA;&#xA;Similarly, for C++, I have demonstrated the use of key mappings and also showed the usage of the terminal inside of Vim, this is quite a flawless experience to integrate and use the terminal as per choice and preference.&#xA;&#xA;## Conclusion&#xA;&#xA;So from this article, we were able to set up Vim for competitive programming by adding some custom key mappings and plugins for different languages. This was not a complete guide, I could not include every language&#39;s configuration here, surely you can ask me anytime in the comments, GitHub, Twitter or just mail me I can try to configure a programming language on Vim. Thanks for reading. &#xA;&#xA;Happy Viming and Happy Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Why use Vim ?</title>
      <link>meetgor.com/why-use-vim</link>
      <description></description>
      <pubDate>Sun, 05 Sep 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;So, Why would one use Vim? As Vim being the most complicated Text editor when it comes to **closing it**!! Also, people think it&#39;s not worth the time or it&#39;s just not their type of Text Editor. Well, that&#39;s true, I am not forcing anyone to use Vim, just to tell the reasons why people use Vim. Again, it&#39;s not to show off to anyone that I use Vim, just to appreciate the power of Vim and its community, it&#39;s just amazing!!&#xA;&#xA;Vim is not a text editor just for anyone, it can be daunting initially but the more you use it, the more you love it. There is nothing called a time-wastage in learning Vim, if you think learning something is waste of time, just don&#39;t learn it! To have understood and got good at something you need to dedicate time and effort to it, there&#39;s no shortcut. When it comes to shortcuts, Vim is the fairyland of it, just use one or create your own. That&#39;s how cool Vim can be when used properly.&#xA;&#xA;Some of the most important and crucial reasons why people use Vim are:&#xA;&#xA;## Vim is Speed!&#xA;&#xA;Vim can be opened from the terminal, and that itself can speak that it is lightweight and uses lower system resources and hence causing minimal lag. This might not be an issue for high-end computers but when it comes to low-end machines, Vim behaves as a life-saver. Using certain commands feels so wicked fast and intuitive. Certain commands such as `t` or `f`, `u`, and many others are really powerful when it comes to editing in Vim. When you don&#39;t have to think about what keys you should type, you are really getting faster in Vim. &#xA;&#xA;![](https://s6.gifyu.com/images/screenrecording.gif)&#xA;&#xA;The above screencast is from my article [Vim: Set up for Python](https://mr-destructive.github.io/techstructive-blog/python/vim/2021/06/06/Vim-for-Python.html), which uses some key mappings to run python code directly from Vim itself by executing the shell commands from Vim&#39;s Command mode. A simple map can save a lot of time.&#xA;&#xA;```&#xA;nnoremap py :!python %&#xA;```&#xA;&#xA;&#xA;## Number of Commands/shortcuts&#xA;&#xA;When it comes to using key-bindings and shortcuts, there is no shortage of them. You can spend days, weeks, months, years but still, there will be some or the other thing to learn in Vim. That can be very intimidating to some people but that&#39;s how life is. **You cannot get perfect at anything but surely better is the word to focus on.** There is a good little cheatsheet at [devhints](https://devhints.io/vim) for beginners to quickly get started. Also, you can follow with the Youtuber- [ThePrimeagen](https://www.youtube.com/channel/UC8ENHE5xdFSwx71u3fDH5Xw), who focuses on switching and using Vim. Vim is has a robust set of command and key-bindings by far compared to other tex-editors. Here are some of my daily used [editing commands](https://mr-destructive.github.io/techstructive-blog/vim/2021/07/18/Vim-Enhancing-Editing-speed.html) and [navigation commands](https://mr-destructive.github.io/techstructive-blog/vim/2021/06/26/Vim-Enhancing-Movement-speed.html).&#xA;&#xA;## Power to use it as an IDE&#xA;&#xA;Vim provides some awesome features such as [terminal integration](https://mr-destructive.github.io/techstructive-blog/vim/2021/06/29/Vim-Terminal.html), [Key-mappings](https://mr-destructive.github.io/techstructive-blog/vim/2021/06/14/Vim-Keymapping.html), [Window Splits](https://mr-destructive.github.io/techstructive-blog/vim/2021/08/06/Vim-Window-Splits.html), etc to take text-editing and developer environment to a next-level. You can literally use Vim as an IDE for many of the programming languages like C/C++, Python, Java, Javascript, GO, etc. Though it can&#39;t replace entire IDE-like features, it is indeed powerful enough to add features in making a custom IDE experience. It might require some time and research to configure it to use it as a full-blown IDE, but it might be a very useful and self-motivating experience. There are definitely many articles, tutorials out to guide you in configuring the editor to an IDE. People might not use Vim for the features it has but also for the lightweights as compared to other IDEs such as Visual Studio, Android Studio, Eclipse, IntelliJ IDEA, etc.&#xA;&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1630827706766/cdN6GdnhH.png)&#xA;&#xA;From, the above screenshot, we can see that I have configured Vim almost like VSCode, Ok! Just the look of it is similar but ya we have the file manager as [NERDTree](https://mr-destructive.github.io/techstructive-blog/vim/2021/08/31/Vim-NERDTree.html), integrated Terminal, and the buffer opened as the editor. You can even add more functionality like autocomplete, keymaps to compile/run/build the code. There is are infinite possibilities when it comes to customization in Vim and to make it a full-blown IDE. OH! And by the way my Vim look changes from time to time XD&#xA;&#xA;## Available almost everywhere&#xA;&#xA;As said, Vim can be opened via the terminal, and hence it is quite viable when it comes to accessibility. It is pre-installed in almost every Linux-distributions, macOS, FreeBSD, etc. Hence it is quite reliable when it comes to compatibility and cross-platform support. You can start editing in any environment in Vim, so it becomes a good reason to learn to use Vim at least basic editing and opening, closing, etc. Vim being minimal and lightweight, it just becomes easy to work with servers. Production-environment, etc. It also isn&#39;t that complicated once you make your head around it. Being available in almost every Operating System has some value to it like it is the most dependable editor out there. Even after 30 years, yes Vim was released in 1991, it is still maintained by its producer [Brain Moolenaar](https://en.wikipedia.org/wiki/Bram_Moolenaar). That is mind-boggling, Vim is truly a vintage text editor silently but widely dominated in terms of its reach in Computing.   &#xA;&#xA;## The Level of Customization/Configuration &#xA;&#xA;It&#39;s kind of a double-sided sword for some people as it can be daunting to customize from scratch and also, it could be a rewarding and pleasurable experience of having the personalized experience.  With the number of plugins, custom vimrc and color schemes, etc Vim is very prone to personalization. It is **Open Source**, so we also have it&#39;s distributions such as [SpaceVim](https://github.com/SpaceVim/SpaceVim), [SPF-13](https://github.com/spf13/spf13-vim), etc. Some more distribution can be found [here](https://dev.to/ajeebkp23/some-popular-vim-distributions-a68). Some Distribution is pref-configured with some basic stuff and is ready to use, so they are quite beginner-friendly and introduce them to Vim in a better way. NeoVim which is an evolution of Vim written in Lua is much more powerful and provides even more customization keeping the basic key-bindings in mind. Editing Vimrc is quite an amazing and intuitive experience as it allows to add functionality or enhance the existing features in Vim. &#xA;&#xA;&#xA;## Conclusion&#xA;&#xA;&gt; Text Editors don&#39;t matter, what matters are the problem-solving skills&#xA;&#xA;Vim is a simple and minimal text editor, everyone can use it but not everyone finds the need to use it, that&#39;s fine. It might be ideal for me to use Vim than other editors but it might not be for you. But there is nothing to lose in knowing some basics of Vim. It might be useful somewhere, you never know! And if your favorite editor is not available, Vim might prove to be a great quick solution. Thanks for reading. Happing Coding :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Vim: NERDTree</title>
      <link>meetgor.com/vim-nerdtree</link>
      <description></description>
      <pubDate>Tue, 31 Aug 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;[NERDTree](https://github.com/preservim/nerdtree) is a great plugin in Vim for managing and navigating Files. Some might prefer fzf, telescope, and other plugins for navigation, NERDTree is not a bad option to begin within Vim. NERDTree allows you to even create/delete/move files and folders flawlessly without much effort, so it becomes a much more viable beginner&#39;s plugin.&#xA;&#xA;## Installing NERDTree Plugin&#xA;&#xA;So, let&#39;s start with the Installation of the NERDTree Plugin, it&#39;s quite straightforward and simple.&#xA;&#xA;You should have a Plugin-Manager for installing this plugin. It&#39;s not mandatory to have one but it becomes much easier to work with. You can choose any between `Vundle`, `Vim-Plug`, `Pathogen` to name a few. It does not really matter with what you use just stick to one but if you are stuck somewhere just switch and it&#39;s not a big trouble to use other Plugin Managers as they are quite similar to each other.&#xA; &#xA;#### Vundle&#xA;&#xA;To install a plugin using Vundle, you need to configure Vundle first if you have not already done it. You can find the installation docs [here](https://github.com/VundleVim/Vundle.vim). &#xA;After Vundle has been configured in your vimrc you can simply add `Plugin &#39;preservim/nerdtree&#39;` between the call begin and end of Vundle, like :&#xA;&#xA;```vim&#xA;call vundle#begin()&#xA;  Plugin &#39;preservim/nerdtree&#39;&#xA;call vundle#end()&#xA;``` &#xA;&#xA;All of your other Plugins will go in between those two statements, i.e. `call vundle#begin()` and `call vundle#end()`. &#xA;After saving and sourcing the vimrc file, you need to install the plugin using the command `:PluginInstall`, and there you are all Done!&#xA;&#xA;&#xA;#### Vim-Plug&#xA;&#xA;To install a plugin using the Vim-Plug manager, you need to configure Vim-Plug if you have not already configured it in your vimrc. You can find the installation docs at the GitHub README of [Vim-Plug](https://github.com/junegunn/vim-plug).&#xA;After Vim-Plug has been configured in your vimrc you can simply add `Plug &#39;preservim/nerdtree&#39;` between the call plug begin and end statements. Just like:&#xA;&#xA;```vim&#xA;call plug#begin()&#xA;  Plug &#39;preservim/nerdtree&#39;&#xA;call plug#end()&#xA;``` &#xA;&#xA;All of your other Plugins will go in between those two statements, i.e. `call plug#begin()` and `call plug#end()`. &#xA;After saving and sourcing your vimrc file, you need to now install those plugins using the command `:PlugInstall`, and that is it!&#xA;&#xA;#### Pathogen&#xA;&#xA;To install any plugin using Pathogen plugin manager, you need to configure Pathogen in your vimrc if you have not done it already. You can find the installation docs on [Pathogen.vim](https://github.com/tpope/vim-pathogen).&#xA;After Pathogen has been configured in your vimrc, you can clone the git repository of that plugin into your local machine and then activate it using Pathogen. &#xA;&#xA;```&#xA;git clone https://github.com/preservim/nerdtree.git ~/.vim/bundle/nerdtree&#xA;```&#xA;&#xA;After cloning the repository, you can add this to your vimrc where you have configured it. It&#39;s a kind of DIY manager in terms of managing the folders of the plugin.&#xA;&#xA;```vim&#xA;call plug#begin()&#xA;call pathogen#infect()&#xA;syntax on&#xA;filetype plugin indent on&#xA;```&#xA;&#xA;After this, you need to run this command to get docs and help with the plugins,&#xA;&#xA;`:help tags ~/.vim/bundle/nerdtree/doc/` or `:help tags`&#xA;&#xA;And there you are done with the plugin installed.&#xA;&#xA;There are other Plugin managers as well, but these three are the most widely supported ones and they work out of the box, surely explore for yourself and find the perfect one for you.&#xA;&#xA;&#xA;## Activating and Using NERDTree&#xA;&#xA;Now, we actually need to use NERDTree, for that we can type in `:NERDTree` in any folder in our local machine, and there should be a window open a vertical split to the left, just like this:&#xA;![NERDTree activate](https://i.imgur.com/KU2vMxO.png)&#xA;&#xA;After this, you can use &lt;C-w&gt; that is **CTRL+W twice** twice to switch back and forth between windows. You can also use **CTRL+W and HJKL** to move in directions in the windows. For further guides and key-bindings in Window-Splits, you can read my article [here](https://mr-destructive.github.io/techstructive-blog/vim/2021/08/06/Vim-Window-Splits.html). &#xA;&#xA;Now, you can navigate to the file/folders using HJKL or arrows keys(not preferred). You can even use the numbers before the HJKL to jump and hop around the large codebases, this integrates really well with base Vim key-bindings.&#xA;You can quiet the NERDTree window by just pressing `q` or `:q`, definitely the former is efficient. You can open/collapse the folders also using the enter key to open the file in the current buffer. But hey that&#39;s quite limited, what have you ever seen!&#xA;&#xA;#### Open File in Splits&#xA;&#xA;You can open a file in a horizontal split using the key `i` on the file. You can open a file in Vertical split using the `s` key keeping the current highlight in NERDTree on the file which you would like to open. This can be really a great feature to have while opening multiple files and file structures.&#xA;&#xA;&#xA;#### Managing Files/Folders using NERDTree&#xA;&#xA;You can create files using the NERDTree window by pressing m inside the particular folder where you want to. If you want to create a file in the root folder, you can go to the topmost file location and press `m` inside the NERDTree window. If you press `m`, you will be able to see different kinds of options namely:&#xA;&#xA;1. Add a child node.(`a`)&#xA;&#xA;&#x9;We can create a file or a folder using the key `a` or simply `Enter` to create the file in the current highlighted location. &#xA;&#xA;2. Move the Current Node. (`m`)&#xA;&#xA;&#x9;We can create a file or a folder using the key `a` or simply `Enter` to create the file in the current highlighted location. &#xA;&#xA;3. Delete the current Node. (`d`)&#xA;&#xA;&#x9;We can move the currently highlighted file/folder to any other directory using the file manager itself. &#xA;&#xA;4. Open the current Node in the system Text-Editor.(`o`)&#xA;&#xA;&#x9;We can delete the file/folder which is currently selected on the NERDTree menu.&#xA;&#xA;5. Copy the current Node. (`c`)&#xA;&#xA;&#x9;We can open the file in the system-default text-editor using the key `o`.&#xA;&#xA;6. Copy the Path to the clipboard.(`p`)&#xA;&#xA;&#x9;We can copy the current file/folder or a node using the command `c`.&#xA;&#xA;7. List the Current Node. (`l`)&#xA;&#xA;&#x9;We can list the file/folder i.e to display its properties the read/write/execute permissions, date modified and created, etc.&#xA;&#xA;8. Run system Command in this folder. (`s`)&#xA;&#xA;&#x9;We can run system commands or shell/terminal commands using the key `s`, For windows, we open the COMMAND PROMPT, and in Linux and macOS, it is terminal.&#xA;&#xA;You can quit that window by pressing `Esc`. &#xA;&#xA;&#xA;Here is some of the Screencast of me demonstrating the NERDTree plugin features and the edit options.&#xA;![vimnerd.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1630423628366/zZE7R5aL7.gif)&#xA;&#xA;This is just self-explanatory and beginner-friendly sets of commands, it becomes really easy to do this with some custom macros as we&#39;ll talk about in the next sections.&#xA;&#xA;&#xA;&#xA;## Macros to open file tree&#xA;&#xA;You can make a key-binding to open the NERDTree, &#xA;&#xA;```vim&#xA;nnoremap &lt;C-n&gt; :NERDTree&lt;CR&gt;&#xA;```&#xA;You can map anything instead of `&lt;C-n&gt;`, most people use `&lt;leader&gt;` but it&#39;s easy to use `CTRL+N` for me, it&#39;s just personal preference.&#xA;&#xA;If you do not like to open NERDTree again and again, you can keep it open whatsoever using the custom key-binding in your vimrc.&#xA;&#xA;```vim&#xA;autocmd VimEnter * NERDTree&#xA;```&#xA;This will open the NERDTree automatically for you when you open Vim, Ya I get it, it&#39;s not needed every time but most of the time a developer is switching between the files. &#xA;&#xA;## Enabling Autoreload&#xA;&#xA;We can auto-reload the NERDTree window when there is a change in the file structure, i.e. a file/folder is deleted/created/moved/etc. We again need to set this in our vimrc:&#xA;&#xA;```vim&#xA;autocmd BufEnter NERD_tree_* | execute &#39;normal R&#39;&#xA;au CursorHold * if exists(&#34;t:NerdTreeBufName&#34;) | call &lt;SNR&gt;15_refreshRoot() | endif&#xA;```&#xA;This will reload the NERDTree when the cursor is in the NERDTree&#39;s window. This could be really time-saving and a nice quick configuration to enhance the efficiency of your Text-editing.&#xA; &#xA;&#xA;## Enabling Autorefresh for change in the current directory&#xA;&#xA;We can also reload the NERDTree when we change the directory. The above-mentioned command is not sufficient to do that, we have to add another set of configurations.&#xA;&#xA;```vim&#xA;augroup DIRCHANGE&#xA;    au!&#xA;    autocmd DirChanged global :NERDTreeCWD&#xA;augroup END&#xA;```&#xA;&#xA;By adding this to your vimrc, you will refresh the NERDTree every time you enter or change the current directory. This is also a great addition to have to save time by reloading the Window for every change in the path, if you are looking for something among a huge code-base, this works a charm.&#xA;&#xA;&#xA;## Auto close &#xA;&#xA;You need to close the NERDTree manually each time you want to exit out of it, but this can also be automated just for the sake of simplicity and effectiveness in **QUITTING VIM**.&#xA;&#xA;```vim&#xA;autocmd bufenter * if (winnr(&#34;$&#34;) == 1 &amp;&amp; exists(&#34;b:NERDTree&#34;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif&#xA;```&#xA;This will close the NERDTree window if it is the only open window. That can be frustrating at moments but the majority of the time this is a great addon indeed.&#xA;&#xA;## Packing it together&#xA;&#xA;So, we have learned the basics of using and modifying NERDTree according to our needs, to put it together, you can use this snippet directly into your vimrc and enjoy the flawless experience.&#xA;&#xA;```vim&#xA;&#34; Open nerdtree window on opening Vim&#xA;autocmd VimEnter * NERDTree&#xA;&#xA;&#34; Refresh the current folder if any changes&#xA;autocmd BufEnter NERD_tree_* | execute &#39;normal R&#39;&#xA;au CursorHold * if exists(&#34;t:NerdTreeBufName&#34;) | call &lt;SNR&gt;15_refreshRoot() | endif&#xA;&#xA;&#34;Reload the window if directory is changed&#xA;augroup DIRCHANGE&#xA;    au!&#xA;    autocmd DirChanged global :NERDTreeCWD&#xA;augroup END&#xA;&#xA;&#34;Close nerdtree automatically if it is theonly window open&#xA;autocmd bufenter * if (winnr(&#34;$&#34;) == 1 &amp;&amp; exists(&#34;b:NERDTree&#34;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif&#xA;```&#xA;&#xA;&#xA;## Conclusion:&#xA;&#xA;So, We were able to make Vim a better place to work with. Making it easier to navigate along with files and folders. Configuring the NERDTree Plugin, customizing the look and functionality of Vim as per the needs. &#xA;NERDTree is a great plugin no matter how you use it. It makes Vim more viable as a text editor for daily use and that also in an efficient and clean way. Surely there might be other plugins that are super powerful and blazing fast, NERDTree provides a good UI as well by providing a graphical representation of the File structure that enhances its usage.&#xA;That is what Vim is about, learning every day some things to change the way to edit. Thank you for reading. Happy Viming and Coding :)&#xA;&#xA;### References:&#xA;&#xA;- [NERDTree - docs](https://github.com/preservim/nerdtree)&#xA;- [Refresh NERDTree](https://stackoverflow.com/questions/8793489/nerdtree-reload-new-files/8794468)&#xA;- [Reload NERDTree on Directory change](https://vi.stackexchange.com/questions/31050/how-can-i-make-nerdtree-update-root-to-the-current-directory-when-i-change-direc)&#xA;- [Open NERDTree in Vim by default](https://stackoverflow.com/questions/1447334/how-to-add-nerdtree-to-your-vimrc)&#xA;- [Close NERDTree automatically](https://stackoverflow.com/questions/2066590/automatically-quit-vim-if-nerdtree-is-last-and-only-buffer)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Vim: Buffers</title>
      <link>meetgor.com/vim-buffers</link>
      <description></description>
      <pubDate>Wed, 11 Aug 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;&#xA;I have talked about Vim [tabs](https://mr-destructive.github.io/techstructive-blog/vim/2021/08/03/Vim-Tabs.html),  [window splits](https://mr-destructive.github.io/techstructive-blog/vim/2021/08/06/Vim-Window-Splits.html)  in the previous articles, and now I am quite keen on explaining the finest unit of file that you can open using Vim and that is a buffer. Tabs are a collection of windows, Windows are the viewport on buffers (collection to view the buffers), and Buffers are the memory that holds text in the file. So let us explore buffer in detail. This article won&#39;t cover each and every tiny detail about buffers but surely enough to make you understand what a buffer is and how to manage those.&#xA;&#xA;## What is a Vim buffer&#xA;&#xA;Vim buffers are the chunks of memory that hold the text in a file. Vim buffers are used from opening a file to using, installing, upgrading the Plugins, using file managers, and everything you can edit and work within Vim. &#xA;&#xA;So, why bother using Vim buffer, you&#39;ll ask. Well, you will need it to make some complex tasks possible in Vim, such as configuring it as your IDE or having much more control over what and how you open and close files in Vim. You might not need it in the broader sense but having a grasp of what you are using and understanding the process under the hood is vital whatsoever. &#xA;&#xA;## Creating a buffer&#xA;&#xA;No need to create a buffer, if you are editing a file, that&#39;s already a buffer :) If you open Vim, a fresh open, then you already have that current buffer as an empty buffer. You can create an empty buffer by entering the command `:enew`. This will actually make a new empty buffer, if you have edited the contents of the previous buffer you need to specify to write/save the buffer in a file.&#xA;&#xA;You can see the details of the buffers opened currently by using the command `:ls` or `:buffers`. This will open a list of buffers currently loaded in the Vim instance. You will see the output somewhat like this:&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1628681203173/qSSRrlB2J.png)&#xA;&#xA;We can see the name of the current buffer which in this case it is `&#34;No name&#34;` this will be replaced with a file name if we had a file open. This won&#39;t only print the current buffer but all the loaded buffers in the present Window of Vim. We will explore the details of this command in the next section.&#xA;&#xA;&#xA;## Navigating through the buffers list&#xA;&#xA;![buff1.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628681927410/t9DDPbDEs.gif)&#xA;&#xA;In the first column in the only row, you can see `1` indicating the number of the buffer, secondly, there are indicators `%a` and `#` and others as well. These are used for referencing the buffers using certain attributes those have like :&#xA;&#xA;- `%` stands for the buffer in the current window.&#xA;- `a` stands for the currently active buffer.&#xA;- `#` stands for the alternate buffer (previously edited).&#xA;- `h` stands for the hidden buffer ( used for navigating to other files without saving changes ).&#xA;&#xA;We also have additional attributes or indicators for the buffers like:&#xA;&#xA;- `+` indicating the buffer is modified.&#xA;- `-` indicating the buffer cannot be modified. &#xA;- `=` indicating the buffer is read only.&#xA;&#xA;To use the attribute `h`, you have to set the option in the current window only, you can use `:set hiddden` to hide the files i.e to edit another file without saving changes to the current buffer(with the file loaded).  If you want a permanent option of hidden files you can add `set hidden` in your `vimrc` file.&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1628683076849/lWQ2ZEj0E.png)&#xA;&#xA;If you have enabled a hidden file in the window and you modify the file, you can see the `+` symbol in the `:ls` command output before the file, indicating that the file has been modified. If you try to quit the window, it will prompt you to save those unsaved modifications.  &#xA;&#xA;This is the power of Vim buffers, you can get really fast in terms of editing multiple files and saving all of them at once. This feature can allow you to work more effectively and flawlessly with Window Splits and Tabs as they can contain multiple buffers within them. &#xA;&#xA;Now we will see how to move between those buffers. We can pretty effectively use the numbers in the buffer list to directly jump to that buffer. We can use `:b n` where n is any number of the buffer in the list of buffers to move through the buffers. Optionally we can use `:buffer n` but that is quite a long command. &#xA;&#xA;We can move to the previous buffer as `:bp`  to move to the previous buffer in the list. Similarly, we can use `:bn` to move to the next buffer in the list, and `:bfirst` and `:blast` to move to the first and the last buffer respectively.  &#xA;&#xA;![buff2.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628684713072/QzqBC99NV.gif)&#xA;&#xA;## Moving through the buffers&#xA;&#xA;We can move through our opened buffers using `Ctrl + o` to move backward a buffer and `Ctrl + i` to move forward a buffer. This can be helpful if you do not want to remember the numbers associated with the buffers. &#xA;&#xA;![buff2.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628689030442/KNDDAlJpN.gif)&#xA;&#xA;We can scan through the current buffers opened and jump through them one by one and it becomes quite effective in switching between few files. This could probably be suited for Web development where you can hop between HTML/CSS/JS files or in Android development for java/XML files, and so on you get the idea for using it as per your needs.&#xA;&#xA;## Deleting buffers&#xA;&#xA;Now we will see how to delete the loaded buffers, we can simply use `:bd n` where n is the number of the buffer in the list to delete the buffer, optionally we can use `:bd filename` to delete the buffer loaded with that file. &#xA;&#xA;![buff2.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628685481565/m4bBHPf5C.gif)&#xA;&#xA;We can also delete a number of buffers at a time using a range of buffers like `:n,mbd` where `n` is the first buffer and `m` is the last buffer. We will delete every buffer between `n` and `m` including `n` and `m` using the above command. &#xA;&#xA;![buff2.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628685657441/s4rJ_CRRQ.gif)&#xA;&#xA;Just a quick fact, if you do not delete buffers, they will stay in memory even if you use `:q` they won&#39;t get erased from the buffer list, you are just exiting the buffer view and not removing the buffer from the current memory. This can get really messy if you are opening too many files and keeping them in memory. &#xA;&#xA;## Creating splits in buffer&#xA;&#xA;We can even create splits in buffers, basically a window split but we will see this with the view of buffers this time. To create a horizontal split, we can type in `:new filename` to open the file in the split. We can even create a vertical split with `:vnew filename` to open a vertical split with the provided file.  &#xA;&#xA;![buff2.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628686386964/O2HhFqaKa2.gif)&#xA;&#xA;We can see some wired things in the ls menu if we open a new tab in the current instance of Vim. The list command shows all the buffers in the current Tab as well as in the previous tab.  &#xA;&#xA;We can also open buffers in splits by using numbers or file names. We can use `:sb n` to open the contents of the buffer n(any number of buffer), and with `:sb filename` to open the file in a split this will only be a horizontal split. &#xA;&#xA;We can use `:sba` to open all the buffers in the split windows. This can be quite handy to find any file which you cannot remember was edited or wanted at the moment, this opens every buffer loaded in the current instance. We can also use `:sbp` and `:sbn` to open the previous and next buffer respectively in a split. &#xA;&#xA;Additionally, we also have `:vertical ba` and `:ba` (`:ball`)to open all the buffers in vertical and horizontal splits respectively.  &#xA;![buff2.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628693311069/5y_xbPho7.gif)&#xA;&#xA;**Also**, We have `:tab ba` or `:tab ball` to open all the buffers as tabs in the current instance. &#xA;&#xA;![bufftab.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628693521966/f1RKu4JwM.gif)&#xA;&#xA;You can add more layers of effectiveness or customization using keymaps to split certain buffers and make use of the above set of commands more powerful and make them work according to your needs.&#xA;&#xA;## Conclusion&#xA;&#xA;So, from the above sections, we were able to see what happens under the hood when you open, close, or edit a file in Vim. Though it was not an in-depth view of each and every detail of the buffers in Vim. But enough to make you understand what and how buffers work and how to use them to become more effective. Hopefully, you have understood how to perform movements with buffers and create and delete them with tremendous control over what files you could edit. Thank you for reading till here.   &#xA;&#xA;### Buffers &lt; Window Splits &lt; Tabs&#xA;&#xA;So from these three articles, we were able to understand the terminology of Buffers, Window Splits, and Tabs. These all are the units of the Vim file system/ Way of grouping Files. We can use buffers to load the file from the memory, we can split various buffers into windows which are all contained in a tab. Some might prefer using buffers, splits, or tabs but hey! what are you even talking about? They are all part of tabs so use everything as per need don&#39;t force yourself to use only one thing. &#xA;&#xA;**Use buffers for opening few files, if you need to open many files regularly use window splits, If that&#39;s not enough use tabs to separate from different folders or directories**. Don&#39;t stop Viming, Happy Coding :)&#xA;&#xA;### References&#xA;&#xA;- [Vim Fandom: Buffers](https://vim.fandom.com/wiki/Buffers)&#xA;&#xA;- [Vim Buffers FAQ](https://vim.fandom.com/wiki/Vim_buffer_FAQ)&#xA;&#xA;- [Linux Hint - Understanding and using VIM Buffers ](https://linuxhint.com/how_vim_buffers_work/)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Vim: Window Splits</title>
      <link>meetgor.com/vim-window-splits</link>
      <description></description>
      <pubDate>Fri, 06 Aug 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Have you ever been stuck in Vim opening multiple files within a single window? Didn&#39;t anyone tell you, you can create multiple windows and split them within a single tab. Definitely, the window splits will be in separate buffers. In this way you can create multiple windows inside of a single Tab, what are Tabs? You can learn some basics about it from my previous article about  [Tabs in Vim](https://mr-destructive.github.io/techstructive-blog/vim/2021/08/03/Vim-Tabs.html). We can either create Vertical or Horizontal splits within the window making it flexible to work with multiple files in Vim. This article will look into the creation, navigation, closing, and rearrangement of Window Splits.&#xA;&#xA;## Creating a Window Split&#xA;&#xA;Creating Window splits is quite straightforward. You should keep in mind the following things though:&#xA;- You can create a horizontal or a vertical split within a window.&#xA;- Creating a Split either vertically or horizontally can shorten the current window&#39;s size, making it equally spaced.&#xA;&#xA;Let&#39;s take a look at creating the vertical and horizontal splits one by one: &#xA;&#xA;### Vertical Splits&#xA;&#xA;Vertical Split as the name suggests, it will split the current window into **two halves vertically** or a **standing split between two windows**.&#xA;&#xA;The below image clearly shows a vertical split between two windows. Here we are splitting a single window into two windows. We can also think it of in splitting the window from left to right.&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1628232885853/xtBgWb-Yg.png)&#xA;&#xA;To create a vertical split, you can use `:vsp` or `:vsplit` to create a split of the same file/ blank file.&#xA;&#xA;![vsp.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628233753115/4seJbY-h9.gif)&#xA;&#xA;If you already have a file open, it will open the same file in the split as long as you don&#39;t specify which file to open. You can specify the name of the file after the command `:vsp filename` or `:vsplit filename`&#xA;&#xA;![vsp.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628233871768/B3D_3NNGo.gif)&#xA;&#xA;It&#39;s not like that you can create only a single split, you can create multiple vertical splits. That can get pretty wild pretty quickly.&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1628234228391/vmJxW5HOo.png)&#xA;&#xA;In the above screenshot, I have created 5 vertical splits from a single window, so making them equally wide and evenly spaced. This might not be useful every time but can get quite handy in some tricky situations.&#xA;&#xA;### Horizontal Splits&#xA;&#xA;Similar to Vertical splits, we have horizontal Splits indicating to split from top to bottom. We can **split a single window into two halves horizontally** or a **sleeping split between the windows**. &#xA;&#xA;The below image clearly shows a horizontal split between two windows. Here we are splitting a single window into two windows. We can also think it of in splitting the window from top to bottom.&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1628233063400/5PVdEsGHZ.png)&#xA;&#xA;To create a horizontal split, you can use `:sp` or `:split` to create a horizontal split of the same file/ blank file. This will create a blank file inside a horizontal split.&#xA;&#xA;![sp.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628235156757/ckfDxh-1D.gif)&#xA;&#xA;Similar to the vertical splits, you can open files by creating the split. You can use the command `:sp filename` or `:split filename` to create the horizontal split between the windows and opening a specified file in it.&#xA;&#xA;![sp.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628235452142/eVGrEZmHVK.gif)&#xA;&#xA;Again as seen in the vertical split, we can create as many splits as we like. This looks very ugly but who knows when you may need this. We can basically create Splits in any order of vertical or horizontal, we&#39;ll see it in the later section to the same.&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1628235679425/9dtK5TV6G.png)&#xA;&#xA;### Vertical and Horizontal Splits Together&#xA;We can also create Vertical split and horizontal splits independently like we are not restricted to only creating the only kinds of splits at a time. You can create a vertical split once and then can create a horizontal split within the vertical split created, in this way we can make good use of both the splits as per our needs.&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1628236573469/7FOJIgP-z.png)&#xA;&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1628236677571/CCeVePLkp.png)&#xA;&#xA;## Moving around Splits&#xA;&#xA;Now let&#39;s talk about the navigation around these splits, it&#39;s again a simple thing. We can use `Ctrl+w` as our primary command along with Vim navigation to move around the splits. Like for example `Ctrl + w + h` will take you to the left split to your current open window. You can also use `Ctrl+w`** twice** to hop around to the next window split in a repeating loop. &#xA;&#xA;So, we can use:&#xA;&#xA;`Ctrl + w `+ `w` -&gt; Switch to the next split (in the order of creation of those splits).&#xA;&#xA;`Ctrl + w ` + `h` -&gt; Move to the left split.&#xA;&#xA;`Ctrl + w ` + `l` -&gt; Move to the right split.&#xA;&#xA;`Ctrl + w ` + `j`  -&gt; Move to the below split.&#xA;&#xA;`Ctrl + w ` + `k`  -&gt; Move to a upper split.&#xA;&#xA;These commands might be good enough to pull you through any splits from anywhere, it just becomes easy to use Vim navigation inside of these. You can use arrow keys if you are stuck somewhere but using Vim key bindings will work out of the box.&#xA;&#xA;## Creating Splits using Keyboard shortcuts&#xA;&#xA;If you think you are wasting time going into the command mode and typing the commands to create splits, well there are some shortcuts for you. &#xA;&#xA;`Ctrl + w` + `v` -&gt; Create a vertical split.&#xA;&#xA;`Ctrl + w `+ `s` -&gt; Create a horizontal split.&#xA;&#xA;This will open the split with the current file in the original window, so if you need to change the file, you can use the edit command (`:e filename`) inside the split. &#xA; &#xA;&#xA;## Rearranging the Window Splits&#xA;&#xA;If you have a  specific set of splits of a kind open, you can rotate between those. Like for example, if we have a horizontal split, you can rotate the split to move the upper split down and below split up.  &#xA;&#xA;![cwr.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628240624930/HBIKPummz.gif)&#xA;&#xA;From the above illustration, we can see we rotated(swapped) the splits. We can also use certain commands to arrange the splits into appropriate positions according to the user. &#xA;&#xA;`Ctrl + w` + `r` -&gt; Swap the two splits(either horizontal or vertical)&#xA;&#xA;`Ctrl + w` + `H` -&gt; Move the split to the left ( `Ctrl + w` + `Shift + h`). &#xA;&#xA;`Ctrl + w` + `J` -&gt; Move the split down ( `Ctrl + w` + `Shift + j`). &#xA;&#xA;`Ctrl + w` + `K` -&gt; Move the split up ( `Ctrl + w` + `Shift + k`). . &#xA;&#xA;`Ctrl + w` + `L` -&gt; Move the split to the right ( `Ctrl + w` + `Shift + l`).&#xA;&#xA;&#xA;![spr.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628242295049/_HadBQPrs.gif)&#xA;&#xA;We can see that we were able to swap the splits to a location suitable according to our wish. We can definitely switch the splits internally as well.&#xA;&#xA;We can resize the splits as per the requirement and remove the equality in those splits. We have a couple of options to do this:&#xA;&#xA;`Ctrl +w` + `+` -&gt;  Increase the height of the current split.&#xA;&#xA;`Ctrl +w` + `-` -&gt;  Decrease the height of the current split.&#xA;&#xA;`Ctrl +w` + `&gt;` -&gt;  Increase the width of the current split.&#xA;&#xA;`Ctrl +w` +  `&lt;` -&gt;  Decrease the width of the current split.&#xA;&#xA;`Ctrl +w` + `=` -&gt;  Make the splits equal in width and height.&#xA;&#xA;![spr.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628243827459/nL3mus88d.gif)&#xA;&#xA;We can also use `:resize {number}` to manually set the size of the horizontal split and `:vertical resize {number}` to manually set the size of the vertical split. This is really risky, like if you know what you are doing then it&#39;s totally fine. The commands demonstrated earlier are really adjustable and user-friendly. &#xA;&#xA;We can also use `Ctrl + w` + `_` to minimize all the window split except the current one.&#xA; &#xA;## Closing the Splits&#xA;&#xA;Now after doing all sorts of wizardry with the window splits the finishing touch is to close those splits after use. We can surely use `:q` to close the current window split but that is not intuitive to enter each split and manually close all of them, we can use:&#xA;&#xA;`Ctrl +w` + `c` -&gt;  Close the current split.&#xA;&#xA;`Ctrl +w` + `o` -&gt;  Quit all other splits except the current one. &#xA;&#xA;![closesp.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628244089101/Ebdup7wNE.gif)&#xA;&#xA;## Conclusion&#xA;&#xA;So, we have seen the basics of using Window Splits in Vim. Please let me know if there is some important point that is missing. Thank you for reading through here. We have seen how to create, navigate, rearrange, closing and other basic stuff related to Window splits in Vim.&#xA;&#xA;### References:&#xA;&#xA;- [Sodocumentation](https://sodocumentation.net/vim/topic/1705/split-windows)&#xA;- [Linux Hint Vim Split Screen](https://linuxhint.com/vim_split_screen/)&#xA;- [Starefossen](https://gist.github.com/Starefossen/5957088)&#xA;&#xA;Hopefully, this might have given you some good idea to deal with Vim in windows splits. Happy Coding and Viming :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Vim: Tabs</title>
      <link>meetgor.com/vim-tabs</link>
      <description></description>
      <pubDate>Tue, 03 Aug 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;So, you are playing with Vim and getting good at but something pulls you off. Basically can&#39;t get used to switching between files or windows, and that&#39;s totally fine. Some may prefer using Window splitting, file managers, and whatnot. But let me introduce you to TABS in Vim. A simple and elegant way to open multiple files in Vim. &#xA;&#xA;## Opening Tabs&#xA;&#xA;To open a tab, you can press `:tabnew`  or  `:tabedit` to open a blank Tab with no file open in it. This basically works like the `:e` command, which opens a buffer for you with no named file.&#xA;&#xA; If you already have an existing file in the current folder you are in, then you can press `:tabf filename` or `:tabnew filename` or `:tabedit filename`. This also applies to opening folders or directories, which will open the file structure in Vim buffer. &#xA;&#xA;![tabop.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1627994196949/A-ZMWZefa.gif)&#xA;&#xA;From the above illustration, we can see that the new tab was created using the filename with the `tabf` command and an empty tab was created with `tabnew` command. Ya, we can use `tabnew` for both cases but it saves time to write two more letters. It depends on the preference as you don&#39;t have to remember one more command in this case. You can also customize the commands if you feel they are too big to type in like a simple mapping would do the trick for opening the tabs for you.&#xA;&#xA;### To open a Tab with a file specified.&#xA;&#xA;- `:tabf filename` &#xA;&#xA;- `:tabnew filename` &#xA;&#xA;- `:tabedit filename`   &#xA;&#xA;### Open a Tab without any file specified.&#xA;&#xA;- `:tabnew` &#xA;&#xA;- `:tabedit`&#xA;&#xA;&#xA;You can open the tabs as per your choice like it could be ideal if you are gonna use certain files for a longer duration of time. This could be very ideal for various programming cases especially in Web, Android, Application Development where we need to edit a few files again and again. If you prefer Window-Splitting, that&#39;s totally fine, this is just to tell that there exist other ways as well.&#xA;&#xA;## Switching Tabs&#xA;&#xA;Now if you are comfortable with opening tabs, we can now move on to switching between tabs. If you just have few tabs open, you can easily switch to the next tab using `gt` and to the previous tab using `gT` commands. But if you are in a great mode and want to open ten-twenty tabs XD, then you can use the numbers before the `gt` command. Like you can type `5gt` to move to the 5th Tab. If you do not know which tab is which, you can type in `:tabs` and this will open up the currently open tabs along with the numbers.&#xA;&#xA;&#xA;![tabsw.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1627996436129/vApSyRD6o.gif)&#xA; &#xA;You can see my keystrokes(except the last keystroke) in the lower right corner. We can easily switch between tabs using the three sets of commands and surely configure them as per your preference. We also saw the `:tabs` command which can be pretty handy if you are working with a number of tabs.&#xA;&#xA;You can move around Tabs using some special commands like `:tablast` to move to the last tab and `:tabfirst` to move to the first tab. &#xA;&#xA;- `gt`  -&gt; Move to the **NEXT** Tab being in Normal mode.&#xA;&#xA;- `gT` -&gt; Move to the **PREVIOUS** Tab being in Normal mode.&#xA;&#xA;- `ngt`  -&gt; Move to the Nth Tab in Normal mode. (n is any number of tab which are opened).&#xA;&#xA;- `:tablast` -&gt; Move to the **LAST** Tab.&#xA;&#xA;- `:tabfirst` -&gt; Move to the **FIRST** Tab.&#xA;&#xA;- `tabs`  -&gt; Get a list of Tabs which are currently opened. (includes file opened in the tab and the number)&#xA;&#xA;&#xA;## Closing Tabs&#xA;&#xA;So, after opening tabs you want to close em right? That is quite simple as expected. Just type `:tabc`, this will delete the current tab. You can close the specific tab by prefixing `tabc` with the number of that tab. Like if you want to delete the 2nd tab, use `:2tabc` to close the 2nd tab. &#xA;&#xA; If you want to reopen the closed tab, you can look out for the buffer name using `:ls` and then after finding the number of buffers in which your tab was open, you can type `:tabnew +nbuf`, here n is that number of the buffer. &#xA;&#xA;If you want to close all the tabs except the current one, you can use `:tabo`. This will clear the tabs except in which you are in, hence it will also collapse the top tab bar showing the file opened in those tabs.&#xA;&#xA;![tabce.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1627997764101/HhUmFFQLZ.gif)&#xA;&#xA;As from the above GIF, we can see we located the number of the buffer last closed as we knew the name of the file which was opened in that tab. We also saw how to delete the specific tab using its number and the current tab.&#xA;&#xA;- `:tabc` -&gt; Close the current tab.&#xA;&#xA;- `:ntabc`-&gt; Close the Nth Tab.&#xA;&#xA;- `:tabo`  -&gt; Close all the tabs except the current Tab.&#xA; &#xA;## Re-ordering Tabs&#xA;&#xA;This is a very tiny little detail but becomes a super tool in many cases. Let&#39;s say you want some reference of some content in the file, again and again, it&#39;s quite likely you should make the tabs nearby instead of switching tabs again and again. You can use Window splitting in this case, though we will see how to reorder tabs just for having the grasp on using Tabs in Vim.&#xA;&#xA;To reorder tabs, you are basically moving a tab from one position to other. Let&#39;s say you have a Tab at position `5` which is your current tab, you want it at position 2. So what you can do is move the current tab to position two, as simple as to speak `:tabm 1`. This will move the current tab which is at number 5 to the 2nd position. Remember the tab order is 0 based so just use the number you are thinking minus 1. So the command becomes `:tabm n`, where n is the index of the tab(starts from 0, the left-most tab). If you want to move to the last tab, you would not specify any number just type the `tabm` command, and that&#39;s it.&#xA;&#xA;![tabmv.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1628001405055/m0XQAfdQJ.gif)&#xA; &#xA;From the above example, we were able to move around the tabs to our desired location without a hassle. This is some basic stuff you can do with Tabs in Vim, surely you can add in your custom mappings to enhance the productivity and improve the workflow in Tabs in Vim.&#xA;&#xA;- `:tabm n` -&gt; Move the current opened Tab to the Nth position (Starts from 0).&#xA;&#xA;## Conclusion&#xA;&#xA;So, we have seen how we can use Tabs and move around in between files and folders, we are now able to open, close, move, navigate around the tabs in Vim. By using some custom mappings, this can be overhauled for much fewer keystrokes that get in it. There are many other navigation techniques in VIm, and using Tabs is one of them, surely it won&#39;t suit everyone but there will be someone who will prefer using this. Thank you for reading till here. I hope you learned something from this to enhance your grasp in Vim. Happy Coding and Viming :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Vim: Registers</title>
      <link>meetgor.com/vim-registers</link>
      <description></description>
      <pubDate>Wed, 21 Jul 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Have you ever found it difficult to manage and operate text in Vim, especially in Cut/Copy/Paste stuff. You cannot figure out how on earth am I supposed to retrieve my un-saved, un-committed changes in Vim. Then this my dear friend is an article for you. You will learn what are Vim registers and where your deletes and copied stuff resides. This won&#39;t be a comprehensive guide but enough to let you through in performing the wizardry of registers in Vim.&#xA;&#xA;## What are Vim Registers?&#xA;Vim Registers are memory addresses that store data. Technically they are spaces of memory that Vim can store to retrieve later. It can store text, operations, commands, and anything you can do with text in Vim. &#xA;&#xA;## Access Vim Register&#xA;To store something in register `x` we can use the format `&#34;[register-name][command]`. This will perform the command and store the output in the register specified.&#xA;&#xA;A register can be accessed by using the double quotes `&#34;` before its name. Let&#39;s say we have stored something in x register we can access its content using &#34;x in the normal mode and lastly we can perform commands here.&#xA;&#xA;![vimreg.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1626940084837/x99b92Wsq.gif)&#xA;&#xA;For example, in the above gif, I tanked the selected text using the yank command but I stored it in the register x by prefixing the command with `&#34;x`. Hence the command became `&#34;xy` and similarly for pasting from the x register we can use `&#34;xp`, quite simple, right? But what is the purpose of it? This can really shine in handling multiple files and imagine you lost your yanked text by using yank somewhere else. Vim registers add extra dimensions in storing and retrieving text, it is not used often but can shine really well in certain tricky situations. &#xA;&#xA;## Commonly used Vim Registers&#xA;You will use some Registers daily in Vim if you use it all the time. Some common ones are the clipboard registers/ selection registers `&#34;+` and `&#34;*`. These are used to perform operations on the content stored in the system clipboard. They come quite handy in copy and paste in Vim from other applications such as Stack Overflow XD. Just kidding, it can be used in any other application on the system. We can add `p` or `y` after the registers to paste and respectively in Vim, so to paste and yank text to and from Vim, you can use `&#34;+p` and `&#34;+y`.&#xA;&#xA;## Types of Vim Registers&#xA;There are many different types of vim registers used for particular needs and also some for custom editing. &#xA;&#xA;- ### 26 Named registers (`a` to `z`)&#xA;&#xA;These are the registers just for you. You can use this for whatever copy/pasting/editing and other creative stuff you could do with this. In the example where we utilized the `x` register, which was one of them. We can use a to z any register we want, it just boils down to the ease of the key combination as per preference. **Remember anything you yank into any register will also be stored in the unnamed register (discussed later)**. &#xA;&#xA;Also, if you try to use capital named registers (A-Z), the content will be appended to the lowercase named registers as well along with the unnamed register. Making it a bit safer to work with but messy at the same time. &#xA;&#xA;- ### 10 numbered registers (`0` to `9`)&#xA;&#xA;These are the registers updated automatically filled in by Vim, they store the recently yanked or deleted content in the current buffer. &#xA;- The `0` register stores the most recent yanked/copied text.&#xA;- The `1` register stores the most recent deletion of text.&#xA;- The `2` register stores the 2nd most recent deletion. &#xA;&#xA;.. and so on.&#xA;&#xA;The content of the 9th register is flushed away every single time you delete something. The contents are shifted to the next numbered registers every time there is a deletion. For example, If we delete something the content is stored in the `1` register but its previous content gets shifted to the `2` register, and so on. So we have 9 clipboards for our deletion history. That is undoubtedly a powerful thing.&#xA;&#xA;- ### Selection and drop registers (`*` , `+` , and `~`)&#xA;&#xA;As discussed earlier, Selection registers are used for storing the contents of the system clipboard. There are differences in the `*` and `+` for Unix-like operating systems but they can do similar things. In Unix-like Operating systems, the `*` register stores the text from the mouse selection in the X Window, whereas the `+` register is used to store the text system clipboard. On Windows and other operating systems besides Unix-like, both of them function similarly.&#xA;&#xA;The Drop register `~` is available only for the Gvim version as it stores the text from the last drag and drops/drag down operations performed. &#xA;&#xA;- ### Read-only registers (`:`, `.`, and `%`)&#xA;&#xA;The registers `:`, `.`, and `%` are Read-only, which means you cannot change their content, they are modified and maintained by VIm automatically. &#xA;&#xA;Using the `:` register, we can get the content of any register in the Insert mode so that we can copy the contents and edit if we have stored it in some registers. This is quite a neat little feature, not used most of the time but it can become the most powerful tool in corner cases and tricky situations. &#xA;&#xA;![vimc-r.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1626946965392/KBSZmxOHvi.gif)&#xA;From the example in the gif, we deleted the line, and hence the content was stored in register 1 so when we press `Ctrl + R` in Insert mode, we can now paste in the contents of any register. Here we used the register `1` to get our content back. &#xA;&#xA;The `%` register holds the name of the current file, this is really a great and life-saving editor, as it is also used in automating the compilation and running of the source files from Vim itself. &#xA;&#xA;The `.` register contains the last inserted text, this can also be used in various scenarios. They make Vim a bit polished and well organized.&#xA;&#xA;![vimc-r.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1626948017124/dQCky3kfC.gif)&#xA;&#xA;From the above gif, we inserted some text, and using the Read-only register, we inserted the last inserted text to the screen using the `.` register and also we used the register `%` to get the current file name.&#xA;&#xA;- ### Expression and Search pattern register (`=`, `/`)&#xA;&#xA;The register `=` is used to perform operations and store them in the register. Vim has some built-in functions and some of them are listed  [here](https://renenyffenegger.ch/notes/development/vim/script/vimscript/functions/index). We can use these functions after we type `Ctrl + R` in insert mode and `=` to assign it to the register `=`. I have used some simple multiplication operations in the above gif, but you can take this further however you like and desire. &#xA;&#xA;The register `/` takes searching in Vim even further. We use /pattern in normal mode to search for the pattern. But the actual work is done with help of the register. We actually store the text in the register and Vim accesses it later t find the next pattern or any other operations performed with the pattern. This is again a read-only register but you can change its content using some methods and practices. It is not preferred to change the read-only registers as it can mess up the functions of Vim.&#xA; &#xA;- ### small delete and the alternate file register (`-`, `#`)&#xA;&#xA;Small delete is quite a meaningful and sensible word to put in the context of its functioning. The `-` register or small delete register stores the content of some small deletes like characters or words. Basically, anything smaller than a line is small for Vim. If you delete something let&#39;s say a word from a line, it&#39;ll be stored in the `-` register. &#xA;&#xA;The &#39;#&#39; register or alternate file register is the register that stores the alternate file in Vim. An alternate file is a file edited before the current file in Vim. If you edited a `file-x` and now you are in the `file-y`, the `file-x` becomes your alternate file. &#xA;&#xA;![vimc-r.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1626950574633/P7U01Ssy_.gif)&#xA;&#xA;This example shows how we can use the small delete register to retrieve back the small deletions. Also, we saw the current file and alternate files in Vim and in which registers they are stored.&#xA;&#xA;- ### Unnamed and black hole register (`&#34;`, `_`)&#xA;&#xA;Unnamed register `&#34;`, simply to put in it is a register which stores everything from deletions to yank. It stores the text performed by the d, D, x, X, s, S, c, C, y, Y, some variants of these commands. This is quite good and a bad feature sometimes. It is nice to have such types of registers in hand. &#xA;&#xA;Wear your space goggles as we see will how Black holes work :) Blackhole register is an elegant touch to the series of registers we have. The register acts as a sink for our deletions. We can simply dump anything we don&#39;t care about in this register. This register helps in scenarios where we want to avoid adding stuff from deletions to the named or numbered registers. Isn&#39;t it like Blackholes? Just Swallow the things. &#xA;&#xA;![vimc-r.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1626951775215/OEanNfA4a.gif)&#xA;The above example makes it clear that we simply dump the deletion to the `_` register and avoid changing the rest of the registers which may replace the deletion and lose the saved configuration or set up of registers. We first deleted the line `solve(s);` and dumped the statement `string s = &#34;0110` into the black hole register `_`, when we retrieve with thee unnamed register `&#34;` we get back the deleted statement rather than the dumped statement. Quite neat and elegant.&#xA;&#xA;## Where can you use Vim registers&#xA;&#xA;Well, this may differ as per the experience with your programming journey, you may find it useless as a beginner but mind you this is some extraordinary stuff that can boost some development time. You may be tempted to use it the scenarios where there is a huge depth in file systems and the code to be edited is a lot for you. When you have a ton of things to be edited systematically, this concept can add &#xA; lights and dimensions to your work and make it comfortable and risk-free. &#xA;&#xA;## Conclusion&#xA;&#xA;![vimregistertable.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1626953924487/2bPqejVkT.png)&#xA;The above chart is quite simple to remember if you are really into making Vim for complex projects and even for staying productive in Vim editor. Hope you find it interesting and easy to remember.&#xA;This was a small introduction to Vim-registers but is a small topic with extensive usage and skill-dependent concept. Vim is already a customizable editor, registers add an extra dimension to its customizability in editing and programming. Thank you for listening to me. Happy Coding :)&#xA;&#xA;**References** :&#xA; [baeldung.com](https://www.baeldung.com/linux/vim-registers), [brianstorti.com](https://www.brianstorti.com/vim-registers/)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Vim: Enhancing Editing Speed</title>
      <link>meetgor.com/vim-editing-speed</link>
      <description></description>
      <pubDate>Sun, 18 Jul 2021 00:00:00 UTC</pubDate>
      <content>&#xA;&#xA;## Introduction&#xA;Editing/ Writing is a crucial part of any text editor, the swiftness with which one can make changes in a file(s) or a structure is a bit dependent on the editor we use as well. Vim can be a bit hassle for beginners in the initial stage but it becomes second nature soon. It also depends majorly on the level of usage and the area of usage. If you are an advanced programmer, you will use these commands extensively, and might not be a big deal for you, But for a beginner, it might take some time to get used to the workflow in Vim.&#xA;&#xA;This article won&#39;t be covering the basics of editing in Vim but the ways to save time on the basic level commands to improve efficiency. That being said, beginners can also read to be aware of the possibilities and tricks in Vim. &#xA;&#xA;Below are some quick basic commands for getting started in editing and improving the overall workflow. &#xA;&#xA;### Entering in into the Insert Mode&#xA;&#xA;`i`  -&gt; Enter into **Insert mode** from the cursor.&#xA;&#xA;`I`   -&gt; Enter into **Insert mode** from the beginning of the current line.&#xA;&#xA;`a`   -&gt; Enter into **Insert mode**  just after the cursor.&#xA;&#xA;`A`   -&gt; Enter into **Insert mode** from the end of the current line.&#xA;&#xA;`o`   -&gt; Enter into **Insert mode** below the current line.&#xA;&#xA;`O`   -&gt; Enter the **Insert mode** above the current line.&#xA;&#xA;The above commands are purely to add text in the line or above or below the line without deleting anything.&#xA;&#xA;The following commands will delete some characters/words/lines and then entering into the Insert mode.&#xA;&#xA;`s`   -&gt; delete the character under the cursor and enter into **Insert mode**.&#xA;&#xA;`cw`  -&gt; Delete the word under cursor and enter into **Insert mode**.&#xA;&#xA;`S`   -&gt; delete the entire line under the cursor and enter into **Insert mode**.&#xA;&#xA;&#xA;## Cut Copy Paste Commands&#xA;&#xA;This set of commands are quite helpful as a programmer and it is used quite frequently. These commands can surely boost the time to cut-copy-paste but also they will provide more customization to the way you do these tasks.&#xA;&#xA;### Cut/Delete Commands&#xA;&#xA;The below-mentioned commands can be used in Normal or any Visual/ Selection mode as it depends whether you have selected the text or you want to work in Normal mode itself. &#xA;&#xA;`dd`  -&gt; Delete the current entire line.&#xA;&#xA;`dw`  -&gt; Delete the word on the cursor.&#xA;&#xA;`d0` -&gt; Deletes the line from the current cursor position to the beginning of the line.&#xA;&#xA;`D` or `d$` -&gt; Deletes the line from the current cursor position to the end of the line.&#xA;&#xA;`d`  -&gt; Delete the selected text (only in Visual/Visual-Line/Visual-Block/Selection mode).&#xA;&#xA;`x`  -&gt; Delete the character under the cursor.&#xA;&#xA;### Yank/Copy Commands&#xA;&#xA;The following commands are used in the Normal mode as they perform the copying of text with words and lines only.&#xA;&#xA;`yw` -&gt; yank(copy) the word on the cursor.&#xA;&#xA;`y$`  -&gt; yank(copy) line till the end from the current cursor position.&#xA;&#xA;`yy`  -&gt; yank(copy) the current entire line to the unnamed register (&#34;&#34;).&#xA;&#xA;You have to be in Visual/ Visual line/ Selection mode to yank the text for the next set of yanking commands. &#xA;&#xA;`y`  -&gt; yank(copy) the selected text to the unnamed register (&#34;&#34;).&#xA;&#xA;`&#34;+y` -&gt; yank(copy) the selected text to the system clipboard (&#34;+ register).&#xA;&#xA;### Paste Commands&#xA;&#xA;`p`   -&gt; Paste the content of the unnamed register(&#34;&#34;) below the cursor.&#xA;&#xA;`P`   -&gt; Paste the content of the unnamed register(&#34;&#34;) above the cursor.&#xA;&#xA;`&#34;+p`  -&gt; Paster the content of system clipboard (&#34;+ register) to the cursor.&#xA;&#xA;&#xA;### Replacing Text&#xA;&#xA;Replacing is a great option for instant productivity, if you want to make some minor changes, you don&#39;t have to go into insert mode and delete and then edit the text. Instead, the replace commands such as `r` and `R` allow us to replace some characters being in Normal and Replace mode respectively. This can be used very heavily if you just want to replace it instead of adding/removing text.&#xA;&#xA;`r`   -&gt; replace the character under the cursor with the following key entered from the keyboard.&#xA;&#xA;`R`   -&gt; Enter into **Replace mode**( replace the character with the specified word from the keyboard). &#xA;&#xA;### Undoing and Redoing&#xA;&#xA;We often make mistakes and want to revert to the changes we have to make and start from the last save. The following sets of commands will make us do exactly that.&#xA;&#xA;`u`   -&gt; Undo the last made changes before saving.&#xA;&#xA;`U` -&gt; Restore the changes in the entire line.&#xA;&#xA;`&lt;C-R&gt;`   -&gt; Redo the last undo (un-undo -&gt; revert back changes).&#xA;&#xA;&#xA;### Search and Replacement&#xA;&#xA;Some of the below-mentioned commands are a great set for bulk replacement and addition. We can either replace a particular pattern in the entire file or in specific parts of the file as mentioned and explained as follows:&#xA;&#xA;`:%s/old/new`  -&gt; Replace the word `old` with `new` in the entire file.&#xA;&#xA;`:4s/old/new`  -&gt; Replace the word `old` with the word `new` on line 4( where 4 can be any number of lines in the file).&#xA;&#xA;`:2, 9s/old/new`  -&gt; Replace the word `old` with `new` between the lines 2 and 9 inclusive(where 2 and 9 can be any number of lines in the file).&#xA;&#xA;`:%s/^/This`  -&gt; Add `This` to the beginning of each line in the file.&#xA;&#xA;`:%s/$/That`  -&gt; Append the word `That` to the end of each file.&#xA;&#xA;You can notice that the `%` symbol here indicates the entire file. We can skip prefixing s with `%` to make changes only in the current line or any number of lines specified instead of it. This command is quite a lot customizable and powerful, I can&#39;t show each and every combination of this command. It should be used as per requirement and thus should be modified accordingly.&#xA;&#xA;&#xA;### Indenting Text&#xA;&#xA;Indenting is quite important in certain languages like Python, YAML, Haskell, etc. This can get really frustrating if you even miss a single indentation, you have to format everything to a proper indentation scratch. But thanks to powerful Text-editors and IDEs which have made the indentation quite easy and even auto-correct the wrong indentation. Vim has some commands to make those indentations much easier and it also has a customizable number of spaces in its config file called vimrc.&#xA;&#xA;`&gt;&gt;`  -&gt; Indent or shift the current line to the right. (normal mode)&#xA;&#xA;`&lt;&lt;`  -&gt; Unindent shift the current line to the left. (normal mode)&#xA;&#xA;`&gt;`   -&gt; Indent or shift the selected text to right. (Visual/Visual-line/VIsual-block/Select mode)&#xA;&#xA;`&lt;`  -&gt; Unindent or shift the selected text to left. (Visual/Visual-line/VIsual-block/Select mode)&#xA; &#xA;If your file is saved as a particular language that supports indentation, it will automatically indent lines for you but it cannot be reliable. So, we need to [IndentLine](https://github.com/Yggdroot/indentLine), and others as well. &#xA;&#xA;## Miscellaneous&#xA;&#xA;`~` -&gt; Convert the character under the cursor to upper case/ lower case.&#xA;&#xA;`vip` -&gt; Yank a entire paragraph ( till empty line).&#xA;&#xA;`gu` -&gt; Convert the selected text into lowercase. (Visual/Select Mode)&#xA;&#xA;`gU` -&gt; Convert the selected text into Uppercase. (Visual/Select Mode)&#xA;&#xA;&#xA;&#xA;All of the above commands were somewhat basic and commonly used but if used along with other key shortcuts for movement can also improve the editing speed quite considerably. Just keep using these commands and you&#39;ll be amazed by the speed you&#39;ve developed. Thanks for reading. Happy Coding :)&#xA;&#xA;References:  [catswhocode](https://catswhocode.com/vim-commands/)  [The valuable dev](https://thevaluable.dev/vim-advanced/) [rtorr.com](https://vim.rtorr.com/)&#xA;                      &#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Vim: Terminal Integration</title>
      <link>meetgor.com/vim-plus-teminal</link>
      <description></description>
      <pubDate>Tue, 29 Jun 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Vim and Terminal!?&#xA;Vim was made to work with the command line. Many beginners do not understand what are the true capabilities of Vim, myself included:) Vim can run terminal commands without leaving the text editor, open an instance of a terminal, work with shell environments, and other things depending on the use case.&#xA;&#xA;## Running Terminal/ shell commands from within Vim&#xA;&#xA;You can run the commands from inside of Vim by just using `:!` before the command, this means you have to be in command mode. Just after being in command mode, the ! or bang operator will execute the command typed after it from the terminal(Linux/ macOS) or your default shell(Windows -&gt; CMD/Powershell).&#xA;```&#xA;:!pwd&#xA;```&#xA;The above command from vim will redirect to the terminal and show the output of the command and return on pressing any key. In this case, it will execute the PWD command and just wait for the user to enter any key to return to Vim.&#xA;&#xA;The following is an example of how it could be used from Vim in Windows using Powershell as the default shell.&#xA;&#xA;![Animation.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1624885870237/Ie5C-3u1B.gif)&#xA;&#xA;In Windows, dir is equivalent of ls for Linux. That was not the best example of how a terminal can be used at its best, You can also use a logical operator from within vim to run multiple commands at once. &#xA;&#xA;### Running programs/ code from Vim on terminal&#xA;&#xA;This becomes quite a great feature for making Vim from a text editor to an IDE, this can be paired with Keymaps i.e when the user types certain keys, the command gets executed making the code run from the terminal. I have already used this feature to set up Vim for python, bash, and other programming languages. Also, I have written an article about  [keymapping](https://dev.to/mrdestructive/vim-keymapping-guide-3olb)  and Vim setup for  [Python](https://dev.to/mrdestructive/setting-up-vim-for-python-ej)  and  [Bash](https://techstructiveblog.hashnode.dev/vim-setup-for-bash-scripting), this will give you an idea of how to setup vim for any programming language. &#xA;&#xA;Vim can really shine in this kind of feature as it just becomes flawless and a smooth experience even for a beginner. We just have to run the compile the code and run its executable/ output file, rather for python and other interpreted languages, we have to just pass the file name to the interpreter and that&#39;s it.  &#xA;&#xA;## Opening instance of Terminal within Vim.&#xA;&#xA;Vim can also create an instance of the terminal within its window by making a split. This is quite similar to VS Code and other Text editors that have the functionality to create an instance of the terminal within itself. This feature is useful for developing complex systems and depending on the use case, it can be quite important and efficient as well. &#xA;&#xA;The terminal can be created in various ways the most preferred way is by typing in `:term` from Vim. &#xA;This will create a horizontal split from the current editor and split it into half. You can change the size of the split using the mouse according to your preference. &#xA;&#xA;![vimtermsplit.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1624888468392/wR0JT8SBN.gif)&#xA;&#xA;Here Vim has certain variables and shortcuts to make things even simpler, say you want to parse the current file to the terminal for execution. You can surely type the name manually or you can be a bit smarter and use % instead, the `%` symbol will parse the file name along with the extension in the terminal. Also `%:r` will parse filename without the extensions(.txt/.py/etc) to the terminal.&#xA;&#xA;There are many things you can do with terminals surely, but with Vim that even goes further than the limits. Terminal/command line is quite important in any development environment as it is an interface for the user to interact with the Operating System. Vim is quite powerful and behaves as a gecko for programmers because it changes itself according to our needs flawlessly and **efficiently**.&#xA;&#xA;&#xA;![vimpython.gif](https://cdn.hashnode.com/res/hashnode/image/upload/v1624891655340/5f81Dpp_O.gif)&#xA;&#xA;Integrating Terminal into a Text Editor truly lights up the environment for development. It becomes an easy and enjoyable experience to test out the code without wasting much time on the actual execution process. Surely it needs time to set up the environment to speed things, for that understanding of the programming and development environment is required. Happy Viming :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Vim: Enhancing Movement Speed</title>
      <link>meetgor.com/vim-movement-speed</link>
      <description></description>
      <pubDate>Sat, 26 Jun 2021 00:00:00 UTC</pubDate>
      <content>&#xA;&#xA;![]({{ page.image | relative_url }})&#xA;## Introduction&#xA;OK! Vim and movement are like bread and butter or failed brakes. To become a proficient Vim user, you need to move in Vim very effectively. You don&#39;t have to think about doing certain things, your fingertips should automatically move without wasting time thinking about it. I am sure, it takes time and effort but OH! it is so rewarding in the end.  &#xA;&#xA;### Why H J K L?&#xA;First things first, unmap arrow keys and make a habit of using h,j,k, and l. Yes, this would not make any sense in the initial stage but that will make no sense for not using it later. &#xA;The thing with H J K L is that they are quite flexible to work with and if you use it with numbers you would navigate much faster than arrow keys. Such as `10j` will move you 10 lines down at a time in normal mode. These keys are used with many of the other key shortcuts and commands which just make it most important to begin learning to move around in Vim with H J K L. &#xA;&#xA;## Moving Horizontally.&#xA;This is quite the common movement that every programmer uses most of the time. This is also a much-neglected part when movement in Vim is concerned. To the basics, we use the following commands: &#xA;&#xA; `w`   -&gt;  **move forward by a word (considering punctuations as separate words).**&#xA;&#xA; `W`   -&gt;  **move forward by a word (punctuations ignored).**&#xA;&#xA;`b`  -&gt;  **move backward by a word (considering punctuations as separate words).**&#xA;&#xA;`B`  -&gt;  **move backward by a word (punctuations ignored).**&#xA;&#xA;`e`  -&gt;  **move to end of a word (considering punctuations as separate words).**&#xA;&#xA;`E`  -&gt;  **move to end of a word (punctuations ignored).**&#xA;&#xA;`0`  -&gt;  **move to the beginning of a sentence.**&#xA;&#xA;`$`  -   **move to the end of a sentence.**&#xA;&#xA;Those are the most useful and common commands for moving across the line. Don&#39;t forget to use the number before the command to repeat the task for that number of times. Like for example, if you would like to go 6 words ahead type in `6w`. This can improve your thinking and typing as well, good signs of a programmer Eh!&#xA; &#xA;&#xA;## Moving Vertically.&#xA;&#xA;To move vertically we can imagine moving within a file or the block of code. For moving in a file, the following are some useful commands.&#xA;&#xA;`gg`  -&gt; **move to the beginning of a file.**&#xA;&#xA;`G`  -&gt;  **move to the end of a file.**&#xA;&#xA;`Ctrl + e`  -&gt;  **move the screen down without moving the cursor.**&#xA;&#xA;`Ctrl + y`  -&gt; **move the screen up without moving the cursor.**&#xA;&#xA;`Ctrl + f`  -&gt; **move forward one entire screen.**&#xA;&#xA;`Ctrl + b`  -&gt; **move backward one entire screen.**&#xA;&#xA;`Ctrl + d`  -&gt; **move forward half screen.**&#xA;&#xA;`Ctrl + u`  -&gt; **move backward half screen.**&#xA;&#xA;This just was moving around the screen and now a bit programmatic movement. We will see some keystrokes to move in code blocks or code snippets very efficiently.&#xA;&#xA;`gd`  -&gt; **move to the local declaration of any code.**&#xA;&#xA;`gD`  -&gt; **move to the global declaration of any code.**&#xA;&#xA;`%`  -&gt; **move between pairs of ( ), { }, [ ] or any other type of such braces.**&#xA;&#xA;`{`  -&gt; **move to the next paragraph/ code block/ function/ etc)**&#xA;&#xA;`}`  -&gt; **move to the previous paragraph/ code block/ functions/ etc)**&#xA;&#xA;`fa`  -&gt; **move to the next occurrence of the character &#39;a&#39; in a sentence.**&#xA;&#xA;`Fa`  -&gt; **move to the previous occurrence of the character &#39;a&#39; in a sentence.**&#xA;&#xA;`ta`  -&gt; **jump to before of the next occurrence of the character &#39;a&#39; in a sentence.**  &#xA;&#xA;`Ta`  -&gt; **jump to after of the previous occurrence of the character &#39;a&#39; in a sentence.**&#xA;&#xA;The above might be quite handy key shortcuts in moving in a large code file. Even in files with complex variable names and structures, this can be quite handy. &#xA;&#xA;## Search and navigation.&#xA;Searching is quite a time-consuming task, especially when the code is quite complex and has a lot of variables and all. Vim shines in many of such aspects where people think it&#39;s dead. It rises from the ashes to produce a performance-driven experience like any other modern IDEs though it requires a bit of research:) Here are some commands that will make searching and navigating around it quite a lot easier.&#xA;&#xA;`*` -&gt; **next occurrence of the word under the cursor.**&#xA;&#xA;`#` -&gt; **previous occurrence of the word under the cursor.**&#xA;&#xA;`n`  -&gt; **next occurrence of the word searched pattern.**&#xA;&#xA;`N`  -&gt; **previous occurrence of the word searched pattern.**&#xA;&#xA;&#xA;The above commands will also work if you search the pattern from the command mode.&#xA;`/pattern`  or `?pattern` Enter and navigate to the next(`*` or `n`) and previous(`#` or `N`) occurrence of that pattern match.&#xA;&#xA;&#xA;## Moving across files.&#xA;&#xA;Moving across files without any plugins or file explorer is often considered tricky or impossible for some people but there is a way. You can switch between files using the following commands:&#xA;&#xA;`Ctrl + O`  -&gt;   **move in the previously opened file.**&#xA;&#xA;and &#xA;&#xA;`Ctrl + I`  -&gt;  **move in the next file.**&#xA;&#xA;We also can use `Ctrl + ^ ` to move the previous two opened files.&#xA;&#xA;&#xA;If you want to switch from buffers, you can use `:bn` for moving into the next buffer, and `:bp` to move in the previous buffer. You always have an option to move from a buffer using the file name `:b filename` or using the index as `:bindex`.&#xA;&#xA;&#xA;## Moving between Tabs.&#xA;&#xA;People rarely use Tabs as far as I have seen, but they are quite useful and provide the polish off just as robust IDEs. &#xA;&#xA;`:tabnew filename`  -&gt;  **create a Tab of a file.**&#xA;&#xA;`gt`  -&gt; **move to the next tab.**&#xA;&#xA;`ngt`  -&gt; **move to the nth tab.**&#xA;&#xA;`gT`  -&gt; **move to the previous tab**&#xA;&#xA;`:tabo`  -&gt; **close all the tabs except the current one.**&#xA;&#xA;`:tabc`  -&gt; **close the tab.**&#xA;&#xA;`:tabm n`  -&gt; **move the current tab to nth position.**&#xA;&#xA;&#xA;## Movement in Marks.&#xA;&#xA;Marks are used for some quite large files and code-bases. It is used to move from one mark(kind of a bookmark) to another using few key commands, marks are generally created when you would go to a particular code block or any part of the file again and again. Some of the quick navigation using maps are the following.&#xA;&#xA;`mn`  -&gt;  **set the current position as mark &#39;n&#39;.**&#xA;&#xA;`&lt;backtick&gt;n`  -&gt;  **jump to the position of mark &#39;n&#39;.**&#xA;&#xA;` `0`  -&gt; **jump to the position where vim was last exited.**&#xA;&#xA;` `&#34;`  -&gt;  **jump to the position when the last edit was made in the file.**&#xA;&#xA;&#xA;## Split Windows Movement&#xA;&#xA;`Ctrl + w + r`  -&gt; **move the split down.**&#xA;&#xA;`Ctrl + w + R`  -&gt; **move the split up.**&#xA;&#xA;`Ctrl + w + h`  -&gt;  **jump to the left split.**&#xA;&#xA;`Ctrl + w + j`  -&gt;  **jump to the split down.**&#xA;&#xA;`Ctrl + w + k`  -&gt; **jump to the upper split.**&#xA;&#xA;`Ctrl + w + l`  -&gt;  **jump to the left split.**&#xA;&#xA;You can use Caps H J K L to move the leftmost, bottom, uppermost, rightmost split respectively. &#xA;That just was quick to make you enough faster than previous hassles.&#xA;&#xA;&#xA;That was probably it, these were some tricks and shortcuts to move around Vim pretty effectively and smoothly. Moving around Vim can be quite complicated at once, but it&#39;s just finding the key shortcuts to make you feel and glide in VIm. There might be quite a lot of shortcuts missing, If you have any quicker shortcuts, Please let me know in the comments.  Happy Viming :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Vim: Keymapping Guide</title>
      <link>meetgor.com/vim-keymaps</link>
      <description></description>
      <pubDate>Mon, 14 Jun 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;&#xA;Keymapping or Key binding is a process in which a user or a system can assign certain keys or commands to perform a particular task or commands. This can be quite useful in Vim as well as in other text editors to avoid some repetitive tasks and save time. In Vim this can be a great power to have for programmers as it can be really very flexible to set up for any programming language and it&#39;s &#xA; environment.&#xA;&#xA;In Vim, you can map a particular keystroke combination to trigger a command or any operation. You can also map a key in place of a weird key combination as well. You can map a key to integrate several commands and make it run at a single key or without much of a hassle. Key Mapping is quite powerful in Vim, only your creativity and imagination are the limits here. Vim can really shine in such aspects where the user has the freedom to tailor the editor and his development environment as per his/her needs.&#xA;&#xA;## Understanding the structure of Key binding&#xA;You can basically map a key depending on the current mode you are in. So that means you can have the same key mapped to different commands depending on the mode. That is really flexible and powerful. Vim allows you to basically map in almost every mode such as normal, insert, visual, command, and any other existing modes. Let us see what a basic key mapping looks like.&#xA;&#xA;&#xA;```&#xA;{mode}{attribute}map {key} {command}&#xA;```&#xA;The key mapping is broken down by adding the mode to map the key, an optional attribute to change/modify the way the mapping behaves and we finally have the key and the command pair. If you want to test a map you can temporarily map in the command mode using the syntax for the map command or if you want a permanent mapping, you can add the mappings in your vimrc file.&#xA;&#xA;For a basic example let us map c to paste from the clipboard.&#xA;&#xA;```vim&#xA;:map c &#34;+p&lt;CR&gt;&#xA;```&#xA;&#xA;The above command maps the &#34;c&#34; key in the **normal/visual mode** by default to paste the contents from the clipboard. It is just an example of how a basic key mapping or binding can be used to save your time and efforts. This is a very small example to demonstrate the concept of mapping in Vim but it scales quite fantastically and smoothly.&#xA;&#xA;Now let&#39;s see how to view the mapping inside of the current vim buffer. We can simply type map, imap, or nmap in the command mode to view the mappings in the respective modes. This will display the maps which are currently present inside of the vim buffer, some might be temporary and most of them will be permanent. &#xA;```&#xA;:map &#xA;```&#xA;If you type in map being in the command mode, it will list out the maps. If you want to stop seeing the list just press q, and you will be back in the editor. You can also view the maps in the normal, visual, insert, or any other modes by prefixing n, v, i, or other modes with map.&#xA;&#xA;## Key Mapping in Modes&#xA;To map a key binding explicitly in the normal mode or any other modes, we have to prefix the word such as n for normal, v for visual or i for insert, and so on. The map will only work in the provided mode so the same keys may have several different maps depending on the current mode, but that can create a bit of confusion so avoid doing that. Let&#39;s map a key in the normal mode for example,&#xA;```vim&#xA;:nmap &lt;C-s&gt; :w&lt;CR&gt;    &#xA;```&#xA;&#xA;This is pretty bad for Vim beginners as it will spoil the real Vim experience of saving with :w, If you feel comfortable using Ctrl + s to save a file, the above map will be perfect. It will map the key Ctrl + s by pressing :w and then pressing enter to save changes to the file. &#xA;&#xA;We can also map certain non-alphabetical keys such as CTRL, ALT, and others, it will help you in saving time to leave a mode and enter the mode again to edit the text. The following is a perfect example of such.&#xA;&#xA;```vim&#xA;:imap &lt;C-c&gt; &lt;ESC&gt;&#34;+pa&#xA;```&#xA;The above command is **mapped in insert mode** as the mode is set to insert at the command&#39;s beginning. The CTRL+c keys are mapped to first Escaping out of insert mode and then pasting from the &#34;+ register which is the device clipboard here. In the end, we again get back to insert mode just to the right of the current cursor position. So, that is how we can map the keys to do the task and save a bit of time. &#xA;&#xA;## Adding Keymaps in vimrc file&#xA;So you can now map in any available modes in Vim and test it out in te=he current buffer, but if you notice when you close the buffer, your custom keymaps will not be functioning as they remain in the buffer until you close it. To make it permanent you need to type the exact map command to the vimrc file. Just don&#39;t add &#34;:&#34; as it is not a command mode, it should be only the pure command of the map.&#xA;&#xA;```vim&#xA;nmap &lt;C-s&gt; :w&lt;CR&gt;&#xA;nmap &lt;C-p&gt; &#34;+p&#xA;vmap &lt;C-y&gt; &#34;+y&#xA;``` &#xA;The above commands are pasted in the vimrc file. These keymaps once sourced will stay in permanently unless you remove them from the file.&#xA;&#xA;## Keymap Modifications&#xA; We can also add extra arguments to the keymaps such as noremap and remap and others. In remap, the keymap is recursive which means the key pair will get mapped to the keys mapped already somewhere. The keymap will redefine its map depending on the already existing maps.  It is preferred to use noremap as it will not mix up the existing maps and have a fresh key binding. The mapping in Vim is quite versatile and there are quite a lot of modifications you could do to make your key binding feel and work according to you. So for further un depth understanding of modifications of keymap in Vim you can check out their documentation  [here](https://vim.fandom.com/wiki/Mapping_keys_in_Vim_-_Tutorial_(Part_1)).&#xA;&#xA;&#xA;## Keymapping Usecases&#xA;Now, it&#39;s entirely up to you to make keymaps according to your preference and choice. You can use your creativity and knowledge to make powerful and efficient keymaps.&#xA;&#xA;For some insights, I&#39;d like to give in some cool and productive keymaps which I personally use very frequently in coding a particular programming language. &#xA;&#xA;```vim&#xA;nmap &lt;C-s&gt; :w&lt;CR&gt;&#xA;nnoremap py :!python %&lt;CR&gt;                          &#34; Python run macro&#xA;nnoremap cpp :!c++ % -o %:r &amp;&amp; ./%:r &lt;CR&gt;           &#34; C++ compile and run macro&#xA;nnoremap sh :!chmod +x % &amp;&amp; source %&lt;CR&gt;            &#34; Bash sourcing macro &#xA;nnoremap c :!clang % -o %:r &amp;&amp; ./%:r &lt;CR&gt;           &#34; C compile and run macro &#xA;nnoremap jv :!javac % &amp;&amp; java %:r &lt;CR&gt;              &#34; Java compile and run macro&#xA;```&#xA;&#xA;&#xA;The above mapping will run the file or compile and run the file you are currently editing in Vim. That is just an overview of how you can use key mappings in Vim for any programming language or tool. Vim allows you to modify and make the keys do the heavy lifting very easily and save a lot of time and frustration. This is how you implement DRY(don&#39;t repeat yourself) perfectly. I personally think this is just perfect to do certain things which are quite common and sometimes daunts you to do this again. So just have a look and play around with Vim keymaps, it is the power with which one can excel in saving time and energy. This is just flawless. OK, That was too much from my side. &#xA;&#xA;## Keymapping and Macros&#xA;Some Keymappings provided above are quite interesting for a person trying to understand macros and key binding. A macro is a bunch of commands packed in together to access it very efficiently, Not the exact definition, but still, it just means to simplify things and saves time. Keymapping is the same thing but to map with the keys. &#xA;&#xA;From some snippets and explanations of VIm keymaps, it must be easier now for a beginner to understand Keymappings in Vim and how to customize accordingly.&#xA;&#xA;I hope it helped, Thank you for listening to my understanding of Vim keymapping. Below are some of my keymaps currently in vim for windows. Some of them were already shown in the code snippets.&#xA;![vimkmap.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1623654888460/pBfJO2jkZ.png)&#xA;&#xA; &#xA;So, Keymaps are quite powerful and can be a bit difficult to set up in a single try. Keep experimenting with keymaps and make Vim the powerhouse of productivity and customization. Happy Viming :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Setting up Vim for BASH Scripting</title>
      <link>meetgor.com/vim-for-bash</link>
      <description></description>
      <pubDate>Thu, 10 Jun 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Vim and BASH? &#xA;Bash Scripting is a powerful skill to have as a programmer because we find Linux almost everywhere and to get through it you must have a command over its interface which is generally the BASH shell. Vim is a great option for doing this, or probably the best out there! Because Vim is pre-installed in almost every Linux distribution. This is not an in-depth setup for BASH on Vim, it is a simple editorial on starting up BASH scripting on the Vim editor. So without wasting time on &#34;Vim features&#34; let&#39;s dive in with the setup for BASH in Vim.&#xA;&#xA;## Boilerplate macro&#xA;Setting up a bash script doesn&#39;t require much code but still in some cases it can be a bit hassle and to avoid the repetitive task, one can easily set up a macro for the boilerplate BASH script.&#xA;&#xA;```vim&#xA;nnoremap bs i#!/bin/bash/&lt;ESC&gt;o&#xA;```&#xA;Ok that was pretty dumb but it can scale pretty quickly and it will be nice to tailor it as per needs, here&#39;s some snippet with function pre-loaded.&#xA;&#xA;```vim&#xA;nnoremap bs i#!/bin/bash/&lt;ESC&gt;o&#xA;nnoremap bs i#!/bin/bash/&lt;ESC&gt;o&lt;ESC&gt;ofunction main(){&lt;ESC&gt;o&lt;ESC&gt;o}&lt;ESC&gt;ki&lt;S-TAB&gt;&#xA;&#xA;```&#xA;![type bs to load boiler-plate code](https://s6.gifyu.com/images/bsclip.gif)&#xA;&#xA;When the key bs is typed in normal mode, you enter into insert mode as per the command macro, then we type in the required text and escape to move to the next line and continue the same stuff. This could be extended further like making some input or printing out some text and any other formatted text that you could think it as repetition. &#xA;&#xA;## Sourcing Scripts&#xA;So, after creating the file, sourcing the script, and running it can be a bit slow for some people, as you have to go to the terminal and toggle in the permission to run the script and then run, But pull on your seatbelts as this is VIM! You can die due to slowness!&#xA;&#xA;```vim&#xA;nnoremap sh :!chmod +x % &amp;&amp; source %&#xA;```&#xA;&#xA;![type sh to run script](https://s6.gifyu.com/images/shclip.gif)&#xA;&#xA;When the sh keys are typed in the normal mode, the preceding command after ! (bang) will be executed in the terminal, the &amp;&amp; keywords will execute the second command only when the first command is successfully executed.&#xA; That just can so fast! Imagine doing this for long scripts and especially for debugging, it will waste 2 minutes every time you leave the editor and for 10 times you do the debugging, you will carelessly was roughly 20 minutes! Improve your debugging skills surely :)&#xA;&#xA;## Plugins&#xA;There are very few plugins out there for BASH as for VIM, but it&#39;s quite to write scripts even without any plugins. One of the most supported and popular plugins for BASH in Vim is  [Bash-Support-Vim](https://www.vim.org/scripts/script.php?script_id=365) for auto-completion and [Shell-Check](https://www.shellcheck.net) for finding/correcting any bugs or error in the script . &#xA;The mentioned plugin is quite awesome and it can greatly improve the speed of scripting for BASH, some commands such as shortcuts for writing if-else, while, for loops, commenting and other aspects in the scripting. The thorough documentation for such commands is also provided by the  [plugin website](https://wolfgangmehner.github.io/vim-plugins/bashsupport.html). &#xA;This can be used for autocompleting keywords and writing nested if-else and other logical operators in BASH scripting. Again, you can do absolutely fine without plugins in Vim as it is heavily customizable to the user&#39;s need and can be very rewarding to set up your own configuration for BASH. You can use standard Vim(barebones) for auto-completion as well with the command CTRL+N and CTRL-P to move down and up respectively.&#xA;&#xA;&#xA;## Some More Tricks&#xA;BASH in Vim can be quite versatile to use as it provides some custom addons to make the script more functional and easier to understand. Some tricks such as using autocompletion can be quite inconvenient to use at once but it can get really smooth after some runs at writing the scripts.&#xA;- In BASH Scripts there are quite a lot of brackets to play with that&#39;s why to jump around swiftly around such parentheses or brackets you can use **% to move from the opened to closed brackets or vice versa**.&#xA;- You can execute any terminal command from Vim, be sure to be in command mode and press ! after the command, you would like to execute. This will run the command from the terminal and you don&#39;t have to leave the editor, it saves a ton of time and it&#39;s blazingly fast.&#xA;- With the above trick, you kind of have a superpower within Vim to make, build, source, run the files or scripts within Vim, that is not repetition but it can run bash within bash. Ok! that&#39;s was pretty fast. Don&#39;t die of quickness now!&#xA;&#xA;Writing BASH scripts in Vim can be also boosted by using some built-in commands such as adding comments for multiple lines at once and some unexplored stuff which can be learned in the way to understanding the flow of Vim and BASH together. Happy Coding and Viming :)&#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Setting up Vim for Python</title>
      <link>meetgor.com/vim-for-python</link>
      <description></description>
      <pubDate>Sun, 06 Jun 2021 00:00:00 UTC</pubDate>
      <content>&#xA;## Introduction&#xA;Vim is quite a powerful text editor which can add performance to the already fast typed language Python. Vim can be highly customizable and efficient to use as it has the power of **adding custom plugins and plugins managers, key mappings**, and the most critical weapon of vim - Access to the terminal straight away.&#xA;This is not a full-featured guide of using vim for python, it&#39;s just a quick setup for using python on vim blazingly fast!!&#xA;&#xA;## Plugin Managers&#xA;So let us start making Vim, the text editor suitable for a python programmer. Firstly we&#39;ll need the vim plugin manager. There are different plugin managers out there, each of them has the same purpose to install, upgrade and manage the plugins for vim. You can install any one of them and get up and running.&#xA;&#xA;-  [Vim Plug](https://www.vim.org/scripts/script.php?script_id=4828) &#xA;-  [Vundle](https://github.com/VundleVim/Vundle.vim) &#xA;-  [Pathogen](https://github.com/tpope/vim-pathogen) &#xA;&#xA;These are some of the finest and well-supported plugin managers in vim. You can use any of these plugin managers, and get started by installing some plugins.&#xA;&#xA;## JEDI-VIM- Auto completion &#xA;Firstly I will like to install Jedi for code completion in Python. The plugin can be simple and straightforward to install using any of the above plugin managers. Jedi-Vim provides some neat and clean** syntax analytics and autocompletion for Python in Vim**. You&#39;ll find the docs and installation process here  [JEDI-VIM ](https://github.com/davidhalter/jedi-vim) &#xA;&#xA;## NERDTree-File manager&#xA;Next, It would be great if we install a file manager for managing the files and folders in the code directories. We can simply use the Nerdtree plugin for this. NerdTree is quite a **fantastic plugin for file management in Vim**. It simply makes Vim feel like VS Code. The installation and docs can be found here  [NERDTree](https://github.com/preservim/nerdtree).&#xA;&#xA;Nerdtree commands can be longer to write, for that let&#39;s start mapping and for that, we can start editing our Vimrc. &#xA;&#xA;```vim&#xA;set number&#xA;syntax enable&#xA;filetype indent on&#xA;set tabstop=4&#xA;set softtabstop=4&#xA;set autoindent &#xA;set encoding=utf-8&#xA;``` &#xA;This can be some addition to your existing vimrc as you might have a setup for plugin managers. You can choose the color scheme of your choice, don&#39;t waste time selecting the color scheme. Feel free and modify the vimrc according to your knowledge and choice. &#xA;&#xA;## Keymappings&#xA;We move on to the Key mappings for NERDTree and other features. You can make mappings generally in the normal mode but there might be cases where you need to use maps for visual mode or insert mode as well, that entirely depends on the user :)&#xA;&#xA;To map in normal mode, we&#39;ll its command to be specific:&#xA;&#xA;&#xA;```vim&#xA;nnoremap &lt;C-n&gt; :NERDTree&lt;CR&gt;&#xA;``` &#xA;&#xA;This will map CTRL+n to open the NERDTree file manager to the left, saving a bit of time and avoiding frustration. Feel free to add any keymap of your choice, this is just for demonstration. &#xA;You can further automate NERDTree for switching between tabs because it makes you type CTRL+w twice, you can reduce that to just typing w.&#xA;&#xA;```vim&#xA;nnoremap w:&lt;C-w&gt;&lt;C-w&gt;&#xA;``` &#xA;&#xA;## Integrated Terminal Macros&#xA;We can open a terminal window like a split between the editor. We can simply use the command :terminal to split the window horizontally, where the upper split will be terminal and the down window will have the editor. This is quite a neat feature of Vim in that it blends with the terminal so well so that we can switch between the terminal and the editor very quickly. For that, you can create a macro if you need to fire up a terminal again and again.&#xA;```vim&#xA;nnoremap &lt;C-t&gt; :terminal&lt;CR&gt;&#xA;```&#xA;If you place the above macro in your vimrc and then type Ctrl+t, the exact thing will happen to fire up a terminal split but with fewer keystrokes and without leaving the normal mode. &#xA;Also, the NERDTree macro can be also fruitful with this as it will make a full-blown IDE-like feeling inside of Vim.&#xA;![Demonstrate macros for NERDTree and terminal split](https://s6.gifyu.com/images/screenrecording.gif)&#xA;&#xA;## Running the Code with a snap&#xA;&#xA;We can automate the process of running python scripts inside of vim. Instead of typing out the entire command for executing python script from vim. We can use keymaps for it as they can significantly boost the time required to run and debug the code. &#xA;&#xA;&#xA;```vim&#xA;nnoremap py :!python %&#xA;``` &#xA;&#xA;This is a small map but can save a lot of time and give some motivation to use vim as you run the code blazingly faster than other editors. I have used py, but it can cause some problems as p is already mapped for pasting. So it&#39;s better to use other key combinations such as ty, yh, or any other key combination of your choice. Try it out and add your own flavor that&#39;s how we all learn.&#xA;&#xA;So, that&#39;s the basic set-up for python on vim, you can make more custom mappings, find more plugins and test out which work out the best for your workflow. Happy Coding and Viming ;) &#xA;</content>
      <type>posts</type>
    </item>
    <item>
      <title>Why and How to make and use Vim as a text editor and customizable IDE</title>
      <link>meetgor.com/vim-text-editor-ide</link>
      <description></description>
      <pubDate>Sat, 20 Feb 2021 00:00:00 UTC</pubDate>
      <content>&#xA;We all are asked to use visual studio code and other rich looking editors as a beginners text editor or an IDE but that makes a habit of a rich and pleasing interface of running and debugging programs, and that is the reason we don&#39;t feel good to use command line or the terminal. Terminal or Command line are quite important to learn and are powerful as well.  &#xA;&#xA;Vim is a text editor, not any text editor but a special and one of the fastest out there if you use it wisely. Vim can be used in the terminal which means it can run terminal commands inside the editor interface. That makes it quite a great option to improve your terminal command skills and also for enhancing your Linux knowledge. You can run program files from vim itself just with a few keystrokes. This text editor is preinstalled in most Linux distributions and hence you could quickly edit some files without going anywhere.  &#xA;&#xA;So that being said, vim is not easy to learn, you have to put some effort to reap the fruits of saving time in the longer run. It takes time to get used to the commands and key combination of Vim.  &#xA;&#xA;## Download VIM&#xA;&#xA;But, let us get our feet wet in learning a few commands in Vim.  &#xA;&#xA;To download vim you can go to the official  [Vim website](https://www.vim.org/download.php) .  &#xA;&#xA;Firstly let us understand how to open vim from the command line or the terminal  &#xA;&#xA;If you are on windows you have to add the vim.exe file&#39;s path to the environment variable PATH. After that open CMD or terminal for windows 10 and type vim and enter. You are in Vim.  &#xA;&#xA;If you are in Linux or macOS, then open the terminal and type vim and enter.  &#xA;&#xA;After you are in Vim, you will surely be trying to type something right? else you are not a geek ; )&#xA;&#xA;## VIM Basics&#xA;&#xA;You won&#39;t see anything happening even if you are typing. This is because are 4 basic modes in Vim, understand it like a room.  The modes are&#xA;&#xA;1.  **Normal Mode**&#xA;&#xA;2.  **Insert Mode**&#xA;&#xA;3.  **Command Mode**&#xA;&#xA;4.  **Visual Mode** &#xA;&#xA;Wait for a second, you should learn how to move in vim first but you cannot learn everything at once, So take it bit by bit.&#xA;&#xA;To navigate around vim like blazing fast you can use h,j,k, and l.  I know it&#39;s wired but you will get used to it.&#xA;&#xA;**h**  -&gt; move left.    ( hop left)&#xA;&#xA;**l**   -&gt; move right.   (opposite of left)&#xA;&#xA;**k**  -&gt; move up.       ( keep it up)&#xA;&#xA;**j**   -&gt; move down.   ( jump down!!)&#xA;&#xA;If you want to apply certain movements several times you can use numbers before hjkl to move the number of times in that direction.&#xA;&#xA;Let&#39;s say you type 23j , here you will go down 23 lines. You can also use : and number to jump to a particular line of that number, :12 moves you to the 12th line. &#xA;&#xA;The default mode is the **Normal mode** where you can navigate in your file, like a passageway between different rooms. Each other mode is accessible via Normal mode. You have to enter normal mode before switching to the other three modes. By default, after opening vim you are in Normal mode. You start inserting text in the file while being in Normal mode but you can replace text and edit the existing text in the file. **Press ESC to enter Normal mode**.&#xA;&#xA;The main mode in VIM is **Insert mode**, where the actual typing and text editing takes place, **Enter i to enter insert mode**. After entering i you can type anything you want. After you feel satisfied with writing in VIM, you can escape out of the insert mode (room) and enter the normal mode (passageway). Now the biggest question VIM beginners ask **&#34;HOW ON EARTH SHOULD I EXIT OUT OF VIM ??&#34;** . Take a breath dear, you need to save your file first. To do that let&#39;s explore a different mode.&#xA;&#xA;The next crucial mode is **Command mode**, where you have to remember some commands to do something. Let&#39;s continue from where we left. To save our file,  **Press :  and Voila!! you are in Command mode**. After it depends you want to save the file, quit vim, save the file and quit vim or quit vim without saving the file. OK, that is too much to take in one go. Be sure to be in Command mode to press the following keys (i.e. press colon before any keys if you were in normal mode).&#xA;&#xA;&#xA;**w**     -&gt; save file.&#xA;&#xA;**q**      -&gt; quit vim.&#xA;&#xA;**wq**     -&gt; save file and quit vim.&#xA;&#xA;**q!**      -&gt; quit vim without saving the file.&#xA;&#xA;These are a few of the commands available in VIM :)&#xA;&#xA;So now let&#39;s talk about **Visual mode**, the little helper mode (room) to do cut/ copy in VIM. There are many ways to edit or add text in Visual mode. You have options to choose from character by character, line by line, or block by block. **To enter Visual mode press v**. This gets you into character by character highlighting whether you want to cut the text or copy (yank) the text. After selecting the portion you can either cut that portion or copy it in vim register. &#xA;&#xA;**y**     -&gt; Copy the selected portion.&#xA;&#xA;**d**     -&gt; Cut the selected portion.&#xA;&#xA;You can use **V (Shift+V) to enter Line Visual mode**, this selects or highlights the portion line by line and not single letter by letter.&#xA;&#xA;You can also use **Ctrl+V to enter Block Visual mode**, this selects a block of code.&#xA;&#xA;Here is a good way to remember switching between basic modes in VIM -&gt;&#xA;&#xA;![image.png](https://cdn.hashnode.com/res/hashnode/image/upload/v1613912016216/SXavZAkPH.png)&#xA;&#xA;&#xA;Switching between basic modes in VIM&#xA;&#xA;It seems to be quite slower than VS Code, doesn&#39;t it? Ya, I know it&#39;s kinda slow but with time it picks up pace, just like a train. Spend time in VIM and it will be worth it. No Text editor is so powerful as VIM, it is so for a reason. If you are curious to dive deeper just dive in fully or stay in VS Code and your fancy.  There is a great community around VIM and you&#39;ll be happy surely to be a part of it. Oh! The quick fact even VS Code has an extension for VIM ;)&#xA;&#xA;##  Some more Basics&#xA;&#xA;You can do most of the basic programming using this but to be a bit faster you can use some tweaked commands to do stuff like,&#xA;&#xA;**I**     -&gt; Enter insert mode to the character at the beginning. ( i puts you in insert mode to the cursor)&#xA;&#xA;**a**  -&gt; Enter insert mode adjacent right to the cursor.&#xA;&#xA;**A**   -&gt; Enter insert mode at the end of the line.&#xA;&#xA;**o**    -&gt; Enter insert mode a line below cursor.&#xA;&#xA;O   -&gt; Enter insert mode a line above cursor.&#xA;&#xA;These commands are an optimized way to enter insert mode in a suitable way. These commands can be used as per needs and quite significantly improve editing speed.&#xA;&#xA;You can also shift from one mode to Normal mode by pressing Ctrl+C or Ctrl+{. Whatever you feel good with.&#xA;&#xA;Pasting is a programmer&#39;s everyday task. No, it&#39;s good as a beginner and only if you are not running as it is. In VIM you can paste from your previously copied text using Visual mode or deleted chunk just using p to paste. Remember if you are on a character it will paste on starting from where your cursor is, which means your character on the current cursor will be overwritten. You can also use &#34;0p to paste from the copied buffer.&#xA;&#xA;If you are pasting from an external source i.e. out of VIM, you have to use &#34;+p . It pastes from the next character from the cursor.   &#xA;&#xA;If you want to search a word in a file, you can use navigation commands like hjkl but there&#39;s a faster way around, If you press / and type the word you are searching for, you will get the first instance of that word. If there are multiple instances of the same word, you can press n to got the next instance. You can also press Shift+N to move to the previous instance of the word.&#xA;&#xA;Some more word searching ahead. Say if you are already on the word which you want to find its instance, then you could press * to move to its next instance and # will do the same backward. Oh ! that was smooth.&#xA;&#xA;You can see that we are just using our keyboards while using vim. This is a great feature of old but gold text editors like vim and others that make you faster on the keyboard and avoid mouse traps. &#xA;&#xA;If you want to jump to the end of the block or a paragraph you can use { and } to go to the beginning and the end of it respectively.&#xA;&#xA;**G**    -&gt; to the end of the file.&#xA;&#xA;**gg** -&gt; to the beginning of the file.&#xA;&#xA;**L**     -&gt; move the cursor to the end of the screen.&#xA;&#xA;&#xA;```&#xA;:%s/old/new/g&#xA;``` &#xA;   in Command mode -&gt; replace the old word with a new word throughout the file(g)&#xA;&#xA;Ctrl p   in Insert mode    -&gt; auto-complete reference from current file.&#xA;&#xA;So these are some quick and pretty good commands to get started with and feel VIM. But this is just VIM used 25% efficiency, you would have to go to the command line or terminal to run and compile the program you have written. It could waste a lot of time. But as a beginner, this is pretty decent and helps to learn the core programming, behind the scenes of compiling and learning new stuff and commands. It gets pretty exciting if you have got the basics cleared. But be sure to make it through.&#xA;&#xA;It&#39;s time to use VIM to its actual powers. VIM + terminal. It can get quite fast. So beware!!!&#xA;&#xA;# Running Programs from VIM&#xA;&#xA;It turns out that you could go to the command mode and run terminal commands from there just use! before the command first.&#xA;&#xA;Linux/Mac Users: use terminal from vim&#xA;&#xA;&#xA;```&#xA;:!ls   &#xA;``` &#xA; //-&gt; ls command from vim&#xA;&#xA;Windows: use CMD from vim&#xA;&#xA;&#xA;```&#xA;:!dir&#xA;``` &#xA;   -&gt; dir command from vim&#xA;&#xA;You could also use other commands which are appropriate to be executed from vim.&#xA;&#xA;Here is where the trick comes in, you don&#39;t have to quit vim now to compile or run the program.&#xA;&#xA;Let&#39;s say you are writing a C++/C code and you have a clang compiler. Then you could use c++ and c respectively command with appropriate file handles to compile from vim. Here&#39;s the command,&#xA;&#xA;&#xA;```&#xA;:!c++ % -o %:r&#xA;``` &#xA;&#xA;&#xA;Here, % stands for the current file and :r removes the extension of the file. So we are creating an executable file without the extension and hence :r. And to execute the file, simply type,&#xA;```&#xA;:!%:r&#xA;```&#xA;this will execute the program. If Windows users face an issue like a file is not identified as a batch file or executable file, you should add .exe after :r to make it an exe file.&#xA;&#xA;For Python or other interpreted language, it is quite simple, just the interpreters name with the file name as it is&#xA;```&#xA;:!python filename.py&#xA;```&#xA;```&#xA;:!python %&#xA;```&#xA;You could find your preferred language&#39;s CLI tool and set it up for your environment and get it plugged with VIM.&#xA;&#xA;**Mapping in VIM**&#xA;&#xA;But this is not it! There is a long way to master VIM. It&#39;s not possible to know everything about anything. So for getting faster I&#39;ll introduce VIM&#39;s fastest tool and the part where it really shines. Mapping!!&#xA;&#xA;You could map (assign) some keys to do a particular task in different modes. Just imagine typing cpp and running the program or py and running the program,no need to go to the mouse to click run button and close the window. It gets really blazing fast. Only your creativity is the limit. Mapping commands are also called macros.&#xA;```&#xA;nmap cpp :!c++ % -o %:r  &amp;&amp;  %:r&#xA;```&#xA;```&#xA;nmap py :!python %&#xA;```&#xA;In the above commands, nmap means in Normal mode MAP cpp and then followed by the command which for this case it is executed in the command mode. There can be various permutations you could make like imap or vmap in Insertion mode and Visual mode and so on.  From mapping,its basically left-hand side mapped to right-hand side. The key combination to the left and command to be executed to the right. &#xA;&#xA;You will surely say, &#34;Do I have to do it every time I run the program or every time I use VIM?&#34;&#xA;&#xA;Well, You can :) but you should not. Because there&#39;s a way around it and this is the fuel of VIM or the soul for its Speed.&#xA;&#xA;Yes, I am talking about VIM CONFIGURATION FILE or vimrc&#xA;&#xA;# VIM Run Commands File(vimrc)&#xA;&#xA;This is really a nasty feature of vim. You could tailor your vim editor as per your needs. You have to write the command once and it will run from the vimrc file. Making a vimrc file is a bit overwhelming in the beginning so, you should have a concrete knowledge of VIM commands and you should remember commands as well. &#xA;&#xA;&#xA;- Make a file called ~/.vimrc&#xA;&#xA;- You should be using VIM to edit it or write it of course! Type vim ~/.vimrc in terminal or cmd&#xA;&#xA;- Enter some commands such as set file type indent on , set number , you can find a  [sample vimrc file ](https://vim.fandom.com/wiki/Example_vimrc) on google and understand its commands and uses.&#xA;Paint your plain canvas vimrc with your own creativity.&#xA;&#xA;From here you can add the mappings and other key combinations that you might have been using while learning VIM to your vimrc. VIM also has plugins and more customizable tweaks that can enhance your productivity. &#xA;&#xA;You could always get more help in VIM by using :help commandname. Also you can learn from vimtutor from terminal or CMD.&#xA;&#xA;If you want to dive in more deeper , i link some few resources and video links to get your vim skills to new level.&#xA;&#xA; [VIM Official Documentation. ](https://www.vim.org/docs.php) &#xA;&#xA; [VIM fandom Wiki](https://vim.fandom.com/wiki/Vim_Tips_Wiki) &#xA;&#xA; [130+ VIM commands. ](https://catswhocode.com/vim-commands/) &#xA;&#xA; [Vim Interactive Guide.](https://scotch.io/tutorials/getting-started-with-vim-an-interactive-guide) &#xA;&#xA; [Vim as your editor.](https://www.youtube.com/watch?v=H3o4l4GVLW0&amp;list=PLm323Lc7iSW_wuxqmKx_xxNtJC_hJbQ7R) &#xA;&#xA;Vim is a tool that can get quite handy for programmers and it stands out from rest of the text editors. By using Vim you will be in very rare people who can make something from almost nothing. Because in VIM you make everything from commands to mapping from customization to functionality. This cannot be done overnight for sure and you would  say you are wasting time in the initial stage but no, you are actually building a foundation for more efficiency and speed. If still you want to use VS Code ,you can use it freely . Because it won&#39;t matter much , at the end of the day its programming skills that win the race.&#xA;&#xA;**This is quite a huge topic and everything could not be explained in a article, it should be self-explored and learnt from various sources to get its best functioning as per needs. This was a quick guide how and why you should be using VIM as a text editor or as a customizable IDE. As you might have seen its functionality is quite customizable and it is quite powerful tool for a programmer. Happy Coding and VIMing ;)**&#xA;</content>
      <type>posts</type>
    </item>
  </channel>
</rss>